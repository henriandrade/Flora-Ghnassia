var _O = Object.defineProperty;
var rE = (s) => {
  throw TypeError(s);
};
var yO = (s, e, t) => e in s ? _O(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var ht = (s, e, t) => yO(s, typeof e != "symbol" ? e + "" : e, t), sE = (s, e, t) => e.has(s) || rE("Cannot " + t);
var Sr = (s, e, t) => (sE(s, e, "read from private field"), t ? t.call(s) : e.get(s)), Lm = (s, e, t) => e.has(s) ? rE("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(s) : e.set(s, t), Ny = (s, e, t, i) => (sE(s, e, "write to private field"), i ? i.call(s, t) : e.set(s, t), t);
const bl = Symbol("$state"), tw = Symbol("legacy props"), Db = !1;
var DC = Array.isArray, xO = Array.prototype.indexOf, bO = Array.from, Xv = Object.keys, wp = Object.defineProperty, Ho = Object.getOwnPropertyDescriptor, IC = Object.getOwnPropertyDescriptors, wO = Object.prototype, SO = Array.prototype, nw = Object.getPrototypeOf;
function $d(s) {
  return typeof s == "function";
}
const Bt = () => {
};
function MO(s) {
  return s();
}
function Yv(s) {
  for (var e = 0; e < s.length; e++)
    s[e]();
}
let jv = !1, Ib = [];
function LC() {
  jv = !1;
  const s = Ib.slice();
  Ib = [], Yv(s);
}
function UC(s) {
  jv || (jv = !0, queueMicrotask(LC)), Ib.push(s);
}
function EO() {
  jv && LC();
}
function kC(s) {
  return s === this.v;
}
function OC(s, e) {
  return s != s ? e == e : s !== e || s !== null && typeof s == "object" || typeof s == "function";
}
function iw(s) {
  return !OC(s, this.v);
}
function TO(s) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function AO() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function CO(s) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function PO() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function RO() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function DO(s) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function IO() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function LO() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function UO() {
  throw new Error("https://svelte.dev/e/state_unsafe_local_read");
}
function kO() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
let gd = !1, OO = !1;
function FO() {
  gd = !0;
}
const NO = 1, BO = 2, zO = 4, VO = 8, GO = 16, HO = 1, WO = 2, FC = "[", NC = "[!", BC = "]", Wf = {}, ns = Symbol(), XO = "http://www.w3.org/2000/svg";
function rw(s) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function sw(s) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
let Ln = null;
function oE(s) {
  Ln = s;
}
function sr(s) {
  return (
    /** @type {T} */
    zC().get(s)
  );
}
function xr(s, e) {
  return zC().set(s, e), e;
}
function Ct(s, e = !1, t) {
  Ln = {
    p: Ln,
    c: null,
    e: null,
    m: !1,
    s,
    x: null,
    l: null
  }, gd && !e && (Ln.l = {
    s: null,
    u: null,
    r1: [],
    r2: qs(!1)
  });
}
function Pt(s) {
  const e = Ln;
  if (e !== null) {
    s !== void 0 && (e.x = s);
    const o = e.e;
    if (o !== null) {
      var t = $n, i = Kn;
      e.e = null;
      try {
        for (var n = 0; n < o.length; n++) {
          var r = o[n];
          Qh(r.effect), Jh(r.reaction), l_(r.fn);
        }
      } finally {
        Qh(t), Jh(i);
      }
    }
    Ln = e.p, e.m = !0;
  }
  return s || /** @type {T} */
  {};
}
function i_() {
  return !gd || Ln !== null && Ln.l === null;
}
function zC(s) {
  return Ln === null && sw(), Ln.c ?? (Ln.c = new Map(YO(Ln) || void 0));
}
function YO(s) {
  let e = s.p;
  for (; e !== null; ) {
    const t = e.c;
    if (t !== null)
      return t;
    e = e.p;
  }
  return null;
}
function qs(s, e) {
  var t = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: s,
    reactions: null,
    equals: kC,
    rv: 0,
    wv: 0
  };
  return t;
}
function Us(s) {
  return /* @__PURE__ */ VC(qs(s));
}
// @__NO_SIDE_EFFECTS__
function r_(s, e = !1) {
  var i;
  const t = qs(s);
  return e || (t.equals = iw), gd && Ln !== null && Ln.l !== null && ((i = Ln.l).s ?? (i.s = [])).push(t), t;
}
function Xf(s, e = !1) {
  return /* @__PURE__ */ VC(/* @__PURE__ */ r_(s, e));
}
// @__NO_SIDE_EFFECTS__
function VC(s) {
  return Kn !== null && !vo && Kn.f & 2 && (Wo === null ? QO([s]) : Wo.push(s)), s;
}
function In(s, e) {
  return Kn !== null && !vo && i_() && Kn.f & 18 && // If the source was created locally within the current derived, then
  // we allow the mutation.
  (Wo === null || !Wo.includes(s)) && kO(), jO(s, e);
}
function jO(s, e) {
  return s.equals(e) || (s.v, s.v = e, s.wv = KC(), GC(s, 2048), i_() && $n !== null && $n.f & 1024 && !($n.f & 96) && (va === null ? eF([s]) : va.push(s))), e;
}
function GC(s, e) {
  var t = s.reactions;
  if (t !== null)
    for (var i = i_(), n = t.length, r = 0; r < n; r++) {
      var o = t[r], a = o.f;
      a & 2048 || !i && o === $n || (bo(o, e), a & 1280 && (a & 2 ? GC(
        /** @type {Derived} */
        o,
        4096
      ) : a_(
        /** @type {Effect} */
        o
      )));
    }
}
// @__NO_SIDE_EFFECTS__
function wt(s) {
  var e = 2050, t = Kn !== null && Kn.f & 2 ? (
    /** @type {Derived} */
    Kn
  ) : null;
  return $n === null || t !== null && t.f & 256 ? e |= 256 : $n.f |= 1048576, {
    ctx: Ln,
    deps: null,
    effects: null,
    equals: kC,
    f: e,
    fn: s,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      null
    ),
    wv: 0,
    parent: t ?? $n
  };
}
// @__NO_SIDE_EFFECTS__
function bv(s) {
  const e = /* @__PURE__ */ wt(s);
  return e.equals = iw, e;
}
function HC(s) {
  var e = s.effects;
  if (e !== null) {
    s.effects = null;
    for (var t = 0; t < e.length; t += 1)
      Ko(
        /** @type {Effect} */
        e[t]
      );
  }
}
function qO(s) {
  for (var e = s.parent; e !== null; ) {
    if (!(e.f & 2))
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function ZO(s) {
  var e, t = $n;
  Qh(qO(s));
  try {
    HC(s), e = JC(s);
  } finally {
    Qh(t);
  }
  return e;
}
function WC(s) {
  var e = ZO(s), t = (fl || s.f & 256) && s.deps !== null ? 4096 : 1024;
  bo(s, t), s.equals(e) || (s.v = e, s.wv = KC());
}
let Nn = !1;
function dl(s) {
  Nn = s;
}
let oi;
function Pa(s) {
  if (s === null)
    throw rw(), Wf;
  return oi = s;
}
function ou() {
  return Pa(
    /** @type {TemplateNode} */
    /* @__PURE__ */ Eu(oi)
  );
}
function Dc(s) {
  if (Nn) {
    if (/* @__PURE__ */ Eu(oi) !== null)
      throw rw(), Wf;
    oi = s;
  }
}
function KO() {
  for (var s = 0, e = oi; ; ) {
    if (e.nodeType === 8) {
      var t = (
        /** @type {Comment} */
        e.data
      );
      if (t === BC) {
        if (s === 0) return e;
        s -= 1;
      } else (t === FC || t === NC) && (s += 1);
    }
    var i = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Eu(e)
    );
    e.remove(), e = i;
  }
}
function pr(s, e = null, t) {
  if (typeof s != "object" || s === null || bl in s)
    return s;
  const i = nw(s);
  if (i !== wO && i !== SO)
    return s;
  var n = /* @__PURE__ */ new Map(), r = DC(s), o = qs(0);
  r && n.set("length", qs(
    /** @type {any[]} */
    s.length
  ));
  var a;
  return new Proxy(
    /** @type {any} */
    s,
    {
      defineProperty(l, c, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && IO();
        var h = n.get(c);
        return h === void 0 ? (h = qs(u.value), n.set(c, h)) : In(h, pr(u.value, a)), !0;
      },
      deleteProperty(l, c) {
        var u = n.get(c);
        if (u === void 0)
          c in l && n.set(c, qs(ns));
        else {
          if (r && typeof c == "string") {
            var h = (
              /** @type {Source<number>} */
              n.get("length")
            ), d = Number(c);
            Number.isInteger(d) && d < h.v && In(h, d);
          }
          In(u, ns), aE(o);
        }
        return !0;
      },
      get(l, c, u) {
        var m;
        if (c === bl)
          return s;
        var h = n.get(c), d = c in l;
        if (h === void 0 && (!d || (m = Ho(l, c)) != null && m.writable) && (h = qs(pr(d ? l[c] : ns, a)), n.set(c, h)), h !== void 0) {
          var f = pe(h);
          return f === ns ? void 0 : f;
        }
        return Reflect.get(l, c, u);
      },
      getOwnPropertyDescriptor(l, c) {
        var u = Reflect.getOwnPropertyDescriptor(l, c);
        if (u && "value" in u) {
          var h = n.get(c);
          h && (u.value = pe(h));
        } else if (u === void 0) {
          var d = n.get(c), f = d == null ? void 0 : d.v;
          if (d !== void 0 && f !== ns)
            return {
              enumerable: !0,
              configurable: !0,
              value: f,
              writable: !0
            };
        }
        return u;
      },
      has(l, c) {
        var f;
        if (c === bl)
          return !0;
        var u = n.get(c), h = u !== void 0 && u.v !== ns || Reflect.has(l, c);
        if (u !== void 0 || $n !== null && (!h || (f = Ho(l, c)) != null && f.writable)) {
          u === void 0 && (u = qs(h ? pr(l[c], a) : ns), n.set(c, u));
          var d = pe(u);
          if (d === ns)
            return !1;
        }
        return h;
      },
      set(l, c, u, h) {
        var w;
        var d = n.get(c), f = c in l;
        if (r && c === "length")
          for (var m = u; m < /** @type {Source<number>} */
          d.v; m += 1) {
            var g = n.get(m + "");
            g !== void 0 ? In(g, ns) : m in l && (g = qs(ns), n.set(m + "", g));
          }
        d === void 0 ? (!f || (w = Ho(l, c)) != null && w.writable) && (d = qs(void 0), In(d, pr(u, a)), n.set(c, d)) : (f = d.v !== ns, In(d, pr(u, a)));
        var v = Reflect.getOwnPropertyDescriptor(l, c);
        if (v != null && v.set && v.set.call(h, u), !f) {
          if (r && typeof c == "string") {
            var _ = (
              /** @type {Source<number>} */
              n.get("length")
            ), y = Number(c);
            Number.isInteger(y) && y >= _.v && In(_, y + 1);
          }
          aE(o);
        }
        return !0;
      },
      ownKeys(l) {
        pe(o);
        var c = Reflect.ownKeys(l).filter((d) => {
          var f = n.get(d);
          return f === void 0 || f.v !== ns;
        });
        for (var [u, h] of n)
          h.v !== ns && !(u in l) && c.push(u);
        return c;
      },
      setPrototypeOf() {
        LO();
      }
    }
  );
}
function aE(s, e = 1) {
  In(s, s.v + e);
}
var lE, XC, YC, jC;
function Lb() {
  if (lE === void 0) {
    lE = window, XC = /Firefox/.test(navigator.userAgent);
    var s = Element.prototype, e = Node.prototype;
    YC = Ho(e, "firstChild").get, jC = Ho(e, "nextSibling").get, s.__click = void 0, s.__className = "", s.__attributes = null, s.__styles = null, s.__e = void 0, Text.prototype.__t = void 0;
  }
}
function Qp(s = "") {
  return document.createTextNode(s);
}
// @__NO_SIDE_EFFECTS__
function au(s) {
  return YC.call(s);
}
// @__NO_SIDE_EFFECTS__
function Eu(s) {
  return jC.call(s);
}
function Ic(s, e) {
  if (!Nn)
    return /* @__PURE__ */ au(s);
  var t = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ au(oi)
  );
  return t === null && (t = oi.appendChild(Qp())), Pa(t), t;
}
function dt(s, e) {
  if (!Nn) {
    var t = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ au(
        /** @type {Node} */
        s
      )
    );
    return t instanceof Comment && t.data === "" ? /* @__PURE__ */ Eu(t) : t;
  }
  return oi;
}
function Wn(s, e = 1, t = !1) {
  let i = Nn ? oi : s;
  for (var n; e--; )
    n = i, i = /** @type {TemplateNode} */
    /* @__PURE__ */ Eu(i);
  if (!Nn)
    return i;
  var r = i == null ? void 0 : i.nodeType;
  if (t && r !== 3) {
    var o = Qp();
    return i === null ? n == null || n.after(o) : i.before(o), Pa(o), o;
  }
  return Pa(i), /** @type {TemplateNode} */
  i;
}
function $O(s) {
  s.textContent = "";
}
const qC = 0, JO = 1;
let wv = !1, Sv = qC, Sp = !1, Mp = null, Bh = !1, ow = !1;
function cE(s) {
  Bh = s;
}
function uE(s) {
  ow = s;
}
let Lc = [], zh = 0;
let Kn = null, vo = !1;
function Jh(s) {
  Kn = s;
}
let $n = null;
function Qh(s) {
  $n = s;
}
let Wo = null;
function QO(s) {
  Wo = s;
}
let Wr = null, ys = 0, va = null;
function eF(s) {
  va = s;
}
let ZC = 1, qv = 0, fl = !1;
function KC() {
  return ++ZC;
}
function vd(s) {
  var h;
  var e = s.f;
  if (e & 2048)
    return !0;
  if (e & 4096) {
    var t = s.deps, i = (e & 256) !== 0;
    if (t !== null) {
      var n, r, o = (e & 512) !== 0, a = i && $n !== null && !fl, l = t.length;
      if (o || a) {
        var c = (
          /** @type {Derived} */
          s
        ), u = c.parent;
        for (n = 0; n < l; n++)
          r = t[n], (o || !((h = r == null ? void 0 : r.reactions) != null && h.includes(c))) && (r.reactions ?? (r.reactions = [])).push(c);
        o && (c.f ^= 512), a && u !== null && !(u.f & 256) && (c.f ^= 256);
      }
      for (n = 0; n < l; n++)
        if (r = t[n], vd(
          /** @type {Derived} */
          r
        ) && WC(
          /** @type {Derived} */
          r
        ), r.wv > s.wv)
          return !0;
    }
    (!i || $n !== null && !fl) && bo(s, 1024);
  }
  return !1;
}
function tF(s, e) {
  for (var t = e; t !== null; ) {
    if (t.f & 128)
      try {
        t.fn(s);
        return;
      } catch {
        t.f ^= 128;
      }
    t = t.parent;
  }
  throw wv = !1, s;
}
function nF(s) {
  return (s.f & 16384) === 0 && (s.parent === null || (s.parent.f & 128) === 0);
}
function s_(s, e, t, i) {
  if (wv) {
    if (t === null && (wv = !1), nF(e))
      throw s;
    return;
  }
  t !== null && (wv = !0);
  {
    tF(s, e);
    return;
  }
}
function $C(s, e, t = !0) {
  var i = s.reactions;
  if (i !== null)
    for (var n = 0; n < i.length; n++) {
      var r = i[n];
      r.f & 2 ? $C(
        /** @type {Derived} */
        r,
        e,
        !1
      ) : e === r && (t ? bo(r, 2048) : r.f & 1024 && bo(r, 4096), a_(
        /** @type {Effect} */
        r
      ));
    }
}
function JC(s) {
  var f;
  var e = Wr, t = ys, i = va, n = Kn, r = fl, o = Wo, a = Ln, l = vo, c = s.f;
  Wr = /** @type {null | Value[]} */
  null, ys = 0, va = null, Kn = c & 96 ? null : s, fl = (c & 256) !== 0 && (!Bh || n === null || l), Wo = null, oE(s.ctx), vo = !1, qv++;
  try {
    var u = (
      /** @type {Function} */
      (0, s.fn)()
    ), h = s.deps;
    if (Wr !== null) {
      var d;
      if (Zv(s, ys), h !== null && ys > 0)
        for (h.length = ys + Wr.length, d = 0; d < Wr.length; d++)
          h[ys + d] = Wr[d];
      else
        s.deps = h = Wr;
      if (!fl)
        for (d = ys; d < h.length; d++)
          ((f = h[d]).reactions ?? (f.reactions = [])).push(s);
    } else h !== null && ys < h.length && (Zv(s, ys), h.length = ys);
    if (i_() && va !== null && !vo && h !== null && !(s.f & 6146))
      for (d = 0; d < /** @type {Source[]} */
      va.length; d++)
        $C(
          va[d],
          /** @type {Effect} */
          s
        );
    return n !== null && qv++, u;
  } finally {
    Wr = e, ys = t, va = i, Kn = n, fl = r, Wo = o, oE(a), vo = l;
  }
}
function iF(s, e) {
  let t = e.reactions;
  if (t !== null) {
    var i = xO.call(t, s);
    if (i !== -1) {
      var n = t.length - 1;
      n === 0 ? t = e.reactions = null : (t[i] = t[n], t.pop());
    }
  }
  t === null && e.f & 2 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Wr === null || !Wr.includes(e)) && (bo(e, 4096), e.f & 768 || (e.f ^= 512), HC(
    /** @type {Derived} **/
    e
  ), Zv(
    /** @type {Derived} **/
    e,
    0
  ));
}
function Zv(s, e) {
  var t = s.deps;
  if (t !== null)
    for (var i = e; i < t.length; i++)
      iF(s, t[i]);
}
function o_(s) {
  var e = s.f;
  if (!(e & 16384)) {
    bo(s, 1024);
    var t = $n, i = Ln;
    $n = s;
    try {
      e & 16 ? hF(s) : sP(s), rP(s);
      var n = JC(s);
      s.teardown = typeof n == "function" ? n : null, s.wv = ZC;
      var r = s.deps, o;
      Db && OO && s.f & 2048;
    } catch (a) {
      s_(a, s, t, i || s.ctx);
    } finally {
      $n = t;
    }
  }
}
function QC() {
  if (zh > 1e3) {
    zh = 0;
    try {
      PO();
    } catch (s) {
      if (Mp !== null)
        s_(s, Mp, null);
      else
        throw s;
    }
  }
  zh++;
}
function eP(s) {
  var e = s.length;
  if (e !== 0) {
    QC();
    var t = Bh;
    Bh = !0;
    try {
      for (var i = 0; i < e; i++) {
        var n = s[i];
        n.f & 1024 || (n.f ^= 1024);
        var r = oF(n);
        rF(r);
      }
    } finally {
      Bh = t;
    }
  }
}
function rF(s) {
  var e = s.length;
  if (e !== 0)
    for (var t = 0; t < e; t++) {
      var i = s[t];
      if (!(i.f & 24576))
        try {
          vd(i) && (o_(i), i.deps === null && i.first === null && i.nodes_start === null && (i.teardown === null ? oP(i) : i.fn = null));
        } catch (n) {
          s_(n, i, null, i.ctx);
        }
    }
}
function sF() {
  if (Sp = !1, zh > 1001)
    return;
  const s = Lc;
  Lc = [], eP(s), Sp || (zh = 0, Mp = null);
}
function a_(s) {
  Sv === qC && (Sp || (Sp = !0, queueMicrotask(sF))), Mp = s;
  for (var e = s; e.parent !== null; ) {
    e = e.parent;
    var t = e.f;
    if (t & 96) {
      if (!(t & 1024)) return;
      e.f ^= 1024;
    }
  }
  Lc.push(e);
}
function oF(s) {
  var e = [], t = s.first;
  e: for (; t !== null; ) {
    var i = t.f, n = (i & 32) !== 0, r = n && (i & 1024) !== 0, o = t.next;
    if (!r && !(i & 8192)) {
      if (i & 4)
        e.push(t);
      else if (n)
        t.f ^= 1024;
      else {
        var a = Kn;
        try {
          Kn = t, vd(t) && o_(t);
        } catch (u) {
          s_(u, t, null, t.ctx);
        } finally {
          Kn = a;
        }
      }
      var l = t.first;
      if (l !== null) {
        t = l;
        continue;
      }
    }
    if (o === null) {
      let u = t.parent;
      for (; u !== null; ) {
        if (s === u)
          break e;
        var c = u.next;
        if (c !== null) {
          t = c;
          continue e;
        }
        u = u.parent;
      }
    }
    t = o;
  }
  return e;
}
function V(s) {
  var e = Sv, t = Lc;
  try {
    QC();
    const n = [];
    Sv = JO, Lc = n, Sp = !1, eP(t);
    var i = s == null ? void 0 : s();
    return EO(), (Lc.length > 0 || n.length > 0) && V(), zh = 0, Mp = null, i;
  } finally {
    Sv = e, Lc = t;
  }
}
async function aw() {
  await Promise.resolve(), V();
}
function pe(s) {
  var e = s.f, t = (e & 2) !== 0;
  if (Kn !== null && !vo) {
    Wo !== null && Wo.includes(s) && UO();
    var i = Kn.deps;
    s.rv < qv && (s.rv = qv, Wr === null && i !== null && i[ys] === s ? ys++ : Wr === null ? Wr = [s] : (!fl || !Wr.includes(s)) && Wr.push(s));
  } else if (t && /** @type {Derived} */
  s.deps === null && /** @type {Derived} */
  s.effects === null) {
    var n = (
      /** @type {Derived} */
      s
    ), r = n.parent;
    r !== null && !(r.f & 256) && (n.f ^= 256);
  }
  return t && (n = /** @type {Derived} */
  s, vd(n) && WC(n)), s.v;
}
function io(s) {
  var e = vo;
  try {
    return vo = !0, s();
  } finally {
    vo = e;
  }
}
const aF = -7169;
function bo(s, e) {
  s.f = s.f & aF | e;
}
function Ah(s) {
  if (!(typeof s != "object" || !s || s instanceof EventTarget)) {
    if (bl in s)
      Ub(s);
    else if (!Array.isArray(s))
      for (let e in s) {
        const t = s[e];
        typeof t == "object" && t && bl in t && Ub(t);
      }
  }
}
function Ub(s, e = /* @__PURE__ */ new Set()) {
  if (typeof s == "object" && s !== null && // We don't want to traverse DOM elements
  !(s instanceof EventTarget) && !e.has(s)) {
    e.add(s), s instanceof Date && s.getTime();
    for (let i in s)
      try {
        Ub(s[i], e);
      } catch {
      }
    const t = nw(s);
    if (t !== Object.prototype && t !== Array.prototype && t !== Map.prototype && t !== Set.prototype && t !== Date.prototype) {
      const i = IC(t);
      for (let n in i) {
        const r = i[n].get;
        if (r)
          try {
            r.call(s);
          } catch {
          }
      }
    }
  }
}
function tP(s) {
  $n === null && Kn === null && CO(), Kn !== null && Kn.f & 256 && $n === null && AO(), ow && TO();
}
function lF(s, e) {
  var t = e.last;
  t === null ? e.last = e.first = s : (t.next = s, s.prev = t, e.last = s);
}
function Tu(s, e, t, i = !0) {
  var n = (s & 64) !== 0, r = $n, o = {
    ctx: Ln,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: s | 2048,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: n ? null : r,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0
  };
  if (t) {
    var a = Bh;
    try {
      cE(!0), o_(o), o.f |= 32768;
    } catch (u) {
      throw Ko(o), u;
    } finally {
      cE(a);
    }
  } else e !== null && a_(o);
  var l = t && o.deps === null && o.first === null && o.nodes_start === null && o.teardown === null && (o.f & 1048704) === 0;
  if (!l && !n && i && (r !== null && lF(o, r), Kn !== null && Kn.f & 2)) {
    var c = (
      /** @type {Derived} */
      Kn
    );
    (c.effects ?? (c.effects = [])).push(o);
  }
  return o;
}
function nP() {
  return Kn !== null && !vo;
}
function iP(s) {
  const e = Tu(8, null, !1);
  return bo(e, 1024), e.teardown = s, e;
}
function Ht(s) {
  tP();
  var e = $n !== null && ($n.f & 32) !== 0 && Ln !== null && !Ln.m;
  if (e) {
    var t = (
      /** @type {ComponentContext} */
      Ln
    );
    (t.e ?? (t.e = [])).push({
      fn: s,
      effect: $n,
      reaction: Kn
    });
  } else {
    var i = l_(s);
    return i;
  }
}
function $e(s) {
  return tP(), _d(s);
}
function cF(s) {
  const e = Tu(64, s, !0);
  return () => {
    Ko(e);
  };
}
function uF(s) {
  const e = Tu(64, s, !0);
  return (t = {}) => new Promise((i) => {
    t.outro ? Ep(e, () => {
      Ko(e), i(void 0);
    }) : (Ko(e), i(void 0));
  });
}
function l_(s) {
  return Tu(4, s, !1);
}
function ul(s, e) {
  var t = (
    /** @type {ComponentContextLegacy} */
    Ln
  ), i = { effect: null, ran: !1 };
  t.l.r1.push(i), i.effect = _d(() => {
    s(), !i.ran && (i.ran = !0, In(t.l.r2, !0), io(e));
  });
}
function lw() {
  var s = (
    /** @type {ComponentContextLegacy} */
    Ln
  );
  _d(() => {
    if (pe(s.l.r2)) {
      for (var e of s.l.r1) {
        var t = e.effect;
        t.f & 1024 && bo(t, 4096), vd(t) && o_(t), e.ran = !1;
      }
      s.l.r2.v = !1;
    }
  });
}
function _d(s) {
  return Tu(8, s, !0);
}
function By(s, e = [], t = wt) {
  const i = e.map(t);
  return em(() => s(...i.map(pe)));
}
function em(s, e = 0) {
  return Tu(24 | e, s, !0);
}
function ed(s, e = !0) {
  return Tu(40, s, !0, e);
}
function rP(s) {
  var e = s.teardown;
  if (e !== null) {
    const t = ow, i = Kn;
    uE(!0), Jh(null);
    try {
      e.call(null);
    } finally {
      uE(t), Jh(i);
    }
  }
}
function sP(s, e = !1) {
  var t = s.first;
  for (s.first = s.last = null; t !== null; ) {
    var i = t.next;
    Ko(t, e), t = i;
  }
}
function hF(s) {
  for (var e = s.first; e !== null; ) {
    var t = e.next;
    e.f & 32 || Ko(e), e = t;
  }
}
function Ko(s, e = !0) {
  var t = !1;
  if ((e || s.f & 524288) && s.nodes_start !== null) {
    for (var i = s.nodes_start, n = s.nodes_end; i !== null; ) {
      var r = i === n ? null : (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Eu(i)
      );
      i.remove(), i = r;
    }
    t = !0;
  }
  sP(s, e && !t), Zv(s, 0), bo(s, 16384);
  var o = s.transitions;
  if (o !== null)
    for (const l of o)
      l.stop();
  rP(s);
  var a = s.parent;
  a !== null && a.first !== null && oP(s), s.next = s.prev = s.teardown = s.ctx = s.deps = s.fn = s.nodes_start = s.nodes_end = null;
}
function oP(s) {
  var e = s.parent, t = s.prev, i = s.next;
  t !== null && (t.next = i), i !== null && (i.prev = t), e !== null && (e.first === s && (e.first = i), e.last === s && (e.last = t));
}
function Ep(s, e) {
  var t = [];
  aP(s, t, !0), dF(t, () => {
    Ko(s), e && e();
  });
}
function dF(s, e) {
  var t = s.length;
  if (t > 0) {
    var i = () => --t || e();
    for (var n of s)
      n.out(i);
  } else
    e();
}
function aP(s, e, t) {
  if (!(s.f & 8192)) {
    if (s.f ^= 8192, s.transitions !== null)
      for (const o of s.transitions)
        (o.is_global || t) && e.push(o);
    for (var i = s.first; i !== null; ) {
      var n = i.next, r = (i.f & 65536) !== 0 || (i.f & 32) !== 0;
      aP(i, e, r ? t : !1), i = n;
    }
  }
}
function kb(s) {
  lP(s, !0);
}
function lP(s, e) {
  if (s.f & 8192) {
    s.f ^= 8192, s.f & 1024 || (s.f ^= 1024), vd(s) && (bo(s, 2048), a_(s));
    for (var t = s.first; t !== null; ) {
      var i = t.next, n = (t.f & 65536) !== 0 || (t.f & 32) !== 0;
      lP(t, n ? e : !1), t = i;
    }
    if (s.transitions !== null)
      for (const r of s.transitions)
        (r.is_global || e) && r.in();
  }
}
const fF = /* @__PURE__ */ new Set(), hE = /* @__PURE__ */ new Set();
function Um(s) {
  var y;
  var e = this, t = (
    /** @type {Node} */
    e.ownerDocument
  ), i = s.type, n = ((y = s.composedPath) == null ? void 0 : y.call(s)) || [], r = (
    /** @type {null | Element} */
    n[0] || s.target
  ), o = 0, a = s.__root;
  if (a) {
    var l = n.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      s.__root = e;
      return;
    }
    var c = n.indexOf(e);
    if (c === -1)
      return;
    l <= c && (o = l);
  }
  if (r = /** @type {Element} */
  n[o] || s.target, r !== e) {
    wp(s, "currentTarget", {
      configurable: !0,
      get() {
        return r || t;
      }
    });
    var u = Kn, h = $n;
    Jh(null), Qh(null);
    try {
      for (var d, f = []; r !== null; ) {
        var m = r.assignedSlot || r.parentNode || /** @type {any} */
        r.host || null;
        try {
          var g = r["__" + i];
          if (g !== void 0 && !/** @type {any} */
          r.disabled)
            if (DC(g)) {
              var [v, ..._] = g;
              v.apply(r, [s, ..._]);
            } else
              g.call(r, s);
        } catch (w) {
          d ? f.push(w) : d = w;
        }
        if (s.cancelBubble || m === e || m === null)
          break;
        r = m;
      }
      if (d) {
        for (let w of f)
          queueMicrotask(() => {
            throw w;
          });
        throw d;
      }
    } finally {
      s.__root = e, delete s.currentTarget, Jh(u), Qh(h);
    }
  }
}
function pF(s) {
  var e = document.createElement("template");
  return e.innerHTML = s, e.content;
}
function Wc(s, e) {
  var t = (
    /** @type {Effect} */
    $n
  );
  t.nodes_start === null && (t.nodes_start = s, t.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function ni(s, e) {
  var t = (e & HO) !== 0, i = (e & WO) !== 0, n, r = !s.startsWith("<!>");
  return () => {
    if (Nn)
      return Wc(oi, null), oi;
    n === void 0 && (n = pF(r ? s : "<!>" + s), t || (n = /** @type {Node} */
    /* @__PURE__ */ au(n)));
    var o = (
      /** @type {TemplateNode} */
      i || XC ? document.importNode(n, !0) : n.cloneNode(!0)
    );
    if (t) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ au(o)
      ), l = (
        /** @type {TemplateNode} */
        o.lastChild
      );
      Wc(a, l);
    } else
      Wc(o, o);
    return o;
  };
}
function At() {
  if (Nn)
    return Wc(oi, null), oi;
  var s = document.createDocumentFragment(), e = document.createComment(""), t = Qp();
  return s.append(e, t), Wc(e, t), s;
}
function ut(s, e) {
  if (Nn) {
    $n.nodes_end = oi, ou();
    return;
  }
  s !== null && s.before(
    /** @type {Node} */
    e
  );
}
const mF = ["touchstart", "touchmove"];
function gF(s) {
  return mF.includes(s);
}
const vF = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function _F(s) {
  return vF.includes(
    /** @type {RAW_TEXT_ELEMENTS[number]} */
    s
  );
}
function cP(s, e) {
  return uP(s, e);
}
function yF(s, e) {
  Lb(), e.intro = e.intro ?? !1;
  const t = e.target, i = Nn, n = oi;
  try {
    for (var r = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ au(t)
    ); r && (r.nodeType !== 8 || /** @type {Comment} */
    r.data !== FC); )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ Eu(r);
    if (!r)
      throw Wf;
    dl(!0), Pa(
      /** @type {Comment} */
      r
    ), ou();
    const o = uP(s, { ...e, anchor: r });
    if (oi === null || oi.nodeType !== 8 || /** @type {Comment} */
    oi.data !== BC)
      throw rw(), Wf;
    return dl(!1), /**  @type {Exports} */
    o;
  } catch (o) {
    if (o === Wf)
      return e.recover === !1 && RO(), Lb(), $O(t), dl(!1), cP(s, e);
    throw o;
  } finally {
    dl(i), Pa(n);
  }
}
const Hu = /* @__PURE__ */ new Map();
function uP(s, { target: e, anchor: t, props: i = {}, events: n, context: r, intro: o = !0 }) {
  Lb();
  var a = /* @__PURE__ */ new Set(), l = (h) => {
    for (var d = 0; d < h.length; d++) {
      var f = h[d];
      if (!a.has(f)) {
        a.add(f);
        var m = gF(f);
        e.addEventListener(f, Um, { passive: m });
        var g = Hu.get(f);
        g === void 0 ? (document.addEventListener(f, Um, { passive: m }), Hu.set(f, 1)) : Hu.set(f, g + 1);
      }
    }
  };
  l(bO(fF)), hE.add(l);
  var c = void 0, u = uF(() => {
    var h = t ?? e.appendChild(Qp());
    return ed(() => {
      if (r) {
        Ct({});
        var d = (
          /** @type {ComponentContext} */
          Ln
        );
        d.c = r;
      }
      n && (i.$$events = n), Nn && Wc(
        /** @type {TemplateNode} */
        h,
        null
      ), c = s(h, i) || {}, Nn && ($n.nodes_end = oi), r && Pt();
    }), () => {
      var m;
      for (var d of a) {
        e.removeEventListener(d, Um);
        var f = (
          /** @type {number} */
          Hu.get(d)
        );
        --f === 0 ? (document.removeEventListener(d, Um), Hu.delete(d)) : Hu.set(d, f);
      }
      hE.delete(l), h !== t && ((m = h.parentNode) == null || m.removeChild(h));
    };
  });
  return Ob.set(c, u), c;
}
let Ob = /* @__PURE__ */ new WeakMap();
function xF(s, e) {
  const t = Ob.get(s);
  return t ? (Ob.delete(s), t(e)) : Promise.resolve();
}
function Rt(s) {
  return new bF(s);
}
var ya, js;
class bF {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    /** @type {any} */
    Lm(this, ya);
    /** @type {Record<string, any>} */
    Lm(this, js);
    var r;
    var t = /* @__PURE__ */ new Map(), i = (o, a) => {
      var l = /* @__PURE__ */ r_(a);
      return t.set(o, l), l;
    };
    const n = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, a) {
          return pe(t.get(a) ?? i(a, Reflect.get(o, a)));
        },
        has(o, a) {
          return a === tw ? !0 : (pe(t.get(a) ?? i(a, Reflect.get(o, a))), Reflect.has(o, a));
        },
        set(o, a, l) {
          return In(t.get(a) ?? i(a, l), l), Reflect.set(o, a, l);
        }
      }
    );
    Ny(this, js, (e.hydrate ? yF : cP)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: n,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    })), (!((r = e == null ? void 0 : e.props) != null && r.$$host) || e.sync === !1) && V(), Ny(this, ya, n.$$events);
    for (const o of Object.keys(Sr(this, js)))
      o === "$set" || o === "$destroy" || o === "$on" || wp(this, o, {
        get() {
          return Sr(this, js)[o];
        },
        /** @param {any} value */
        set(a) {
          Sr(this, js)[o] = a;
        },
        enumerable: !0
      });
    Sr(this, js).$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(n, o);
    }, Sr(this, js).$destroy = () => {
      xF(Sr(this, js));
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    Sr(this, js).$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, t) {
    Sr(this, ya)[e] = Sr(this, ya)[e] || [];
    const i = (...n) => t.call(this, ...n);
    return Sr(this, ya)[e].push(i), () => {
      Sr(this, ya)[e] = Sr(this, ya)[e].filter(
        /** @param {any} fn */
        (n) => n !== i
      );
    };
  }
  $destroy() {
    Sr(this, js).$destroy();
  }
}
ya = new WeakMap(), js = new WeakMap();
const wF = "5";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(wF);
FO();
function Ai(s, e, t = !1) {
  Nn && ou();
  var i = s, n = null, r = null, o = ns, a = t ? 65536 : 0, l = !1;
  const c = (h, d = !0) => {
    l = !0, u(d, h);
  }, u = (h, d) => {
    if (o === (o = h)) return;
    let f = !1;
    if (Nn) {
      const m = (
        /** @type {Comment} */
        i.data === NC
      );
      !!o === m && (i = KO(), Pa(i), dl(!1), f = !0);
    }
    o ? (n ? kb(n) : d && (n = ed(() => d(i))), r && Ep(r, () => {
      r = null;
    })) : (r ? kb(r) : d && (r = ed(() => d(i))), n && Ep(n, () => {
      n = null;
    })), f && dl(!0);
  };
  em(() => {
    l = !1, e(c), l || u(null, null);
  }, a), Nn && (i = oi);
}
function dE(s, e, t, i, n) {
  var a;
  Nn && ou();
  var r = (a = e.$$slots) == null ? void 0 : a[t], o = !1;
  r === !0 && (r = e[t === "default" ? "children" : t], o = !0), r === void 0 || r(s, o ? () => i : i);
}
function Wt(s, e, ...t) {
  var i = s, n = Bt, r;
  em(() => {
    n !== (n = e()) && (r && (Ko(r), r = null), r = ed(() => (
      /** @type {SnippetFn} */
      n(i, ...t)
    )));
  }, 65536), Nn && (i = oi);
}
function Rs(s, e, t) {
  Nn && ou();
  var i = s, n, r;
  em(() => {
    n !== (n = e()) && (r && (Ep(r), r = null), n && (r = ed(() => t(i, n))));
  }, 65536), Nn && (i = oi);
}
function SF(s, e, t, i, n, r) {
  let o = Nn;
  Nn && ou();
  var a, l, c = null;
  Nn && oi.nodeType === 1 && (c = /** @type {Element} */
  oi, ou());
  var u = (
    /** @type {TemplateNode} */
    Nn ? oi : s
  ), h;
  em(() => {
    const d = e() || null;
    var f = d === "svg" ? XO : null;
    d !== a && (h && (d === null ? Ep(h, () => {
      h = null, l = null;
    }) : d === l ? kb(h) : Ko(h)), d && d !== l && (h = ed(() => {
      if (c = Nn ? (
        /** @type {Element} */
        c
      ) : f ? document.createElementNS(f, d) : document.createElement(d), Wc(c, c), i) {
        Nn && _F(d) && c.append(document.createComment(""));
        var m = (
          /** @type {TemplateNode} */
          Nn ? /* @__PURE__ */ au(c) : c.appendChild(Qp())
        );
        Nn && (m === null ? dl(!1) : Pa(m)), i(c, m);
      }
      $n.nodes_end = c, u.before(c);
    })), a = d, a && (l = a));
  }, 65536), o && (dl(!0), Pa(u));
}
function hP(s, e) {
  UC(() => {
    var t = s.getRootNode(), i = (
      /** @type {ShadowRoot} */
      t.host ? (
        /** @type {ShadowRoot} */
        t
      ) : (
        /** @type {Document} */
        t.head ?? /** @type {Document} */
        t.ownerDocument.head
      )
    );
    if (!i.querySelector("#" + e.hash)) {
      const n = document.createElement("style");
      n.id = e.hash, n.textContent = e.code, i.appendChild(n);
    }
  });
}
function MF(s, e, t) {
  l_(() => {
    var i = io(() => e(s, t == null ? void 0 : t()) || {});
    if (i != null && i.destroy)
      return () => (
        /** @type {Function} */
        i.destroy()
      );
  });
}
function dP(s) {
  var e, t, i = "";
  if (typeof s == "string" || typeof s == "number") i += s;
  else if (typeof s == "object") if (Array.isArray(s)) {
    var n = s.length;
    for (e = 0; e < n; e++) s[e] && (t = dP(s[e])) && (i && (i += " "), i += t);
  } else for (t in s) s[t] && (i && (i += " "), i += t);
  return i;
}
function EF() {
  for (var s, e, t = 0, i = "", n = arguments.length; t < n; t++) (s = arguments[t]) && (e = dP(s)) && (i && (i += " "), i += e);
  return i;
}
function fE(s) {
  return typeof s == "object" ? EF(s) : s ?? "";
}
function pE(s, e, t, i) {
  var n = s.__attributes ?? (s.__attributes = {});
  Nn && (n[e] = s.getAttribute(e)), n[e] !== (n[e] = t) && ("__styles" in s && (s.__styles = {}), t == null ? s.removeAttribute(e) : typeof t != "string" && TF(s).includes(e) ? s[e] = t : s.setAttribute(e, t));
}
var mE = /* @__PURE__ */ new Map();
function TF(s) {
  var e = mE.get(s.nodeName);
  if (e) return e;
  mE.set(s.nodeName, e = []);
  for (var t, i = s, n = Element.prototype; n !== i; ) {
    t = IC(i);
    for (var r in t)
      t[r].set && e.push(r);
    i = nw(i);
  }
  return e;
}
function gE(s, e, t) {
  var i = s.__className, n = AF(e);
  Nn && s.className === n ? s.__className = n : (i !== n || Nn && s.className !== n) && (e == null ? s.removeAttribute("class") : s.className = n, s.__className = n);
}
function AF(s, e) {
  return (s ?? "") + "";
}
function yi(s, e, t, i) {
  var n = s.__styles ?? (s.__styles = {});
  n[e] !== t && (n[e] = t, t == null ? s.style.removeProperty(e) : s.style.setProperty(e, t, ""));
}
const CF = () => performance.now(), go = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (s) => requestAnimationFrame(s)
  ),
  now: () => CF(),
  tasks: /* @__PURE__ */ new Set()
};
function fP() {
  const s = go.now();
  go.tasks.forEach((e) => {
    e.c(s) || (go.tasks.delete(e), e.f());
  }), go.tasks.size !== 0 && go.tick(fP);
}
function PF(s) {
  let e;
  return go.tasks.size === 0 && go.tick(fP), {
    promise: new Promise((t) => {
      go.tasks.add(e = { c: s, f: t });
    }),
    abort() {
      go.tasks.delete(e);
    }
  };
}
function RF(s, e, t) {
  var i = Ho(s, e);
  i && i.set && (s[e] = t, iP(() => {
    s[e] = null;
  }));
}
function vE(s, e) {
  return s === e || (s == null ? void 0 : s[bl]) === e;
}
function Vh(s = {}, e, t, i) {
  return l_(() => {
    var n, r;
    return _d(() => {
      n = r, r = [], io(() => {
        s !== t(...r) && (e(s, ...r), n && vE(t(...n), s) && e(null, ...n));
      });
    }), () => {
      UC(() => {
        r && vE(t(...r), s) && e(null, ...r);
      });
    };
  }), s;
}
function Au(s = !1) {
  const e = (
    /** @type {ComponentContextLegacy} */
    Ln
  ), t = e.l.u;
  if (!t) return;
  let i = () => Ah(e.s);
  if (s) {
    let n = 0, r = (
      /** @type {Record<string, any>} */
      {}
    );
    const o = /* @__PURE__ */ wt(() => {
      let a = !1;
      const l = e.s;
      for (const c in l)
        l[c] !== r[c] && (r[c] = l[c], a = !0);
      return a && n++, n;
    });
    i = () => pe(o);
  }
  t.b.length && $e(() => {
    _E(e, i), Yv(t.b);
  }), Ht(() => {
    const n = io(() => t.m.map(MO));
    return () => {
      for (const r of n)
        typeof r == "function" && r();
    };
  }), t.a.length && Ht(() => {
    _E(e, i), Yv(t.a);
  });
}
function _E(s, e) {
  if (s.l.s)
    for (const t of s.l.s) pe(t);
  e();
}
function It(s, e, t) {
  var i;
  s.$$events || (s.$$events = {}), (i = s.$$events)[e] || (i[e] = []), s.$$events[e].push(t);
}
function Lt(s) {
  for (var e in s)
    e in this && (this[e] = s[e]);
}
function So(s) {
  Ln === null && sw(), gd && Ln.l !== null ? DF(Ln).m.push(s) : Ht(() => {
    const e = io(s);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function Ki(s) {
  Ln === null && sw(), So(() => () => io(s));
}
function DF(s) {
  var e = (
    /** @type {ComponentContextLegacy} */
    s.l
  );
  return e.u ?? (e.u = { a: [], b: [], m: [] });
}
function cw(s, e, t) {
  if (s == null)
    return e(void 0), t && t(void 0), Bt;
  const i = io(
    () => s.subscribe(
      e,
      // @ts-expect-error
      t
    )
  );
  return i.unsubscribe ? () => i.unsubscribe() : i;
}
const Wu = [];
function tm(s, e) {
  return {
    subscribe: Gn(s, e).subscribe
  };
}
function Gn(s, e = Bt) {
  let t = null;
  const i = /* @__PURE__ */ new Set();
  function n(a) {
    if (OC(s, a) && (s = a, t)) {
      const l = !Wu.length;
      for (const c of i)
        c[1](), Wu.push(c, s);
      if (l) {
        for (let c = 0; c < Wu.length; c += 2)
          Wu[c][0](Wu[c + 1]);
        Wu.length = 0;
      }
    }
  }
  function r(a) {
    n(a(
      /** @type {T} */
      s
    ));
  }
  function o(a, l = Bt) {
    const c = [a, l];
    return i.add(c), i.size === 1 && (t = e(n, r) || Bt), a(
      /** @type {T} */
      s
    ), () => {
      i.delete(c), i.size === 0 && t && (t(), t = null);
    };
  }
  return { set: n, update: r, subscribe: o };
}
function Cl(s, e, t) {
  const i = !Array.isArray(s), n = i ? [s] : s;
  if (!n.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const r = e.length < 2;
  return tm(t, (o, a) => {
    let l = !1;
    const c = [];
    let u = 0, h = Bt;
    const d = () => {
      if (u)
        return;
      h();
      const m = e(i ? c[0] : c, o, a);
      r ? o(m) : h = typeof m == "function" ? m : Bt;
    }, f = n.map(
      (m, g) => cw(
        m,
        (v) => {
          c[g] = v, u &= ~(1 << g), l && d();
        },
        () => {
          u |= 1 << g;
        }
      )
    );
    return l = !0, d(), function() {
      Yv(f), h(), l = !1;
    };
  });
}
function Kv(s) {
  let e;
  return cw(s, (t) => e = t)(), e;
}
let km = !1, Fb = Symbol();
function Bn(s, e, t) {
  const i = t[e] ?? (t[e] = {
    store: null,
    source: /* @__PURE__ */ r_(void 0),
    unsubscribe: Bt
  });
  if (i.store !== s && !(Fb in t))
    if (i.unsubscribe(), i.store = s ?? null, s == null)
      i.source.v = void 0, i.unsubscribe = Bt;
    else {
      var n = !0;
      i.unsubscribe = cw(s, (r) => {
        n ? i.source.v = r : In(i.source, r);
      }), n = !1;
    }
  return s && Fb in t ? Kv(s) : pe(i.source);
}
function Nb(s, e) {
  return s.set(e), e;
}
function $i() {
  const s = {};
  function e() {
    iP(() => {
      for (var t in s)
        s[t].unsubscribe();
      wp(s, Fb, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [s, e];
}
function IF(s) {
  var e = km;
  try {
    return km = !1, [s(), km];
  } finally {
    km = e;
  }
}
const LF = {
  get(s, e) {
    if (!s.exclude.includes(e))
      return s.props[e];
  },
  set(s, e) {
    return !1;
  },
  getOwnPropertyDescriptor(s, e) {
    if (!s.exclude.includes(e) && e in s.props)
      return {
        enumerable: !0,
        configurable: !0,
        value: s.props[e]
      };
  },
  has(s, e) {
    return s.exclude.includes(e) ? !1 : e in s.props;
  },
  ownKeys(s) {
    return Reflect.ownKeys(s.props).filter((e) => !s.exclude.includes(e));
  }
};
// @__NO_SIDE_EFFECTS__
function an(s, e, t) {
  return new Proxy(
    { props: s, exclude: e },
    LF
  );
}
const UF = {
  get(s, e) {
    let t = s.props.length;
    for (; t--; ) {
      let i = s.props[t];
      if ($d(i) && (i = i()), typeof i == "object" && i !== null && e in i) return i[e];
    }
  },
  set(s, e, t) {
    let i = s.props.length;
    for (; i--; ) {
      let n = s.props[i];
      $d(n) && (n = n());
      const r = Ho(n, e);
      if (r && r.set)
        return r.set(t), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(s, e) {
    let t = s.props.length;
    for (; t--; ) {
      let i = s.props[t];
      if ($d(i) && (i = i()), typeof i == "object" && i !== null && e in i) {
        const n = Ho(i, e);
        return n && !n.configurable && (n.configurable = !0), n;
      }
    }
  },
  has(s, e) {
    if (e === bl || e === tw) return !1;
    for (let t of s.props)
      if ($d(t) && (t = t()), t != null && e in t) return !0;
    return !1;
  },
  ownKeys(s) {
    const e = [];
    for (let t of s.props) {
      $d(t) && (t = t());
      for (const i in t)
        e.includes(i) || e.push(i);
    }
    return e;
  }
};
function sn(...s) {
  return new Proxy({ props: s }, UF);
}
function G(s, e, t, i) {
  var A;
  var n = (t & NO) !== 0, r = !gd || (t & BO) !== 0, o = (t & VO) !== 0, a = (t & GO) !== 0, l = !1, c;
  o ? [c, l] = IF(() => (
    /** @type {V} */
    s[e]
  )) : c = /** @type {V} */
  s[e];
  var u = bl in s || tw in s, h = o && (((A = Ho(s, e)) == null ? void 0 : A.set) ?? (u && e in s && ((E) => s[e] = E))) || void 0, d = (
    /** @type {V} */
    i
  ), f = !0, m = !1, g = () => (m = !0, f && (f = !1, a ? d = io(
    /** @type {() => V} */
    i
  ) : d = /** @type {V} */
  i), d);
  c === void 0 && i !== void 0 && (h && r && DO(), c = g(), h && h(c));
  var v;
  if (r)
    v = () => {
      var E = (
        /** @type {V} */
        s[e]
      );
      return E === void 0 ? g() : (f = !0, m = !1, E);
    };
  else {
    var _ = (n ? wt : bv)(
      () => (
        /** @type {V} */
        s[e]
      )
    );
    _.f |= 131072, v = () => {
      var E = pe(_);
      return E !== void 0 && (d = /** @type {V} */
      void 0), E === void 0 ? d : E;
    };
  }
  if (!(t & zO))
    return v;
  if (h) {
    var y = s.$$legacy;
    return function(E, C) {
      return arguments.length > 0 ? ((!r || !C || y || l) && h(C ? v() : E), E) : v();
    };
  }
  var w = !1, x = /* @__PURE__ */ r_(c), M = /* @__PURE__ */ wt(() => {
    var E = v(), C = pe(x);
    return w ? (w = !1, C) : x.v = E;
  });
  return n || (M.equals = iw), function(E, C) {
    if (arguments.length > 0) {
      const P = C ? pe(M) : r && o ? pr(E) : E;
      return M.equals(P) || (w = !0, In(x, P), m && d !== void 0 && (d = P), io(() => pe(M))), E;
    }
    return pe(M);
  };
}
let pP;
typeof HTMLElement == "function" && (pP = class extends HTMLElement {
  /**
   * @param {*} $$componentCtor
   * @param {*} $$slots
   * @param {*} use_shadow_dom
   */
  constructor(e, t, i) {
    super();
    /** The Svelte component constructor */
    ht(this, "$$ctor");
    /** Slots */
    ht(this, "$$s");
    /** @type {any} The Svelte component instance */
    ht(this, "$$c");
    /** Whether or not the custom element is connected */
    ht(this, "$$cn", !1);
    /** @type {Record<string, any>} Component props data */
    ht(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    ht(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    ht(this, "$$p_d", {});
    /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
    ht(this, "$$l", {});
    /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
    ht(this, "$$l_u", /* @__PURE__ */ new Map());
    /** @type {any} The managed render effect for reflecting attributes */
    ht(this, "$$me");
    this.$$ctor = e, this.$$s = t, i && this.attachShadow({ mode: "open" });
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  addEventListener(e, t, i) {
    if (this.$$l[e] = this.$$l[e] || [], this.$$l[e].push(t), this.$$c) {
      const n = this.$$c.$on(e, t);
      this.$$l_u.set(t, n);
    }
    super.addEventListener(e, t, i);
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  removeEventListener(e, t, i) {
    if (super.removeEventListener(e, t, i), this.$$c) {
      const n = this.$$l_u.get(t);
      n && (n(), this.$$l_u.delete(t));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let e = function(n) {
        return (r) => {
          const o = document.createElement("slot");
          n !== "default" && (o.name = n), ut(r, o);
        };
      };
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const t = {}, i = kF(this);
      for (const n of this.$$s)
        n in i && (n === "default" && !this.$$d.children ? (this.$$d.children = e(n), t.default = !0) : t[n] = e(n));
      for (const n of this.attributes) {
        const r = this.$$g_p(n.name);
        r in this.$$d || (this.$$d[r] = Mv(r, n.value, this.$$p_d, "toProp"));
      }
      for (const n in this.$$p_d)
        !(n in this.$$d) && this[n] !== void 0 && (this.$$d[n] = this[n], delete this[n]);
      this.$$c = Rt({
        component: this.$$ctor,
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: t,
          $$host: this
        }
      }), this.$$me = cF(() => {
        _d(() => {
          var n;
          this.$$r = !0;
          for (const r of Xv(this.$$c)) {
            if (!((n = this.$$p_d[r]) != null && n.reflect)) continue;
            this.$$d[r] = this.$$c[r];
            const o = Mv(
              r,
              this.$$d[r],
              this.$$p_d,
              "toAttribute"
            );
            o == null ? this.removeAttribute(this.$$p_d[r].attribute || r) : this.setAttribute(this.$$p_d[r].attribute || r, o);
          }
          this.$$r = !1;
        });
      });
      for (const n in this.$$l)
        for (const r of this.$$l[n]) {
          const o = this.$$c.$on(n, r);
          this.$$l_u.set(r, o);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  /**
   * @param {string} attr
   * @param {string} _oldValue
   * @param {string} newValue
   */
  attributeChangedCallback(e, t, i) {
    var n;
    this.$$r || (e = this.$$g_p(e), this.$$d[e] = Mv(e, i, this.$$p_d, "toProp"), (n = this.$$c) == null || n.$set({ [e]: this.$$d[e] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$me(), this.$$c = void 0);
    });
  }
  /**
   * @param {string} attribute_name
   */
  $$g_p(e) {
    return Xv(this.$$p_d).find(
      (t) => this.$$p_d[t].attribute === e || !this.$$p_d[t].attribute && t.toLowerCase() === e
    ) || e;
  }
});
function Mv(s, e, t, i) {
  var r;
  const n = (r = t[s]) == null ? void 0 : r.type;
  if (e = n === "Boolean" && typeof e != "boolean" ? e != null : e, !i || !t[s])
    return e;
  if (i === "toAttribute")
    switch (n) {
      case "Object":
      case "Array":
        return e == null ? null : JSON.stringify(e);
      case "Boolean":
        return e ? "" : null;
      case "Number":
        return e ?? null;
      default:
        return e;
    }
  else
    switch (n) {
      case "Object":
      case "Array":
        return e && JSON.parse(e);
      case "Boolean":
        return e;
      // conversion already handled above
      case "Number":
        return e != null ? +e : e;
      default:
        return e;
    }
}
function kF(s) {
  const e = {};
  return s.childNodes.forEach((t) => {
    e[
      /** @type {Element} node */
      t.slot || "default"
    ] = !0;
  }), e;
}
function Ut(s, e, t, i, n, r) {
  let o = class extends pP {
    constructor() {
      super(s, t, n), this.$$p_d = e;
    }
    static get observedAttributes() {
      return Xv(e).map(
        (a) => (e[a].attribute || a).toLowerCase()
      );
    }
  };
  return Xv(e).forEach((a) => {
    wp(o.prototype, a, {
      get() {
        return this.$$c && a in this.$$c ? this.$$c[a] : this.$$d[a];
      },
      set(l) {
        var h;
        l = Mv(a, l, e), this.$$d[a] = l;
        var c = this.$$c;
        if (c) {
          var u = (h = Ho(c, a)) == null ? void 0 : h.get;
          u ? c[a] = l : c.$set({ [a]: l });
        }
      }
    });
  }), i.forEach((a) => {
    wp(o.prototype, a, {
      get() {
        var l;
        return (l = this.$$c) == null ? void 0 : l[a];
      }
    });
  }), s.element = /** @type {any} */
  o, o;
}
(function() {
  function s() {
    for (var i = arguments.length, n = 0; n < i; n++) {
      var r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
      r.nodeType === 1 || r.nodeType === 11 ? this.appendChild(r) : this.appendChild(document.createTextNode(String(r)));
    }
  }
  function e() {
    for (; this.lastChild; )
      this.removeChild(this.lastChild);
    arguments.length && this.append.apply(this, arguments);
  }
  function t() {
    for (var i = this.parentNode, n = arguments.length, r = new Array(n), o = 0; o < n; o++)
      r[o] = arguments[o];
    var a = r.length;
    if (i)
      for (a || i.removeChild(this); a--; ) {
        var l = r[a];
        typeof l != "object" ? l = this.ownerDocument.createTextNode(l) : l.parentNode && l.parentNode.removeChild(l), a ? i.insertBefore(this.previousSibling, l) : i.replaceChild(l, this);
      }
  }
  typeof Element < "u" && (Element.prototype.append || (Element.prototype.append = s, DocumentFragment.prototype.append = s), Element.prototype.replaceChildren || (Element.prototype.replaceChildren = e, DocumentFragment.prototype.replaceChildren = e), Element.prototype.replaceWith || (Element.prototype.replaceWith = t, DocumentFragment.prototype.replaceWith = t));
})();
function OF(s, e) {
  if (!(s instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function yE(s, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(s, i.key, i);
  }
}
function xE(s, e, t) {
  return e && yE(s.prototype, e), t && yE(s, t), s;
}
function FF(s, e, t) {
  return e in s ? Object.defineProperty(s, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : s[e] = t, s;
}
function bE(s, e) {
  var t = Object.keys(s);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(s);
    e && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(s, n).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function wE(s) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? bE(Object(t), !0).forEach(function(i) {
      FF(s, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : bE(Object(t)).forEach(function(i) {
      Object.defineProperty(s, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return s;
}
function mP(s, e) {
  return BF(s) || VF(s, e) || gP(s, e) || HF();
}
function Xr(s) {
  return NF(s) || zF(s) || gP(s) || GF();
}
function NF(s) {
  if (Array.isArray(s)) return Bb(s);
}
function BF(s) {
  if (Array.isArray(s)) return s;
}
function zF(s) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(s)) return Array.from(s);
}
function VF(s, e) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(s)))) {
    var t = [], i = !0, n = !1, r = void 0;
    try {
      for (var o = s[Symbol.iterator](), a; !(i = (a = o.next()).done) && (t.push(a.value), !(e && t.length === e)); i = !0)
        ;
    } catch (l) {
      n = !0, r = l;
    } finally {
      try {
        !i && o.return != null && o.return();
      } finally {
        if (n) throw r;
      }
    }
    return t;
  }
}
function gP(s, e) {
  if (s) {
    if (typeof s == "string") return Bb(s, e);
    var t = Object.prototype.toString.call(s).slice(8, -1);
    if (t === "Object" && s.constructor && (t = s.constructor.name), t === "Map" || t === "Set") return Array.from(s);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Bb(s, e);
  }
}
function Bb(s, e) {
  (e == null || e > s.length) && (e = s.length);
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = s[t];
  return i;
}
function GF() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function HF() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Uc(s, e) {
  return Object.getOwnPropertyNames(Object(s)).reduce(function(t, i) {
    var n = Object.getOwnPropertyDescriptor(Object(s), i), r = Object.getOwnPropertyDescriptor(Object(e), i);
    return Object.defineProperty(t, i, r || n);
  }, {});
}
function nm(s) {
  return typeof s == "string";
}
function uw(s) {
  return Array.isArray(s);
}
function Om() {
  var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = Uc(s), t;
  return e.types !== void 0 ? t = e.types : e.split !== void 0 && (t = e.split), t !== void 0 && (e.types = (nm(t) || uw(t) ? String(t) : "").split(",").map(function(i) {
    return String(i).trim();
  }).filter(function(i) {
    return /((line)|(word)|(char))/i.test(i);
  })), (e.absolute || e.position) && (e.absolute = e.absolute || /absolute/.test(s.position)), e;
}
function hw(s) {
  var e = nm(s) || uw(s) ? String(s) : "";
  return {
    none: !e,
    lines: /line/i.test(e),
    words: /word/i.test(e),
    chars: /char/i.test(e)
  };
}
function c_(s) {
  return s !== null && typeof s == "object";
}
function WF(s) {
  return c_(s) && /^(1|3|11)$/.test(s.nodeType);
}
function XF(s) {
  return typeof s == "number" && s > -1 && s % 1 === 0;
}
function YF(s) {
  return c_(s) && XF(s.length);
}
function lu(s) {
  return uw(s) ? s : s == null ? [] : YF(s) ? Array.prototype.slice.call(s) : [s];
}
function SE(s) {
  var e = s;
  return nm(s) && (/^(#[a-z]\w+)$/.test(s.trim()) ? e = document.getElementById(s.trim().slice(1)) : e = document.querySelectorAll(s)), lu(e).reduce(function(t, i) {
    return [].concat(Xr(t), Xr(lu(i).filter(WF)));
  }, []);
}
var jF = Object.entries, $v = "_splittype", yo = {}, qF = 0;
function Bo(s, e, t) {
  if (!c_(s))
    return console.warn("[data.set] owner is not an object"), null;
  var i = s[$v] || (s[$v] = ++qF), n = yo[i] || (yo[i] = {});
  return t === void 0 ? e && Object.getPrototypeOf(e) === Object.prototype && (yo[i] = wE(wE({}, n), e)) : e !== void 0 && (n[e] = t), t;
}
function kc(s, e) {
  var t = c_(s) ? s[$v] : null, i = t && yo[t] || {};
  return i;
}
function vP(s) {
  var e = s && s[$v];
  e && (delete s[e], delete yo[e]);
}
function ZF() {
  Object.keys(yo).forEach(function(s) {
    delete yo[s];
  });
}
function KF() {
  jF(yo).forEach(function(s) {
    var e = mP(s, 2), t = e[0], i = e[1], n = i.isRoot, r = i.isSplit;
    (!n || !r) && (yo[t] = null, delete yo[t]);
  });
}
function $F(s) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ", t = s ? String(s) : "";
  return t.trim().replace(/\s+/g, " ").split(e);
}
var dw = "\\ud800-\\udfff", _P = "\\u0300-\\u036f\\ufe20-\\ufe23", yP = "\\u20d0-\\u20f0", xP = "\\ufe0e\\ufe0f", JF = "[".concat(dw, "]"), zb = "[".concat(_P).concat(yP, "]"), Vb = "\\ud83c[\\udffb-\\udfff]", QF = "(?:".concat(zb, "|").concat(Vb, ")"), bP = "[^".concat(dw, "]"), wP = "(?:\\ud83c[\\udde6-\\uddff]){2}", SP = "[\\ud800-\\udbff][\\udc00-\\udfff]", MP = "\\u200d", EP = "".concat(QF, "?"), TP = "[".concat(xP, "]?"), eN = "(?:" + MP + "(?:" + [bP, wP, SP].join("|") + ")" + TP + EP + ")*", tN = TP + EP + eN, nN = "(?:".concat(["".concat(bP).concat(zb, "?"), zb, wP, SP, JF].join("|"), `
)`), iN = RegExp("".concat(Vb, "(?=").concat(Vb, ")|").concat(nN).concat(tN), "g"), rN = [MP, dw, _P, yP, xP], sN = RegExp("[".concat(rN.join(""), "]"));
function oN(s) {
  return s.split("");
}
function AP(s) {
  return sN.test(s);
}
function aN(s) {
  return s.match(iN) || [];
}
function lN(s) {
  return AP(s) ? aN(s) : oN(s);
}
function cN(s) {
  return s == null ? "" : String(s);
}
function uN(s) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return s = cN(s), s && nm(s) && !e && AP(s) ? lN(s) : s.split(e);
}
function Gb(s, e) {
  var t = document.createElement(s);
  return e && Object.keys(e).forEach(function(i) {
    var n = e[i], r = nm(n) ? n.trim() : n;
    r === null || r === "" || (i === "children" ? t.append.apply(t, Xr(lu(r))) : t.setAttribute(i, r));
  }), t;
}
var fw = {
  splitClass: "",
  lineClass: "line",
  wordClass: "word",
  charClass: "char",
  types: ["lines", "words", "chars"],
  absolute: !1,
  tagName: "div"
};
function hN(s, e) {
  e = Uc(fw, e);
  var t = hw(e.types), i = e.tagName, n = s.nodeValue, r = document.createDocumentFragment(), o = [], a = [];
  return /^\s/.test(n) && r.append(" "), o = $F(n).reduce(function(l, c, u, h) {
    var d, f;
    return t.chars && (f = uN(c).map(function(m) {
      var g = Gb(i, {
        class: "".concat(e.splitClass, " ").concat(e.charClass),
        style: "display: inline-block;",
        children: m
      });
      return Bo(g, "isChar", !0), a = [].concat(Xr(a), [g]), g;
    })), t.words || t.lines ? (d = Gb(i, {
      class: "".concat(e.wordClass, " ").concat(e.splitClass),
      style: "display: inline-block; ".concat(t.words && e.absolute ? "position: relative;" : ""),
      children: t.chars ? f : c
    }), Bo(d, {
      isWord: !0,
      isWordStart: !0,
      isWordEnd: !0
    }), r.appendChild(d)) : f.forEach(function(m) {
      r.appendChild(m);
    }), u < h.length - 1 && r.append(" "), t.words ? l.concat(d) : l;
  }, []), /\s$/.test(n) && r.append(" "), s.replaceWith(r), {
    words: o,
    chars: a
  };
}
function CP(s, e) {
  var t = s.nodeType, i = {
    words: [],
    chars: []
  };
  if (!/(1|3|11)/.test(t))
    return i;
  if (t === 3 && /\S/.test(s.nodeValue))
    return hN(s, e);
  var n = lu(s.childNodes);
  if (n.length && (Bo(s, "isSplit", !0), !kc(s).isRoot)) {
    s.style.display = "inline-block", s.style.position = "relative";
    var r = s.nextSibling, o = s.previousSibling, a = s.textContent || "", l = r ? r.textContent : " ", c = o ? o.textContent : " ";
    Bo(s, {
      isWordEnd: /\s$/.test(a) || /^\s/.test(l),
      isWordStart: /^\s/.test(a) || /\s$/.test(c)
    });
  }
  return n.reduce(function(u, h) {
    var d = CP(h, e), f = d.words, m = d.chars;
    return {
      words: [].concat(Xr(u.words), Xr(f)),
      chars: [].concat(Xr(u.chars), Xr(m))
    };
  }, i);
}
function dN(s, e, t, i) {
  if (!t.absolute)
    return {
      top: e ? s.offsetTop : null
    };
  var n = s.offsetParent, r = mP(i, 2), o = r[0], a = r[1], l = 0, c = 0;
  if (n && n !== document.body) {
    var u = n.getBoundingClientRect();
    l = u.x + o, c = u.y + a;
  }
  var h = s.getBoundingClientRect(), d = h.width, f = h.height, m = h.x, g = h.y, v = g + a - c, _ = m + o - l;
  return {
    width: d,
    height: f,
    top: v,
    left: _
  };
}
function PP(s) {
  kc(s).isWord ? (vP(s), s.replaceWith.apply(s, Xr(s.childNodes))) : lu(s.children).forEach(function(e) {
    return PP(e);
  });
}
var fN = function() {
  return document.createDocumentFragment();
};
function pN(s, e, t) {
  var i = hw(e.types), n = e.tagName, r = s.getElementsByTagName("*"), o = [], a = [], l = null, c, u, h, d = [], f = s.parentElement, m = s.nextElementSibling, g = fN(), v = window.getComputedStyle(s), _ = v.textAlign, y = parseFloat(v.fontSize), w = y * 0.2;
  return e.absolute && (h = {
    left: s.offsetLeft,
    top: s.offsetTop,
    width: s.offsetWidth
  }, u = s.offsetWidth, c = s.offsetHeight, Bo(s, {
    cssWidth: s.style.width,
    cssHeight: s.style.height
  })), lu(r).forEach(function(x) {
    var M = x.parentElement === s, A = dN(x, M, e, t), E = A.width, C = A.height, P = A.top, T = A.left;
    /^br$/i.test(x.nodeName) || (i.lines && M && ((l === null || P - l >= w) && (l = P, o.push(a = [])), a.push(x)), e.absolute && Bo(x, {
      top: P,
      left: T,
      width: E,
      height: C
    }));
  }), f && f.removeChild(s), i.lines && (d = o.map(function(x) {
    var M = Gb(n, {
      class: "".concat(e.splitClass, " ").concat(e.lineClass),
      style: "display: block; text-align: ".concat(_, "; width: 100%;")
    });
    Bo(M, "isLine", !0);
    var A = {
      height: 0,
      top: 1e4
    };
    return g.appendChild(M), x.forEach(function(E, C, P) {
      var T = kc(E), I = T.isWordEnd, D = T.top, U = T.height, L = P[C + 1];
      A.height = Math.max(A.height, U), A.top = Math.min(A.top, D), M.appendChild(E), I && kc(L).isWordStart && M.append(" ");
    }), e.absolute && Bo(M, {
      height: A.height,
      top: A.top
    }), M;
  }), i.words || PP(g), s.replaceChildren(g)), e.absolute && (s.style.width = "".concat(s.style.width || u, "px"), s.style.height = "".concat(c, "px"), lu(r).forEach(function(x) {
    var M = kc(x), A = M.isLine, E = M.top, C = M.left, P = M.width, T = M.height, I = kc(x.parentElement), D = !A && I.isLine;
    x.style.top = "".concat(D ? E - I.top : E, "px"), x.style.left = A ? "".concat(h.left, "px") : "".concat(C - (D ? h.left : 0), "px"), x.style.height = "".concat(T, "px"), x.style.width = A ? "".concat(h.width, "px") : "".concat(P, "px"), x.style.position = "absolute";
  })), f && (m ? f.insertBefore(s, m) : f.appendChild(s)), d;
}
var Xu = Uc(fw, {}), Ev = /* @__PURE__ */ function() {
  xE(s, null, [{
    key: "clearData",
    /**
     * CLears all data
     */
    value: function() {
      ZF();
    }
    /**
     * The default settings for all splitType instances
     * @static
     */
  }, {
    key: "setDefaults",
    /**
     * Sets the default settings for all SplitType instances.
     * The provided object will be merged with the existing defaults objects.
     *
     * @param {Object} settings an object containing the settings to override
     * @returns {Object} the new default settings
     * @public
     * @static
     * @example
     * SplitType.setDefaults({ "position": "absolute" })
     */
    value: function(t) {
      return Xu = Uc(Xu, Om(t)), fw;
    }
    /**
     * Revert target elements to their original html content
     * Has no effect on that
     *
     * @param {any} elements The target elements to revert. One of:
     *  - {string} A css selector
     *  - {HTMLElement} A single element
     * -  {NodeList} A NodeList or collection
     *  - {HTMLElement[]} An array of Elements
     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements
     * @static
     */
  }, {
    key: "revert",
    value: function(t) {
      SE(t).forEach(function(i) {
        var n = kc(i), r = n.isSplit, o = n.html, a = n.cssWidth, l = n.cssHeight;
        r && (i.innerHTML = o, i.style.width = a || "", i.style.height = l || "", vP(i));
      });
    }
    /**
     * Creates a new SplitType instance
     * This static method provides a way to create a `SplitType` instance without
     * using the `new` keyword.
     *
     * @param {any} target The target elements to split. One of:
     *  - {string} A css selector
     *  - {HTMLElement} A single element
     * -  {NodeList} A NodeList or collection
     *  - {HTMLElement[]} An array of Elements
     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements
     * @param {Object} [options] Settings for the SplitType instance
     * @return {SplitType} the SplitType instance
     * @static
     */
  }, {
    key: "create",
    value: function(t, i) {
      return new s(t, i);
    }
    /**
     * Creates a new `SplitType` instance
     *
     * @param {any} elements The target elements to split. One of:
     *  - {string} A css selector
     *  - {HTMLElement} A single element
     * -  {NodeList} A NodeList or collection
     *  - {HTMLElement[]} An array of Elements
     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements
     * @param {Object} [options] Settings for the SplitType instance
     */
  }, {
    key: "data",
    /**
     * The internal data store
     */
    get: function() {
      return yo;
    }
  }, {
    key: "defaults",
    get: function() {
      return Xu;
    },
    set: function(t) {
      Xu = Uc(Xu, Om(t));
    }
  }]);
  function s(e, t) {
    OF(this, s), this.isSplit = !1, this.settings = Uc(Xu, Om(t)), this.elements = SE(e), this.split();
  }
  return xE(s, [{
    key: "split",
    value: function(t) {
      var i = this;
      this.revert(), this.elements.forEach(function(o) {
        Bo(o, "html", o.innerHTML);
      }), this.lines = [], this.words = [], this.chars = [];
      var n = [window.pageXOffset, window.pageYOffset];
      t !== void 0 && (this.settings = Uc(this.settings, Om(t)));
      var r = hw(this.settings.types);
      r.none || (this.elements.forEach(function(o) {
        Bo(o, "isRoot", !0);
        var a = CP(o, i.settings), l = a.words, c = a.chars;
        i.words = [].concat(Xr(i.words), Xr(l)), i.chars = [].concat(Xr(i.chars), Xr(c));
      }), this.elements.forEach(function(o) {
        if (r.lines || i.settings.absolute) {
          var a = pN(o, i.settings, n);
          i.lines = [].concat(Xr(i.lines), Xr(a));
        }
      }), this.isSplit = !0, window.scrollTo(n[0], n[1]), KF());
    }
    /**
     * Reverts target element(s) back to their original html content
     * Deletes all stored data associated with the target elements
     * Resets the properties on the splitType instance
     *
     * @public
     */
  }, {
    key: "revert",
    value: function() {
      this.isSplit && (this.lines = null, this.words = null, this.chars = null, this.isSplit = !1), s.revert(this.elements);
    }
  }]), s;
}();
function ma(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function RP(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, s.__proto__ = e;
}
/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Ds = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, td = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, pw, _r, hi, Xo = 1e8, Ur = 1 / Xo, Hb = Math.PI * 2, mN = Hb / 4, gN = 0, DP = Math.sqrt, vN = Math.cos, _N = Math.sin, rr = function(e) {
  return typeof e == "string";
}, Si = function(e) {
  return typeof e == "function";
}, Ra = function(e) {
  return typeof e == "number";
}, mw = function(e) {
  return typeof e > "u";
}, $o = function(e) {
  return typeof e == "object";
}, as = function(e) {
  return e !== !1;
}, gw = function() {
  return typeof window < "u";
}, Fm = function(e) {
  return Si(e) || rr(e);
}, IP = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, kr = Array.isArray, Wb = /(?:-?\.?\d|\.)+/gi, LP = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Rh = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, zy = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, UP = /[+-]=-?[.\d]+/, kP = /[^,'"\[\]\s]+/gi, yN = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, mi, Uo, Xb, vw, ks = {}, Jv = {}, OP, FP = function(e) {
  return (Jv = nd(e, ks)) && ds;
}, _w = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, Tp = function(e, t) {
  return !t && console.warn(e);
}, NP = function(e, t) {
  return e && (ks[e] = t) && Jv && (Jv[e] = t) || ks;
}, Ap = function() {
  return 0;
}, xN = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, Tv = {
  suppressEvents: !0,
  kill: !1
}, bN = {
  suppressEvents: !0
}, yw = {}, wl = [], Yb = {}, BP, ws = {}, Vy = {}, ME = 30, Av = [], xw = "", bw = function(e) {
  var t = e[0], i, n;
  if ($o(t) || Si(t) || (e = [e]), !(i = (t._gsap || {}).harness)) {
    for (n = Av.length; n-- && !Av[n].targetTest(t); )
      ;
    i = Av[n];
  }
  for (n = e.length; n--; )
    e[n] && (e[n]._gsap || (e[n]._gsap = new cR(e[n], i))) || e.splice(n, 1);
  return e;
}, Xc = function(e) {
  return e._gsap || bw(Qs(e))[0]._gsap;
}, zP = function(e, t, i) {
  return (i = e[t]) && Si(i) ? e[t]() : mw(i) && e.getAttribute && e.getAttribute(t) || i;
}, ls = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, Ti = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, ki = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, Gh = function(e, t) {
  var i = t.charAt(0), n = parseFloat(t.substr(2));
  return e = parseFloat(e), i === "+" ? e + n : i === "-" ? e - n : i === "*" ? e * n : e / n;
}, wN = function(e, t) {
  for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i; )
    ;
  return n < i;
}, Qv = function() {
  var e = wl.length, t = wl.slice(0), i, n;
  for (Yb = {}, wl.length = 0, i = 0; i < e; i++)
    n = t[i], n && n._lazy && (n.render(n._lazy[0], n._lazy[1], !0)._lazy = 0);
}, VP = function(e, t, i, n) {
  wl.length && !_r && Qv(), e.render(t, i, _r && t < 0 && (e._initted || e._startAt)), wl.length && !_r && Qv();
}, GP = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(kP).length < 2 ? t : rr(e) ? e.trim() : e;
}, HP = function(e) {
  return e;
}, Os = function(e, t) {
  for (var i in t)
    i in e || (e[i] = t[i]);
  return e;
}, SN = function(e) {
  return function(t, i) {
    for (var n in i)
      n in t || n === "duration" && e || n === "ease" || (t[n] = i[n]);
  };
}, nd = function(e, t) {
  for (var i in t)
    e[i] = t[i];
  return e;
}, EE = function s(e, t) {
  for (var i in t)
    i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = $o(t[i]) ? s(e[i] || (e[i] = {}), t[i]) : t[i]);
  return e;
}, e0 = function(e, t) {
  var i = {}, n;
  for (n in e)
    n in t || (i[n] = e[n]);
  return i;
}, Yf = function(e) {
  var t = e.parent || mi, i = e.keyframes ? SN(kr(e.keyframes)) : Os;
  if (as(e.inherit))
    for (; t; )
      i(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, MN = function(e, t) {
  for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i]; )
    ;
  return i < 0;
}, WP = function(e, t, i, n, r) {
  var o = e[n], a;
  if (r)
    for (a = t[r]; o && o[r] > a; )
      o = o._prev;
  return o ? (t._next = o._next, o._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[n] = t, t._prev = o, t.parent = t._dp = e, t;
}, u_ = function(e, t, i, n) {
  i === void 0 && (i = "_first"), n === void 0 && (n = "_last");
  var r = t._prev, o = t._next;
  r ? r._next = o : e[i] === t && (e[i] = o), o ? o._prev = r : e[n] === t && (e[n] = r), t._next = t._prev = t.parent = null;
}, Pl = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, Yc = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0))
    for (var i = e; i; )
      i._dirty = 1, i = i.parent;
  return e;
}, EN = function(e) {
  for (var t = e.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, jb = function(e, t, i, n) {
  return e._startAt && (_r ? e._startAt.revert(Tv) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, n));
}, TN = function s(e) {
  return !e || e._ts && s(e.parent);
}, TE = function(e) {
  return e._repeat ? id(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, id = function(e, t) {
  var i = Math.floor(e = ki(e / t));
  return e && i === e ? i - 1 : i;
}, t0 = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, h_ = function(e) {
  return e._end = ki(e._start + (e._tDur / Math.abs(e._ts || e._rts || Ur) || 0));
}, d_ = function(e, t) {
  var i = e._dp;
  return i && i.smoothChildTiming && e._ts && (e._start = ki(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), h_(e), i._dirty || Yc(i, e)), e;
}, XP = function(e, t) {
  var i;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = t0(e.rawTime(), t), (!t._dur || im(0, t.totalDuration(), i) - t._tTime > Ur) && t.render(i, !0)), Yc(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration())
      for (i = e; i._dp; )
        i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
    e._zTime = -1e-8;
  }
}, Oo = function(e, t, i, n) {
  return t.parent && Pl(t), t._start = ki((Ra(i) ? i : i || e !== mi ? Xs(e, i, t) : e._time) + t._delay), t._end = ki(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), WP(e, t, "_first", "_last", e._sort ? "_start" : 0), qb(t) || (e._recent = t), n || XP(e, t), e._ts < 0 && d_(e, e._tTime), e;
}, YP = function(e, t) {
  return (ks.ScrollTrigger || _w("scrollTrigger", t)) && ks.ScrollTrigger.create(t, e);
}, jP = function(e, t, i, n, r) {
  if (Sw(e, t, r), !e._initted)
    return 1;
  if (!i && e._pt && !_r && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && BP !== Ms.frame)
    return wl.push(e), e._lazy = [r, n], 1;
}, AN = function s(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t));
}, qb = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, CN = function(e, t, i, n) {
  var r = e.ratio, o = t < 0 || !t && (!e._start && AN(e) && !(!e._initted && qb(e)) || (e._ts < 0 || e._dp._ts < 0) && !qb(e)) ? 0 : 1, a = e._rDelay, l = 0, c, u, h;
  if (a && e._repeat && (l = im(0, e._tDur, t), u = id(l, a), e._yoyo && u & 1 && (o = 1 - o), u !== id(e._tTime, a) && (r = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== r || _r || n || e._zTime === Ur || !t && e._zTime) {
    if (!e._initted && jP(e, t, n, i, l))
      return;
    for (h = e._zTime, e._zTime = t || (i ? Ur : 0), i || (i = t && !h), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, c = e._pt; c; )
      c.r(o, c.d), c = c._next;
    t < 0 && jb(e, t, i, !0), e._onUpdate && !i && Ts(e, "onUpdate"), l && e._repeat && !i && e.parent && Ts(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && Pl(e, 1), !i && !_r && (Ts(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, PN = function(e, t, i) {
  var n;
  if (i > t)
    for (n = e._first; n && n._start <= i; ) {
      if (n.data === "isPause" && n._start > t)
        return n;
      n = n._next;
    }
  else
    for (n = e._last; n && n._start >= i; ) {
      if (n.data === "isPause" && n._start < t)
        return n;
      n = n._prev;
    }
}, rd = function(e, t, i, n) {
  var r = e._repeat, o = ki(t) || 0, a = e._tTime / e._tDur;
  return a && !n && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : ki(o * (r + 1) + e._rDelay * r) : o, a > 0 && !n && d_(e, e._tTime = e._tDur * a), e.parent && h_(e), i || Yc(e.parent, e), e;
}, AE = function(e) {
  return e instanceof Yr ? Yc(e) : rd(e, e._dur);
}, RN = {
  _start: 0,
  endTime: Ap,
  totalDuration: Ap
}, Xs = function s(e, t, i) {
  var n = e.labels, r = e._recent || RN, o = e.duration() >= Xo ? r.endTime(!1) : e._dur, a, l, c;
  return rr(t) && (isNaN(t) || t in n) ? (l = t.charAt(0), c = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? r : i).totalDuration() / 100 : 1)) : a < 0 ? (t in n || (n[t] = o), n[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), c && i && (l = l / 100 * (kr(i) ? i[0] : i).totalDuration()), a > 1 ? s(e, t.substr(0, a - 1), i) + l : o + l)) : t == null ? o : +t;
}, jf = function(e, t, i) {
  var n = Ra(t[1]), r = (n ? 2 : 1) + (e < 2 ? 0 : 1), o = t[r], a, l;
  if (n && (o.duration = t[1]), o.parent = i, e) {
    for (a = o, l = i; l && !("immediateRender" in a); )
      a = l.vars.defaults || {}, l = as(l.vars.inherit) && l.parent;
    o.immediateRender = as(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[r - 1];
  }
  return new Li(t[0], o, t[r + 1]);
}, Ul = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, im = function(e, t, i) {
  return i < e ? e : i > t ? t : i;
}, Ir = function(e, t) {
  return !rr(e) || !(t = yN.exec(e)) ? "" : t[1];
}, DN = function(e, t, i) {
  return Ul(i, function(n) {
    return im(e, t, n);
  });
}, Zb = [].slice, qP = function(e, t) {
  return e && $o(e) && "length" in e && (!t && !e.length || e.length - 1 in e && $o(e[0])) && !e.nodeType && e !== Uo;
}, IN = function(e, t, i) {
  return i === void 0 && (i = []), e.forEach(function(n) {
    var r;
    return rr(n) && !t || qP(n, 1) ? (r = i).push.apply(r, Qs(n)) : i.push(n);
  }) || i;
}, Qs = function(e, t, i) {
  return hi && !t && hi.selector ? hi.selector(e) : rr(e) && !i && (Xb || !sd()) ? Zb.call((t || vw).querySelectorAll(e), 0) : kr(e) ? IN(e, i) : qP(e) ? Zb.call(e, 0) : e ? [e] : [];
}, Kb = function(e) {
  return e = Qs(e)[0] || Tp("Invalid scope") || {}, function(t) {
    var i = e.current || e.nativeElement || e;
    return Qs(t, i.querySelectorAll ? i : i === e ? Tp("Invalid scope") || vw.createElement("div") : e);
  };
}, ZP = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, KP = function(e) {
  if (Si(e))
    return e;
  var t = $o(e) ? e : {
    each: e
  }, i = jc(t.ease), n = t.from || 0, r = parseFloat(t.base) || 0, o = {}, a = n > 0 && n < 1, l = isNaN(n) || a, c = t.axis, u = n, h = n;
  return rr(n) ? u = h = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[n] || 0 : !a && l && (u = n[0], h = n[1]), function(d, f, m) {
    var g = (m || t).length, v = o[g], _, y, w, x, M, A, E, C, P;
    if (!v) {
      if (P = t.grid === "auto" ? 0 : (t.grid || [1, Xo])[1], !P) {
        for (E = -1e8; E < (E = m[P++].getBoundingClientRect().left) && P < g; )
          ;
        P < g && P--;
      }
      for (v = o[g] = [], _ = l ? Math.min(P, g) * u - 0.5 : n % P, y = P === Xo ? 0 : l ? g * h / P - 0.5 : n / P | 0, E = 0, C = Xo, A = 0; A < g; A++)
        w = A % P - _, x = y - (A / P | 0), v[A] = M = c ? Math.abs(c === "y" ? x : w) : DP(w * w + x * x), M > E && (E = M), M < C && (C = M);
      n === "random" && ZP(v), v.max = E - C, v.min = C, v.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (P > g ? g - 1 : c ? c === "y" ? g / P : P : Math.max(P, g / P)) || 0) * (n === "edges" ? -1 : 1), v.b = g < 0 ? r - g : r, v.u = Ir(t.amount || t.each) || 0, i = i && g < 0 ? oR(i) : i;
    }
    return g = (v[d] - v.min) / v.max || 0, ki(v.b + (i ? i(g) : g) * v.v) + v.u;
  };
}, $b = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(i) {
    var n = ki(Math.round(parseFloat(i) / e) * e * t);
    return (n - n % 1) / t + (Ra(i) ? 0 : Ir(i));
  };
}, $P = function(e, t) {
  var i = kr(e), n, r;
  return !i && $o(e) && (n = i = e.radius || Xo, e.values ? (e = Qs(e.values), (r = !Ra(e[0])) && (n *= n)) : e = $b(e.increment)), Ul(t, i ? Si(e) ? function(o) {
    return r = e(o), Math.abs(r - o) <= n ? r : o;
  } : function(o) {
    for (var a = parseFloat(r ? o.x : o), l = parseFloat(r ? o.y : 0), c = Xo, u = 0, h = e.length, d, f; h--; )
      r ? (d = e[h].x - a, f = e[h].y - l, d = d * d + f * f) : d = Math.abs(e[h] - a), d < c && (c = d, u = h);
    return u = !n || c <= n ? e[u] : o, r || u === o || Ra(o) ? u : u + Ir(o);
  } : $b(e));
}, JP = function(e, t, i, n) {
  return Ul(kr(e) ? !t : i === !0 ? !!(i = 0) : !n, function() {
    return kr(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) * i * n) / n;
  });
}, LN = function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
    t[i] = arguments[i];
  return function(n) {
    return t.reduce(function(r, o) {
      return o(r);
    }, n);
  };
}, UN = function(e, t) {
  return function(i) {
    return e(parseFloat(i)) + (t || Ir(i));
  };
}, kN = function(e, t, i) {
  return eR(e, t, 0, 1, i);
}, QP = function(e, t, i) {
  return Ul(i, function(n) {
    return e[~~t(n)];
  });
}, ON = function s(e, t, i) {
  var n = t - e;
  return kr(e) ? QP(e, s(0, e.length), t) : Ul(i, function(r) {
    return (n + (r - e) % n) % n + e;
  });
}, FN = function s(e, t, i) {
  var n = t - e, r = n * 2;
  return kr(e) ? QP(e, s(0, e.length - 1), t) : Ul(i, function(o) {
    return o = (r + (o - e) % r) % r || 0, e + (o > n ? r - o : o);
  });
}, Cp = function(e) {
  for (var t = 0, i = "", n, r, o, a; ~(n = e.indexOf("random(", t)); )
    o = e.indexOf(")", n), a = e.charAt(n + 7) === "[", r = e.substr(n + 7, o - n - 7).match(a ? kP : Wb), i += e.substr(t, n - t) + JP(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5), t = o + 1;
  return i + e.substr(t, e.length - t);
}, eR = function(e, t, i, n, r) {
  var o = t - e, a = n - i;
  return Ul(r, function(l) {
    return i + ((l - e) / o * a || 0);
  });
}, NN = function s(e, t, i, n) {
  var r = isNaN(e + t) ? 0 : function(f) {
    return (1 - f) * e + f * t;
  };
  if (!r) {
    var o = rr(e), a = {}, l, c, u, h, d;
    if (i === !0 && (n = 1) && (i = null), o)
      e = {
        p: e
      }, t = {
        p: t
      };
    else if (kr(e) && !kr(t)) {
      for (u = [], h = e.length, d = h - 2, c = 1; c < h; c++)
        u.push(s(e[c - 1], e[c]));
      h--, r = function(m) {
        m *= h;
        var g = Math.min(d, ~~m);
        return u[g](m - g);
      }, i = t;
    } else n || (e = nd(kr(e) ? [] : {}, e));
    if (!u) {
      for (l in t)
        ww.call(a, e, l, "get", t[l]);
      r = function(m) {
        return Tw(m, a) || (o ? e.p : e);
      };
    }
  }
  return Ul(i, r);
}, CE = function(e, t, i) {
  var n = e.labels, r = Xo, o, a, l;
  for (o in n)
    a = n[o] - t, a < 0 == !!i && a && r > (a = Math.abs(a)) && (l = o, r = a);
  return l;
}, Ts = function(e, t, i) {
  var n = e.vars, r = n[t], o = hi, a = e._ctx, l, c, u;
  if (r)
    return l = n[t + "Params"], c = n.callbackScope || e, i && wl.length && Qv(), a && (hi = a), u = l ? r.apply(c, l) : r.call(c), hi = o, u;
}, Pf = function(e) {
  return Pl(e), e.scrollTrigger && e.scrollTrigger.kill(!!_r), e.progress() < 1 && Ts(e, "onInterrupt"), e;
}, Dh, tR = [], nR = function(e) {
  if (e)
    if (e = !e.name && e.default || e, gw() || e.headless) {
      var t = e.name, i = Si(e), n = t && !i && e.init ? function() {
        this._props = [];
      } : e, r = {
        init: Ap,
        render: Tw,
        add: ww,
        kill: eB,
        modifier: QN,
        rawVars: 0
      }, o = {
        targetTest: 0,
        get: 0,
        getSetter: Ew,
        aliases: {},
        register: 0
      };
      if (sd(), e !== n) {
        if (ws[t])
          return;
        Os(n, Os(e0(e, r), o)), nd(n.prototype, nd(r, e0(e, o))), ws[n.prop = t] = n, e.targetTest && (Av.push(n), yw[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      NP(t, n), e.register && e.register(ds, n, cs);
    } else
      tR.push(e);
}, jn = 255, Rf = {
  aqua: [0, jn, jn],
  lime: [0, jn, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, jn],
  navy: [0, 0, 128],
  white: [jn, jn, jn],
  olive: [128, 128, 0],
  yellow: [jn, jn, 0],
  orange: [jn, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [jn, 0, 0],
  pink: [jn, 192, 203],
  cyan: [0, jn, jn],
  transparent: [jn, jn, jn, 0]
}, Gy = function(e, t, i) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < 0.5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * jn + 0.5 | 0;
}, iR = function(e, t, i) {
  var n = e ? Ra(e) ? [e >> 16, e >> 8 & jn, e & jn] : 0 : Rf.black, r, o, a, l, c, u, h, d, f, m;
  if (!n) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Rf[e])
      n = Rf[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (r = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + r + r + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9)
        return n = parseInt(e.substr(1, 6), 16), [n >> 16, n >> 8 & jn, n & jn, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), n = [e >> 16, e >> 8 & jn, e & jn];
    } else if (e.substr(0, 3) === "hsl") {
      if (n = m = e.match(Wb), !t)
        l = +n[0] % 360 / 360, c = +n[1] / 100, u = +n[2] / 100, o = u <= 0.5 ? u * (c + 1) : u + c - u * c, r = u * 2 - o, n.length > 3 && (n[3] *= 1), n[0] = Gy(l + 1 / 3, r, o), n[1] = Gy(l, r, o), n[2] = Gy(l - 1 / 3, r, o);
      else if (~e.indexOf("="))
        return n = e.match(LP), i && n.length < 4 && (n[3] = 1), n;
    } else
      n = e.match(Wb) || Rf.transparent;
    n = n.map(Number);
  }
  return t && !m && (r = n[0] / jn, o = n[1] / jn, a = n[2] / jn, h = Math.max(r, o, a), d = Math.min(r, o, a), u = (h + d) / 2, h === d ? l = c = 0 : (f = h - d, c = u > 0.5 ? f / (2 - h - d) : f / (h + d), l = h === r ? (o - a) / f + (o < a ? 6 : 0) : h === o ? (a - r) / f + 2 : (r - o) / f + 4, l *= 60), n[0] = ~~(l + 0.5), n[1] = ~~(c * 100 + 0.5), n[2] = ~~(u * 100 + 0.5)), i && n.length < 4 && (n[3] = 1), n;
}, rR = function(e) {
  var t = [], i = [], n = -1;
  return e.split(Sl).forEach(function(r) {
    var o = r.match(Rh) || [];
    t.push.apply(t, o), i.push(n += o.length + 1);
  }), t.c = i, t;
}, PE = function(e, t, i) {
  var n = "", r = (e + n).match(Sl), o = t ? "hsla(" : "rgba(", a = 0, l, c, u, h;
  if (!r)
    return e;
  if (r = r.map(function(d) {
    return (d = iR(d, t, 1)) && o + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")";
  }), i && (u = rR(e), l = i.c, l.join(n) !== u.c.join(n)))
    for (c = e.replace(Sl, "1").split(Rh), h = c.length - 1; a < h; a++)
      n += c[a] + (~l.indexOf(a) ? r.shift() || o + "0,0,0,0)" : (u.length ? u : r.length ? r : i).shift());
  if (!c)
    for (c = e.split(Sl), h = c.length - 1; a < h; a++)
      n += c[a] + r[a];
  return n + c[h];
}, Sl = function() {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in Rf)
    s += "|" + e + "\\b";
  return new RegExp(s + ")", "gi");
}(), BN = /hsl[a]?\(/, sR = function(e) {
  var t = e.join(" "), i;
  if (Sl.lastIndex = 0, Sl.test(t))
    return i = BN.test(t), e[1] = PE(e[1], i), e[0] = PE(e[0], i, rR(e[1])), !0;
}, Pp, Ms = function() {
  var s = Date.now, e = 500, t = 33, i = s(), n = i, r = 1e3 / 240, o = r, a = [], l, c, u, h, d, f, m = function g(v) {
    var _ = s() - n, y = v === !0, w, x, M, A;
    if ((_ > e || _ < 0) && (i += _ - t), n += _, M = n - i, w = M - o, (w > 0 || y) && (A = ++h.frame, d = M - h.time * 1e3, h.time = M = M / 1e3, o += w + (w >= r ? 4 : r - w), x = 1), y || (l = c(g)), x)
      for (f = 0; f < a.length; f++)
        a[f](M, d, A, v);
  };
  return h = {
    time: 0,
    frame: 0,
    tick: function() {
      m(!0);
    },
    deltaRatio: function(v) {
      return d / (1e3 / (v || 60));
    },
    wake: function() {
      OP && (!Xb && gw() && (Uo = Xb = window, vw = Uo.document || {}, ks.gsap = ds, (Uo.gsapVersions || (Uo.gsapVersions = [])).push(ds.version), FP(Jv || Uo.GreenSockGlobals || !Uo.gsap && Uo || {}), tR.forEach(nR)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && h.sleep(), c = u || function(v) {
        return setTimeout(v, o - h.time * 1e3 + 1 | 0);
      }, Pp = 1, m(2));
    },
    sleep: function() {
      (u ? cancelAnimationFrame : clearTimeout)(l), Pp = 0, c = Ap;
    },
    lagSmoothing: function(v, _) {
      e = v || 1 / 0, t = Math.min(_ || 33, e);
    },
    fps: function(v) {
      r = 1e3 / (v || 240), o = h.time * 1e3 + r;
    },
    add: function(v, _, y) {
      var w = _ ? function(x, M, A, E) {
        v(x, M, A, E), h.remove(w);
      } : v;
      return h.remove(v), a[y ? "unshift" : "push"](w), sd(), w;
    },
    remove: function(v, _) {
      ~(_ = a.indexOf(v)) && a.splice(_, 1) && f >= _ && f--;
    },
    _listeners: a
  }, h;
}(), sd = function() {
  return !Pp && Ms.wake();
}, wn = {}, zN = /^[\d.\-M][\d.\-,\s]/, VN = /["']/g, GN = function(e) {
  for (var t = {}, i = e.substr(1, e.length - 3).split(":"), n = i[0], r = 1, o = i.length, a, l, c; r < o; r++)
    l = i[r], a = r !== o - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, a), t[n] = isNaN(c) ? c.replace(VN, "").trim() : +c, n = l.substr(a + 1).trim();
  return t;
}, HN = function(e) {
  var t = e.indexOf("(") + 1, i = e.indexOf(")"), n = e.indexOf("(", t);
  return e.substring(t, ~n && n < i ? e.indexOf(")", i + 1) : i);
}, WN = function(e) {
  var t = (e + "").split("("), i = wn[t[0]];
  return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [GN(t[1])] : HN(e).split(",").map(GP)) : wn._CE && zN.test(e) ? wn._CE("", e) : i;
}, oR = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, aR = function s(e, t) {
  for (var i = e._first, n; i; )
    i instanceof Yr ? s(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? s(i.timeline, t) : (n = i._ease, i._ease = i._yEase, i._yEase = n, i._yoyo = t)), i = i._next;
}, jc = function(e, t) {
  return e && (Si(e) ? e : wn[e] || WN(e)) || t;
}, Cu = function(e, t, i, n) {
  i === void 0 && (i = function(l) {
    return 1 - t(1 - l);
  }), n === void 0 && (n = function(l) {
    return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
  });
  var r = {
    easeIn: t,
    easeOut: i,
    easeInOut: n
  }, o;
  return ls(e, function(a) {
    wn[a] = ks[a] = r, wn[o = a.toLowerCase()] = i;
    for (var l in r)
      wn[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = wn[a + "." + l] = r[l];
  }), r;
}, lR = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, Hy = function s(e, t, i) {
  var n = t >= 1 ? t : 1, r = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), o = r / Hb * (Math.asin(1 / n) || 0), a = function(u) {
    return u === 1 ? 1 : n * Math.pow(2, -10 * u) * _N((u - o) * r) + 1;
  }, l = e === "out" ? a : e === "in" ? function(c) {
    return 1 - a(1 - c);
  } : lR(a);
  return r = Hb / r, l.config = function(c, u) {
    return s(e, c, u);
  }, l;
}, Wy = function s(e, t) {
  t === void 0 && (t = 1.70158);
  var i = function(o) {
    return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
  }, n = e === "out" ? i : e === "in" ? function(r) {
    return 1 - i(1 - r);
  } : lR(i);
  return n.config = function(r) {
    return s(e, r);
  }, n;
};
ls("Linear,Quad,Cubic,Quart,Quint,Strong", function(s, e) {
  var t = e < 5 ? e + 1 : e;
  Cu(s + ",Power" + (t - 1), e ? function(i) {
    return Math.pow(i, t);
  } : function(i) {
    return i;
  }, function(i) {
    return 1 - Math.pow(1 - i, t);
  }, function(i) {
    return i < 0.5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2;
  });
});
wn.Linear.easeNone = wn.none = wn.Linear.easeIn;
Cu("Elastic", Hy("in"), Hy("out"), Hy());
(function(s, e) {
  var t = 1 / e, i = 2 * t, n = 2.5 * t, r = function(a) {
    return a < t ? s * a * a : a < i ? s * Math.pow(a - 1.5 / e, 2) + 0.75 : a < n ? s * (a -= 2.25 / e) * a + 0.9375 : s * Math.pow(a - 2.625 / e, 2) + 0.984375;
  };
  Cu("Bounce", function(o) {
    return 1 - r(1 - o);
  }, r);
})(7.5625, 2.75);
Cu("Expo", function(s) {
  return Math.pow(2, 10 * (s - 1)) * s + s * s * s * s * s * s * (1 - s);
});
Cu("Circ", function(s) {
  return -(DP(1 - s * s) - 1);
});
Cu("Sine", function(s) {
  return s === 1 ? 1 : -vN(s * mN) + 1;
});
Cu("Back", Wy("in"), Wy("out"), Wy());
wn.SteppedEase = wn.steps = ks.SteppedEase = {
  config: function(e, t) {
    e === void 0 && (e = 1);
    var i = 1 / e, n = e + (t ? 0 : 1), r = t ? 1 : 0, o = 1 - Ur;
    return function(a) {
      return ((n * im(0, o, a) | 0) + r) * i;
    };
  }
};
td.ease = wn["quad.out"];
ls("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(s) {
  return xw += s + "," + s + "Params,";
});
var cR = function(e, t) {
  this.id = gN++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : zP, this.set = t ? t.getSetter : Ew;
}, Rp = /* @__PURE__ */ function() {
  function s(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, rd(this, +t.duration, 1, 1), this.data = t.data, hi && (this._ctx = hi, hi.data.push(this)), Pp || Ms.wake();
  }
  var e = s.prototype;
  return e.delay = function(i) {
    return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay;
  }, e.duration = function(i) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(i) {
    return arguments.length ? (this._dirty = 0, rd(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(i, n) {
    if (sd(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (d_(this, i), !r._dp || r.parent || XP(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && Oo(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== i || !this._dur && !n || this._initted && Math.abs(this._zTime) === Ur || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), VP(this, i, n)), this;
  }, e.time = function(i, n) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + TE(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), n) : this._time;
  }, e.totalProgress = function(i, n) {
    return arguments.length ? this.totalTime(this.totalDuration() * i, n) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(i, n) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + TE(this), n) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(i, n) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (i - 1) * r, n) : this._repeat ? id(this._tTime, r) + 1 : 1;
  }, e.timeScale = function(i, n) {
    if (!arguments.length)
      return this._rts === -1e-8 ? 0 : this._rts;
    if (this._rts === i)
      return this;
    var r = this.parent && this._ts ? t0(this.parent._time, this) : this._tTime;
    return this._rts = +i || 0, this._ts = this._ps || i === -1e-8 ? 0 : this._rts, this.totalTime(im(-Math.abs(this._delay), this._tDur, r), n !== !1), h_(this), EN(this);
  }, e.paused = function(i) {
    return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (sd(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Ur && (this._tTime -= Ur)))), this) : this._ps;
  }, e.startTime = function(i) {
    if (arguments.length) {
      this._start = i;
      var n = this.parent || this._dp;
      return n && (n._sort || !this.parent) && Oo(n, this, i - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(i) {
    return this._start + (as(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(i) {
    var n = this.parent || this._dp;
    return n ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? t0(n.rawTime(i), this) : this._tTime : this._tTime;
  }, e.revert = function(i) {
    i === void 0 && (i = bN);
    var n = _r;
    return _r = i, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i), this.totalTime(-0.01, i.suppressEvents)), this.data !== "nested" && i.kill !== !1 && this.kill(), _r = n, this;
  }, e.globalTime = function(i) {
    for (var n = this, r = arguments.length ? i : n.rawTime(); n; )
      r = n._start + r / (Math.abs(n._ts) || 1), n = n._dp;
    return !this.parent && this._sat ? this._sat.globalTime(i) : r;
  }, e.repeat = function(i) {
    return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, AE(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(i) {
    if (arguments.length) {
      var n = this._time;
      return this._rDelay = i, AE(this), n ? this.time(n) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(i) {
    return arguments.length ? (this._yoyo = i, this) : this._yoyo;
  }, e.seek = function(i, n) {
    return this.totalTime(Xs(this, i), as(n));
  }, e.restart = function(i, n) {
    return this.play().totalTime(i ? -this._delay : 0, as(n)), this._dur || (this._zTime = -1e-8), this;
  }, e.play = function(i, n) {
    return i != null && this.seek(i, n), this.reversed(!1).paused(!1);
  }, e.reverse = function(i, n) {
    return i != null && this.seek(i || this.totalDuration(), n), this.reversed(!0).paused(!1);
  }, e.pause = function(i, n) {
    return i != null && this.seek(i, n), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(i) {
    return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -1e-8 : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -1e-8, this;
  }, e.isActive = function() {
    var i = this.parent || this._dp, n = this._start, r;
    return !!(!i || this._ts && this._initted && i.isActive() && (r = i.rawTime(!0)) >= n && r < this.endTime(!0) - Ur);
  }, e.eventCallback = function(i, n, r) {
    var o = this.vars;
    return arguments.length > 1 ? (n ? (o[i] = n, r && (o[i + "Params"] = r), i === "onUpdate" && (this._onUpdate = n)) : delete o[i], this) : o[i];
  }, e.then = function(i) {
    var n = this;
    return new Promise(function(r) {
      var o = Si(i) ? i : HP, a = function() {
        var c = n.then;
        n.then = null, Si(o) && (o = o(n)) && (o.then || o === n) && (n.then = c), r(o), n.then = c;
      };
      n._initted && n.totalProgress() === 1 && n._ts >= 0 || !n._tTime && n._ts < 0 ? a() : n._prom = a;
    });
  }, e.kill = function() {
    Pf(this);
  }, s;
}();
Os(Rp.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -1e-8,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Yr = /* @__PURE__ */ function(s) {
  RP(e, s);
  function e(i, n) {
    var r;
    return i === void 0 && (i = {}), r = s.call(this, i) || this, r.labels = {}, r.smoothChildTiming = !!i.smoothChildTiming, r.autoRemoveChildren = !!i.autoRemoveChildren, r._sort = as(i.sortChildren), mi && Oo(i.parent || mi, ma(r), n), i.reversed && r.reverse(), i.paused && r.paused(!0), i.scrollTrigger && YP(ma(r), i.scrollTrigger), r;
  }
  var t = e.prototype;
  return t.to = function(n, r, o) {
    return jf(0, arguments, this), this;
  }, t.from = function(n, r, o) {
    return jf(1, arguments, this), this;
  }, t.fromTo = function(n, r, o, a) {
    return jf(2, arguments, this), this;
  }, t.set = function(n, r, o) {
    return r.duration = 0, r.parent = this, Yf(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Li(n, r, Xs(this, o), 1), this;
  }, t.call = function(n, r, o) {
    return Oo(this, Li.delayedCall(0, n, r), o);
  }, t.staggerTo = function(n, r, o, a, l, c, u) {
    return o.duration = r, o.stagger = o.stagger || a, o.onComplete = c, o.onCompleteParams = u, o.parent = this, new Li(n, o, Xs(this, l)), this;
  }, t.staggerFrom = function(n, r, o, a, l, c, u) {
    return o.runBackwards = 1, Yf(o).immediateRender = as(o.immediateRender), this.staggerTo(n, r, o, a, l, c, u);
  }, t.staggerFromTo = function(n, r, o, a, l, c, u, h) {
    return a.startAt = o, Yf(a).immediateRender = as(a.immediateRender), this.staggerTo(n, r, a, l, c, u, h);
  }, t.render = function(n, r, o) {
    var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, u = n <= 0 ? 0 : ki(n), h = this._zTime < 0 != n < 0 && (this._initted || !c), d, f, m, g, v, _, y, w, x, M, A, E;
    if (this !== mi && u > l && n >= 0 && (u = l), u !== this._tTime || o || h) {
      if (a !== this._time && c && (u += this._time - a, n += this._time - a), d = u, x = this._start, w = this._ts, _ = !w, h && (c || (a = this._zTime), (n || !r) && (this._zTime = n)), this._repeat) {
        if (A = this._yoyo, v = c + this._rDelay, this._repeat < -1 && n < 0)
          return this.totalTime(v * 100 + n, r, o);
        if (d = ki(u % v), u === l ? (g = this._repeat, d = c) : (M = ki(u / v), g = ~~M, g && g === M && (d = c, g--), d > c && (d = c)), M = id(this._tTime, v), !a && this._tTime && M !== g && this._tTime - M * v - this._dur <= 0 && (M = g), A && g & 1 && (d = c - d, E = 1), g !== M && !this._lock) {
          var C = A && M & 1, P = C === (A && g & 1);
          if (g < M && (C = !C), a = C ? 0 : u % c ? c : u, this._lock = 1, this.render(a || (E ? 0 : ki(g * v)), r, !c)._lock = 0, this._tTime = u, !r && this.parent && Ts(this, "onRepeat"), this.vars.repeatRefresh && !E && (this.invalidate()._lock = 1), a && a !== this._time || _ !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (c = this._dur, l = this._tDur, P && (this._lock = 2, a = C ? c : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !E && this.invalidate()), this._lock = 0, !this._ts && !_)
            return this;
          aR(this, E);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (y = PN(this, ki(a), ki(d)), y && (u -= d - (d = y._start))), this._tTime = u, this._time = d, this._act = !w, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = n, a = 0), !a && d && !r && !g && (Ts(this, "onStart"), this._tTime !== u))
        return this;
      if (d >= a && n >= 0)
        for (f = this._first; f; ) {
          if (m = f._next, (f._act || d >= f._start) && f._ts && y !== f) {
            if (f.parent !== this)
              return this.render(n, r, o);
            if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, r, o), d !== this._time || !this._ts && !_) {
              y = 0, m && (u += this._zTime = -1e-8);
              break;
            }
          }
          f = m;
        }
      else {
        f = this._last;
        for (var T = n < 0 ? n : d; f; ) {
          if (m = f._prev, (f._act || T <= f._end) && f._ts && y !== f) {
            if (f.parent !== this)
              return this.render(n, r, o);
            if (f.render(f._ts > 0 ? (T - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (T - f._start) * f._ts, r, o || _r && (f._initted || f._startAt)), d !== this._time || !this._ts && !_) {
              y = 0, m && (u += this._zTime = T ? -1e-8 : Ur);
              break;
            }
          }
          f = m;
        }
      }
      if (y && !r && (this.pause(), y.render(d >= a ? 0 : -1e-8)._zTime = d >= a ? 1 : -1, this._ts))
        return this._start = x, h_(this), this.render(n, r, o);
      this._onUpdate && !r && Ts(this, "onUpdate", !0), (u === l && this._tTime >= this.totalDuration() || !u && a) && (x === this._start || Math.abs(w) !== Math.abs(this._ts)) && (this._lock || ((n || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && Pl(this, 1), !r && !(n < 0 && !a) && (u || a || !l) && (Ts(this, u === l && n >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(n, r) {
    var o = this;
    if (Ra(r) || (r = Xs(this, r, n)), !(n instanceof Rp)) {
      if (kr(n))
        return n.forEach(function(a) {
          return o.add(a, r);
        }), this;
      if (rr(n))
        return this.addLabel(n, r);
      if (Si(n))
        n = Li.delayedCall(0, n);
      else
        return this;
    }
    return this !== n ? Oo(this, n, r) : this;
  }, t.getChildren = function(n, r, o, a) {
    n === void 0 && (n = !0), r === void 0 && (r = !0), o === void 0 && (o = !0), a === void 0 && (a = -1e8);
    for (var l = [], c = this._first; c; )
      c._start >= a && (c instanceof Li ? r && l.push(c) : (o && l.push(c), n && l.push.apply(l, c.getChildren(!0, r, o)))), c = c._next;
    return l;
  }, t.getById = function(n) {
    for (var r = this.getChildren(1, 1, 1), o = r.length; o--; )
      if (r[o].vars.id === n)
        return r[o];
  }, t.remove = function(n) {
    return rr(n) ? this.removeLabel(n) : Si(n) ? this.killTweensOf(n) : (n.parent === this && u_(this, n), n === this._recent && (this._recent = this._last), Yc(this));
  }, t.totalTime = function(n, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ki(Ms.time - (this._ts > 0 ? n / this._ts : (this.totalDuration() - n) / -this._ts))), s.prototype.totalTime.call(this, n, r), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(n, r) {
    return this.labels[n] = Xs(this, r), this;
  }, t.removeLabel = function(n) {
    return delete this.labels[n], this;
  }, t.addPause = function(n, r, o) {
    var a = Li.delayedCall(0, r || Ap, o);
    return a.data = "isPause", this._hasPause = 1, Oo(this, a, Xs(this, n));
  }, t.removePause = function(n) {
    var r = this._first;
    for (n = Xs(this, n); r; )
      r._start === n && r.data === "isPause" && Pl(r), r = r._next;
  }, t.killTweensOf = function(n, r, o) {
    for (var a = this.getTweensOf(n, o), l = a.length; l--; )
      pl !== a[l] && a[l].kill(n, r);
    return this;
  }, t.getTweensOf = function(n, r) {
    for (var o = [], a = Qs(n), l = this._first, c = Ra(r), u; l; )
      l instanceof Li ? wN(l._targets, a) && (c ? (!pl || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, r)).length && o.push.apply(o, u), l = l._next;
    return o;
  }, t.tweenTo = function(n, r) {
    r = r || {};
    var o = this, a = Xs(o, n), l = r, c = l.startAt, u = l.onStart, h = l.onStartParams, d = l.immediateRender, f, m = Li.to(o, Os({
      ease: r.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: a,
      overwrite: "auto",
      duration: r.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()) || Ur,
      onStart: function() {
        if (o.pause(), !f) {
          var v = r.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale());
          m._dur !== v && rd(m, v, 0, 1).render(m._time, !0, !0), f = 1;
        }
        u && u.apply(m, h || []);
      }
    }, r));
    return d ? m.render(0) : m;
  }, t.tweenFromTo = function(n, r, o) {
    return this.tweenTo(r, Os({
      startAt: {
        time: Xs(this, n)
      }
    }, o));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(n) {
    return n === void 0 && (n = this._time), CE(this, Xs(this, n));
  }, t.previousLabel = function(n) {
    return n === void 0 && (n = this._time), CE(this, Xs(this, n), 1);
  }, t.currentLabel = function(n) {
    return arguments.length ? this.seek(n, !0) : this.previousLabel(this._time + Ur);
  }, t.shiftChildren = function(n, r, o) {
    o === void 0 && (o = 0);
    for (var a = this._first, l = this.labels, c; a; )
      a._start >= o && (a._start += n, a._end += n), a = a._next;
    if (r)
      for (c in l)
        l[c] >= o && (l[c] += n);
    return Yc(this);
  }, t.invalidate = function(n) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(n), r = r._next;
    return s.prototype.invalidate.call(this, n);
  }, t.clear = function(n) {
    n === void 0 && (n = !0);
    for (var r = this._first, o; r; )
      o = r._next, this.remove(r), r = o;
    return this._dp && (this._time = this._tTime = this._pTime = 0), n && (this.labels = {}), Yc(this);
  }, t.totalDuration = function(n) {
    var r = 0, o = this, a = o._last, l = Xo, c, u, h;
    if (arguments.length)
      return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -n : n));
    if (o._dirty) {
      for (h = o.parent; a; )
        c = a._prev, a._dirty && a.totalDuration(), u = a._start, u > l && o._sort && a._ts && !o._lock ? (o._lock = 1, Oo(o, a, u - a._delay, 1)._lock = 0) : l = u, u < 0 && a._ts && (r -= u, (!h && !o._dp || h && h.smoothChildTiming) && (o._start += u / o._ts, o._time -= u, o._tTime -= u), o.shiftChildren(-u, !1, -1 / 0), l = 0), a._end > r && a._ts && (r = a._end), a = c;
      rd(o, o === mi && o._time > r ? o._time : r, 1, 1), o._dirty = 0;
    }
    return o._tDur;
  }, e.updateRoot = function(n) {
    if (mi._ts && (VP(mi, t0(n, mi)), BP = Ms.frame), Ms.frame >= ME) {
      ME += Ds.autoSleep || 120;
      var r = mi._first;
      if ((!r || !r._ts) && Ds.autoSleep && Ms._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || Ms.sleep();
      }
    }
  }, e;
}(Rp);
Os(Yr.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var XN = function(e, t, i, n, r, o, a) {
  var l = new cs(this._pt, e, t, 0, 1, mR, null, r), c = 0, u = 0, h, d, f, m, g, v, _, y;
  for (l.b = i, l.e = n, i += "", n += "", (_ = ~n.indexOf("random(")) && (n = Cp(n)), o && (y = [i, n], o(y, e, t), i = y[0], n = y[1]), d = i.match(zy) || []; h = zy.exec(n); )
    m = h[0], g = n.substring(c, h.index), f ? f = (f + 1) % 5 : g.substr(-5) === "rgba(" && (f = 1), m !== d[u++] && (v = parseFloat(d[u - 1]) || 0, l._pt = {
      _next: l._pt,
      p: g || u === 1 ? g : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: v,
      c: m.charAt(1) === "=" ? Gh(v, m) - v : parseFloat(m) - v,
      m: f && f < 4 ? Math.round : 0
    }, c = zy.lastIndex);
  return l.c = c < n.length ? n.substring(c, n.length) : "", l.fp = a, (UP.test(n) || _) && (l.e = 0), this._pt = l, l;
}, ww = function(e, t, i, n, r, o, a, l, c, u) {
  Si(n) && (n = n(r || 0, e, o));
  var h = e[t], d = i !== "get" ? i : Si(h) ? c ? e[t.indexOf("set") || !Si(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : h, f = Si(h) ? c ? KN : fR : Mw, m;
  if (rr(n) && (~n.indexOf("random(") && (n = Cp(n)), n.charAt(1) === "=" && (m = Gh(d, n) + (Ir(d) || 0), (m || m === 0) && (n = m))), !u || d !== n || Jb)
    return !isNaN(d * n) && n !== "" ? (m = new cs(this._pt, e, t, +d || 0, n - (d || 0), typeof h == "boolean" ? JN : pR, 0, f), c && (m.fp = c), a && m.modifier(a, this, e), this._pt = m) : (!h && !(t in e) && _w(t, n), XN.call(this, e, t, d, n, f, l || Ds.stringFilter, c));
}, YN = function(e, t, i, n, r) {
  if (Si(e) && (e = qf(e, r, t, i, n)), !$o(e) || e.style && e.nodeType || kr(e) || IP(e))
    return rr(e) ? qf(e, r, t, i, n) : e;
  var o = {}, a;
  for (a in e)
    o[a] = qf(e[a], r, t, i, n);
  return o;
}, uR = function(e, t, i, n, r, o) {
  var a, l, c, u;
  if (ws[e] && (a = new ws[e]()).init(r, a.rawVars ? t[e] : YN(t[e], n, r, o, i), i, n, o) !== !1 && (i._pt = l = new cs(i._pt, r, e, 0, 1, a.render, a, 0, a.priority), i !== Dh))
    for (c = i._ptLookup[i._targets.indexOf(r)], u = a._props.length; u--; )
      c[a._props[u]] = l;
  return a;
}, pl, Jb, Sw = function s(e, t, i) {
  var n = e.vars, r = n.ease, o = n.startAt, a = n.immediateRender, l = n.lazy, c = n.onUpdate, u = n.runBackwards, h = n.yoyoEase, d = n.keyframes, f = n.autoRevert, m = e._dur, g = e._startAt, v = e._targets, _ = e.parent, y = _ && _.data === "nested" ? _.vars.targets : v, w = e._overwrite === "auto" && !pw, x = e.timeline, M, A, E, C, P, T, I, D, U, L, k, B, j;
  if (x && (!d || !r) && (r = "none"), e._ease = jc(r, td.ease), e._yEase = h ? oR(jc(h === !0 ? r : h, td.ease)) : 0, h && e._yoyo && !e._repeat && (h = e._yEase, e._yEase = e._ease, e._ease = h), e._from = !x && !!n.runBackwards, !x || d && !n.stagger) {
    if (D = v[0] ? Xc(v[0]).harness : 0, B = D && n[D.prop], M = e0(n, yw), g && (g._zTime < 0 && g.progress(1), t < 0 && u && a && !f ? g.render(-1, !0) : g.revert(u && m ? Tv : xN), g._lazy = 0), o) {
      if (Pl(e._startAt = Li.set(v, Os({
        data: "isStart",
        overwrite: !1,
        parent: _,
        immediateRender: !0,
        lazy: !g && as(l),
        startAt: null,
        delay: 0,
        onUpdate: c && function() {
          return Ts(e, "onUpdate");
        },
        stagger: 0
      }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (_r || !a && !f) && e._startAt.revert(Tv), a && m && t <= 0 && i <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (u && m && !g) {
      if (t && (a = !1), E = Os({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: a && !g && as(l),
        immediateRender: a,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: _
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, M), B && (E[D.prop] = B), Pl(e._startAt = Li.set(v, E)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (_r ? e._startAt.revert(Tv) : e._startAt.render(-1, !0)), e._zTime = t, !a)
        s(e._startAt, Ur, Ur);
      else if (!t)
        return;
    }
    for (e._pt = e._ptCache = 0, l = m && as(l) || l && !m, A = 0; A < v.length; A++) {
      if (P = v[A], I = P._gsap || bw(v)[A]._gsap, e._ptLookup[A] = L = {}, Yb[I.id] && wl.length && Qv(), k = y === v ? A : y.indexOf(P), D && (U = new D()).init(P, B || M, e, k, y) !== !1 && (e._pt = C = new cs(e._pt, P, U.name, 0, 1, U.render, U, 0, U.priority), U._props.forEach(function(q) {
        L[q] = C;
      }), U.priority && (T = 1)), !D || B)
        for (E in M)
          ws[E] && (U = uR(E, M, e, k, P, y)) ? U.priority && (T = 1) : L[E] = C = ww.call(e, P, E, "get", M[E], k, y, 0, n.stringFilter);
      e._op && e._op[A] && e.kill(P, e._op[A]), w && e._pt && (pl = e, mi.killTweensOf(P, L, e.globalTime(t)), j = !e.parent, pl = 0), e._pt && l && (Yb[I.id] = 1);
    }
    T && gR(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = c, e._initted = (!e._op || e._pt) && !j, d && t <= 0 && x.render(Xo, !0, !0);
}, jN = function(e, t, i, n, r, o, a, l) {
  var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], u, h, d, f;
  if (!c)
    for (c = e._ptCache[t] = [], d = e._ptLookup, f = e._targets.length; f--; ) {
      if (u = d[f][t], u && u.d && u.d._pt)
        for (u = u.d._pt; u && u.p !== t && u.fp !== t; )
          u = u._next;
      if (!u)
        return Jb = 1, e.vars[t] = "+=0", Sw(e, a), Jb = 0, l ? Tp(t + " not eligible for reset") : 1;
      c.push(u);
    }
  for (f = c.length; f--; )
    h = c[f], u = h._pt || h, u.s = (n || n === 0) && !r ? n : u.s + (n || 0) + o * u.c, u.c = i - u.s, h.e && (h.e = Ti(i) + Ir(h.e)), h.b && (h.b = u.s + Ir(h.b));
}, qN = function(e, t) {
  var i = e[0] ? Xc(e[0]).harness : 0, n = i && i.aliases, r, o, a, l;
  if (!n)
    return t;
  r = nd({}, t);
  for (o in n)
    if (o in r)
      for (l = n[o].split(","), a = l.length; a--; )
        r[l[a]] = r[o];
  return r;
}, ZN = function(e, t, i, n) {
  var r = t.ease || n || "power1.inOut", o, a;
  if (kr(t))
    a = i[e] || (i[e] = []), t.forEach(function(l, c) {
      return a.push({
        t: c / (t.length - 1) * 100,
        v: l,
        e: r
      });
    });
  else
    for (o in t)
      a = i[o] || (i[o] = []), o === "ease" || a.push({
        t: parseFloat(e),
        v: t[o],
        e: r
      });
}, qf = function(e, t, i, n, r) {
  return Si(e) ? e.call(t, i, n, r) : rr(e) && ~e.indexOf("random(") ? Cp(e) : e;
}, hR = xw + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", dR = {};
ls(hR + ",id,stagger,delay,duration,paused,scrollTrigger", function(s) {
  return dR[s] = 1;
});
var Li = /* @__PURE__ */ function(s) {
  RP(e, s);
  function e(i, n, r, o) {
    var a;
    typeof n == "number" && (r.duration = n, n = r, r = null), a = s.call(this, o ? n : Yf(n)) || this;
    var l = a.vars, c = l.duration, u = l.delay, h = l.immediateRender, d = l.stagger, f = l.overwrite, m = l.keyframes, g = l.defaults, v = l.scrollTrigger, _ = l.yoyoEase, y = n.parent || mi, w = (kr(i) || IP(i) ? Ra(i[0]) : "length" in n) ? [i] : Qs(i), x, M, A, E, C, P, T, I;
    if (a._targets = w.length ? bw(w) : Tp("GSAP target " + i + " not found. https://gsap.com", !Ds.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = f, m || d || Fm(c) || Fm(u)) {
      if (n = a.vars, x = a.timeline = new Yr({
        data: "nested",
        defaults: g || {},
        targets: y && y.data === "nested" ? y.vars.targets : w
      }), x.kill(), x.parent = x._dp = ma(a), x._start = 0, d || Fm(c) || Fm(u)) {
        if (E = w.length, T = d && KP(d), $o(d))
          for (C in d)
            ~hR.indexOf(C) && (I || (I = {}), I[C] = d[C]);
        for (M = 0; M < E; M++)
          A = e0(n, dR), A.stagger = 0, _ && (A.yoyoEase = _), I && nd(A, I), P = w[M], A.duration = +qf(c, ma(a), M, P, w), A.delay = (+qf(u, ma(a), M, P, w) || 0) - a._delay, !d && E === 1 && A.delay && (a._delay = u = A.delay, a._start += u, A.delay = 0), x.to(P, A, T ? T(M, P, w) : 0), x._ease = wn.none;
        x.duration() ? c = u = 0 : a.timeline = 0;
      } else if (m) {
        Yf(Os(x.vars.defaults, {
          ease: "none"
        })), x._ease = jc(m.ease || n.ease || "none");
        var D = 0, U, L, k;
        if (kr(m))
          m.forEach(function(B) {
            return x.to(w, B, ">");
          }), x.duration();
        else {
          A = {};
          for (C in m)
            C === "ease" || C === "easeEach" || ZN(C, m[C], A, m.easeEach);
          for (C in A)
            for (U = A[C].sort(function(B, j) {
              return B.t - j.t;
            }), D = 0, M = 0; M < U.length; M++)
              L = U[M], k = {
                ease: L.e,
                duration: (L.t - (M ? U[M - 1].t : 0)) / 100 * c
              }, k[C] = L.v, x.to(w, k, D), D += k.duration;
          x.duration() < c && x.to({}, {
            duration: c - x.duration()
          });
        }
      }
      c || a.duration(c = x.duration());
    } else
      a.timeline = 0;
    return f === !0 && !pw && (pl = ma(a), mi.killTweensOf(w), pl = 0), Oo(y, ma(a), r), n.reversed && a.reverse(), n.paused && a.paused(!0), (h || !c && !m && a._start === ki(y._time) && as(h) && TN(ma(a)) && y.data !== "nested") && (a._tTime = -1e-8, a.render(Math.max(0, -u) || 0)), v && YP(ma(a), v), a;
  }
  var t = e.prototype;
  return t.render = function(n, r, o) {
    var a = this._time, l = this._tDur, c = this._dur, u = n < 0, h = n > l - Ur && !u ? l : n < Ur ? 0 : n, d, f, m, g, v, _, y, w, x;
    if (!c)
      CN(this, n, r, o);
    else if (h !== this._tTime || !n || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u || this._lazy) {
      if (d = h, w = this.timeline, this._repeat) {
        if (g = c + this._rDelay, this._repeat < -1 && u)
          return this.totalTime(g * 100 + n, r, o);
        if (d = ki(h % g), h === l ? (m = this._repeat, d = c) : (v = ki(h / g), m = ~~v, m && m === v ? (d = c, m--) : d > c && (d = c)), _ = this._yoyo && m & 1, _ && (x = this._yEase, d = c - d), v = id(this._tTime, g), d === a && !o && this._initted && m === v)
          return this._tTime = h, this;
        m !== v && (w && this._yEase && aR(w, _), this.vars.repeatRefresh && !_ && !this._lock && d !== g && this._initted && (this._lock = o = 1, this.render(ki(g * m), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (jP(this, u ? n : d, o, r, h))
          return this._tTime = 0, this;
        if (a !== this._time && !(o && this.vars.repeatRefresh && m !== v))
          return this;
        if (c !== this._dur)
          return this.render(n, r, o);
      }
      if (this._tTime = h, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = y = (x || this._ease)(d / c), this._from && (this.ratio = y = 1 - y), d && !a && !r && !m && (Ts(this, "onStart"), this._tTime !== h))
        return this;
      for (f = this._pt; f; )
        f.r(y, f.d), f = f._next;
      w && w.render(n < 0 ? n : w._dur * w._ease(d / this._dur), r, o) || this._startAt && (this._zTime = n), this._onUpdate && !r && (u && jb(this, n, r, o), Ts(this, "onUpdate")), this._repeat && m !== v && this.vars.onRepeat && !r && this.parent && Ts(this, "onRepeat"), (h === this._tDur || !h) && this._tTime === h && (u && !this._onUpdate && jb(this, n, !0, !0), (n || !c) && (h === this._tDur && this._ts > 0 || !h && this._ts < 0) && Pl(this, 1), !r && !(u && !a) && (h || a || _) && (Ts(this, h === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < l && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(n) {
    return (!n || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(n), s.prototype.invalidate.call(this, n);
  }, t.resetTo = function(n, r, o, a, l) {
    Pp || Ms.wake(), this._ts || this.play();
    var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u;
    return this._initted || Sw(this, c), u = this._ease(c / this._dur), jN(this, n, r, o, a, u, c, l) ? this.resetTo(n, r, o, a, 1) : (d_(this, 0), this.parent || WP(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(n, r) {
    if (r === void 0 && (r = "all"), !n && (!r || r === "all"))
      return this._lazy = this._pt = 0, this.parent ? Pf(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_r), this;
    if (this.timeline) {
      var o = this.timeline.totalDuration();
      return this.timeline.killTweensOf(n, r, pl && pl.vars.overwrite !== !0)._first || Pf(this), this.parent && o !== this.timeline.totalDuration() && rd(this, this._dur * this.timeline._tDur / o, 0, 1), this;
    }
    var a = this._targets, l = n ? Qs(n) : a, c = this._ptLookup, u = this._pt, h, d, f, m, g, v, _;
    if ((!r || r === "all") && MN(a, l))
      return r === "all" && (this._pt = 0), Pf(this);
    for (h = this._op = this._op || [], r !== "all" && (rr(r) && (g = {}, ls(r, function(y) {
      return g[y] = 1;
    }), r = g), r = qN(a, r)), _ = a.length; _--; )
      if (~l.indexOf(a[_])) {
        d = c[_], r === "all" ? (h[_] = r, m = d, f = {}) : (f = h[_] = h[_] || {}, m = r);
        for (g in m)
          v = d && d[g], v && ((!("kill" in v.d) || v.d.kill(g) === !0) && u_(this, v, "_pt"), delete d[g]), f !== "all" && (f[g] = 1);
      }
    return this._initted && !this._pt && u && Pf(this), this;
  }, e.to = function(n, r) {
    return new e(n, r, arguments[2]);
  }, e.from = function(n, r) {
    return jf(1, arguments);
  }, e.delayedCall = function(n, r, o, a) {
    return new e(r, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: n,
      onComplete: r,
      onReverseComplete: r,
      onCompleteParams: o,
      onReverseCompleteParams: o,
      callbackScope: a
    });
  }, e.fromTo = function(n, r, o) {
    return jf(2, arguments);
  }, e.set = function(n, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(n, r);
  }, e.killTweensOf = function(n, r, o) {
    return mi.killTweensOf(n, r, o);
  }, e;
}(Rp);
Os(Li.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
ls("staggerTo,staggerFrom,staggerFromTo", function(s) {
  Li[s] = function() {
    var e = new Yr(), t = Zb.call(arguments, 0);
    return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, t);
  };
});
var Mw = function(e, t, i) {
  return e[t] = i;
}, fR = function(e, t, i) {
  return e[t](i);
}, KN = function(e, t, i, n) {
  return e[t](n.fp, i);
}, $N = function(e, t, i) {
  return e.setAttribute(t, i);
}, Ew = function(e, t) {
  return Si(e[t]) ? fR : mw(e[t]) && e.setAttribute ? $N : Mw;
}, pR = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, JN = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, mR = function(e, t) {
  var i = t._pt, n = "";
  if (!e && t.b)
    n = t.b;
  else if (e === 1 && t.e)
    n = t.e;
  else {
    for (; i; )
      n = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + n, i = i._next;
    n += t.c;
  }
  t.set(t.t, t.p, n, t);
}, Tw = function(e, t) {
  for (var i = t._pt; i; )
    i.r(e, i.d), i = i._next;
}, QN = function(e, t, i, n) {
  for (var r = this._pt, o; r; )
    o = r._next, r.p === n && r.modifier(e, t, i), r = o;
}, eB = function(e) {
  for (var t = this._pt, i, n; t; )
    n = t._next, t.p === e && !t.op || t.op === e ? u_(this, t, "_pt") : t.dep || (i = 1), t = n;
  return !i;
}, tB = function(e, t, i, n) {
  n.mSet(e, t, n.m.call(n.tween, i, n.mt), n);
}, gR = function(e) {
  for (var t = e._pt, i, n, r, o; t; ) {
    for (i = t._next, n = r; n && n.pr > t.pr; )
      n = n._next;
    (t._prev = n ? n._prev : o) ? t._prev._next = t : r = t, (t._next = n) ? n._prev = t : o = t, t = i;
  }
  e._pt = r;
}, cs = /* @__PURE__ */ function() {
  function s(t, i, n, r, o, a, l, c, u) {
    this.t = i, this.s = r, this.c = o, this.p = n, this.r = a || pR, this.d = l || this, this.set = c || Mw, this.pr = u || 0, this._next = t, t && (t._prev = this);
  }
  var e = s.prototype;
  return e.modifier = function(i, n, r) {
    this.mSet = this.mSet || this.set, this.set = tB, this.m = i, this.mt = r, this.tween = n;
  }, s;
}();
ls(xw + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(s) {
  return yw[s] = 1;
});
ks.TweenMax = ks.TweenLite = Li;
ks.TimelineLite = ks.TimelineMax = Yr;
mi = new Yr({
  sortChildren: !1,
  defaults: td,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
Ds.stringFilter = sR;
var qc = [], Cv = {}, nB = [], RE = 0, iB = 0, Xy = function(e) {
  return (Cv[e] || nB).map(function(t) {
    return t();
  });
}, Qb = function() {
  var e = Date.now(), t = [];
  e - RE > 2 && (Xy("matchMediaInit"), qc.forEach(function(i) {
    var n = i.queries, r = i.conditions, o, a, l, c;
    for (a in n)
      o = Uo.matchMedia(n[a]).matches, o && (l = 1), o !== r[a] && (r[a] = o, c = 1);
    c && (i.revert(), l && t.push(i));
  }), Xy("matchMediaRevert"), t.forEach(function(i) {
    return i.onMatch(i, function(n) {
      return i.add(null, n);
    });
  }), RE = e, Xy("matchMedia"));
}, vR = /* @__PURE__ */ function() {
  function s(t, i) {
    this.selector = i && Kb(i), this.data = [], this._r = [], this.isReverted = !1, this.id = iB++, t && this.add(t);
  }
  var e = s.prototype;
  return e.add = function(i, n, r) {
    Si(i) && (r = n, n = i, i = Si);
    var o = this, a = function() {
      var c = hi, u = o.selector, h;
      return c && c !== o && c.data.push(o), r && (o.selector = Kb(r)), hi = o, h = n.apply(o, arguments), Si(h) && o._r.push(h), hi = c, o.selector = u, o.isReverted = !1, h;
    };
    return o.last = a, i === Si ? a(o, function(l) {
      return o.add(null, l);
    }) : i ? o[i] = a : a;
  }, e.ignore = function(i) {
    var n = hi;
    hi = null, i(this), hi = n;
  }, e.getTweens = function() {
    var i = [];
    return this.data.forEach(function(n) {
      return n instanceof s ? i.push.apply(i, n.getTweens()) : n instanceof Li && !(n.parent && n.parent.data === "nested") && i.push(n);
    }), i;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(i, n) {
    var r = this;
    if (i ? function() {
      for (var a = r.getTweens(), l = r.data.length, c; l--; )
        c = r.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function(u) {
          return a.splice(a.indexOf(u), 1);
        }));
      for (a.map(function(u) {
        return {
          g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
          t: u
        };
      }).sort(function(u, h) {
        return h.g - u.g || -1 / 0;
      }).forEach(function(u) {
        return u.t.revert(i);
      }), l = r.data.length; l--; )
        c = r.data[l], c instanceof Yr ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof Li) && c.revert && c.revert(i);
      r._r.forEach(function(u) {
        return u(i, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(a) {
      return a.kill && a.kill();
    }), this.clear(), n)
      for (var o = qc.length; o--; )
        qc[o].id === this.id && qc.splice(o, 1);
  }, e.revert = function(i) {
    this.kill(i || {});
  }, s;
}(), rB = /* @__PURE__ */ function() {
  function s(t) {
    this.contexts = [], this.scope = t, hi && hi.data.push(this);
  }
  var e = s.prototype;
  return e.add = function(i, n, r) {
    $o(i) || (i = {
      matches: i
    });
    var o = new vR(0, r || this.scope), a = o.conditions = {}, l, c, u;
    hi && !o.selector && (o.selector = hi.selector), this.contexts.push(o), n = o.add("onMatch", n), o.queries = i;
    for (c in i)
      c === "all" ? u = 1 : (l = Uo.matchMedia(i[c]), l && (qc.indexOf(o) < 0 && qc.push(o), (a[c] = l.matches) && (u = 1), l.addListener ? l.addListener(Qb) : l.addEventListener("change", Qb)));
    return u && n(o, function(h) {
      return o.add(null, h);
    }), this;
  }, e.revert = function(i) {
    this.kill(i || {});
  }, e.kill = function(i) {
    this.contexts.forEach(function(n) {
      return n.kill(i, !0);
    });
  }, s;
}(), n0 = {
  registerPlugin: function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    t.forEach(function(n) {
      return nR(n);
    });
  },
  timeline: function(e) {
    return new Yr(e);
  },
  getTweensOf: function(e, t) {
    return mi.getTweensOf(e, t);
  },
  getProperty: function(e, t, i, n) {
    rr(e) && (e = Qs(e)[0]);
    var r = Xc(e || {}).get, o = i ? HP : GP;
    return i === "native" && (i = ""), e && (t ? o((ws[t] && ws[t].get || r)(e, t, i, n)) : function(a, l, c) {
      return o((ws[a] && ws[a].get || r)(e, a, l, c));
    });
  },
  quickSetter: function(e, t, i) {
    if (e = Qs(e), e.length > 1) {
      var n = e.map(function(u) {
        return ds.quickSetter(u, t, i);
      }), r = n.length;
      return function(u) {
        for (var h = r; h--; )
          n[h](u);
      };
    }
    e = e[0] || {};
    var o = ws[t], a = Xc(e), l = a.harness && (a.harness.aliases || {})[t] || t, c = o ? function(u) {
      var h = new o();
      Dh._pt = 0, h.init(e, i ? u + i : u, Dh, 0, [e]), h.render(1, h), Dh._pt && Tw(1, Dh);
    } : a.set(e, l);
    return o ? c : function(u) {
      return c(e, l, i ? u + i : u, a, 1);
    };
  },
  quickTo: function(e, t, i) {
    var n, r = ds.to(e, Os((n = {}, n[t] = "+=0.1", n.paused = !0, n.stagger = 0, n), i || {})), o = function(l, c, u) {
      return r.resetTo(t, l, c, u);
    };
    return o.tween = r, o;
  },
  isTweening: function(e) {
    return mi.getTweensOf(e, !0).length > 0;
  },
  defaults: function(e) {
    return e && e.ease && (e.ease = jc(e.ease, td.ease)), EE(td, e || {});
  },
  config: function(e) {
    return EE(Ds, e || {});
  },
  registerEffect: function(e) {
    var t = e.name, i = e.effect, n = e.plugins, r = e.defaults, o = e.extendTimeline;
    (n || "").split(",").forEach(function(a) {
      return a && !ws[a] && !ks[a] && Tp(t + " effect requires " + a + " plugin.");
    }), Vy[t] = function(a, l, c) {
      return i(Qs(a), Os(l || {}, r), c);
    }, o && (Yr.prototype[t] = function(a, l, c) {
      return this.add(Vy[t](a, $o(l) ? l : (c = l) && {}, this), c);
    });
  },
  registerEase: function(e, t) {
    wn[e] = jc(t);
  },
  parseEase: function(e, t) {
    return arguments.length ? jc(e, t) : wn;
  },
  getById: function(e) {
    return mi.getById(e);
  },
  exportRoot: function(e, t) {
    e === void 0 && (e = {});
    var i = new Yr(e), n, r;
    for (i.smoothChildTiming = as(e.smoothChildTiming), mi.remove(i), i._dp = 0, i._time = i._tTime = mi._time, n = mi._first; n; )
      r = n._next, (t || !(!n._dur && n instanceof Li && n.vars.onComplete === n._targets[0])) && Oo(i, n, n._start - n._delay), n = r;
    return Oo(mi, i, 0), i;
  },
  context: function(e, t) {
    return e ? new vR(e, t) : hi;
  },
  matchMedia: function(e) {
    return new rB(e);
  },
  matchMediaRefresh: function() {
    return qc.forEach(function(e) {
      var t = e.conditions, i, n;
      for (n in t)
        t[n] && (t[n] = !1, i = 1);
      i && e.revert();
    }) || Qb();
  },
  addEventListener: function(e, t) {
    var i = Cv[e] || (Cv[e] = []);
    ~i.indexOf(t) || i.push(t);
  },
  removeEventListener: function(e, t) {
    var i = Cv[e], n = i && i.indexOf(t);
    n >= 0 && i.splice(n, 1);
  },
  utils: {
    wrap: ON,
    wrapYoyo: FN,
    distribute: KP,
    random: JP,
    snap: $P,
    normalize: kN,
    getUnit: Ir,
    clamp: DN,
    splitColor: iR,
    toArray: Qs,
    selector: Kb,
    mapRange: eR,
    pipe: LN,
    unitize: UN,
    interpolate: NN,
    shuffle: ZP
  },
  install: FP,
  effects: Vy,
  ticker: Ms,
  updateRoot: Yr.updateRoot,
  plugins: ws,
  globalTimeline: mi,
  core: {
    PropTween: cs,
    globals: NP,
    Tween: Li,
    Timeline: Yr,
    Animation: Rp,
    getCache: Xc,
    _removeLinkedListItem: u_,
    reverting: function() {
      return _r;
    },
    context: function(e) {
      return e && hi && (hi.data.push(e), e._ctx = hi), hi;
    },
    suppressOverwrites: function(e) {
      return pw = e;
    }
  }
};
ls("to,from,fromTo,delayedCall,set,killTweensOf", function(s) {
  return n0[s] = Li[s];
});
Ms.add(Yr.updateRoot);
Dh = n0.to({}, {
  duration: 0
});
var sB = function(e, t) {
  for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
    i = i._next;
  return i;
}, oB = function(e, t) {
  var i = e._targets, n, r, o;
  for (n in t)
    for (r = i.length; r--; )
      o = e._ptLookup[r][n], o && (o = o.d) && (o._pt && (o = sB(o, n)), o && o.modifier && o.modifier(t[n], e, i[r], n));
}, Yy = function(e, t) {
  return {
    name: e,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(n, r, o) {
      o._onInit = function(a) {
        var l, c;
        if (rr(r) && (l = {}, ls(r, function(u) {
          return l[u] = 1;
        }), r = l), t) {
          l = {};
          for (c in r)
            l[c] = t(r[c]);
          r = l;
        }
        oB(a, r);
      };
    }
  };
}, ds = n0.registerPlugin({
  name: "attr",
  init: function(e, t, i, n, r) {
    var o, a, l;
    this.tween = i;
    for (o in t)
      l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], n, r, 0, 0, o), a.op = o, a.b = l, this._props.push(o);
  },
  render: function(e, t) {
    for (var i = t._pt; i; )
      _r ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next;
  }
}, {
  name: "endArray",
  init: function(e, t) {
    for (var i = t.length; i--; )
      this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
  }
}, Yy("roundProps", $b), Yy("modifiers"), Yy("snap", $P)) || n0;
Li.version = Yr.version = ds.version = "3.12.7";
OP = 1;
gw() && sd();
wn.Power0;
wn.Power1;
wn.Power2;
wn.Power3;
wn.Power4;
wn.Linear;
wn.Quad;
wn.Cubic;
wn.Quart;
wn.Quint;
wn.Strong;
wn.Elastic;
wn.Back;
wn.SteppedEase;
wn.Bounce;
wn.Sine;
wn.Expo;
wn.Circ;
/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var DE, ml, Hh, Aw, Oc, IE, Cw, aB = function() {
  return typeof window < "u";
}, Da = {}, Sc = 180 / Math.PI, Wh = Math.PI / 180, Yu = Math.atan2, LE = 1e8, Pw = /([A-Z])/g, lB = /(left|right|width|margin|padding|x)/i, cB = /[\s,\(]\S/, zo = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, e1 = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, uB = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, hB = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, dB = function(e, t) {
  var i = t.s + t.c * e;
  t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
}, _R = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, yR = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, fB = function(e, t, i) {
  return e.style[t] = i;
}, pB = function(e, t, i) {
  return e.style.setProperty(t, i);
}, mB = function(e, t, i) {
  return e._gsap[t] = i;
}, gB = function(e, t, i) {
  return e._gsap.scaleX = e._gsap.scaleY = i;
}, vB = function(e, t, i, n, r) {
  var o = e._gsap;
  o.scaleX = o.scaleY = i, o.renderTransform(r, o);
}, _B = function(e, t, i, n, r) {
  var o = e._gsap;
  o[t] = i, o.renderTransform(r, o);
}, gi = "transform", us = gi + "Origin", yB = function s(e, t) {
  var i = this, n = this.target, r = n.style, o = n._gsap;
  if (e in Da && r) {
    if (this.tfm = this.tfm || {}, e !== "transform")
      e = zo[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(a) {
        return i.tfm[a] = _a(n, a);
      }) : this.tfm[e] = o.x ? o[e] : _a(n, e), e === us && (this.tfm.zOrigin = o.zOrigin);
    else
      return zo.transform.split(",").forEach(function(a) {
        return s.call(i, a, t);
      });
    if (this.props.indexOf(gi) >= 0)
      return;
    o.svg && (this.svgo = n.getAttribute("data-svg-origin"), this.props.push(us, t, "")), e = gi;
  }
  (r || t) && this.props.push(e, t, r[e]);
}, xR = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, xB = function() {
  var e = this.props, t = this.target, i = t.style, n = t._gsap, r, o;
  for (r = 0; r < e.length; r += 3)
    e[r + 1] ? e[r + 1] === 2 ? t[e[r]](e[r + 2]) : t[e[r]] = e[r + 2] : e[r + 2] ? i[e[r]] = e[r + 2] : i.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(Pw, "-$1").toLowerCase());
  if (this.tfm) {
    for (o in this.tfm)
      n[o] = this.tfm[o];
    n.svg && (n.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = Cw(), (!r || !r.isStart) && !i[gi] && (xR(i), n.zOrigin && i[us] && (i[us] += " " + n.zOrigin + "px", n.zOrigin = 0, n.renderTransform()), n.uncache = 1);
  }
}, bR = function(e, t) {
  var i = {
    target: e,
    props: [],
    revert: xB,
    save: yB
  };
  return e._gsap || ds.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(n) {
    return i.save(n);
  }), i;
}, wR, t1 = function(e, t) {
  var i = ml.createElementNS ? ml.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : ml.createElement(e);
  return i && i.style ? i : ml.createElement(e);
}, Yo = function s(e, t, i) {
  var n = getComputedStyle(e);
  return n[t] || n.getPropertyValue(t.replace(Pw, "-$1").toLowerCase()) || n.getPropertyValue(t) || !i && s(e, od(t) || t, 1) || "";
}, UE = "O,Moz,ms,Ms,Webkit".split(","), od = function(e, t, i) {
  var n = t || Oc, r = n.style, o = 5;
  if (e in r && !i)
    return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(UE[o] + e in r); )
    ;
  return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? UE[o] : "") + e;
}, n1 = function() {
  aB() && window.document && (DE = window, ml = DE.document, Hh = ml.documentElement, Oc = t1("div") || {
    style: {}
  }, t1("div"), gi = od(gi), us = gi + "Origin", Oc.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", wR = !!od("perspective"), Cw = ds.core.reverting, Aw = 1);
}, kE = function(e) {
  var t = e.ownerSVGElement, i = t1("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = e.cloneNode(!0), r;
  n.style.display = "block", i.appendChild(n), Hh.appendChild(i);
  try {
    r = n.getBBox();
  } catch {
  }
  return i.removeChild(n), Hh.removeChild(i), r;
}, OE = function(e, t) {
  for (var i = t.length; i--; )
    if (e.hasAttribute(t[i]))
      return e.getAttribute(t[i]);
}, SR = function(e) {
  var t, i;
  try {
    t = e.getBBox();
  } catch {
    t = kE(e), i = 1;
  }
  return t && (t.width || t.height) || i || (t = kE(e)), t && !t.width && !t.x && !t.y ? {
    x: +OE(e, ["x", "cx", "x1"]) || 0,
    y: +OE(e, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, MR = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && SR(e));
}, cu = function(e, t) {
  if (t) {
    var i = e.style, n;
    t in Da && t !== us && (t = gi), i.removeProperty ? (n = t.substr(0, 2), (n === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(n === "--" ? t : t.replace(Pw, "-$1").toLowerCase())) : i.removeAttribute(t);
  }
}, gl = function(e, t, i, n, r, o) {
  var a = new cs(e._pt, t, i, 0, 1, o ? yR : _R);
  return e._pt = a, a.b = n, a.e = r, e._props.push(i), a;
}, FE = {
  deg: 1,
  rad: 1,
  turn: 1
}, bB = {
  grid: 1,
  flex: 1
}, Rl = function s(e, t, i, n) {
  var r = parseFloat(i) || 0, o = (i + "").trim().substr((r + "").length) || "px", a = Oc.style, l = lB.test(t), c = e.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), h = 100, d = n === "px", f = n === "%", m, g, v, _;
  if (n === o || !r || FE[n] || FE[o])
    return r;
  if (o !== "px" && !d && (r = s(e, t, i, "px")), _ = e.getCTM && MR(e), (f || o === "%") && (Da[t] || ~t.indexOf("adius")))
    return m = _ ? e.getBBox()[l ? "width" : "height"] : e[u], Ti(f ? r / m * h : r / 100 * m);
  if (a[l ? "width" : "height"] = h + (d ? o : n), g = n !== "rem" && ~t.indexOf("adius") || n === "em" && e.appendChild && !c ? e : e.parentNode, _ && (g = (e.ownerSVGElement || {}).parentNode), (!g || g === ml || !g.appendChild) && (g = ml.body), v = g._gsap, v && f && v.width && l && v.time === Ms.time && !v.uncache)
    return Ti(r / v.width * h);
  if (f && (t === "height" || t === "width")) {
    var y = e.style[t];
    e.style[t] = h + n, m = e[u], y ? e.style[t] = y : cu(e, t);
  } else
    (f || o === "%") && !bB[Yo(g, "display")] && (a.position = Yo(e, "position")), g === e && (a.position = "static"), g.appendChild(Oc), m = Oc[u], g.removeChild(Oc), a.position = "absolute";
  return l && f && (v = Xc(g), v.time = Ms.time, v.width = g[u]), Ti(d ? m * r / h : m && r ? h / m * r : 0);
}, _a = function(e, t, i, n) {
  var r;
  return Aw || n1(), t in zo && t !== "transform" && (t = zo[t], ~t.indexOf(",") && (t = t.split(",")[0])), Da[t] && t !== "transform" ? (r = Ip(e, n), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : r0(Yo(e, us)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || n || ~(r + "").indexOf("calc(")) && (r = i0[t] && i0[t](e, t, i) || Yo(e, t) || zP(e, t) || (t === "opacity" ? 1 : 0))), i && !~(r + "").trim().indexOf(" ") ? Rl(e, t, r, i) + i : r;
}, wB = function(e, t, i, n) {
  if (!i || i === "none") {
    var r = od(t, e, 1), o = r && Yo(e, r, 1);
    o && o !== i ? (t = r, i = o) : t === "borderColor" && (i = Yo(e, "borderTopColor"));
  }
  var a = new cs(this._pt, e.style, t, 0, 1, mR), l = 0, c = 0, u, h, d, f, m, g, v, _, y, w, x, M;
  if (a.b = i, a.e = n, i += "", n += "", n === "auto" && (g = e.style[t], e.style[t] = n, n = Yo(e, t) || n, g ? e.style[t] = g : cu(e, t)), u = [i, n], sR(u), i = u[0], n = u[1], d = i.match(Rh) || [], M = n.match(Rh) || [], M.length) {
    for (; h = Rh.exec(n); )
      v = h[0], y = n.substring(l, h.index), m ? m = (m + 1) % 5 : (y.substr(-5) === "rgba(" || y.substr(-5) === "hsla(") && (m = 1), v !== (g = d[c++] || "") && (f = parseFloat(g) || 0, x = g.substr((f + "").length), v.charAt(1) === "=" && (v = Gh(f, v) + x), _ = parseFloat(v), w = v.substr((_ + "").length), l = Rh.lastIndex - w.length, w || (w = w || Ds.units[t] || x, l === n.length && (n += w, a.e += w)), x !== w && (f = Rl(e, t, g, w) || 0), a._pt = {
        _next: a._pt,
        p: y || c === 1 ? y : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: f,
        c: _ - f,
        m: m && m < 4 || t === "zIndex" ? Math.round : 0
      });
    a.c = l < n.length ? n.substring(l, n.length) : "";
  } else
    a.r = t === "display" && n === "none" ? yR : _R;
  return UP.test(n) && (a.e = 0), this._pt = a, a;
}, NE = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, SB = function(e) {
  var t = e.split(" "), i = t[0], n = t[1] || "50%";
  return (i === "top" || i === "bottom" || n === "left" || n === "right") && (e = i, i = n, n = e), t[0] = NE[i] || i, t[1] = NE[n] || n, t.join(" ");
}, MB = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var i = t.t, n = i.style, r = t.u, o = i._gsap, a, l, c;
    if (r === "all" || r === !0)
      n.cssText = "", l = 1;
    else
      for (r = r.split(","), c = r.length; --c > -1; )
        a = r[c], Da[a] && (l = 1, a = a === "transformOrigin" ? us : gi), cu(i, a);
    l && (cu(i, gi), o && (o.svg && i.removeAttribute("transform"), n.scale = n.rotate = n.translate = "none", Ip(i, 1), o.uncache = 1, xR(n)));
  }
}, i0 = {
  clearProps: function(e, t, i, n, r) {
    if (r.data !== "isFromStart") {
      var o = e._pt = new cs(e._pt, t, i, 0, 0, MB);
      return o.u = n, o.pr = -10, o.tween = r, e._props.push(i), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, Dp = [1, 0, 0, 1, 0, 0], ER = {}, TR = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, BE = function(e) {
  var t = Yo(e, gi);
  return TR(t) ? Dp : t.substr(7).match(LP).map(Ti);
}, Rw = function(e, t) {
  var i = e._gsap || Xc(e), n = e.style, r = BE(e), o, a, l, c;
  return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, r = [l.a, l.b, l.c, l.d, l.e, l.f], r.join(",") === "1,0,0,1,0,0" ? Dp : r) : (r === Dp && !e.offsetParent && e !== Hh && !i.svg && (l = n.display, n.display = "block", o = e.parentNode, (!o || !e.offsetParent && !e.getBoundingClientRect().width) && (c = 1, a = e.nextElementSibling, Hh.appendChild(e)), r = BE(e), l ? n.display = l : cu(e, "display"), c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Hh.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
}, i1 = function(e, t, i, n, r, o) {
  var a = e._gsap, l = r || Rw(e, !0), c = a.xOrigin || 0, u = a.yOrigin || 0, h = a.xOffset || 0, d = a.yOffset || 0, f = l[0], m = l[1], g = l[2], v = l[3], _ = l[4], y = l[5], w = t.split(" "), x = parseFloat(w[0]) || 0, M = parseFloat(w[1]) || 0, A, E, C, P;
  i ? l !== Dp && (E = f * v - m * g) && (C = x * (v / E) + M * (-g / E) + (g * y - v * _) / E, P = x * (-m / E) + M * (f / E) - (f * y - m * _) / E, x = C, M = P) : (A = SR(e), x = A.x + (~w[0].indexOf("%") ? x / 100 * A.width : x), M = A.y + (~(w[1] || w[0]).indexOf("%") ? M / 100 * A.height : M)), n || n !== !1 && a.smooth ? (_ = x - c, y = M - u, a.xOffset = h + (_ * f + y * g) - _, a.yOffset = d + (_ * m + y * v) - y) : a.xOffset = a.yOffset = 0, a.xOrigin = x, a.yOrigin = M, a.smooth = !!n, a.origin = t, a.originIsAbsolute = !!i, e.style[us] = "0px 0px", o && (gl(o, a, "xOrigin", c, x), gl(o, a, "yOrigin", u, M), gl(o, a, "xOffset", h, a.xOffset), gl(o, a, "yOffset", d, a.yOffset)), e.setAttribute("data-svg-origin", x + " " + M);
}, Ip = function(e, t) {
  var i = e._gsap || new cR(e);
  if ("x" in i && !t && !i.uncache)
    return i;
  var n = e.style, r = i.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), c = Yo(e, us) || "0", u, h, d, f, m, g, v, _, y, w, x, M, A, E, C, P, T, I, D, U, L, k, B, j, q, Z, N, z, J, se, K, Q;
  return u = h = d = g = v = _ = y = w = x = 0, f = m = 1, i.svg = !!(e.getCTM && MR(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (n[gi] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[gi] !== "none" ? l[gi] : "")), n.scale = n.rotate = n.translate = "none"), E = Rw(e, i.svg), i.svg && (i.uncache ? (q = e.getBBox(), c = i.xOrigin - q.x + "px " + (i.yOrigin - q.y) + "px", j = "") : j = !t && e.getAttribute("data-svg-origin"), i1(e, j || c, !!j || i.originIsAbsolute, i.smooth !== !1, E)), M = i.xOrigin || 0, A = i.yOrigin || 0, E !== Dp && (I = E[0], D = E[1], U = E[2], L = E[3], u = k = E[4], h = B = E[5], E.length === 6 ? (f = Math.sqrt(I * I + D * D), m = Math.sqrt(L * L + U * U), g = I || D ? Yu(D, I) * Sc : 0, y = U || L ? Yu(U, L) * Sc + g : 0, y && (m *= Math.abs(Math.cos(y * Wh))), i.svg && (u -= M - (M * I + A * U), h -= A - (M * D + A * L))) : (Q = E[6], se = E[7], N = E[8], z = E[9], J = E[10], K = E[11], u = E[12], h = E[13], d = E[14], C = Yu(Q, J), v = C * Sc, C && (P = Math.cos(-C), T = Math.sin(-C), j = k * P + N * T, q = B * P + z * T, Z = Q * P + J * T, N = k * -T + N * P, z = B * -T + z * P, J = Q * -T + J * P, K = se * -T + K * P, k = j, B = q, Q = Z), C = Yu(-U, J), _ = C * Sc, C && (P = Math.cos(-C), T = Math.sin(-C), j = I * P - N * T, q = D * P - z * T, Z = U * P - J * T, K = L * T + K * P, I = j, D = q, U = Z), C = Yu(D, I), g = C * Sc, C && (P = Math.cos(C), T = Math.sin(C), j = I * P + D * T, q = k * P + B * T, D = D * P - I * T, B = B * P - k * T, I = j, k = q), v && Math.abs(v) + Math.abs(g) > 359.9 && (v = g = 0, _ = 180 - _), f = Ti(Math.sqrt(I * I + D * D + U * U)), m = Ti(Math.sqrt(B * B + Q * Q)), C = Yu(k, B), y = Math.abs(C) > 2e-4 ? C * Sc : 0, x = K ? 1 / (K < 0 ? -K : K) : 0), i.svg && (j = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !TR(Yo(e, gi)), j && e.setAttribute("transform", j))), Math.abs(y) > 90 && Math.abs(y) < 270 && (r ? (f *= -1, y += g <= 0 ? 180 : -180, g += g <= 0 ? 180 : -180) : (m *= -1, y += y <= 0 ? 180 : -180)), t = t || i.uncache, i.x = u - ((i.xPercent = u && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + o, i.y = h - ((i.yPercent = h && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + o, i.z = d + o, i.scaleX = Ti(f), i.scaleY = Ti(m), i.rotation = Ti(g) + a, i.rotationX = Ti(v) + a, i.rotationY = Ti(_) + a, i.skewX = y + a, i.skewY = w + a, i.transformPerspective = x + o, (i.zOrigin = parseFloat(c.split(" ")[2]) || !t && i.zOrigin || 0) && (n[us] = r0(c)), i.xOffset = i.yOffset = 0, i.force3D = Ds.force3D, i.renderTransform = i.svg ? TB : wR ? AR : EB, i.uncache = 0, i;
}, r0 = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, jy = function(e, t, i) {
  var n = Ir(t);
  return Ti(parseFloat(t) + parseFloat(Rl(e, "x", i + "px", n))) + n;
}, EB = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, AR(e, t);
}, Ql = "0deg", Jd = "0px", ec = ") ", AR = function(e, t) {
  var i = t || this, n = i.xPercent, r = i.yPercent, o = i.x, a = i.y, l = i.z, c = i.rotation, u = i.rotationY, h = i.rotationX, d = i.skewX, f = i.skewY, m = i.scaleX, g = i.scaleY, v = i.transformPerspective, _ = i.force3D, y = i.target, w = i.zOrigin, x = "", M = _ === "auto" && e && e !== 1 || _ === !0;
  if (w && (h !== Ql || u !== Ql)) {
    var A = parseFloat(u) * Wh, E = Math.sin(A), C = Math.cos(A), P;
    A = parseFloat(h) * Wh, P = Math.cos(A), o = jy(y, o, E * P * -w), a = jy(y, a, -Math.sin(A) * -w), l = jy(y, l, C * P * -w + w);
  }
  v !== Jd && (x += "perspective(" + v + ec), (n || r) && (x += "translate(" + n + "%, " + r + "%) "), (M || o !== Jd || a !== Jd || l !== Jd) && (x += l !== Jd || M ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + ec), c !== Ql && (x += "rotate(" + c + ec), u !== Ql && (x += "rotateY(" + u + ec), h !== Ql && (x += "rotateX(" + h + ec), (d !== Ql || f !== Ql) && (x += "skew(" + d + ", " + f + ec), (m !== 1 || g !== 1) && (x += "scale(" + m + ", " + g + ec), y.style[gi] = x || "translate(0, 0)";
}, TB = function(e, t) {
  var i = t || this, n = i.xPercent, r = i.yPercent, o = i.x, a = i.y, l = i.rotation, c = i.skewX, u = i.skewY, h = i.scaleX, d = i.scaleY, f = i.target, m = i.xOrigin, g = i.yOrigin, v = i.xOffset, _ = i.yOffset, y = i.forceCSS, w = parseFloat(o), x = parseFloat(a), M, A, E, C, P;
  l = parseFloat(l), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, l += u), l || c ? (l *= Wh, c *= Wh, M = Math.cos(l) * h, A = Math.sin(l) * h, E = Math.sin(l - c) * -d, C = Math.cos(l - c) * d, c && (u *= Wh, P = Math.tan(c - u), P = Math.sqrt(1 + P * P), E *= P, C *= P, u && (P = Math.tan(u), P = Math.sqrt(1 + P * P), M *= P, A *= P)), M = Ti(M), A = Ti(A), E = Ti(E), C = Ti(C)) : (M = h, C = d, A = E = 0), (w && !~(o + "").indexOf("px") || x && !~(a + "").indexOf("px")) && (w = Rl(f, "x", o, "px"), x = Rl(f, "y", a, "px")), (m || g || v || _) && (w = Ti(w + m - (m * M + g * E) + v), x = Ti(x + g - (m * A + g * C) + _)), (n || r) && (P = f.getBBox(), w = Ti(w + n / 100 * P.width), x = Ti(x + r / 100 * P.height)), P = "matrix(" + M + "," + A + "," + E + "," + C + "," + w + "," + x + ")", f.setAttribute("transform", P), y && (f.style[gi] = P);
}, AB = function(e, t, i, n, r) {
  var o = 360, a = rr(r), l = parseFloat(r) * (a && ~r.indexOf("rad") ? Sc : 1), c = l - n, u = n + c + "deg", h, d;
  return a && (h = r.split("_")[1], h === "short" && (c %= o, c !== c % (o / 2) && (c += c < 0 ? o : -360)), h === "cw" && c < 0 ? c = (c + o * LE) % o - ~~(c / o) * o : h === "ccw" && c > 0 && (c = (c - o * LE) % o - ~~(c / o) * o)), e._pt = d = new cs(e._pt, t, i, n, c, uB), d.e = u, d.u = "deg", e._props.push(i), d;
}, zE = function(e, t) {
  for (var i in t)
    e[i] = t[i];
  return e;
}, CB = function(e, t, i) {
  var n = zE({}, i._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", o = i.style, a, l, c, u, h, d, f, m;
  n.svg ? (c = i.getAttribute("transform"), i.setAttribute("transform", ""), o[gi] = t, a = Ip(i, 1), cu(i, gi), i.setAttribute("transform", c)) : (c = getComputedStyle(i)[gi], o[gi] = t, a = Ip(i, 1), o[gi] = c);
  for (l in Da)
    c = n[l], u = a[l], c !== u && r.indexOf(l) < 0 && (f = Ir(c), m = Ir(u), h = f !== m ? Rl(i, l, c, m) : parseFloat(c), d = parseFloat(u), e._pt = new cs(e._pt, a, l, h, d - h, e1), e._pt.u = m || 0, e._props.push(l));
  zE(a, n);
};
ls("padding,margin,Width,Radius", function(s, e) {
  var t = "Top", i = "Right", n = "Bottom", r = "Left", o = (e < 3 ? [t, i, n, r] : [t + r, t + i, n + i, n + r]).map(function(a) {
    return e < 2 ? s + a : "border" + a + s;
  });
  i0[e > 1 ? "border" + s : s] = function(a, l, c, u, h) {
    var d, f;
    if (arguments.length < 4)
      return d = o.map(function(m) {
        return _a(a, m, c);
      }), f = d.join(" "), f.split(d[0]).length === 5 ? d[0] : f;
    d = (u + "").split(" "), f = {}, o.forEach(function(m, g) {
      return f[m] = d[g] = d[g] || d[(g - 1) / 2 | 0];
    }), a.init(l, f, h);
  };
});
var CR = {
  name: "css",
  register: n1,
  targetTest: function(e) {
    return e.style && e.nodeType;
  },
  init: function(e, t, i, n, r) {
    var o = this._props, a = e.style, l = i.vars.startAt, c, u, h, d, f, m, g, v, _, y, w, x, M, A, E, C;
    Aw || n1(), this.styles = this.styles || bR(e), C = this.styles.props, this.tween = i;
    for (g in t)
      if (g !== "autoRound" && (u = t[g], !(ws[g] && uR(g, t, i, n, e, r)))) {
        if (f = typeof u, m = i0[g], f === "function" && (u = u.call(i, n, e, r), f = typeof u), f === "string" && ~u.indexOf("random(") && (u = Cp(u)), m)
          m(this, e, g, u, i) && (E = 1);
        else if (g.substr(0, 2) === "--")
          c = (getComputedStyle(e).getPropertyValue(g) + "").trim(), u += "", Sl.lastIndex = 0, Sl.test(c) || (v = Ir(c), _ = Ir(u)), _ ? v !== _ && (c = Rl(e, g, c, _) + _) : v && (u += v), this.add(a, "setProperty", c, u, n, r, 0, 0, g), o.push(g), C.push(g, 0, a[g]);
        else if (f !== "undefined") {
          if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(i, n, e, r) : l[g], rr(c) && ~c.indexOf("random(") && (c = Cp(c)), Ir(c + "") || c === "auto" || (c += Ds.units[g] || Ir(_a(e, g)) || ""), (c + "").charAt(1) === "=" && (c = _a(e, g))) : c = _a(e, g), d = parseFloat(c), y = f === "string" && u.charAt(1) === "=" && u.substr(0, 2), y && (u = u.substr(2)), h = parseFloat(u), g in zo && (g === "autoAlpha" && (d === 1 && _a(e, "visibility") === "hidden" && h && (d = 0), C.push("visibility", 0, a.visibility), gl(this, a, "visibility", d ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), g !== "scale" && g !== "transform" && (g = zo[g], ~g.indexOf(",") && (g = g.split(",")[0]))), w = g in Da, w) {
            if (this.styles.save(g), x || (M = e._gsap, M.renderTransform && !t.parseTransform || Ip(e, t.parseTransform), A = t.smoothOrigin !== !1 && M.smooth, x = this._pt = new cs(this._pt, a, gi, 0, 1, M.renderTransform, M, 0, -1), x.dep = 1), g === "scale")
              this._pt = new cs(this._pt, M, "scaleY", M.scaleY, (y ? Gh(M.scaleY, y + h) : h) - M.scaleY || 0, e1), this._pt.u = 0, o.push("scaleY", g), g += "X";
            else if (g === "transformOrigin") {
              C.push(us, 0, a[us]), u = SB(u), M.svg ? i1(e, u, 0, A, 0, this) : (_ = parseFloat(u.split(" ")[2]) || 0, _ !== M.zOrigin && gl(this, M, "zOrigin", M.zOrigin, _), gl(this, a, g, r0(c), r0(u)));
              continue;
            } else if (g === "svgOrigin") {
              i1(e, u, 1, A, 0, this);
              continue;
            } else if (g in ER) {
              AB(this, M, g, d, y ? Gh(d, y + u) : u);
              continue;
            } else if (g === "smoothOrigin") {
              gl(this, M, "smooth", M.smooth, u);
              continue;
            } else if (g === "force3D") {
              M[g] = u;
              continue;
            } else if (g === "transform") {
              CB(this, u, e);
              continue;
            }
          } else g in a || (g = od(g) || g);
          if (w || (h || h === 0) && (d || d === 0) && !cB.test(u) && g in a)
            v = (c + "").substr((d + "").length), h || (h = 0), _ = Ir(u) || (g in Ds.units ? Ds.units[g] : v), v !== _ && (d = Rl(e, g, c, _)), this._pt = new cs(this._pt, w ? M : a, g, d, (y ? Gh(d, y + h) : h) - d, !w && (_ === "px" || g === "zIndex") && t.autoRound !== !1 ? dB : e1), this._pt.u = _ || 0, v !== _ && _ !== "%" && (this._pt.b = c, this._pt.r = hB);
          else if (g in a)
            wB.call(this, e, g, c, y ? y + u : u);
          else if (g in e)
            this.add(e, g, c || e[g], y ? y + u : u, n, r);
          else if (g !== "parseTransform") {
            _w(g, u);
            continue;
          }
          w || (g in a ? C.push(g, 0, a[g]) : typeof e[g] == "function" ? C.push(g, 2, e[g]()) : C.push(g, 1, c || e[g])), o.push(g);
        }
      }
    E && gR(this);
  },
  render: function(e, t) {
    if (t.tween._time || !Cw())
      for (var i = t._pt; i; )
        i.r(e, i.d), i = i._next;
    else
      t.styles.revert();
  },
  get: _a,
  aliases: zo,
  getSetter: function(e, t, i) {
    var n = zo[t];
    return n && n.indexOf(",") < 0 && (t = n), t in Da && t !== us && (e._gsap.x || _a(e, "x")) ? i && IE === i ? t === "scale" ? gB : mB : (IE = i || {}) && (t === "scale" ? vB : _B) : e.style && !mw(e.style[t]) ? fB : ~t.indexOf("-") ? pB : Ew(e, t);
  },
  core: {
    _removeProperty: cu,
    _getMatrix: Rw
  }
};
ds.utils.checkPrefix = od;
ds.core.getStyleSaver = bR;
(function(s, e, t, i) {
  var n = ls(s + "," + e + "," + t, function(r) {
    Da[r] = 1;
  });
  ls(e, function(r) {
    Ds.units[r] = "deg", ER[r] = 1;
  }), zo[n[13]] = s + "," + e, ls(i, function(r) {
    var o = r.split(":");
    zo[o[1]] = n[o[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
ls("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(s) {
  Ds.units[s] = "px";
});
ds.registerPlugin(CR);
var Vo = ds.registerPlugin(CR) || ds;
Vo.core.Tween;
function Dw(s, e) {
  return new.target ? Rt({ component: Dw, ...s }) : (Ct(e, !1), So(() => {
    const t = document.querySelector(".hero-flora"), i = document.querySelector(".hero-ghnassia"), n = new Ev(t, { types: "chars" }), r = new Ev(i, { types: "chars" }), o = Vo.timeline();
    o.from(n.chars, {
      y: "-100%",
      opacity: 0,
      duration: 5,
      ease: "power4.out",
      stagger: { amount: 0.8, ease: "power2.inOut" }
    }), o.from(
      r.chars,
      {
        y: "-100%",
        opacity: 0,
        duration: 5,
        ease: "power4.out",
        stagger: { amount: 0.8, ease: "power1.out" }
      },
      "-=85%"
    ), o.eventCallback("onComplete", () => {
      [...n.chars, ...r.chars].forEach((c) => {
        c.style.transition = "transform 0.4s ease", c.addEventListener("mouseenter", () => {
          Vo.to(c, {
            y: "-50%",
            duration: 0.4,
            ease: "power3.inOut"
          });
        });
        const u = () => {
          Vo.to(c, { y: "0%", duration: 0.4, ease: "power2.out" });
        };
        c.addEventListener("mouseleave", u);
      });
    }), document.querySelectorAll("[animate-text-duration]").forEach((l) => {
      const c = parseFloat(l.getAttribute("animate-text-duration") || "1"), u = parseFloat(l.getAttribute("animate-delay") || "0"), h = new Ev(l, { types: "lines" });
      h.lines && (h.lines.forEach((d) => {
        d.style.overflow = "hidden";
        const f = document.createElement("div");
        f.innerHTML = d.innerHTML, f.style.display = "block", d.innerHTML = "", d.appendChild(f);
      }), Vo.fromTo(h.lines.map((d) => d.firstChild), { y: "150%" }, {
        y: "0%",
        duration: c,
        delay: u,
        stagger: 0.1,
        // Add stagger effect between lines
        ease: "power3.out",
        scrollTrigger: {
          trigger: l,
          start: "top bottom-=100",
          toggleActions: "play none none none"
        }
      }));
    });
  }), Au(), Pt({
    $set: Lt,
    $on: (t, i) => It(e, t, i)
  }));
}
Ut(Dw, {}, [], [], !0);
var PB = "1.1.20";
function PR(s, e, t) {
  return Math.max(s, Math.min(e, t));
}
function RB(s, e, t) {
  return (1 - t) * s + t * e;
}
function DB(s, e, t, i) {
  return RB(s, e, 1 - Math.exp(-t * i));
}
function IB(s, e) {
  return (s % e + e) % e;
}
var LB = class {
  constructor() {
    ht(this, "isRunning", !1);
    ht(this, "value", 0);
    ht(this, "from", 0);
    ht(this, "to", 0);
    ht(this, "currentTime", 0);
    // These are instanciated in the fromTo method
    ht(this, "lerp");
    ht(this, "duration");
    ht(this, "easing");
    ht(this, "onUpdate");
  }
  /**
   * Advance the animation by the given delta time
   *
   * @param deltaTime - The time in seconds to advance the animation
   */
  advance(s) {
    var t;
    if (!this.isRunning) return;
    let e = !1;
    if (this.duration && this.easing) {
      this.currentTime += s;
      const i = PR(0, this.currentTime / this.duration, 1);
      e = i >= 1;
      const n = e ? 1 : this.easing(i);
      this.value = this.from + (this.to - this.from) * n;
    } else this.lerp ? (this.value = DB(this.value, this.to, this.lerp * 60, s), Math.round(this.value) === this.to && (this.value = this.to, e = !0)) : (this.value = this.to, e = !0);
    e && this.stop(), (t = this.onUpdate) == null || t.call(this, this.value, e);
  }
  /** Stop the animation */
  stop() {
    this.isRunning = !1;
  }
  /**
   * Set up the animation from a starting value to an ending value
   * with optional parameters for lerping, duration, easing, and onUpdate callback
   *
   * @param from - The starting value
   * @param to - The ending value
   * @param options - Options for the animation
   */
  fromTo(s, e, { lerp: t, duration: i, easing: n, onStart: r, onUpdate: o }) {
    this.from = this.value = s, this.to = e, this.lerp = t, this.duration = i, this.easing = n, this.currentTime = 0, this.isRunning = !0, r == null || r(), this.onUpdate = o;
  }
};
function UB(s, e) {
  let t;
  return function(...i) {
    let n = this;
    clearTimeout(t), t = setTimeout(() => {
      t = void 0, s.apply(n, i);
    }, e);
  };
}
var kB = class {
  constructor(s, e, { autoResize: t = !0, debounce: i = 250 } = {}) {
    ht(this, "width", 0);
    ht(this, "height", 0);
    ht(this, "scrollHeight", 0);
    ht(this, "scrollWidth", 0);
    // These are instanciated in the constructor as they need information from the options
    ht(this, "debouncedResize");
    ht(this, "wrapperResizeObserver");
    ht(this, "contentResizeObserver");
    ht(this, "resize", () => {
      this.onWrapperResize(), this.onContentResize();
    });
    ht(this, "onWrapperResize", () => {
      this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);
    });
    ht(this, "onContentResize", () => {
      this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth);
    });
    this.wrapper = s, this.content = e, t && (this.debouncedResize = UB(this.resize, i), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize();
  }
  destroy() {
    var s, e;
    (s = this.wrapperResizeObserver) == null || s.disconnect(), (e = this.contentResizeObserver) == null || e.disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1);
  }
  get limit() {
    return {
      x: this.scrollWidth - this.width,
      y: this.scrollHeight - this.height
    };
  }
}, RR = class {
  constructor() {
    ht(this, "events", {});
  }
  /**
   * Emit an event with the given data
   * @param event Event name
   * @param args Data to pass to the event handlers
   */
  emit(s, ...e) {
    var i;
    let t = this.events[s] || [];
    for (let n = 0, r = t.length; n < r; n++)
      (i = t[n]) == null || i.call(t, ...e);
  }
  /**
   * Add a callback to the event
   * @param event Event name
   * @param cb Callback function
   * @returns Unsubscribe function
   */
  on(s, e) {
    var t;
    return (t = this.events[s]) != null && t.push(e) || (this.events[s] = [e]), () => {
      var i;
      this.events[s] = (i = this.events[s]) == null ? void 0 : i.filter((n) => e !== n);
    };
  }
  /**
   * Remove a callback from the event
   * @param event Event name
   * @param callback Callback function
   */
  off(s, e) {
    var t;
    this.events[s] = (t = this.events[s]) == null ? void 0 : t.filter((i) => e !== i);
  }
  /**
   * Remove all event listeners and clean up
   */
  destroy() {
    this.events = {};
  }
}, VE = 100 / 6, ja = { passive: !1 }, OB = class {
  constructor(s, e = { wheelMultiplier: 1, touchMultiplier: 1 }) {
    ht(this, "touchStart", {
      x: 0,
      y: 0
    });
    ht(this, "lastDelta", {
      x: 0,
      y: 0
    });
    ht(this, "window", {
      width: 0,
      height: 0
    });
    ht(this, "emitter", new RR());
    /**
     * Event handler for 'touchstart' event
     *
     * @param event Touch event
     */
    ht(this, "onTouchStart", (s) => {
      const { clientX: e, clientY: t } = s.targetTouches ? s.targetTouches[0] : s;
      this.touchStart.x = e, this.touchStart.y = t, this.lastDelta = {
        x: 0,
        y: 0
      }, this.emitter.emit("scroll", {
        deltaX: 0,
        deltaY: 0,
        event: s
      });
    });
    /** Event handler for 'touchmove' event */
    ht(this, "onTouchMove", (s) => {
      const { clientX: e, clientY: t } = s.targetTouches ? s.targetTouches[0] : s, i = -(e - this.touchStart.x) * this.options.touchMultiplier, n = -(t - this.touchStart.y) * this.options.touchMultiplier;
      this.touchStart.x = e, this.touchStart.y = t, this.lastDelta = {
        x: i,
        y: n
      }, this.emitter.emit("scroll", {
        deltaX: i,
        deltaY: n,
        event: s
      });
    });
    ht(this, "onTouchEnd", (s) => {
      this.emitter.emit("scroll", {
        deltaX: this.lastDelta.x,
        deltaY: this.lastDelta.y,
        event: s
      });
    });
    /** Event handler for 'wheel' event */
    ht(this, "onWheel", (s) => {
      let { deltaX: e, deltaY: t, deltaMode: i } = s;
      const n = i === 1 ? VE : i === 2 ? this.window.width : 1, r = i === 1 ? VE : i === 2 ? this.window.height : 1;
      e *= n, t *= r, e *= this.options.wheelMultiplier, t *= this.options.wheelMultiplier, this.emitter.emit("scroll", { deltaX: e, deltaY: t, event: s });
    });
    ht(this, "onWindowResize", () => {
      this.window = {
        width: window.innerWidth,
        height: window.innerHeight
      };
    });
    this.element = s, this.options = e, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, ja), this.element.addEventListener(
      "touchstart",
      this.onTouchStart,
      ja
    ), this.element.addEventListener(
      "touchmove",
      this.onTouchMove,
      ja
    ), this.element.addEventListener("touchend", this.onTouchEnd, ja);
  }
  /**
   * Add an event listener for the given event and callback
   *
   * @param event Event name
   * @param callback Callback function
   */
  on(s, e) {
    return this.emitter.on(s, e);
  }
  /** Remove all event listeners and clean up */
  destroy() {
    this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, ja), this.element.removeEventListener(
      "touchstart",
      this.onTouchStart,
      ja
    ), this.element.removeEventListener(
      "touchmove",
      this.onTouchMove,
      ja
    ), this.element.removeEventListener(
      "touchend",
      this.onTouchEnd,
      ja
    );
  }
}, FB = class {
  constructor({
    wrapper: s = window,
    content: e = document.documentElement,
    eventsTarget: t = s,
    smoothWheel: i = !0,
    syncTouch: n = !1,
    syncTouchLerp: r = 0.075,
    touchInertiaMultiplier: o = 35,
    duration: a,
    // in seconds
    easing: l = (A) => Math.min(1, 1.001 - Math.pow(2, -10 * A)),
    lerp: c = 0.1,
    infinite: u = !1,
    orientation: h = "vertical",
    // vertical, horizontal
    gestureOrientation: d = "vertical",
    // vertical, horizontal, both
    touchMultiplier: f = 1,
    wheelMultiplier: m = 1,
    autoResize: g = !0,
    prevent: v,
    virtualScroll: _,
    overscroll: y = !0,
    autoRaf: w = !1,
    anchors: x = !1,
    __experimental__naiveDimensions: M = !1
  } = {}) {
    ht(this, "_isScrolling", !1);
    // true when scroll is animating
    ht(this, "_isStopped", !1);
    // true if user should not be able to scroll - enable/disable programmatically
    ht(this, "_isLocked", !1);
    // same as isStopped but enabled/disabled when scroll reaches target
    ht(this, "_preventNextNativeScrollEvent", !1);
    ht(this, "_resetVelocityTimeout", null);
    ht(this, "__rafID", null);
    /**
     * Whether or not the user is touching the screen
     */
    ht(this, "isTouching");
    /**
     * The time in ms since the lenis instance was created
     */
    ht(this, "time", 0);
    /**
     * User data that will be forwarded through the scroll event
     *
     * @example
     * lenis.scrollTo(100, {
     *   userData: {
     *     foo: 'bar'
     *   }
     * })
     */
    ht(this, "userData", {});
    /**
     * The last velocity of the scroll
     */
    ht(this, "lastVelocity", 0);
    /**
     * The current velocity of the scroll
     */
    ht(this, "velocity", 0);
    /**
     * The direction of the scroll
     */
    ht(this, "direction", 0);
    /**
     * The options passed to the lenis instance
     */
    ht(this, "options");
    /**
     * The target scroll value
     */
    ht(this, "targetScroll");
    /**
     * The animated scroll value
     */
    ht(this, "animatedScroll");
    // These are instanciated here as they don't need information from the options
    ht(this, "animate", new LB());
    ht(this, "emitter", new RR());
    // These are instanciated in the constructor as they need information from the options
    ht(this, "dimensions");
    // This is not private because it's used in the Snap class
    ht(this, "virtualScroll");
    ht(this, "onScrollEnd", (s) => {
      s instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && s.stopPropagation();
    });
    ht(this, "dispatchScrollendEvent", () => {
      this.options.wrapper.dispatchEvent(
        new CustomEvent("scrollend", {
          bubbles: this.options.wrapper === window,
          // cancelable: false,
          detail: {
            lenisScrollEnd: !0
          }
        })
      );
    });
    ht(this, "onClick", (s) => {
      const t = s.composedPath().find(
        (i) => {
          var n;
          return i instanceof HTMLAnchorElement && ((n = i.getAttribute("href")) == null ? void 0 : n.startsWith("#"));
        }
      );
      if (t) {
        const i = t.getAttribute("href");
        if (i) {
          const n = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0;
          this.scrollTo(i, n);
        }
      }
    });
    ht(this, "onPointerDown", (s) => {
      s.button === 1 && this.reset();
    });
    ht(this, "onVirtualScroll", (s) => {
      if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(s) === !1)
        return;
      const { deltaX: e, deltaY: t, event: i } = s;
      if (this.emitter.emit("virtual-scroll", { deltaX: e, deltaY: t, event: i }), i.ctrlKey || i.lenisStopPropagation) return;
      const n = i.type.includes("touch"), r = i.type.includes("wheel");
      this.isTouching = i.type === "touchstart" || i.type === "touchmove";
      const o = e === 0 && t === 0;
      if (this.options.syncTouch && n && i.type === "touchstart" && o && !this.isStopped && !this.isLocked) {
        this.reset();
        return;
      }
      const l = this.options.gestureOrientation === "vertical" && t === 0 || this.options.gestureOrientation === "horizontal" && e === 0;
      if (o || l)
        return;
      let c = i.composedPath();
      c = c.slice(0, c.indexOf(this.rootElement));
      const u = this.options.prevent;
      if (c.find(
        (v) => {
          var _, y, w;
          return v instanceof HTMLElement && (typeof u == "function" && (u == null ? void 0 : u(v)) || ((_ = v.hasAttribute) == null ? void 0 : _.call(v, "data-lenis-prevent")) || n && ((y = v.hasAttribute) == null ? void 0 : y.call(v, "data-lenis-prevent-touch")) || r && ((w = v.hasAttribute) == null ? void 0 : w.call(v, "data-lenis-prevent-wheel")));
        }
      ))
        return;
      if (this.isStopped || this.isLocked) {
        i.preventDefault();
        return;
      }
      if (!(this.options.syncTouch && n || this.options.smoothWheel && r)) {
        this.isScrolling = "native", this.animate.stop(), i.lenisStopPropagation = !0;
        return;
      }
      let d = t;
      this.options.gestureOrientation === "both" ? d = Math.abs(t) > Math.abs(e) ? t : e : this.options.gestureOrientation === "horizontal" && (d = e), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && t > 0 || this.animatedScroll === this.limit && t < 0)) && (i.lenisStopPropagation = !0), i.preventDefault();
      const f = n && this.options.syncTouch, g = n && i.type === "touchend" && Math.abs(d) > 5;
      g && (d = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + d, {
        programmatic: !1,
        ...f ? {
          lerp: g ? this.options.syncTouchLerp : 1
          // immediate: !hasTouchInertia,
        } : {
          lerp: this.options.lerp,
          duration: this.options.duration,
          easing: this.options.easing
        }
      });
    });
    ht(this, "onNativeScroll", () => {
      if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) {
        this._preventNextNativeScrollEvent = !1;
        return;
      }
      if (this.isScrolling === !1 || this.isScrolling === "native") {
        const s = this.animatedScroll;
        this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - s, this.direction = Math.sign(
          this.animatedScroll - s
        ), this.isStopped || (this.isScrolling = "native"), this.emit(), this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout(() => {
          this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit();
        }, 400));
      }
    });
    /**
     * RequestAnimationFrame for lenis
     *
     * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus
     */
    ht(this, "raf", (s) => {
      const e = s - (this.time || s);
      this.time = s, this.animate.advance(e * 1e-3), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf));
    });
    window.lenisVersion = PB, (!s || s === document.documentElement) && (s = window), this.options = {
      wrapper: s,
      content: e,
      eventsTarget: t,
      smoothWheel: i,
      syncTouch: n,
      syncTouchLerp: r,
      touchInertiaMultiplier: o,
      duration: a,
      easing: l,
      lerp: c,
      infinite: u,
      gestureOrientation: d,
      orientation: h,
      touchMultiplier: f,
      wheelMultiplier: m,
      autoResize: g,
      prevent: v,
      virtualScroll: _,
      overscroll: y,
      autoRaf: w,
      anchors: x,
      __experimental__naiveDimensions: M
    }, this.dimensions = new kB(s, e, { autoResize: g }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
      capture: !0
    }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener(
      "click",
      this.onClick,
      !1
    ), this.options.wrapper.addEventListener(
      "pointerdown",
      this.onPointerDown,
      !1
    ), this.virtualScroll = new OB(t, {
      touchMultiplier: f,
      wheelMultiplier: m
    }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf));
  }
  /**
   * Destroy the lenis instance, remove all event listeners and clean up the class name
   */
  destroy() {
    this.emitter.destroy(), this.options.wrapper.removeEventListener(
      "scroll",
      this.onNativeScroll,
      !1
    ), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
      capture: !0
    }), this.options.wrapper.removeEventListener(
      "pointerdown",
      this.onPointerDown,
      !1
    ), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener(
      "click",
      this.onClick,
      !1
    ), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID);
  }
  on(s, e) {
    return this.emitter.on(s, e);
  }
  off(s, e) {
    return this.emitter.off(s, e);
  }
  setScroll(s) {
    this.isHorizontal ? this.options.wrapper.scrollTo({ left: s, behavior: "instant" }) : this.options.wrapper.scrollTo({ top: s, behavior: "instant" });
  }
  /**
   * Force lenis to recalculate the dimensions
   */
  resize() {
    this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit();
  }
  emit() {
    this.emitter.emit("scroll", this);
  }
  reset() {
    this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop();
  }
  /**
   * Start lenis scroll after it has been stopped
   */
  start() {
    this.isStopped && (this.reset(), this.isStopped = !1);
  }
  /**
   * Stop lenis scroll
   */
  stop() {
    this.isStopped || (this.reset(), this.isStopped = !0);
  }
  /**
   * Scroll to a target value
   *
   * @param target The target value to scroll to
   * @param options The options for the scroll
   *
   * @example
   * lenis.scrollTo(100, {
   *   offset: 100,
   *   duration: 1,
   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),
   *   lerp: 0.1,
   *   onStart: () => {
   *     console.log('onStart')
   *   },
   *   onComplete: () => {
   *     console.log('onComplete')
   *   },
   * })
   */
  scrollTo(s, {
    offset: e = 0,
    immediate: t = !1,
    lock: i = !1,
    duration: n = this.options.duration,
    easing: r = this.options.easing,
    lerp: o = this.options.lerp,
    onStart: a,
    onComplete: l,
    force: c = !1,
    // scroll even if stopped
    programmatic: u = !0,
    // called from outside of the class
    userData: h
  } = {}) {
    if (!((this.isStopped || this.isLocked) && !c)) {
      if (typeof s == "string" && ["top", "left", "start"].includes(s))
        s = 0;
      else if (typeof s == "string" && ["bottom", "right", "end"].includes(s))
        s = this.limit;
      else {
        let d;
        if (typeof s == "string" ? d = document.querySelector(s) : s instanceof HTMLElement && (s != null && s.nodeType) && (d = s), d) {
          if (this.options.wrapper !== window) {
            const m = this.rootElement.getBoundingClientRect();
            e -= this.isHorizontal ? m.left : m.top;
          }
          const f = d.getBoundingClientRect();
          s = (this.isHorizontal ? f.left : f.top) + this.animatedScroll;
        }
      }
      if (typeof s == "number") {
        if (s += e, s = Math.round(s), this.options.infinite ? u && (this.targetScroll = this.animatedScroll = this.scroll) : s = PR(0, s, this.limit), s === this.targetScroll) {
          a == null || a(this), l == null || l(this);
          return;
        }
        if (this.userData = h ?? {}, t) {
          this.animatedScroll = this.targetScroll = s, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), l == null || l(this), this.userData = {}, requestAnimationFrame(() => {
            this.dispatchScrollendEvent();
          });
          return;
        }
        u || (this.targetScroll = s), this.animate.fromTo(this.animatedScroll, s, {
          duration: n,
          easing: r,
          lerp: o,
          onStart: () => {
            i && (this.isLocked = !0), this.isScrolling = "smooth", a == null || a(this);
          },
          onUpdate: (d, f) => {
            this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = d - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = d, this.setScroll(this.scroll), u && (this.targetScroll = d), f || this.emit(), f && (this.reset(), this.emit(), l == null || l(this), this.userData = {}, requestAnimationFrame(() => {
              this.dispatchScrollendEvent();
            }), this.preventNextNativeScrollEvent());
          }
        });
      }
    }
  }
  preventNextNativeScrollEvent() {
    this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => {
      this._preventNextNativeScrollEvent = !1;
    });
  }
  /**
   * The root element on which lenis is instanced
   */
  get rootElement() {
    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;
  }
  /**
   * The limit which is the maximum scroll value
   */
  get limit() {
    return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
  }
  /**
   * Whether or not the scroll is horizontal
   */
  get isHorizontal() {
    return this.options.orientation === "horizontal";
  }
  /**
   * The actual scroll value
   */
  get actualScroll() {
    const s = this.options.wrapper;
    return this.isHorizontal ? s.scrollX ?? s.scrollLeft : s.scrollY ?? s.scrollTop;
  }
  /**
   * The current scroll value
   */
  get scroll() {
    return this.options.infinite ? IB(this.animatedScroll, this.limit) : this.animatedScroll;
  }
  /**
   * The progress of the scroll relative to the limit
   */
  get progress() {
    return this.limit === 0 ? 1 : this.scroll / this.limit;
  }
  /**
   * Current scroll state
   */
  get isScrolling() {
    return this._isScrolling;
  }
  set isScrolling(s) {
    this._isScrolling !== s && (this._isScrolling = s, this.updateClassName());
  }
  /**
   * Check if lenis is stopped
   */
  get isStopped() {
    return this._isStopped;
  }
  set isStopped(s) {
    this._isStopped !== s && (this._isStopped = s, this.updateClassName());
  }
  /**
   * Check if lenis is locked
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(s) {
    this._isLocked !== s && (this._isLocked = s, this.updateClassName());
  }
  /**
   * Check if lenis is smooth scrolling
   */
  get isSmooth() {
    return this.isScrolling === "smooth";
  }
  /**
   * The class name applied to the wrapper element
   */
  get className() {
    let s = "lenis";
    return this.isStopped && (s += " lenis-stopped"), this.isLocked && (s += " lenis-locked"), this.isScrolling && (s += " lenis-scrolling"), this.isScrolling === "smooth" && (s += " lenis-smooth"), s;
  }
  updateClassName() {
    this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();
  }
  cleanUpClassName() {
    this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim();
  }
};
function NB(s) {
  In(s, s.v + 1);
}
function BB(s) {
  let e = 0, t = qs(0), i;
  return () => {
    nP() && (pe(t), _d(() => (e === 0 && (i = io(() => s(() => NB(t)))), e += 1, () => {
      aw().then(() => {
        e -= 1, e === 0 && (i == null || i(), i = void 0);
      });
    })));
  };
}
function rm(s) {
  let e;
  const t = BB((n) => {
    let r = !1;
    const o = s.subscribe((a) => {
      e = a, r && n();
    });
    return r = !0, o;
  });
  function i() {
    return nP() ? (t(), e) : Kv(s);
  }
  return "set" in s ? {
    get current() {
      return i();
    },
    set current(n) {
      s.set(n);
    }
  } : {
    get current() {
      return i();
    }
  };
}
const zB = tm(null, (s) => {
  const e = new FB({
    duration: 1.2,
    easing: (r) => Math.min(1, 1.001 - Math.pow(2, -10 * r)),
    touchMultiplier: 2,
    infinite: !1
  });
  function t(r) {
    e.raf(r), requestAnimationFrame(t);
  }
  requestAnimationFrame(t), e.stop(), e.start();
  let i;
  function n() {
    clearTimeout(i), i = setTimeout(() => {
      requestAnimationFrame(() => {
        e.resize();
      });
    }, 300);
  }
  return window.addEventListener("load", n), document.querySelectorAll("img[loading='lazy']").forEach((r) => {
    r.addEventListener("load", n);
  }), s(e), () => {
    e.destroy(), s(null);
  };
});
function GE(s) {
  return Object.prototype.toString.call(s) === "[object Date]";
}
function r1(s, e, t, i) {
  if (typeof t == "number" || GE(t)) {
    const n = i - t, r = (t - e) / (s.dt || 1 / 60), o = s.opts.stiffness * n, a = s.opts.damping * r, l = (o - a) * s.inv_mass, c = (r + l) * s.dt;
    return Math.abs(c) < s.opts.precision && Math.abs(n) < s.opts.precision ? i : (s.settled = !1, GE(t) ? new Date(t.getTime() + c) : t + c);
  } else {
    if (Array.isArray(t))
      return t.map(
        (n, r) => (
          // @ts-ignore
          r1(s, e[r], t[r], i[r])
        )
      );
    if (typeof t == "object") {
      const n = {};
      for (const r in t)
        n[r] = r1(s, e[r], t[r], i[r]);
      return n;
    } else
      throw new Error(`Cannot spring ${typeof t} values`);
  }
}
function VB(s, e = {}) {
  const t = Gn(s), { stiffness: i = 0.15, damping: n = 0.8, precision: r = 0.01 } = e;
  let o, a, l, c = (
    /** @type {T} */
    s
  ), u = (
    /** @type {T | undefined} */
    s
  ), h = 1, d = 0, f = !1;
  function m(v, _ = {}) {
    u = v;
    const y = l = {};
    return s == null || _.hard || g.stiffness >= 1 && g.damping >= 1 ? (f = !0, o = go.now(), c = v, t.set(s = u), Promise.resolve()) : (_.soft && (d = 1 / ((_.soft === !0 ? 0.5 : +_.soft) * 60), h = 0), a || (o = go.now(), f = !1, a = PF((w) => {
      if (f)
        return f = !1, a = null, !1;
      h = Math.min(h + d, 1);
      const x = Math.min(w - o, 1e3 / 30), M = {
        inv_mass: h,
        opts: g,
        settled: !0,
        dt: x * 60 / 1e3
      }, A = r1(M, c, s, u);
      return o = w, c = /** @type {T} */
      s, t.set(s = /** @type {T} */
      A), M.settled && (a = null), !M.settled;
    })), new Promise((w) => {
      a.promise.then(() => {
        y === l && w();
      });
    }));
  }
  const g = {
    set: m,
    update: (v, _) => m(v(
      /** @type {T} */
      u,
      /** @type {T} */
      s
    ), _),
    subscribe: t.subscribe,
    stiffness: i,
    damping: n,
    precision: r
  };
  return g;
}
function Iw(s, e) {
  if (new.target) return Rt({
    component: Iw,
    ...s
  });
  Ct(e, !1);
  const [t, i] = $i(), n = () => Bn(l, "$velocitySpring", t), r = () => Bn(zB, "$lenisController", t), o = () => Bn(u, "$setted", t);
  let a;
  const l = VB(0, { stiffness: 0.1, damping: 0.5 });
  let c = Xf(!1), u = Gn(!1);
  const h = () => {
    if (!o()) {
      Nb(u, !0), document.body.style.setProperty("--scroll-velocity", "0"), a = document.querySelectorAll(".home-project-instance");
      for (let f of a) {
        const m = window.getComputedStyle(f).transform;
        f.style.transform = "none";
        const g = f.querySelector(".home-project-image.original");
        g.style.zIndex = "1000", g.style.transform = "translateZ(100%)";
        let v = 8;
        const _ = document.createElement("div");
        _.classList.add("clones-container"), _.style.zIndex = "0";
        for (let x = 0; x < v; x++) {
          const M = g.cloneNode(!0);
          M.classList.remove("original"), M.classList.add("clone"), _.appendChild(M);
        }
        f.children[0].appendChild(_);
        const y = Array.from(_.querySelectorAll(".home-project-image.clone")), w = (x, { opacity: M, translate: A, transformIndex: E }) => {
          x.style.opacity = `${M}`;
          const C = `-${A * 1.25 + (E * E / 2 || 0) * 0.1}rem`, P = `${A * 2}rem`, I = `calc(var(--scroll-velocity)*${E}*0.05rem)`;
          x.style.transform = `${m} translateY(${I}) translate3d(${C}, ${P}, 0)`;
        };
        w(g, { opacity: 1, translate: 0, transformIndex: 0 });
        for (let [x, M] of y.reverse().entries()) {
          const A = Vo.utils.interpolate(0.85, 0.15, x / v), E = Vo.utils.interpolate(0.25, 4, x / v);
          w(M, {
            opacity: A,
            translate: E,
            transformIndex: x + 1
          });
        }
      }
    }
  };
  So(() => {
    h();
  }), ul(
    () => (r(), pe(c)),
    () => {
      r() && !pe(c) && (In(c, !0), r().on("scroll", (f) => {
        Nb(l, f.velocity);
      }));
    }
  ), ul(() => n(), () => {
    document.body.style.setProperty("--scroll-velocity", `${n()}`);
  }), lw(), Au();
  var d = Pt({
    $set: Lt,
    $on: (f, m) => It(e, f, m)
  });
  return i(), d;
}
Ut(Iw, {}, [], [], !0);
function Lw(s, e) {
  if (new.target) return Rt({ component: Lw, ...s });
  Ct(e, !1);
  const t = (n) => {
    new Ev(n, { types: "chars,words" });
    const r = n.querySelector(".menu-item");
    r.style.display = "flex", r.style.flexDirection = "column", r.style.alignItems = "center", r.style.justifyContent = "center", r.style.overflow = "hidden", r.style.height = "2rem";
    const o = n.querySelector(".word").cloneNode(!0);
    o.style.position = "absolute", o.style.transform = "translateY(125%)", o.classList.add("clone"), r.appendChild(o);
    const a = n.querySelectorAll(".char"), l = o.querySelectorAll(".char"), c = Vo.timeline({ paused: !0 });
    c.to(
      a,
      {
        yPercent: -125,
        duration: 0.8,
        stagger: 0.06,
        ease: "power2.out"
      },
      0
    ), c.to(
      l,
      {
        yPercent: -125,
        duration: 0.8,
        stagger: 0.06,
        ease: "power2.out"
      },
      0
    ), n.addEventListener("mouseenter", () => {
      c.timeScale(1), c.play();
    }), n.addEventListener("mouseleave", () => {
      c.timeScale(2), c.reverse();
    });
  }, i = () => {
    document.querySelectorAll(".menu-link").forEach((r) => {
      t(r);
    });
  };
  return So(() => {
    i();
  }), Au(), Pt({
    $set: Lt,
    $on: (n, r) => It(e, n, r)
  });
}
Ut(Lw, {}, [], [], !0);
const GB = {
  hash: "svelte-1ezyzfm",
  code: ".drawing-canvas {position:relative;width:100%;height:100%;background-color:white;overflow:hidden;}"
};
function Uw(s, e) {
  if (new.target) return Rt({ component: Uw, ...s });
  Ct(e, !1), hP(s, GB);
  let t, i, n, r = [];
  const o = 10, a = 100, l = 1e3;
  function c(_) {
    const y = i.getBoundingClientRect();
    return {
      x: _.clientX - y.left,
      y: _.clientY - y.top
    };
  }
  function u(_, y) {
    return Math.sqrt(Math.pow(y.x - _.x, 2) + Math.pow(y.y - _.y, 2));
  }
  function h(_) {
    let y = 0;
    for (let w = 1; w < _.length; w++)
      y += u(_[w - 1], _[w]);
    return y;
  }
  function d(_) {
    const y = c(_);
    r.push({
      x: y.x,
      y: y.y,
      timestamp: Date.now()
    }), r.length > l && r.shift(), f();
  }
  function f() {
    if (n.clearRect(0, 0, i.width, i.height), r.length <= 1) return;
    let _ = [], y = [];
    _.push(r[r.length - 1]);
    let w = 0;
    for (let x = r.length - 2; x >= 0; x--) {
      const M = u(r[x], r[x + 1]);
      if (w += M, w <= a)
        _.unshift(r[x]);
      else {
        y = r.slice(0, x + 1), _.length > 0 && _[0] !== r[x] && _.unshift(r[x]);
        break;
      }
    }
    if (y.length === 0 && r.length > 1 && (y = [r[0]]), y.length > 0) {
      n.beginPath(), n.moveTo(y[0].x, y[0].y);
      for (let x = 1; x < y.length; x++)
        n.lineTo(y[x].x, y[x].y);
      n.strokeStyle = "black", n.lineWidth = o, n.lineCap = "round", n.lineJoin = "round", n.stroke();
    }
    if (_.length > 1) {
      const x = h(_);
      let M = 0;
      for (let A = 0; A < _.length - 1; A++) {
        const E = _[A], C = _[A + 1], P = u(E, C), T = M / x, I = (M + P) / x, D = A === 0 ? o : o * (1 - Math.pow(T, 1.5)), U = o * (1 - Math.pow(I, 1.5)), L = A === 0 && E === y[y.length - 1] ? o : (D + U) / 2;
        n.beginPath(), n.moveTo(E.x, E.y), n.lineTo(C.x, C.y), n.strokeStyle = "black", n.lineWidth = L, n.lineCap = "round", n.lineJoin = "round", n.stroke(), M += P;
      }
    }
  }
  function m() {
    n.clearRect(0, 0, i.width, i.height), r = [];
  }
  function g() {
    const _ = document.createElement("a");
    _.href = i.toDataURL("image/png"), _.download = "drawing.png", _.click();
  }
  function v() {
    const _ = n.getImageData(0, 0, i.width, i.height);
    i.width = t.clientWidth, i.height = t.clientHeight, n.putImageData(_, 0, 0), n.lineCap = "round", n.lineJoin = "round", f();
  }
  return So(() => {
    t = document.querySelector(".drawing-canvas"), i = document.createElement("canvas"), i.width = t.clientWidth, i.height = t.clientHeight, i.style.display = "block", n = i.getContext("2d"), n.lineCap = "round", n.lineJoin = "round", t.appendChild(i), t.style.cursor = "none", i.addEventListener("pointermove", d), window.addEventListener("resize", v);
    const _ = document.querySelector("#download-btn"), y = document.querySelector("#reset-btn");
    return _ && y && (_.addEventListener("click", g), y.addEventListener("click", (w) => {
      w.preventDefault(), m();
    })), () => {
      i.removeEventListener("pointermove", d), window.removeEventListener("resize", v), _ && y && (_.removeEventListener("click", g), y.removeEventListener("click", (w) => {
        w.preventDefault(), m();
      }));
    };
  }), Au(), Pt({
    $set: Lt,
    $on: (_, y) => It(e, _, y)
  });
}
Ut(Uw, {}, [], [], !0);
function HB(s, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(s, i.key, i);
  }
}
function WB(s, e, t) {
  return e && HB(s.prototype, e), s;
}
/*!
 * Observer 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var mr, Pv, Es, vl, _l, Xh, DR, Mc, Zf, IR, Sa, fo, LR, UR = function() {
  return mr || typeof window < "u" && (mr = window.gsap) && mr.registerPlugin && mr;
}, kR = 1, Ih = [], fn = [], jo = [], Kf = Date.now, s1 = function(e, t) {
  return t;
}, XB = function() {
  var e = Zf.core, t = e.bridge || {}, i = e._scrollers, n = e._proxies;
  i.push.apply(i, fn), n.push.apply(n, jo), fn = i, jo = n, s1 = function(o, a) {
    return t[o](a);
  };
}, Ml = function(e, t) {
  return ~jo.indexOf(e) && jo[jo.indexOf(e) + 1][t];
}, $f = function(e) {
  return !!~IR.indexOf(e);
}, Br = function(e, t, i, n, r) {
  return e.addEventListener(t, i, {
    passive: n !== !1,
    capture: !!r
  });
}, Fr = function(e, t, i, n) {
  return e.removeEventListener(t, i, !!n);
}, Nm = "scrollLeft", Bm = "scrollTop", o1 = function() {
  return Sa && Sa.isPressed || fn.cache++;
}, s0 = function(e, t) {
  var i = function n(r) {
    if (r || r === 0) {
      kR && (Es.history.scrollRestoration = "manual");
      var o = Sa && Sa.isPressed;
      r = n.v = Math.round(r) || (Sa && Sa.iOS ? 1 : 0), e(r), n.cacheID = fn.cache, o && s1("ss", r);
    } else (t || fn.cache !== n.cacheID || s1("ref")) && (n.cacheID = fn.cache, n.v = e());
    return n.v + n.offset;
  };
  return i.offset = 0, e && i;
}, jr = {
  s: Nm,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: s0(function(s) {
    return arguments.length ? Es.scrollTo(s, Wi.sc()) : Es.pageXOffset || vl[Nm] || _l[Nm] || Xh[Nm] || 0;
  })
}, Wi = {
  s: Bm,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: jr,
  sc: s0(function(s) {
    return arguments.length ? Es.scrollTo(jr.sc(), s) : Es.pageYOffset || vl[Bm] || _l[Bm] || Xh[Bm] || 0;
  })
}, rs = function(e, t) {
  return (t && t._ctx && t._ctx.selector || mr.utils.toArray)(e)[0] || (typeof e == "string" && mr.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null);
}, Dl = function(e, t) {
  var i = t.s, n = t.sc;
  $f(e) && (e = vl.scrollingElement || _l);
  var r = fn.indexOf(e), o = n === Wi.sc ? 1 : 2;
  !~r && (r = fn.push(e) - 1), fn[r + o] || Br(e, "scroll", o1);
  var a = fn[r + o], l = a || (fn[r + o] = s0(Ml(e, i), !0) || ($f(e) ? n : s0(function(c) {
    return arguments.length ? e[i] = c : e[i];
  })));
  return l.target = e, a || (l.smooth = mr.getProperty(e, "scrollBehavior") === "smooth"), l;
}, a1 = function(e, t, i) {
  var n = e, r = e, o = Kf(), a = o, l = t || 50, c = Math.max(500, l * 3), u = function(m, g) {
    var v = Kf();
    g || v - o > l ? (r = n, n = m, a = o, o = v) : i ? n += m : n = r + (m - r) / (v - a) * (o - a);
  }, h = function() {
    r = n = i ? 0 : n, a = o = 0;
  }, d = function(m) {
    var g = a, v = r, _ = Kf();
    return (m || m === 0) && m !== n && u(m), o === a || _ - a > c ? 0 : (n + (i ? v : -v)) / ((i ? _ : o) - g) * 1e3;
  };
  return {
    update: u,
    reset: h,
    getVelocity: d
  };
}, Qd = function(e, t) {
  return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e;
}, HE = function(e) {
  var t = Math.max.apply(Math, e), i = Math.min.apply(Math, e);
  return Math.abs(t) >= Math.abs(i) ? t : i;
}, OR = function() {
  Zf = mr.core.globals().ScrollTrigger, Zf && Zf.core && XB();
}, FR = function(e) {
  return mr = e || UR(), !Pv && mr && typeof document < "u" && document.body && (Es = window, vl = document, _l = vl.documentElement, Xh = vl.body, IR = [Es, vl, _l, Xh], mr.utils.clamp, LR = mr.core.context || function() {
  }, Mc = "onpointerenter" in Xh ? "pointer" : "mouse", DR = Ci.isTouch = Es.matchMedia && Es.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Es || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, fo = Ci.eventTypes = ("ontouchstart" in _l ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in _l ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
    return kR = 0;
  }, 500), OR(), Pv = 1), Pv;
};
jr.op = Wi;
fn.cache = 0;
var Ci = /* @__PURE__ */ function() {
  function s(t) {
    this.init(t);
  }
  var e = s.prototype;
  return e.init = function(i) {
    Pv || FR(mr) || console.warn("Please gsap.registerPlugin(Observer)"), Zf || OR();
    var n = i.tolerance, r = i.dragMinimum, o = i.type, a = i.target, l = i.lineHeight, c = i.debounce, u = i.preventDefault, h = i.onStop, d = i.onStopDelay, f = i.ignore, m = i.wheelSpeed, g = i.event, v = i.onDragStart, _ = i.onDragEnd, y = i.onDrag, w = i.onPress, x = i.onRelease, M = i.onRight, A = i.onLeft, E = i.onUp, C = i.onDown, P = i.onChangeX, T = i.onChangeY, I = i.onChange, D = i.onToggleX, U = i.onToggleY, L = i.onHover, k = i.onHoverEnd, B = i.onMove, j = i.ignoreCheck, q = i.isNormalizer, Z = i.onGestureStart, N = i.onGestureEnd, z = i.onWheel, J = i.onEnable, se = i.onDisable, K = i.onClick, Q = i.scrollSpeed, de = i.capture, ce = i.allowClicks, _e = i.lockAxis, Fe = i.onLockAxis;
    this.target = a = rs(a) || _l, this.vars = i, f && (f = mr.utils.toArray(f)), n = n || 1e-9, r = r || 0, m = m || 1, Q = Q || 1, o = o || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat(Es.getComputedStyle(Xh).lineHeight) || 22);
    var Ie, Ee, me, xe, $, Ue, Me, oe = this, Te = 0, Ye = 0, Oe = i.passive || !u && i.passive !== !1, X = Dl(a, jr), Y = Dl(a, Wi), fe = X(), ue = Y(), te = ~o.indexOf("touch") && !~o.indexOf("pointer") && fo[0] === "pointerdown", Se = $f(a), ye = a.ownerDocument || vl, Ae = [0, 0, 0], Ce = [0, 0, 0], Ge = 0, De = function() {
      return Ge = Kf();
    }, Ve = function(at, ft) {
      return (oe.event = at) && f && ~f.indexOf(at.target) || ft && te && at.pointerType !== "touch" || j && j(at, ft);
    }, ze = function() {
      oe._vx.reset(), oe._vy.reset(), Ee.pause(), h && h(oe);
    }, Ze = function() {
      var at = oe.deltaX = HE(Ae), ft = oe.deltaY = HE(Ce), Qe = Math.abs(at) >= n, xt = Math.abs(ft) >= n;
      I && (Qe || xt) && I(oe, at, ft, Ae, Ce), Qe && (M && oe.deltaX > 0 && M(oe), A && oe.deltaX < 0 && A(oe), P && P(oe), D && oe.deltaX < 0 != Te < 0 && D(oe), Te = oe.deltaX, Ae[0] = Ae[1] = Ae[2] = 0), xt && (C && oe.deltaY > 0 && C(oe), E && oe.deltaY < 0 && E(oe), T && T(oe), U && oe.deltaY < 0 != Ye < 0 && U(oe), Ye = oe.deltaY, Ce[0] = Ce[1] = Ce[2] = 0), (xe || me) && (B && B(oe), me && (v && me === 1 && v(oe), y && y(oe), me = 0), xe = !1), Ue && !(Ue = !1) && Fe && Fe(oe), $ && (z(oe), $ = !1), Ie = 0;
    }, Le = function(at, ft, Qe) {
      Ae[Qe] += at, Ce[Qe] += ft, oe._vx.update(at), oe._vy.update(ft), c ? Ie || (Ie = requestAnimationFrame(Ze)) : Ze();
    }, ot = function(at, ft) {
      _e && !Me && (oe.axis = Me = Math.abs(at) > Math.abs(ft) ? "x" : "y", Ue = !0), Me !== "y" && (Ae[2] += at, oe._vx.update(at, !0)), Me !== "x" && (Ce[2] += ft, oe._vy.update(ft, !0)), c ? Ie || (Ie = requestAnimationFrame(Ze)) : Ze();
    }, tt = function(at) {
      if (!Ve(at, 1)) {
        at = Qd(at, u);
        var ft = at.clientX, Qe = at.clientY, xt = ft - oe.x, yt = Qe - oe.y, Mt = oe.isDragging;
        oe.x = ft, oe.y = Qe, (Mt || (xt || yt) && (Math.abs(oe.startX - ft) >= r || Math.abs(oe.startY - Qe) >= r)) && (me = Mt ? 2 : 1, Mt || (oe.isDragging = !0), ot(xt, yt));
      }
    }, mt = oe.onPress = function(je) {
      Ve(je, 1) || je && je.button || (oe.axis = Me = null, Ee.pause(), oe.isPressed = !0, je = Qd(je), Te = Ye = 0, oe.startX = oe.x = je.clientX, oe.startY = oe.y = je.clientY, oe._vx.reset(), oe._vy.reset(), Br(q ? a : ye, fo[1], tt, Oe, !0), oe.deltaX = oe.deltaY = 0, w && w(oe));
    }, le = oe.onRelease = function(je) {
      if (!Ve(je, 1)) {
        Fr(q ? a : ye, fo[1], tt, !0);
        var at = !isNaN(oe.y - oe.startY), ft = oe.isDragging, Qe = ft && (Math.abs(oe.x - oe.startX) > 3 || Math.abs(oe.y - oe.startY) > 3), xt = Qd(je);
        !Qe && at && (oe._vx.reset(), oe._vy.reset(), u && ce && mr.delayedCall(0.08, function() {
          if (Kf() - Ge > 300 && !je.defaultPrevented) {
            if (je.target.click)
              je.target.click();
            else if (ye.createEvent) {
              var yt = ye.createEvent("MouseEvents");
              yt.initMouseEvent("click", !0, !0, Es, 1, xt.screenX, xt.screenY, xt.clientX, xt.clientY, !1, !1, !1, !1, 0, null), je.target.dispatchEvent(yt);
            }
          }
        })), oe.isDragging = oe.isGesturing = oe.isPressed = !1, h && ft && !q && Ee.restart(!0), me && Ze(), _ && ft && _(oe), x && x(oe, Qe);
      }
    }, ve = function(at) {
      return at.touches && at.touches.length > 1 && (oe.isGesturing = !0) && Z(at, oe.isDragging);
    }, be = function() {
      return (oe.isGesturing = !1) || N(oe);
    }, Xe = function(at) {
      if (!Ve(at)) {
        var ft = X(), Qe = Y();
        Le((ft - fe) * Q, (Qe - ue) * Q, 1), fe = ft, ue = Qe, h && Ee.restart(!0);
      }
    }, We = function(at) {
      if (!Ve(at)) {
        at = Qd(at, u), z && ($ = !0);
        var ft = (at.deltaMode === 1 ? l : at.deltaMode === 2 ? Es.innerHeight : 1) * m;
        Le(at.deltaX * ft, at.deltaY * ft, 0), h && !q && Ee.restart(!0);
      }
    }, Ne = function(at) {
      if (!Ve(at)) {
        var ft = at.clientX, Qe = at.clientY, xt = ft - oe.x, yt = Qe - oe.y;
        oe.x = ft, oe.y = Qe, xe = !0, h && Ee.restart(!0), (xt || yt) && ot(xt, yt);
      }
    }, ct = function(at) {
      oe.event = at, L(oe);
    }, gt = function(at) {
      oe.event = at, k(oe);
    }, nt = function(at) {
      return Ve(at) || Qd(at, u) && K(oe);
    };
    Ee = oe._dc = mr.delayedCall(d || 0.25, ze).pause(), oe.deltaX = oe.deltaY = 0, oe._vx = a1(0, 50, !0), oe._vy = a1(0, 50, !0), oe.scrollX = X, oe.scrollY = Y, oe.isDragging = oe.isGesturing = oe.isPressed = !1, LR(this), oe.enable = function(je) {
      return oe.isEnabled || (Br(Se ? ye : a, "scroll", o1), o.indexOf("scroll") >= 0 && Br(Se ? ye : a, "scroll", Xe, Oe, de), o.indexOf("wheel") >= 0 && Br(a, "wheel", We, Oe, de), (o.indexOf("touch") >= 0 && DR || o.indexOf("pointer") >= 0) && (Br(a, fo[0], mt, Oe, de), Br(ye, fo[2], le), Br(ye, fo[3], le), ce && Br(a, "click", De, !0, !0), K && Br(a, "click", nt), Z && Br(ye, "gesturestart", ve), N && Br(ye, "gestureend", be), L && Br(a, Mc + "enter", ct), k && Br(a, Mc + "leave", gt), B && Br(a, Mc + "move", Ne)), oe.isEnabled = !0, oe.isDragging = oe.isGesturing = oe.isPressed = xe = me = !1, oe._vx.reset(), oe._vy.reset(), fe = X(), ue = Y(), je && je.type && mt(je), J && J(oe)), oe;
    }, oe.disable = function() {
      oe.isEnabled && (Ih.filter(function(je) {
        return je !== oe && $f(je.target);
      }).length || Fr(Se ? ye : a, "scroll", o1), oe.isPressed && (oe._vx.reset(), oe._vy.reset(), Fr(q ? a : ye, fo[1], tt, !0)), Fr(Se ? ye : a, "scroll", Xe, de), Fr(a, "wheel", We, de), Fr(a, fo[0], mt, de), Fr(ye, fo[2], le), Fr(ye, fo[3], le), Fr(a, "click", De, !0), Fr(a, "click", nt), Fr(ye, "gesturestart", ve), Fr(ye, "gestureend", be), Fr(a, Mc + "enter", ct), Fr(a, Mc + "leave", gt), Fr(a, Mc + "move", Ne), oe.isEnabled = oe.isPressed = oe.isDragging = !1, se && se(oe));
    }, oe.kill = oe.revert = function() {
      oe.disable();
      var je = Ih.indexOf(oe);
      je >= 0 && Ih.splice(je, 1), Sa === oe && (Sa = 0);
    }, Ih.push(oe), q && $f(a) && (Sa = oe), oe.enable(g);
  }, WB(s, [{
    key: "velocityX",
    get: function() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function() {
      return this._vy.getVelocity();
    }
  }]), s;
}();
Ci.version = "3.12.7";
Ci.create = function(s) {
  return new Ci(s);
};
Ci.register = FR;
Ci.getAll = function() {
  return Ih.slice();
};
Ci.getById = function(s) {
  return Ih.filter(function(e) {
    return e.vars.id === s;
  })[0];
};
UR() && mr.registerPlugin(Ci);
/*!
 * ScrollTrigger 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Dt, Ch, dn, Qn, Ss, Fn, kw, o0, Lp, Jf, Df, zm, Ar, f_, l1, Gr, WE, XE, Ph, NR, qy, BR, Vr, c1, zR, VR, al, u1, Ow, Yh, Fw, a0, h1, Zy, Vm = 1, Rr = Date.now, Ky = Rr(), no = 0, If = 0, YE = function(e, t, i) {
  var n = bs(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
  return i["_" + t + "Clamp"] = n, n ? e.substr(6, e.length - 7) : e;
}, jE = function(e, t) {
  return t && (!bs(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e;
}, YB = function s() {
  return If && requestAnimationFrame(s);
}, qE = function() {
  return f_ = 1;
}, ZE = function() {
  return f_ = 0;
}, ko = function(e) {
  return e;
}, Lf = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, GR = function() {
  return typeof window < "u";
}, HR = function() {
  return Dt || GR() && (Dt = window.gsap) && Dt.registerPlugin && Dt;
}, uu = function(e) {
  return !!~kw.indexOf(e);
}, WR = function(e) {
  return (e === "Height" ? Fw : dn["inner" + e]) || Ss["client" + e] || Fn["client" + e];
}, XR = function(e) {
  return Ml(e, "getBoundingClientRect") || (uu(e) ? function() {
    return Uv.width = dn.innerWidth, Uv.height = Fw, Uv;
  } : function() {
    return xa(e);
  });
}, jB = function(e, t, i) {
  var n = i.d, r = i.d2, o = i.a;
  return (o = Ml(e, "getBoundingClientRect")) ? function() {
    return o()[n];
  } : function() {
    return (t ? WR(r) : e["client" + r]) || 0;
  };
}, qB = function(e, t) {
  return !t || ~jo.indexOf(e) ? XR(e) : function() {
    return Uv;
  };
}, Go = function(e, t) {
  var i = t.s, n = t.d2, r = t.d, o = t.a;
  return Math.max(0, (i = "scroll" + n) && (o = Ml(e, i)) ? o() - XR(e)()[r] : uu(e) ? (Ss[i] || Fn[i]) - WR(n) : e[i] - e["offset" + n]);
}, Gm = function(e, t) {
  for (var i = 0; i < Ph.length; i += 3)
    (!t || ~t.indexOf(Ph[i + 1])) && e(Ph[i], Ph[i + 1], Ph[i + 2]);
}, bs = function(e) {
  return typeof e == "string";
}, Lr = function(e) {
  return typeof e == "function";
}, Uf = function(e) {
  return typeof e == "number";
}, Ec = function(e) {
  return typeof e == "object";
}, ef = function(e, t, i) {
  return e && e.progress(t ? 0 : 1) && i && e.pause();
}, $y = function(e, t) {
  if (e.enabled) {
    var i = e._ctx ? e._ctx.add(function() {
      return t(e);
    }) : t(e);
    i && i.totalTime && (e.callbackAnimation = i);
  }
}, ju = Math.abs, YR = "left", jR = "top", Nw = "right", Bw = "bottom", Zc = "width", Kc = "height", Qf = "Right", ep = "Left", tp = "Top", np = "Bottom", Ii = "padding", Zs = "margin", ad = "Width", zw = "Height", Hi = "px", Ks = function(e) {
  return dn.getComputedStyle(e);
}, ZB = function(e) {
  var t = Ks(e).position;
  e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
}, KE = function(e, t) {
  for (var i in t)
    i in e || (e[i] = t[i]);
  return e;
}, xa = function(e, t) {
  var i = t && Ks(e)[l1] !== "matrix(1, 0, 0, 1, 0, 0)" && Dt.to(e, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1), n = e.getBoundingClientRect();
  return i && i.progress(0).kill(), n;
}, l0 = function(e, t) {
  var i = t.d2;
  return e["offset" + i] || e["client" + i] || 0;
}, qR = function(e) {
  var t = [], i = e.labels, n = e.duration(), r;
  for (r in i)
    t.push(i[r] / n);
  return t;
}, KB = function(e) {
  return function(t) {
    return Dt.utils.snap(qR(e), t);
  };
}, Vw = function(e) {
  var t = Dt.utils.snap(e), i = Array.isArray(e) && e.slice(0).sort(function(n, r) {
    return n - r;
  });
  return i ? function(n, r, o) {
    o === void 0 && (o = 1e-3);
    var a;
    if (!r)
      return t(n);
    if (r > 0) {
      for (n -= o, a = 0; a < i.length; a++)
        if (i[a] >= n)
          return i[a];
      return i[a - 1];
    } else
      for (a = i.length, n += o; a--; )
        if (i[a] <= n)
          return i[a];
    return i[0];
  } : function(n, r, o) {
    o === void 0 && (o = 1e-3);
    var a = t(n);
    return !r || Math.abs(a - n) < o || a - n < 0 == r < 0 ? a : t(r < 0 ? n - e : n + e);
  };
}, $B = function(e) {
  return function(t, i) {
    return Vw(qR(e))(t, i.direction);
  };
}, Hm = function(e, t, i, n) {
  return i.split(",").forEach(function(r) {
    return e(t, r, n);
  });
}, ir = function(e, t, i, n, r) {
  return e.addEventListener(t, i, {
    passive: !n,
    capture: !!r
  });
}, nr = function(e, t, i, n) {
  return e.removeEventListener(t, i, !!n);
}, Wm = function(e, t, i) {
  i = i && i.wheelHandler, i && (e(t, "wheel", i), e(t, "touchmove", i));
}, $E = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
}, Xm = {
  toggleActions: "play",
  anticipatePin: 0
}, c0 = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
}, Rv = function(e, t) {
  if (bs(e)) {
    var i = e.indexOf("="), n = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
    ~i && (e.indexOf("%") > i && (n *= t / 100), e = e.substr(0, i - 1)), e = n + (e in c0 ? c0[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0);
  }
  return e;
}, Ym = function(e, t, i, n, r, o, a, l) {
  var c = r.startColor, u = r.endColor, h = r.fontSize, d = r.indent, f = r.fontWeight, m = Qn.createElement("div"), g = uu(i) || Ml(i, "pinType") === "fixed", v = e.indexOf("scroller") !== -1, _ = g ? Fn : i, y = e.indexOf("start") !== -1, w = y ? c : u, x = "border-color:" + w + ";font-size:" + h + ";color:" + w + ";font-weight:" + f + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  return x += "position:" + ((v || l) && g ? "fixed;" : "absolute;"), (v || l || !g) && (x += (n === Wi ? Nw : Bw) + ":" + (o + parseFloat(d)) + "px;"), a && (x += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), m._isStart = y, m.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), m.style.cssText = x, m.innerText = t || t === 0 ? e + "-" + t : e, _.children[0] ? _.insertBefore(m, _.children[0]) : _.appendChild(m), m._offset = m["offset" + n.op.d2], Dv(m, 0, n, y), m;
}, Dv = function(e, t, i, n) {
  var r = {
    display: "block"
  }, o = i[n ? "os2" : "p2"], a = i[n ? "p2" : "os2"];
  e._isFlipped = n, r[i.a + "Percent"] = n ? -100 : 0, r[i.a] = n ? "1px" : 0, r["border" + o + ad] = 1, r["border" + a + ad] = 0, r[i.p] = t + "px", Dt.set(e, r);
}, ln = [], d1 = {}, Up, JE = function() {
  return Rr() - no > 34 && (Up || (Up = requestAnimationFrame(Ta)));
}, qu = function() {
  (!Vr || !Vr.isPressed || Vr.startX > Fn.clientWidth) && (fn.cache++, Vr ? Up || (Up = requestAnimationFrame(Ta)) : Ta(), no || du("scrollStart"), no = Rr());
}, Jy = function() {
  VR = dn.innerWidth, zR = dn.innerHeight;
}, kf = function(e) {
  fn.cache++, (e === !0 || !Ar && !BR && !Qn.fullscreenElement && !Qn.webkitFullscreenElement && (!c1 || VR !== dn.innerWidth || Math.abs(dn.innerHeight - zR) > dn.innerHeight * 0.25)) && o0.restart(!0);
}, hu = {}, JB = [], ZR = function s() {
  return nr(pn, "scrollEnd", s) || Fc(!0);
}, du = function(e) {
  return hu[e] && hu[e].map(function(t) {
    return t();
  }) || JB;
}, xs = [], KR = function(e) {
  for (var t = 0; t < xs.length; t += 5)
    (!e || xs[t + 4] && xs[t + 4].query === e) && (xs[t].style.cssText = xs[t + 1], xs[t].getBBox && xs[t].setAttribute("transform", xs[t + 2] || ""), xs[t + 3].uncache = 1);
}, Gw = function(e, t) {
  var i;
  for (Gr = 0; Gr < ln.length; Gr++)
    i = ln[Gr], i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
  a0 = !0, t && KR(t), t || du("revert");
}, $R = function(e, t) {
  fn.cache++, (t || !Hr) && fn.forEach(function(i) {
    return Lr(i) && i.cacheID++ && (i.rec = 0);
  }), bs(e) && (dn.history.scrollRestoration = Ow = e);
}, Hr, $c = 0, QE, QB = function() {
  if (QE !== $c) {
    var e = QE = $c;
    requestAnimationFrame(function() {
      return e === $c && Fc(!0);
    });
  }
}, JR = function() {
  Fn.appendChild(Yh), Fw = !Vr && Yh.offsetHeight || dn.innerHeight, Fn.removeChild(Yh);
}, eT = function(e) {
  return Lp(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
    return t.style.display = e ? "none" : "block";
  });
}, Fc = function(e, t) {
  if (Ss = Qn.documentElement, Fn = Qn.body, kw = [dn, Qn, Ss, Fn], no && !e && !a0) {
    ir(pn, "scrollEnd", ZR);
    return;
  }
  JR(), Hr = pn.isRefreshing = !0, fn.forEach(function(n) {
    return Lr(n) && ++n.cacheID && (n.rec = n());
  });
  var i = du("refreshInit");
  NR && pn.sort(), t || Gw(), fn.forEach(function(n) {
    Lr(n) && (n.smooth && (n.target.style.scrollBehavior = "auto"), n(0));
  }), ln.slice(0).forEach(function(n) {
    return n.refresh();
  }), a0 = !1, ln.forEach(function(n) {
    if (n._subPinOffset && n.pin) {
      var r = n.vars.horizontal ? "offsetWidth" : "offsetHeight", o = n.pin[r];
      n.revert(!0, 1), n.adjustPinSpacing(n.pin[r] - o), n.refresh();
    }
  }), h1 = 1, eT(!0), ln.forEach(function(n) {
    var r = Go(n.scroller, n._dir), o = n.vars.end === "max" || n._endClamp && n.end > r, a = n._startClamp && n.start >= r;
    (o || a) && n.setPositions(a ? r - 1 : n.start, o ? Math.max(a ? r : n.start + 1, r) : n.end, !0);
  }), eT(!1), h1 = 0, i.forEach(function(n) {
    return n && n.render && n.render(-1);
  }), fn.forEach(function(n) {
    Lr(n) && (n.smooth && requestAnimationFrame(function() {
      return n.target.style.scrollBehavior = "smooth";
    }), n.rec && n(n.rec));
  }), $R(Ow, 1), o0.pause(), $c++, Hr = 2, Ta(2), ln.forEach(function(n) {
    return Lr(n.vars.onRefresh) && n.vars.onRefresh(n);
  }), Hr = pn.isRefreshing = !1, du("refresh");
}, f1 = 0, Iv = 1, ip, Ta = function(e) {
  if (e === 2 || !Hr && !a0) {
    pn.isUpdating = !0, ip && ip.update(0);
    var t = ln.length, i = Rr(), n = i - Ky >= 50, r = t && ln[0].scroll();
    if (Iv = f1 > r ? -1 : 1, Hr || (f1 = r), n && (no && !f_ && i - no > 200 && (no = 0, du("scrollEnd")), Df = Ky, Ky = i), Iv < 0) {
      for (Gr = t; Gr-- > 0; )
        ln[Gr] && ln[Gr].update(0, n);
      Iv = 1;
    } else
      for (Gr = 0; Gr < t; Gr++)
        ln[Gr] && ln[Gr].update(0, n);
    pn.isUpdating = !1;
  }
  Up = 0;
}, p1 = [YR, jR, Bw, Nw, Zs + np, Zs + Qf, Zs + tp, Zs + ep, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], Lv = p1.concat([Zc, Kc, "boxSizing", "max" + ad, "max" + zw, "position", Zs, Ii, Ii + tp, Ii + Qf, Ii + np, Ii + ep]), ez = function(e, t, i) {
  jh(i);
  var n = e._gsap;
  if (n.spacerIsNative)
    jh(n.spacerState);
  else if (e._gsap.swappedIn) {
    var r = t.parentNode;
    r && (r.insertBefore(e, t), r.removeChild(t));
  }
  e._gsap.swappedIn = !1;
}, Qy = function(e, t, i, n) {
  if (!e._gsap.swappedIn) {
    for (var r = p1.length, o = t.style, a = e.style, l; r--; )
      l = p1[r], o[l] = i[l];
    o.position = i.position === "absolute" ? "absolute" : "relative", i.display === "inline" && (o.display = "inline-block"), a[Bw] = a[Nw] = "auto", o.flexBasis = i.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[Zc] = l0(e, jr) + Hi, o[Kc] = l0(e, Wi) + Hi, o[Ii] = a[Zs] = a[jR] = a[YR] = "0", jh(n), a[Zc] = a["max" + ad] = i[Zc], a[Kc] = a["max" + zw] = i[Kc], a[Ii] = i[Ii], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0;
  }
}, tz = /([A-Z])/g, jh = function(e) {
  if (e) {
    var t = e.t.style, i = e.length, n = 0, r, o;
    for ((e.t._gsap || Dt.core.getCache(e.t)).uncache = 1; n < i; n += 2)
      o = e[n + 1], r = e[n], o ? t[r] = o : t[r] && t.removeProperty(r.replace(tz, "-$1").toLowerCase());
  }
}, jm = function(e) {
  for (var t = Lv.length, i = e.style, n = [], r = 0; r < t; r++)
    n.push(Lv[r], i[Lv[r]]);
  return n.t = e, n;
}, nz = function(e, t, i) {
  for (var n = [], r = e.length, o = i ? 8 : 0, a; o < r; o += 2)
    a = e[o], n.push(a, a in t ? t[a] : e[o + 1]);
  return n.t = e.t, n;
}, Uv = {
  left: 0,
  top: 0
}, tT = function(e, t, i, n, r, o, a, l, c, u, h, d, f, m) {
  Lr(e) && (e = e(l)), bs(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? Rv("0" + e.substr(3), i) : 0));
  var g = f ? f.time() : 0, v, _, y;
  if (f && f.seek(0), isNaN(e) || (e = +e), Uf(e))
    f && (e = Dt.utils.mapRange(f.scrollTrigger.start, f.scrollTrigger.end, 0, d, e)), a && Dv(a, i, n, !0);
  else {
    Lr(t) && (t = t(l));
    var w = (e || "0").split(" "), x, M, A, E;
    y = rs(t, l) || Fn, x = xa(y) || {}, (!x || !x.left && !x.top) && Ks(y).display === "none" && (E = y.style.display, y.style.display = "block", x = xa(y), E ? y.style.display = E : y.style.removeProperty("display")), M = Rv(w[0], x[n.d]), A = Rv(w[1] || "0", i), e = x[n.p] - c[n.p] - u + M + r - A, a && Dv(a, A, n, i - A < 20 || a._isStart && A > 20), i -= i - A;
  }
  if (m && (l[m] = e || -1e-3, e < 0 && (e = 0)), o) {
    var C = e + i, P = o._isStart;
    v = "scroll" + n.d2, Dv(o, C, n, P && C > 20 || !P && (h ? Math.max(Fn[v], Ss[v]) : o.parentNode[v]) <= C + 1), h && (c = xa(a), h && (o.style[n.op.p] = c[n.op.p] - n.op.m - o._offset + Hi));
  }
  return f && y && (v = xa(y), f.seek(d), _ = xa(y), f._caScrollDist = v[n.p] - _[n.p], e = e / f._caScrollDist * d), f && f.seek(g), f ? e : Math.round(e);
}, iz = /(webkit|moz|length|cssText|inset)/i, nT = function(e, t, i, n) {
  if (e.parentNode !== t) {
    var r = e.style, o, a;
    if (t === Fn) {
      e._stOrig = r.cssText, a = Ks(e);
      for (o in a)
        !+o && !iz.test(o) && a[o] && typeof r[o] == "string" && o !== "0" && (r[o] = a[o]);
      r.top = i, r.left = n;
    } else
      r.cssText = e._stOrig;
    Dt.core.getCache(e).uncache = 1, t.appendChild(e);
  }
}, QR = function(e, t, i) {
  var n = t, r = n;
  return function(o) {
    var a = Math.round(e());
    return a !== n && a !== r && Math.abs(a - n) > 3 && Math.abs(a - r) > 3 && (o = a, i && i()), r = n, n = Math.round(o), n;
  };
}, qm = function(e, t, i) {
  var n = {};
  n[t.p] = "+=" + i, Dt.set(e, n);
}, iT = function(e, t) {
  var i = Dl(e, t), n = "_scroll" + t.p2, r = function o(a, l, c, u, h) {
    var d = o.tween, f = l.onComplete, m = {};
    c = c || i();
    var g = QR(i, c, function() {
      d.kill(), o.tween = 0;
    });
    return h = u && h || 0, u = u || a - c, d && d.kill(), l[n] = a, l.inherit = !1, l.modifiers = m, m[n] = function() {
      return g(c + u * d.ratio + h * d.ratio * d.ratio);
    }, l.onUpdate = function() {
      fn.cache++, o.tween && Ta();
    }, l.onComplete = function() {
      o.tween = 0, f && f.call(d);
    }, d = o.tween = Dt.to(e, l), d;
  };
  return e[n] = i, i.wheelHandler = function() {
    return r.tween && r.tween.kill() && (r.tween = 0);
  }, ir(e, "wheel", i.wheelHandler), pn.isTouch && ir(e, "touchmove", i.wheelHandler), r;
}, pn = /* @__PURE__ */ function() {
  function s(t, i) {
    Ch || s.register(Dt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), u1(this), this.init(t, i);
  }
  var e = s.prototype;
  return e.init = function(i, n) {
    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !If) {
      this.update = this.refresh = this.kill = ko;
      return;
    }
    i = KE(bs(i) || Uf(i) || i.nodeType ? {
      trigger: i
    } : i, Xm);
    var r = i, o = r.onUpdate, a = r.toggleClass, l = r.id, c = r.onToggle, u = r.onRefresh, h = r.scrub, d = r.trigger, f = r.pin, m = r.pinSpacing, g = r.invalidateOnRefresh, v = r.anticipatePin, _ = r.onScrubComplete, y = r.onSnapComplete, w = r.once, x = r.snap, M = r.pinReparent, A = r.pinSpacer, E = r.containerAnimation, C = r.fastScrollEnd, P = r.preventOverlaps, T = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? jr : Wi, I = !h && h !== 0, D = rs(i.scroller || dn), U = Dt.core.getCache(D), L = uu(D), k = ("pinType" in i ? i.pinType : Ml(D, "pinType") || L && "fixed") === "fixed", B = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack], j = I && i.toggleActions.split(" "), q = "markers" in i ? i.markers : Xm.markers, Z = L ? 0 : parseFloat(Ks(D)["border" + T.p2 + ad]) || 0, N = this, z = i.onRefreshInit && function() {
      return i.onRefreshInit(N);
    }, J = jB(D, L, T), se = qB(D, L), K = 0, Q = 0, de = 0, ce = Dl(D, T), _e, Fe, Ie, Ee, me, xe, $, Ue, Me, oe, Te, Ye, Oe, X, Y, fe, ue, te, Se, ye, Ae, Ce, Ge, De, Ve, ze, Ze, Le, ot, tt, mt, le, ve, be, Xe, We, Ne, ct, gt;
    if (N._startClamp = N._endClamp = !1, N._dir = T, v *= 45, N.scroller = D, N.scroll = E ? E.time.bind(E) : ce, Ee = ce(), N.vars = i, n = n || i.animation, "refreshPriority" in i && (NR = 1, i.refreshPriority === -9999 && (ip = N)), U.tweenScroll = U.tweenScroll || {
      top: iT(D, Wi),
      left: iT(D, jr)
    }, N.tweenTo = _e = U.tweenScroll[T.p], N.scrubDuration = function(Qe) {
      ve = Uf(Qe) && Qe, ve ? le ? le.duration(Qe) : le = Dt.to(n, {
        ease: "expo",
        totalProgress: "+=0",
        inherit: !1,
        duration: ve,
        paused: !0,
        onComplete: function() {
          return _ && _(N);
        }
      }) : (le && le.progress(1).kill(), le = 0);
    }, n && (n.vars.lazy = !1, n._initted && !N.isReverted || n.vars.immediateRender !== !1 && i.immediateRender !== !1 && n.duration() && n.render(0, !0, !0), N.animation = n.pause(), n.scrollTrigger = N, N.scrubDuration(h), tt = 0, l || (l = n.vars.id)), x && ((!Ec(x) || x.push) && (x = {
      snapTo: x
    }), "scrollBehavior" in Fn.style && Dt.set(L ? [Fn, Ss] : D, {
      scrollBehavior: "auto"
    }), fn.forEach(function(Qe) {
      return Lr(Qe) && Qe.target === (L ? Qn.scrollingElement || Ss : D) && (Qe.smooth = !1);
    }), Ie = Lr(x.snapTo) ? x.snapTo : x.snapTo === "labels" ? KB(n) : x.snapTo === "labelsDirectional" ? $B(n) : x.directional !== !1 ? function(Qe, xt) {
      return Vw(x.snapTo)(Qe, Rr() - Q < 500 ? 0 : xt.direction);
    } : Dt.utils.snap(x.snapTo), be = x.duration || {
      min: 0.1,
      max: 2
    }, be = Ec(be) ? Jf(be.min, be.max) : Jf(be, be), Xe = Dt.delayedCall(x.delay || ve / 2 || 0.1, function() {
      var Qe = ce(), xt = Rr() - Q < 500, yt = _e.tween;
      if ((xt || Math.abs(N.getVelocity()) < 10) && !yt && !f_ && K !== Qe) {
        var Mt = (Qe - xe) / X, nn = n && !I ? n.totalProgress() : Mt, zt = xt ? 0 : (nn - mt) / (Rr() - Df) * 1e3 || 0, $t = Dt.utils.clamp(-Mt, 1 - Mt, ju(zt / 2) * zt / 0.185), qt = Mt + (x.inertia === !1 ? 0 : $t), en, xn, on = x, zi = on.onStart, un = on.onInterrupt, An = on.onComplete;
        if (en = Ie(qt, N), Uf(en) || (en = qt), xn = Math.max(0, Math.round(xe + en * X)), Qe <= $ && Qe >= xe && xn !== Qe) {
          if (yt && !yt._initted && yt.data <= ju(xn - Qe))
            return;
          x.inertia === !1 && ($t = en - Mt), _e(xn, {
            duration: be(ju(Math.max(ju(qt - nn), ju(en - nn)) * 0.185 / zt / 0.05 || 0)),
            ease: x.ease || "power3",
            data: ju(xn - Qe),
            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
            onInterrupt: function() {
              return Xe.restart(!0) && un && un(N);
            },
            onComplete: function() {
              N.update(), K = ce(), n && !I && (le ? le.resetTo("totalProgress", en, n._tTime / n._tDur) : n.progress(en)), tt = mt = n && !I ? n.totalProgress() : N.progress, y && y(N), An && An(N);
            }
          }, Qe, $t * X, xn - Qe - $t * X), zi && zi(N, _e.tween);
        }
      } else N.isActive && K !== Qe && Xe.restart(!0);
    }).pause()), l && (d1[l] = N), d = N.trigger = rs(d || f !== !0 && f), gt = d && d._gsap && d._gsap.stRevert, gt && (gt = gt(N)), f = f === !0 ? d : rs(f), bs(a) && (a = {
      targets: d,
      className: a
    }), f && (m === !1 || m === Zs || (m = !m && f.parentNode && f.parentNode.style && Ks(f.parentNode).display === "flex" ? !1 : Ii), N.pin = f, Fe = Dt.core.getCache(f), Fe.spacer ? Y = Fe.pinState : (A && (A = rs(A), A && !A.nodeType && (A = A.current || A.nativeElement), Fe.spacerIsNative = !!A, A && (Fe.spacerState = jm(A))), Fe.spacer = te = A || Qn.createElement("div"), te.classList.add("pin-spacer"), l && te.classList.add("pin-spacer-" + l), Fe.pinState = Y = jm(f)), i.force3D !== !1 && Dt.set(f, {
      force3D: !0
    }), N.spacer = te = Fe.spacer, ot = Ks(f), De = ot[m + T.os2], ye = Dt.getProperty(f), Ae = Dt.quickSetter(f, T.a, Hi), Qy(f, te, ot), ue = jm(f)), q) {
      Ye = Ec(q) ? KE(q, $E) : $E, oe = Ym("scroller-start", l, D, T, Ye, 0), Te = Ym("scroller-end", l, D, T, Ye, 0, oe), Se = oe["offset" + T.op.d2];
      var nt = rs(Ml(D, "content") || D);
      Ue = this.markerStart = Ym("start", l, nt, T, Ye, Se, 0, E), Me = this.markerEnd = Ym("end", l, nt, T, Ye, Se, 0, E), E && (ct = Dt.quickSetter([Ue, Me], T.a, Hi)), !k && !(jo.length && Ml(D, "fixedMarkers") === !0) && (ZB(L ? Fn : D), Dt.set([oe, Te], {
        force3D: !0
      }), ze = Dt.quickSetter(oe, T.a, Hi), Le = Dt.quickSetter(Te, T.a, Hi));
    }
    if (E) {
      var je = E.vars.onUpdate, at = E.vars.onUpdateParams;
      E.eventCallback("onUpdate", function() {
        N.update(0, 0, 1), je && je.apply(E, at || []);
      });
    }
    if (N.previous = function() {
      return ln[ln.indexOf(N) - 1];
    }, N.next = function() {
      return ln[ln.indexOf(N) + 1];
    }, N.revert = function(Qe, xt) {
      if (!xt)
        return N.kill(!0);
      var yt = Qe !== !1 || !N.enabled, Mt = Ar;
      yt !== N.isReverted && (yt && (We = Math.max(ce(), N.scroll.rec || 0), de = N.progress, Ne = n && n.progress()), Ue && [Ue, Me, oe, Te].forEach(function(nn) {
        return nn.style.display = yt ? "none" : "block";
      }), yt && (Ar = N, N.update(yt)), f && (!M || !N.isActive) && (yt ? ez(f, te, Y) : Qy(f, te, Ks(f), Ve)), yt || N.update(yt), Ar = Mt, N.isReverted = yt);
    }, N.refresh = function(Qe, xt, yt, Mt) {
      if (!((Ar || !N.enabled) && !xt)) {
        if (f && Qe && no) {
          ir(s, "scrollEnd", ZR);
          return;
        }
        !Hr && z && z(N), Ar = N, _e.tween && !yt && (_e.tween.kill(), _e.tween = 0), le && le.pause(), g && n && n.revert({
          kill: !1
        }).invalidate(), N.isReverted || N.revert(!0, !0), N._subPinOffset = !1;
        var nn = J(), zt = se(), $t = E ? E.duration() : Go(D, T), qt = X <= 0.01, en = 0, xn = Mt || 0, on = Ec(yt) ? yt.end : i.end, zi = i.endTrigger || d, un = Ec(yt) ? yt.start : i.start || (i.start === 0 || !d ? 0 : f ? "0 0" : "0 100%"), An = N.pinnedContainer = i.pinnedContainer && rs(i.pinnedContainer, N), O = d && Math.max(0, ln.indexOf(N)) || 0, ee = O, he, F, ie, re, ne, ae, we, Pe, Re, He, qe, Ke, Je;
        for (q && Ec(yt) && (Ke = Dt.getProperty(oe, T.p), Je = Dt.getProperty(Te, T.p)); ee-- > 0; )
          ae = ln[ee], ae.end || ae.refresh(0, 1) || (Ar = N), we = ae.pin, we && (we === d || we === f || we === An) && !ae.isReverted && (He || (He = []), He.unshift(ae), ae.revert(!0, !0)), ae !== ln[ee] && (O--, ee--);
        for (Lr(un) && (un = un(N)), un = YE(un, "start", N), xe = tT(un, d, nn, T, ce(), Ue, oe, N, zt, Z, k, $t, E, N._startClamp && "_startClamp") || (f ? -1e-3 : 0), Lr(on) && (on = on(N)), bs(on) && !on.indexOf("+=") && (~on.indexOf(" ") ? on = (bs(un) ? un.split(" ")[0] : "") + on : (en = Rv(on.substr(2), nn), on = bs(un) ? un : (E ? Dt.utils.mapRange(0, E.duration(), E.scrollTrigger.start, E.scrollTrigger.end, xe) : xe) + en, zi = d)), on = YE(on, "end", N), $ = Math.max(xe, tT(on || (zi ? "100% 0" : $t), zi, nn, T, ce() + en, Me, Te, N, zt, Z, k, $t, E, N._endClamp && "_endClamp")) || -1e-3, en = 0, ee = O; ee--; )
          ae = ln[ee], we = ae.pin, we && ae.start - ae._pinPush <= xe && !E && ae.end > 0 && (he = ae.end - (N._startClamp ? Math.max(0, ae.start) : ae.start), (we === d && ae.start - ae._pinPush < xe || we === An) && isNaN(un) && (en += he * (1 - ae.progress)), we === f && (xn += he));
        if (xe += en, $ += en, N._startClamp && (N._startClamp += en), N._endClamp && !Hr && (N._endClamp = $ || -1e-3, $ = Math.min($, Go(D, T))), X = $ - xe || (xe -= 0.01) && 1e-3, qt && (de = Dt.utils.clamp(0, 1, Dt.utils.normalize(xe, $, We))), N._pinPush = xn, Ue && en && (he = {}, he[T.a] = "+=" + en, An && (he[T.p] = "-=" + ce()), Dt.set([Ue, Me], he)), f && !(h1 && N.end >= Go(D, T)))
          he = Ks(f), re = T === Wi, ie = ce(), Ce = parseFloat(ye(T.a)) + xn, !$t && $ > 1 && (qe = (L ? Qn.scrollingElement || Ss : D).style, qe = {
            style: qe,
            value: qe["overflow" + T.a.toUpperCase()]
          }, L && Ks(Fn)["overflow" + T.a.toUpperCase()] !== "scroll" && (qe.style["overflow" + T.a.toUpperCase()] = "scroll")), Qy(f, te, he), ue = jm(f), F = xa(f, !0), Pe = k && Dl(D, re ? jr : Wi)(), m ? (Ve = [m + T.os2, X + xn + Hi], Ve.t = te, ee = m === Ii ? l0(f, T) + X + xn : 0, ee && (Ve.push(T.d, ee + Hi), te.style.flexBasis !== "auto" && (te.style.flexBasis = ee + Hi)), jh(Ve), An && ln.forEach(function(et) {
            et.pin === An && et.vars.pinSpacing !== !1 && (et._subPinOffset = !0);
          }), k && ce(We)) : (ee = l0(f, T), ee && te.style.flexBasis !== "auto" && (te.style.flexBasis = ee + Hi)), k && (ne = {
            top: F.top + (re ? ie - xe : Pe) + Hi,
            left: F.left + (re ? Pe : ie - xe) + Hi,
            boxSizing: "border-box",
            position: "fixed"
          }, ne[Zc] = ne["max" + ad] = Math.ceil(F.width) + Hi, ne[Kc] = ne["max" + zw] = Math.ceil(F.height) + Hi, ne[Zs] = ne[Zs + tp] = ne[Zs + Qf] = ne[Zs + np] = ne[Zs + ep] = "0", ne[Ii] = he[Ii], ne[Ii + tp] = he[Ii + tp], ne[Ii + Qf] = he[Ii + Qf], ne[Ii + np] = he[Ii + np], ne[Ii + ep] = he[Ii + ep], fe = nz(Y, ne, M), Hr && ce(0)), n ? (Re = n._initted, qy(1), n.render(n.duration(), !0, !0), Ge = ye(T.a) - Ce + X + xn, Ze = Math.abs(X - Ge) > 1, k && Ze && fe.splice(fe.length - 2, 2), n.render(0, !0, !0), Re || n.invalidate(!0), n.parent || n.totalTime(n.totalTime()), qy(0)) : Ge = X, qe && (qe.value ? qe.style["overflow" + T.a.toUpperCase()] = qe.value : qe.style.removeProperty("overflow-" + T.a));
        else if (d && ce() && !E)
          for (F = d.parentNode; F && F !== Fn; )
            F._pinOffset && (xe -= F._pinOffset, $ -= F._pinOffset), F = F.parentNode;
        He && He.forEach(function(et) {
          return et.revert(!1, !0);
        }), N.start = xe, N.end = $, Ee = me = Hr ? We : ce(), !E && !Hr && (Ee < We && ce(We), N.scroll.rec = 0), N.revert(!1, !0), Q = Rr(), Xe && (K = -1, Xe.restart(!0)), Ar = 0, n && I && (n._initted || Ne) && n.progress() !== Ne && n.progress(Ne || 0, !0).render(n.time(), !0, !0), (qt || de !== N.progress || E || g || n && !n._initted) && (n && !I && n.totalProgress(E && xe < -1e-3 && !de ? Dt.utils.normalize(xe, $, 0) : de, !0), N.progress = qt || (Ee - xe) / X === de ? 0 : de), f && m && (te._pinOffset = Math.round(N.progress * Ge)), le && le.invalidate(), isNaN(Ke) || (Ke -= Dt.getProperty(oe, T.p), Je -= Dt.getProperty(Te, T.p), qm(oe, T, Ke), qm(Ue, T, Ke - (Mt || 0)), qm(Te, T, Je), qm(Me, T, Je - (Mt || 0))), qt && !Hr && N.update(), u && !Hr && !Oe && (Oe = !0, u(N), Oe = !1);
      }
    }, N.getVelocity = function() {
      return (ce() - me) / (Rr() - Df) * 1e3 || 0;
    }, N.endAnimation = function() {
      ef(N.callbackAnimation), n && (le ? le.progress(1) : n.paused() ? I || ef(n, N.direction < 0, 1) : ef(n, n.reversed()));
    }, N.labelToScroll = function(Qe) {
      return n && n.labels && (xe || N.refresh() || xe) + n.labels[Qe] / n.duration() * X || 0;
    }, N.getTrailing = function(Qe) {
      var xt = ln.indexOf(N), yt = N.direction > 0 ? ln.slice(0, xt).reverse() : ln.slice(xt + 1);
      return (bs(Qe) ? yt.filter(function(Mt) {
        return Mt.vars.preventOverlaps === Qe;
      }) : yt).filter(function(Mt) {
        return N.direction > 0 ? Mt.end <= xe : Mt.start >= $;
      });
    }, N.update = function(Qe, xt, yt) {
      if (!(E && !yt && !Qe)) {
        var Mt = Hr === !0 ? We : N.scroll(), nn = Qe ? 0 : (Mt - xe) / X, zt = nn < 0 ? 0 : nn > 1 ? 1 : nn || 0, $t = N.progress, qt, en, xn, on, zi, un, An, O;
        if (xt && (me = Ee, Ee = E ? ce() : Mt, x && (mt = tt, tt = n && !I ? n.totalProgress() : zt)), v && f && !Ar && !Vm && no && (!zt && xe < Mt + (Mt - me) / (Rr() - Df) * v ? zt = 1e-4 : zt === 1 && $ > Mt + (Mt - me) / (Rr() - Df) * v && (zt = 0.9999)), zt !== $t && N.enabled) {
          if (qt = N.isActive = !!zt && zt < 1, en = !!$t && $t < 1, un = qt !== en, zi = un || !!zt != !!$t, N.direction = zt > $t ? 1 : -1, N.progress = zt, zi && !Ar && (xn = zt && !$t ? 0 : zt === 1 ? 1 : $t === 1 ? 2 : 3, I && (on = !un && j[xn + 1] !== "none" && j[xn + 1] || j[xn], O = n && (on === "complete" || on === "reset" || on in n))), P && (un || O) && (O || h || !n) && (Lr(P) ? P(N) : N.getTrailing(P).forEach(function(ie) {
            return ie.endAnimation();
          })), I || (le && !Ar && !Vm ? (le._dp._time - le._start !== le._time && le.render(le._dp._time - le._start), le.resetTo ? le.resetTo("totalProgress", zt, n._tTime / n._tDur) : (le.vars.totalProgress = zt, le.invalidate().restart())) : n && n.totalProgress(zt, !!(Ar && (Q || Qe)))), f) {
            if (Qe && m && (te.style[m + T.os2] = De), !k)
              Ae(Lf(Ce + Ge * zt));
            else if (zi) {
              if (An = !Qe && zt > $t && $ + 1 > Mt && Mt + 1 >= Go(D, T), M)
                if (!Qe && (qt || An)) {
                  var ee = xa(f, !0), he = Mt - xe;
                  nT(f, Fn, ee.top + (T === Wi ? he : 0) + Hi, ee.left + (T === Wi ? 0 : he) + Hi);
                } else
                  nT(f, te);
              jh(qt || An ? fe : ue), Ze && zt < 1 && qt || Ae(Ce + (zt === 1 && !An ? Ge : 0));
            }
          }
          x && !_e.tween && !Ar && !Vm && Xe.restart(!0), a && (un || w && zt && (zt < 1 || !Zy)) && Lp(a.targets).forEach(function(ie) {
            return ie.classList[qt || w ? "add" : "remove"](a.className);
          }), o && !I && !Qe && o(N), zi && !Ar ? (I && (O && (on === "complete" ? n.pause().totalProgress(1) : on === "reset" ? n.restart(!0).pause() : on === "restart" ? n.restart(!0) : n[on]()), o && o(N)), (un || !Zy) && (c && un && $y(N, c), B[xn] && $y(N, B[xn]), w && (zt === 1 ? N.kill(!1, 1) : B[xn] = 0), un || (xn = zt === 1 ? 1 : 3, B[xn] && $y(N, B[xn]))), C && !qt && Math.abs(N.getVelocity()) > (Uf(C) ? C : 2500) && (ef(N.callbackAnimation), le ? le.progress(1) : ef(n, on === "reverse" ? 1 : !zt, 1))) : I && o && !Ar && o(N);
        }
        if (Le) {
          var F = E ? Mt / E.duration() * (E._caScrollDist || 0) : Mt;
          ze(F + (oe._isFlipped ? 1 : 0)), Le(F);
        }
        ct && ct(-Mt / E.duration() * (E._caScrollDist || 0));
      }
    }, N.enable = function(Qe, xt) {
      N.enabled || (N.enabled = !0, ir(D, "resize", kf), L || ir(D, "scroll", qu), z && ir(s, "refreshInit", z), Qe !== !1 && (N.progress = de = 0, Ee = me = K = ce()), xt !== !1 && N.refresh());
    }, N.getTween = function(Qe) {
      return Qe && _e ? _e.tween : le;
    }, N.setPositions = function(Qe, xt, yt, Mt) {
      if (E) {
        var nn = E.scrollTrigger, zt = E.duration(), $t = nn.end - nn.start;
        Qe = nn.start + $t * Qe / zt, xt = nn.start + $t * xt / zt;
      }
      N.refresh(!1, !1, {
        start: jE(Qe, yt && !!N._startClamp),
        end: jE(xt, yt && !!N._endClamp)
      }, Mt), N.update();
    }, N.adjustPinSpacing = function(Qe) {
      if (Ve && Qe) {
        var xt = Ve.indexOf(T.d) + 1;
        Ve[xt] = parseFloat(Ve[xt]) + Qe + Hi, Ve[1] = parseFloat(Ve[1]) + Qe + Hi, jh(Ve);
      }
    }, N.disable = function(Qe, xt) {
      if (N.enabled && (Qe !== !1 && N.revert(!0, !0), N.enabled = N.isActive = !1, xt || le && le.pause(), We = 0, Fe && (Fe.uncache = 1), z && nr(s, "refreshInit", z), Xe && (Xe.pause(), _e.tween && _e.tween.kill() && (_e.tween = 0)), !L)) {
        for (var yt = ln.length; yt--; )
          if (ln[yt].scroller === D && ln[yt] !== N)
            return;
        nr(D, "resize", kf), L || nr(D, "scroll", qu);
      }
    }, N.kill = function(Qe, xt) {
      N.disable(Qe, xt), le && !xt && le.kill(), l && delete d1[l];
      var yt = ln.indexOf(N);
      yt >= 0 && ln.splice(yt, 1), yt === Gr && Iv > 0 && Gr--, yt = 0, ln.forEach(function(Mt) {
        return Mt.scroller === N.scroller && (yt = 1);
      }), yt || Hr || (N.scroll.rec = 0), n && (n.scrollTrigger = null, Qe && n.revert({
        kill: !1
      }), xt || n.kill()), Ue && [Ue, Me, oe, Te].forEach(function(Mt) {
        return Mt.parentNode && Mt.parentNode.removeChild(Mt);
      }), ip === N && (ip = 0), f && (Fe && (Fe.uncache = 1), yt = 0, ln.forEach(function(Mt) {
        return Mt.pin === f && yt++;
      }), yt || (Fe.spacer = 0)), i.onKill && i.onKill(N);
    }, ln.push(N), N.enable(!1, !1), gt && gt(N), n && n.add && !X) {
      var ft = N.update;
      N.update = function() {
        N.update = ft, fn.cache++, xe || $ || N.refresh();
      }, Dt.delayedCall(0.01, N.update), X = 0.01, xe = $ = 0;
    } else
      N.refresh();
    f && QB();
  }, s.register = function(i) {
    return Ch || (Dt = i || HR(), GR() && window.document && s.enable(), Ch = If), Ch;
  }, s.defaults = function(i) {
    if (i)
      for (var n in i)
        Xm[n] = i[n];
    return Xm;
  }, s.disable = function(i, n) {
    If = 0, ln.forEach(function(o) {
      return o[n ? "kill" : "disable"](i);
    }), nr(dn, "wheel", qu), nr(Qn, "scroll", qu), clearInterval(zm), nr(Qn, "touchcancel", ko), nr(Fn, "touchstart", ko), Hm(nr, Qn, "pointerdown,touchstart,mousedown", qE), Hm(nr, Qn, "pointerup,touchend,mouseup", ZE), o0.kill(), Gm(nr);
    for (var r = 0; r < fn.length; r += 3)
      Wm(nr, fn[r], fn[r + 1]), Wm(nr, fn[r], fn[r + 2]);
  }, s.enable = function() {
    if (dn = window, Qn = document, Ss = Qn.documentElement, Fn = Qn.body, Dt && (Lp = Dt.utils.toArray, Jf = Dt.utils.clamp, u1 = Dt.core.context || ko, qy = Dt.core.suppressOverwrites || ko, Ow = dn.history.scrollRestoration || "auto", f1 = dn.pageYOffset || 0, Dt.core.globals("ScrollTrigger", s), Fn)) {
      If = 1, Yh = document.createElement("div"), Yh.style.height = "100vh", Yh.style.position = "absolute", JR(), YB(), Ci.register(Dt), s.isTouch = Ci.isTouch, al = Ci.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), c1 = Ci.isTouch === 1, ir(dn, "wheel", qu), kw = [dn, Qn, Ss, Fn], Dt.matchMedia ? (s.matchMedia = function(c) {
        var u = Dt.matchMedia(), h;
        for (h in c)
          u.add(h, c[h]);
        return u;
      }, Dt.addEventListener("matchMediaInit", function() {
        return Gw();
      }), Dt.addEventListener("matchMediaRevert", function() {
        return KR();
      }), Dt.addEventListener("matchMedia", function() {
        Fc(0, 1), du("matchMedia");
      }), Dt.matchMedia().add("(orientation: portrait)", function() {
        return Jy(), Jy;
      })) : console.warn("Requires GSAP 3.11.0 or later"), Jy(), ir(Qn, "scroll", qu);
      var i = Fn.hasAttribute("style"), n = Fn.style, r = n.borderTopStyle, o = Dt.core.Animation.prototype, a, l;
      for (o.revert || Object.defineProperty(o, "revert", {
        value: function() {
          return this.time(-0.01, !0);
        }
      }), n.borderTopStyle = "solid", a = xa(Fn), Wi.m = Math.round(a.top + Wi.sc()) || 0, jr.m = Math.round(a.left + jr.sc()) || 0, r ? n.borderTopStyle = r : n.removeProperty("border-top-style"), i || (Fn.setAttribute("style", ""), Fn.removeAttribute("style")), zm = setInterval(JE, 250), Dt.delayedCall(0.5, function() {
        return Vm = 0;
      }), ir(Qn, "touchcancel", ko), ir(Fn, "touchstart", ko), Hm(ir, Qn, "pointerdown,touchstart,mousedown", qE), Hm(ir, Qn, "pointerup,touchend,mouseup", ZE), l1 = Dt.utils.checkPrefix("transform"), Lv.push(l1), Ch = Rr(), o0 = Dt.delayedCall(0.2, Fc).pause(), Ph = [Qn, "visibilitychange", function() {
        var c = dn.innerWidth, u = dn.innerHeight;
        Qn.hidden ? (WE = c, XE = u) : (WE !== c || XE !== u) && kf();
      }, Qn, "DOMContentLoaded", Fc, dn, "load", Fc, dn, "resize", kf], Gm(ir), ln.forEach(function(c) {
        return c.enable(0, 1);
      }), l = 0; l < fn.length; l += 3)
        Wm(nr, fn[l], fn[l + 1]), Wm(nr, fn[l], fn[l + 2]);
    }
  }, s.config = function(i) {
    "limitCallbacks" in i && (Zy = !!i.limitCallbacks);
    var n = i.syncInterval;
    n && clearInterval(zm) || (zm = n) && setInterval(JE, n), "ignoreMobileResize" in i && (c1 = s.isTouch === 1 && i.ignoreMobileResize), "autoRefreshEvents" in i && (Gm(nr) || Gm(ir, i.autoRefreshEvents || "none"), BR = (i.autoRefreshEvents + "").indexOf("resize") === -1);
  }, s.scrollerProxy = function(i, n) {
    var r = rs(i), o = fn.indexOf(r), a = uu(r);
    ~o && fn.splice(o, a ? 6 : 2), n && (a ? jo.unshift(dn, n, Fn, n, Ss, n) : jo.unshift(r, n));
  }, s.clearMatchMedia = function(i) {
    ln.forEach(function(n) {
      return n._ctx && n._ctx.query === i && n._ctx.kill(!0, !0);
    });
  }, s.isInViewport = function(i, n, r) {
    var o = (bs(i) ? rs(i) : i).getBoundingClientRect(), a = o[r ? Zc : Kc] * n || 0;
    return r ? o.right - a > 0 && o.left + a < dn.innerWidth : o.bottom - a > 0 && o.top + a < dn.innerHeight;
  }, s.positionInViewport = function(i, n, r) {
    bs(i) && (i = rs(i));
    var o = i.getBoundingClientRect(), a = o[r ? Zc : Kc], l = n == null ? a / 2 : n in c0 ? c0[n] * a : ~n.indexOf("%") ? parseFloat(n) * a / 100 : parseFloat(n) || 0;
    return r ? (o.left + l) / dn.innerWidth : (o.top + l) / dn.innerHeight;
  }, s.killAll = function(i) {
    if (ln.slice(0).forEach(function(r) {
      return r.vars.id !== "ScrollSmoother" && r.kill();
    }), i !== !0) {
      var n = hu.killAll || [];
      hu = {}, n.forEach(function(r) {
        return r();
      });
    }
  }, s;
}();
pn.version = "3.12.7";
pn.saveStyles = function(s) {
  return s ? Lp(s).forEach(function(e) {
    if (e && e.style) {
      var t = xs.indexOf(e);
      t >= 0 && xs.splice(t, 5), xs.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Dt.core.getCache(e), u1());
    }
  }) : xs;
};
pn.revert = function(s, e) {
  return Gw(!s, e);
};
pn.create = function(s, e) {
  return new pn(s, e);
};
pn.refresh = function(s) {
  return s ? kf(!0) : (Ch || pn.register()) && Fc(!0);
};
pn.update = function(s) {
  return ++fn.cache && Ta(s === !0 ? 2 : 0);
};
pn.clearScrollMemory = $R;
pn.maxScroll = function(s, e) {
  return Go(s, e ? jr : Wi);
};
pn.getScrollFunc = function(s, e) {
  return Dl(rs(s), e ? jr : Wi);
};
pn.getById = function(s) {
  return d1[s];
};
pn.getAll = function() {
  return ln.filter(function(s) {
    return s.vars.id !== "ScrollSmoother";
  });
};
pn.isScrolling = function() {
  return !!no;
};
pn.snapDirectional = Vw;
pn.addEventListener = function(s, e) {
  var t = hu[s] || (hu[s] = []);
  ~t.indexOf(e) || t.push(e);
};
pn.removeEventListener = function(s, e) {
  var t = hu[s], i = t && t.indexOf(e);
  i >= 0 && t.splice(i, 1);
};
pn.batch = function(s, e) {
  var t = [], i = {}, n = e.interval || 0.016, r = e.batchMax || 1e9, o = function(c, u) {
    var h = [], d = [], f = Dt.delayedCall(n, function() {
      u(h, d), h = [], d = [];
    }).pause();
    return function(m) {
      h.length || f.restart(!0), h.push(m.trigger), d.push(m), r <= h.length && f.progress(1);
    };
  }, a;
  for (a in e)
    i[a] = a.substr(0, 2) === "on" && Lr(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
  return Lr(r) && (r = r(), ir(pn, "refresh", function() {
    return r = e.batchMax();
  })), Lp(s).forEach(function(l) {
    var c = {};
    for (a in i)
      c[a] = i[a];
    c.trigger = l, t.push(pn.create(c));
  }), t;
};
var rT = function(e, t, i, n) {
  return t > n ? e(n) : t < 0 && e(0), i > n ? (n - t) / (i - t) : i < 0 ? t / (t - i) : 1;
}, ex = function s(e, t) {
  t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Ci.isTouch ? " pinch-zoom" : "") : "none", e === Ss && s(Fn, t);
}, Zm = {
  auto: 1,
  scroll: 1
}, rz = function(e) {
  var t = e.event, i = e.target, n = e.axis, r = (t.changedTouches ? t.changedTouches[0] : t).target, o = r._gsap || Dt.core.getCache(r), a = Rr(), l;
  if (!o._isScrollT || a - o._isScrollT > 2e3) {
    for (; r && r !== Fn && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !(Zm[(l = Ks(r)).overflowY] || Zm[l.overflowX])); )
      r = r.parentNode;
    o._isScroll = r && r !== i && !uu(r) && (Zm[(l = Ks(r)).overflowY] || Zm[l.overflowX]), o._isScrollT = a;
  }
  (o._isScroll || n === "x") && (t.stopPropagation(), t._gsapAllow = !0);
}, eD = function(e, t, i, n) {
  return Ci.create({
    target: e,
    capture: !0,
    debounce: !1,
    lockAxis: !0,
    type: t,
    onWheel: n = n && rz,
    onPress: n,
    onDrag: n,
    onScroll: n,
    onEnable: function() {
      return i && ir(Qn, Ci.eventTypes[0], oT, !1, !0);
    },
    onDisable: function() {
      return nr(Qn, Ci.eventTypes[0], oT, !0);
    }
  });
}, sz = /(input|label|select|textarea)/i, sT, oT = function(e) {
  var t = sz.test(e.target.tagName);
  (t || sT) && (e._gsapAllow = !0, sT = t);
}, oz = function(e) {
  Ec(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
  var t = e, i = t.normalizeScrollX, n = t.momentum, r = t.allowNestedScroll, o = t.onRelease, a, l, c = rs(e.target) || Ss, u = Dt.core.globals().ScrollSmoother, h = u && u.get(), d = al && (e.content && rs(e.content) || h && e.content !== !1 && !h.smooth() && h.content()), f = Dl(c, Wi), m = Dl(c, jr), g = 1, v = (Ci.isTouch && dn.visualViewport ? dn.visualViewport.scale * dn.visualViewport.width : dn.outerWidth) / dn.innerWidth, _ = 0, y = Lr(n) ? function() {
    return n(a);
  } : function() {
    return n || 2.8;
  }, w, x, M = eD(c, e.type, !0, r), A = function() {
    return x = !1;
  }, E = ko, C = ko, P = function() {
    l = Go(c, Wi), C = Jf(al ? 1 : 0, l), i && (E = Jf(0, Go(c, jr))), w = $c;
  }, T = function() {
    d._gsap.y = Lf(parseFloat(d._gsap.y) + f.offset) + "px", d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)", f.offset = f.cacheID = 0;
  }, I = function() {
    if (x) {
      requestAnimationFrame(A);
      var q = Lf(a.deltaY / 2), Z = C(f.v - q);
      if (d && Z !== f.v + f.offset) {
        f.offset = Z - f.v;
        var N = Lf((parseFloat(d && d._gsap.y) || 0) - f.offset);
        d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + N + ", 0, 1)", d._gsap.y = N + "px", f.cacheID = fn.cache, Ta();
      }
      return !0;
    }
    f.offset && T(), x = !0;
  }, D, U, L, k, B = function() {
    P(), D.isActive() && D.vars.scrollY > l && (f() > l ? D.progress(1) && f(l) : D.resetTo("scrollY", l));
  };
  return d && Dt.set(d, {
    y: "+=0"
  }), e.ignoreCheck = function(j) {
    return al && j.type === "touchmove" && I() || g > 1.05 && j.type !== "touchstart" || a.isGesturing || j.touches && j.touches.length > 1;
  }, e.onPress = function() {
    x = !1;
    var j = g;
    g = Lf((dn.visualViewport && dn.visualViewport.scale || 1) / v), D.pause(), j !== g && ex(c, g > 1.01 ? !0 : i ? !1 : "x"), U = m(), L = f(), P(), w = $c;
  }, e.onRelease = e.onGestureStart = function(j, q) {
    if (f.offset && T(), !q)
      k.restart(!0);
    else {
      fn.cache++;
      var Z = y(), N, z;
      i && (N = m(), z = N + Z * 0.05 * -j.velocityX / 0.227, Z *= rT(m, N, z, Go(c, jr)), D.vars.scrollX = E(z)), N = f(), z = N + Z * 0.05 * -j.velocityY / 0.227, Z *= rT(f, N, z, Go(c, Wi)), D.vars.scrollY = C(z), D.invalidate().duration(Z).play(0.01), (al && D.vars.scrollY >= l || N >= l - 1) && Dt.to({}, {
        onUpdate: B,
        duration: Z
      });
    }
    o && o(j);
  }, e.onWheel = function() {
    D._ts && D.pause(), Rr() - _ > 1e3 && (w = 0, _ = Rr());
  }, e.onChange = function(j, q, Z, N, z) {
    if ($c !== w && P(), q && i && m(E(N[2] === q ? U + (j.startX - j.x) : m() + q - N[1])), Z) {
      f.offset && T();
      var J = z[2] === Z, se = J ? L + j.startY - j.y : f() + Z - z[1], K = C(se);
      J && se !== K && (L += K - se), f(K);
    }
    (Z || q) && Ta();
  }, e.onEnable = function() {
    ex(c, i ? !1 : "x"), pn.addEventListener("refresh", B), ir(dn, "resize", B), f.smooth && (f.target.style.scrollBehavior = "auto", f.smooth = m.smooth = !1), M.enable();
  }, e.onDisable = function() {
    ex(c, !0), nr(dn, "resize", B), pn.removeEventListener("refresh", B), M.kill();
  }, e.lockAxis = e.lockAxis !== !1, a = new Ci(e), a.iOS = al, al && !f() && f(1), al && Dt.ticker.add(ko), k = a._dc, D = Dt.to(a, {
    ease: "power4",
    paused: !0,
    inherit: !1,
    scrollX: i ? "+=0.1" : "+=0",
    scrollY: "+=0.1",
    modifiers: {
      scrollY: QR(f, f(), function() {
        return D.pause();
      })
    },
    onUpdate: Ta,
    onComplete: k.vars.onComplete
  }), a;
};
pn.sort = function(s) {
  if (Lr(s))
    return ln.sort(s);
  var e = dn.pageYOffset || 0;
  return pn.getAll().forEach(function(t) {
    return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + dn.innerHeight;
  }), ln.sort(s || function(t, i) {
    return (t.vars.refreshPriority || 0) * -1e6 + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((i.vars.containerAnimation ? 1e6 : i._sortY) + (i.vars.refreshPriority || 0) * -1e6);
  });
};
pn.observe = function(s) {
  return new Ci(s);
};
pn.normalizeScroll = function(s) {
  if (typeof s > "u")
    return Vr;
  if (s === !0 && Vr)
    return Vr.enable();
  if (s === !1) {
    Vr && Vr.kill(), Vr = s;
    return;
  }
  var e = s instanceof Ci ? s : oz(s);
  return Vr && Vr.target === e.target && Vr.kill(), uu(e.target) && (Vr = e), e;
};
pn.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: a1,
  _inputObserver: eD,
  _scrollers: fn,
  _proxies: jo,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function() {
      no || du("scrollStart"), no = Rr();
    },
    // a way to get the _refreshing value in Observer
    ref: function() {
      return Ar;
    }
  }
};
HR() && Dt.registerPlugin(pn);
var az = /* @__PURE__ */ ni("<!> <!> <!> <!>", 1);
function tD(s, e) {
  if (new.target) return Rt({ component: tD, ...s });
  Ct(e, !1);
  let t = Xf(!1);
  function i(a) {
    Promise.all([
      document.fonts.ready,
      new Promise((l) => {
        document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => l()) : l();
      })
    ]).then(() => {
      requestAnimationFrame(() => {
        a();
      });
    });
  }
  So(() => {
    Vo.registerPlugin(pn), i(() => {
      console.log("Webflow Custom Animations Loaded v6"), In(t, !0);
    });
  }), Au();
  var n = At(), r = dt(n);
  {
    var o = (a) => {
      var l = az(), c = dt(l);
      Dw(c, {});
      var u = Wn(c, 2);
      Iw(u, {});
      var h = Wn(u, 2);
      Lw(h, {});
      var d = Wn(h, 2);
      Uw(d, {}), ut(a, l);
    };
    Ai(r, (a) => {
      pe(t) && a(o);
    });
  }
  return ut(s, n), RF(e, "whenDomIsReady", i), Pt({
    whenDomIsReady: i,
    $set: Lt,
    $on: (a, l) => It(e, a, l)
  });
}
customElements.define("florag-webflow-animations", Ut(tD, {}, [], ["whenDomIsReady"], !0));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const yd = "174", Is = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Nc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, nD = 0, m1 = 1, iD = 2, lz = 3, cz = 0, Hw = 1, rp = 2, Lo = 3, Fs = 0, Yi = 1, wi = 2, Aa = 0, Jc = 1, kp = 2, g1 = 3, v1 = 4, rD = 5, hl = 100, sD = 101, oD = 102, aD = 103, lD = 104, cD = 200, uD = 201, hD = 202, dD = 203, u0 = 204, h0 = 205, fD = 206, pD = 207, mD = 208, gD = 209, vD = 210, _D = 211, yD = 212, xD = 213, bD = 214, d0 = 0, f0 = 1, p0 = 2, fu = 3, m0 = 4, g0 = 5, v0 = 6, _0 = 7, sm = 0, wD = 1, SD = 2, qo = 0, MD = 1, ED = 2, TD = 3, AD = 4, CD = 5, y0 = 6, PD = 7, _1 = "attached", RD = "detached", p_ = 300, Ia = 301, Il = 302, ld = 303, Op = 304, xd = 306, Ns = 1e3, gr = 1001, cd = 1002, Tn = 1003, m_ = 1004, uz = 1004, Bc = 1005, hz = 1005, Sn = 1006, qh = 1007, dz = 1007, As = 1008, fz = 1008, ro = 1009, Fp = 1010, g_ = 1011, pu = 1012, Qc = 1013, hs = 1014, Un = 1015, vr = 1016, v_ = 1017, __ = 1018, mu = 1020, Ww = 35902, Xw = 1021, Yw = 1022, di = 1023, jw = 1024, qw = 1025, eu = 1026, gu = 1027, bd = 1028, wd = 1029, y_ = 1030, Sd = 1031, pz = 1032, vu = 1033, sp = 33776, op = 33777, ap = 33778, lp = 33779, x0 = 35840, b0 = 35841, w0 = 35842, S0 = 35843, M0 = 36196, E0 = 37492, T0 = 37496, A0 = 37808, C0 = 37809, P0 = 37810, R0 = 37811, D0 = 37812, I0 = 37813, L0 = 37814, U0 = 37815, k0 = 37816, O0 = 37817, F0 = 37818, N0 = 37819, B0 = 37820, z0 = 37821, cp = 36492, V0 = 36494, G0 = 36495, Zw = 36283, H0 = 36284, W0 = 36285, X0 = 36286, DD = 2200, ID = 2201, LD = 2202, ud = 2300, hd = 2301, kv = 2302, zc = 2400, Vc = 2401, Np = 2402, x_ = 2500, Kw = 2501, UD = 0, $w = 1, Y0 = 2, kD = 3200, Md = 3201, mz = 3202, gz = 3203, kl = 0, OD = 1, Fo = "", Oi = "srgb", Pi = "srgb-linear", Bp = "linear", Vn = "srgb", vz = 0, Tc = 7680, Ov = 7681, _z = 7682, yz = 7683, xz = 34055, bz = 34056, wz = 5386, Sz = 512, Mz = 513, Ez = 514, Tz = 515, Az = 516, Cz = 517, Pz = 518, j0 = 519, FD = 512, ND = 513, BD = 514, Jw = 515, zD = 516, VD = 517, GD = 518, HD = 519, zp = 35044, Zh = 35048, Rz = 35040, Dz = 35045, Iz = 35049, Lz = 35041, Uz = 35046, kz = 35050, Oz = 35042, Fz = "100", y1 = "300 es", _o = 2e3, Vp = 2001, Nz = {
  COMPUTE: "compute",
  RENDER: "render"
};
class Qo {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(e, t) {
    const i = this._listeners;
    return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(e, t) {
    const i = this._listeners;
    if (i === void 0) return;
    const n = i[e];
    if (n !== void 0) {
      const r = n.indexOf(t);
      r !== -1 && n.splice(r, 1);
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const i = t[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let r = 0, o = n.length; r < o; r++)
        n[r].call(this, e);
      e.target = null;
    }
  }
}
const Mr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let aT = 1234567;
const tu = Math.PI / 180, dd = 180 / Math.PI;
function Ls() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Mr[s & 255] + Mr[s >> 8 & 255] + Mr[s >> 16 & 255] + Mr[s >> 24 & 255] + "-" + Mr[e & 255] + Mr[e >> 8 & 255] + "-" + Mr[e >> 16 & 15 | 64] + Mr[e >> 24 & 255] + "-" + Mr[t & 63 | 128] + Mr[t >> 8 & 255] + "-" + Mr[t >> 16 & 255] + Mr[t >> 24 & 255] + Mr[i & 255] + Mr[i >> 8 & 255] + Mr[i >> 16 & 255] + Mr[i >> 24 & 255]).toLowerCase();
}
function Qt(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function Qw(s, e) {
  return (s % e + e) % e;
}
function Bz(s, e, t, i, n) {
  return i + (s - e) * (n - i) / (t - e);
}
function zz(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function up(s, e, t) {
  return (1 - t) * s + t * e;
}
function Vz(s, e, t, i) {
  return up(s, e, 1 - Math.exp(-t * i));
}
function Gz(s, e = 1) {
  return e - Math.abs(Qw(s, e * 2) - e);
}
function Hz(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
}
function Wz(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function Xz(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function Yz(s, e) {
  return s + Math.random() * (e - s);
}
function jz(s) {
  return s * (0.5 - Math.random());
}
function qz(s) {
  s !== void 0 && (aT = s);
  let e = aT += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function Zz(s) {
  return s * tu;
}
function Kz(s) {
  return s * dd;
}
function $z(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function Jz(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Qz(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function e4(s, e, t, i, n) {
  const r = Math.cos, o = Math.sin, a = r(t / 2), l = o(t / 2), c = r((e + i) / 2), u = o((e + i) / 2), h = r((e - i) / 2), d = o((e - i) / 2), f = r((i - e) / 2), m = o((i - e) / 2);
  switch (n) {
    case "XYX":
      s.set(a * u, l * h, l * d, a * c);
      break;
    case "YZY":
      s.set(l * d, a * u, l * h, a * c);
      break;
    case "ZXZ":
      s.set(l * h, l * d, a * u, a * c);
      break;
    case "XZX":
      s.set(a * u, l * m, l * f, a * c);
      break;
    case "YXY":
      s.set(l * f, a * u, l * m, a * c);
      break;
    case "ZYZ":
      s.set(l * m, l * f, a * u, a * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
  }
}
function qr(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function rn(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Kr = {
  DEG2RAD: tu,
  RAD2DEG: dd,
  generateUUID: Ls,
  clamp: Qt,
  euclideanModulo: Qw,
  mapLinear: Bz,
  inverseLerp: zz,
  lerp: up,
  damp: Vz,
  pingpong: Gz,
  smoothstep: Hz,
  smootherstep: Wz,
  randInt: Xz,
  randFloat: Yz,
  randFloatSpread: jz,
  seededRandom: qz,
  degToRad: Zz,
  radToDeg: Kz,
  isPowerOfTwo: $z,
  ceilPowerOfTwo: Jz,
  floorPowerOfTwo: Qz,
  setQuaternionFromProperEuler: e4,
  normalize: rn,
  denormalize: qr
};
class Be {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(e = 0, t = 0) {
    Be.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Qt(this.x, e.x, t.x), this.y = Qt(this.y, e.y, t.y), this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Qt(this.x, e, t), this.y = Qt(this.y, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Qt(i, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Qt(i, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, o = this.y - e.y;
    return this.x = r * i - o * n + e.x, this.y = r * n + o * i + e.y, this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Jt {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(e, t, i, n, r, o, a, l, c) {
    Jt.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, n, r, o, a, l, c);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(e, t, i, n, r, o, a, l, c) {
    const u = this.elements;
    return u[0] = e, u[1] = n, u[2] = a, u[3] = t, u[4] = r, u[5] = l, u[6] = i, u[7] = o, u[8] = c, this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, o = i[0], a = i[3], l = i[6], c = i[1], u = i[4], h = i[7], d = i[2], f = i[5], m = i[8], g = n[0], v = n[3], _ = n[6], y = n[1], w = n[4], x = n[7], M = n[2], A = n[5], E = n[8];
    return r[0] = o * g + a * y + l * M, r[3] = o * v + a * w + l * A, r[6] = o * _ + a * x + l * E, r[1] = c * g + u * y + h * M, r[4] = c * v + u * w + h * A, r[7] = c * _ + u * x + h * E, r[2] = d * g + f * y + m * M, r[5] = d * v + f * w + m * A, r[8] = d * _ + f * x + m * E, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], u = e[8];
    return t * o * u - t * a * c - i * r * u + i * a * l + n * r * c - n * o * l;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = u * o - a * c, d = a * l - u * r, f = c * r - o * l, m = t * h + i * d + n * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / m;
    return e[0] = h * g, e[1] = (n * c - u * i) * g, e[2] = (a * i - n * o) * g, e[3] = d * g, e[4] = (u * t - n * l) * g, e[5] = (n * r - a * t) * g, e[6] = f * g, e[7] = (i * l - c * t) * g, e[8] = (o * t - i * r) * g, this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(e, t, i, n, r, o, a) {
    const l = Math.cos(r), c = Math.sin(r);
    return this.set(
      i * l,
      i * c,
      -i * (l * o + c * a) + o + e,
      -n * c,
      n * l,
      -n * (-c * o + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(e, t) {
    return this.premultiply(tx.makeScale(e, t)), this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(e) {
    return this.premultiply(tx.makeRotation(-e)), this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(e, t) {
    return this.premultiply(tx.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      i,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const tx = /* @__PURE__ */ new Jt();
function WD(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
const t4 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Lh(s, e) {
  return new t4[s](e);
}
function Gp(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function XD() {
  const s = Gp("canvas");
  return s.style.display = "block", s;
}
const lT = {};
function Ac(s) {
  s in lT || (lT[s] = !0, console.warn(s));
}
function n4(s, e, t) {
  return new Promise(function(i, n) {
    function r() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          n();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(r, t);
          break;
        default:
          i();
      }
    }
    setTimeout(r, t);
  });
}
function i4(s) {
  const e = s.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function r4(s) {
  const e = s.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const cT = /* @__PURE__ */ new Jt().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), uT = /* @__PURE__ */ new Jt().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function s4() {
  const s = {
    enabled: !0,
    workingColorSpace: Pi,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(n, r, o) {
      return this.enabled === !1 || r === o || !r || !o || (this.spaces[r].transfer === Vn && (n.r = Ca(n.r), n.g = Ca(n.g), n.b = Ca(n.b)), this.spaces[r].primaries !== this.spaces[o].primaries && (n.applyMatrix3(this.spaces[r].toXYZ), n.applyMatrix3(this.spaces[o].fromXYZ)), this.spaces[o].transfer === Vn && (n.r = Kh(n.r), n.g = Kh(n.g), n.b = Kh(n.b))), n;
    },
    fromWorkingColorSpace: function(n, r) {
      return this.convert(n, this.workingColorSpace, r);
    },
    toWorkingColorSpace: function(n, r) {
      return this.convert(n, r, this.workingColorSpace);
    },
    getPrimaries: function(n) {
      return this.spaces[n].primaries;
    },
    getTransfer: function(n) {
      return n === Fo ? Bp : this.spaces[n].transfer;
    },
    getLuminanceCoefficients: function(n, r = this.workingColorSpace) {
      return n.fromArray(this.spaces[r].luminanceCoefficients);
    },
    define: function(n) {
      Object.assign(this.spaces, n);
    },
    // Internal APIs
    _getMatrix: function(n, r, o) {
      return n.copy(this.spaces[r].toXYZ).multiply(this.spaces[o].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(n) {
      return this.spaces[n].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(n = this.workingColorSpace) {
      return this.spaces[n].workingColorSpaceConfig.unpackColorSpace;
    }
  }, e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], t = [0.2126, 0.7152, 0.0722], i = [0.3127, 0.329];
  return s.define({
    [Pi]: {
      primaries: e,
      whitePoint: i,
      transfer: Bp,
      toXYZ: cT,
      fromXYZ: uT,
      luminanceCoefficients: t,
      workingColorSpaceConfig: { unpackColorSpace: Oi },
      outputColorSpaceConfig: { drawingBufferColorSpace: Oi }
    },
    [Oi]: {
      primaries: e,
      whitePoint: i,
      transfer: Vn,
      toXYZ: cT,
      fromXYZ: uT,
      luminanceCoefficients: t,
      outputColorSpaceConfig: { drawingBufferColorSpace: Oi }
    }
  }), s;
}
const vn = /* @__PURE__ */ s4();
function Ca(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function Kh(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let Zu;
class YD {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @return {string} The data URI.
   */
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Zu === void 0 && (Zu = Gp("canvas")), Zu.width = e.width, Zu.height = e.height;
      const i = Zu.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Zu;
    }
    return t.toDataURL("image/png");
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Gp("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const n = i.getImageData(0, 0, e.width, e.height), r = n.data;
      for (let o = 0; o < r.length; o++)
        r[o] = Ca(r[o] / 255) * 255;
      return i.putImageData(n, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Ca(t[i] / 255) * 255) : t[i] = Ca(t[i]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let o4 = 0;
class yl {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: o4++ }), this.uuid = Ls(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, n = this.data;
    if (n !== null) {
      let r;
      if (Array.isArray(n)) {
        r = [];
        for (let o = 0, a = n.length; o < a; o++)
          n[o].isDataTexture ? r.push(nx(n[o].image)) : r.push(nx(n[o]));
      } else
        r = nx(n);
      i.url = r;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function nx(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? YD.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let a4 = 0;
class ei extends Qo {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The min filter value.
   * @param {number} [type=UnsignedByteType] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The min filter value.
   * @param {string} [colorSpace=NoColorSpace] - The min filter value.
   */
  constructor(e = ei.DEFAULT_IMAGE, t = ei.DEFAULT_MAPPING, i = gr, n = gr, r = Sn, o = As, a = di, l = ro, c = ei.DEFAULT_ANISOTROPY, u = Fo) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: a4++ }), this.uuid = Ls(), this.name = "", this.source = new yl(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Be(0, 0), this.repeat = new Be(1, 1), this.center = new Be(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Jt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(e) {
    if (this.mapping !== p_) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Ns:
          e.x = e.x - Math.floor(e.x);
          break;
        case gr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case cd:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Ns:
          e.y = e.y - Math.floor(e.y);
          break;
        case gr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case cd:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
ei.DEFAULT_IMAGE = null;
ei.DEFAULT_MAPPING = p_;
ei.DEFAULT_ANISOTROPY = 1;
class Kt {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(e = 0, t = 0, i = 0, n = 1) {
    Kt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = n;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(e, t, i, n) {
    return this.x = e, this.y = t, this.z = i, this.w = n, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(e) {
    return this.w = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * t + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * t + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * t + o[7] * i + o[11] * n + o[15] * r, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(e) {
    let t, i, n, r;
    const l = e.elements, c = l[0], u = l[4], h = l[8], d = l[1], f = l[5], m = l[9], g = l[2], v = l[6], _ = l[10];
    if (Math.abs(u - d) < 0.01 && Math.abs(h - g) < 0.01 && Math.abs(m - v) < 0.01) {
      if (Math.abs(u + d) < 0.1 && Math.abs(h + g) < 0.1 && Math.abs(m + v) < 0.1 && Math.abs(c + f + _ - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const w = (c + 1) / 2, x = (f + 1) / 2, M = (_ + 1) / 2, A = (u + d) / 4, E = (h + g) / 4, C = (m + v) / 4;
      return w > x && w > M ? w < 0.01 ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(w), n = A / i, r = E / i) : x > M ? x < 0.01 ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(x), i = A / n, r = C / n) : M < 0.01 ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(M), i = E / r, n = C / r), this.set(i, n, r, t), this;
    }
    let y = Math.sqrt((v - m) * (v - m) + (h - g) * (h - g) + (d - u) * (d - u));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (v - m) / y, this.y = (h - g) / y, this.z = (d - u) / y, this.w = Math.acos((c + f + _ - 1) / 2), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Qt(this.x, e.x, t.x), this.y = Qt(this.y, e.y, t.y), this.z = Qt(this.z, e.z, t.z), this.w = Qt(this.w, e.w, t.w), this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Qt(this.x, e, t), this.y = Qt(this.y, e, t), this.z = Qt(this.z, e, t), this.w = Qt(this.w, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Qt(i, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class b_ extends Qo {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Kt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Kt(0, 0, e, t);
    const n = { width: e, height: t, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Sn,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const r = new ei(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    r.flipY = !1, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
    const o = i.count;
    for (let a = 0; a < o; a++)
      this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = !0, this.textures[a].renderTarget = this;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let n = 0, r = this.textures.length; n < r; n++)
        this.textures[n].image.width = e, this.textures[n].image.height = t, this.textures[n].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let t = 0, i = e.textures.length; t < i; t++) {
      this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
      const n = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new yl(n);
    }
    return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Bs extends b_ {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), this.isWebGLRenderTarget = !0;
  }
}
class om extends ei {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = Tn, this.minFilter = Tn, this.wrapR = gr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class l4 extends Bs {
  constructor(e = 1, t = 1, i = 1, n = {}) {
    super(e, t, n), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new om(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class w_ extends ei {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = Tn, this.minFilter = Tn, this.wrapR = gr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class c4 extends Bs {
  constructor(e = 1, t = 1, i = 1, n = {}) {
    super(e, t, n), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new w_(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class En {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(e = 0, t = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = n;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed  in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(e, t, i, n, r, o, a) {
    let l = i[n + 0], c = i[n + 1], u = i[n + 2], h = i[n + 3];
    const d = r[o + 0], f = r[o + 1], m = r[o + 2], g = r[o + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
      return;
    }
    if (a === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = m, e[t + 3] = g;
      return;
    }
    if (h !== g || l !== d || c !== f || u !== m) {
      let v = 1 - a;
      const _ = l * d + c * f + u * m + h * g, y = _ >= 0 ? 1 : -1, w = 1 - _ * _;
      if (w > Number.EPSILON) {
        const M = Math.sqrt(w), A = Math.atan2(M, _ * y);
        v = Math.sin(v * A) / M, a = Math.sin(a * A) / M;
      }
      const x = a * y;
      if (l = l * v + d * x, c = c * v + f * x, u = u * v + m * x, h = h * v + g * x, v === 1 - a) {
        const M = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        l *= M, c *= M, u *= M, h *= M;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(e, t, i, n, r, o) {
    const a = i[n], l = i[n + 1], c = i[n + 2], u = i[n + 3], h = r[o], d = r[o + 1], f = r[o + 2], m = r[o + 3];
    return e[t] = a * m + u * h + l * f - c * d, e[t + 1] = l * m + u * d + c * h - a * f, e[t + 2] = c * m + u * f + a * d - l * h, e[t + 3] = u * m - a * h - l * d - c * f, e;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(e, t, i, n) {
    return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(e, t = !0) {
    const i = e._x, n = e._y, r = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(i / 2), u = a(n / 2), h = a(r / 2), d = l(i / 2), f = l(n / 2), m = l(r / 2);
    switch (o) {
      case "XYZ":
        this._x = d * u * h + c * f * m, this._y = c * f * h - d * u * m, this._z = c * u * m + d * f * h, this._w = c * u * h - d * f * m;
        break;
      case "YXZ":
        this._x = d * u * h + c * f * m, this._y = c * f * h - d * u * m, this._z = c * u * m - d * f * h, this._w = c * u * h + d * f * m;
        break;
      case "ZXY":
        this._x = d * u * h - c * f * m, this._y = c * f * h + d * u * m, this._z = c * u * m + d * f * h, this._w = c * u * h - d * f * m;
        break;
      case "ZYX":
        this._x = d * u * h - c * f * m, this._y = c * f * h + d * u * m, this._z = c * u * m - d * f * h, this._w = c * u * h + d * f * m;
        break;
      case "YZX":
        this._x = d * u * h + c * f * m, this._y = c * f * h + d * u * m, this._z = c * u * m - d * f * h, this._w = c * u * h - d * f * m;
        break;
      case "XZY":
        this._x = d * u * h - c * f * m, this._y = c * f * h - d * u * m, this._z = c * u * m + d * f * h, this._w = c * u * h + d * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(e, t) {
    const i = t / 2, n = Math.sin(i);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], n = t[4], r = t[8], o = t[1], a = t[5], l = t[9], c = t[2], u = t[6], h = t[10], d = i + a + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (u - l) * f, this._y = (r - c) * f, this._z = (o - n) * f;
    } else if (i > a && i > h) {
      const f = 2 * Math.sqrt(1 + i - a - h);
      this._w = (u - l) / f, this._x = 0.25 * f, this._y = (n + o) / f, this._z = (r + c) / f;
    } else if (a > h) {
      const f = 2 * Math.sqrt(1 + a - i - h);
      this._w = (r - c) / f, this._x = (n + o) / f, this._y = 0.25 * f, this._z = (l + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - i - a);
      this._w = (o - n) / f, this._x = (r + c) / f, this._y = (l + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Qt(this.dot(e), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const n = Math.min(1, t / i);
    return this.slerp(e, n), this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(e, t) {
    const i = e._x, n = e._y, r = e._z, o = e._w, a = t._x, l = t._y, c = t._z, u = t._w;
    return this._x = i * u + o * a + n * c - r * l, this._y = n * u + o * l + r * a - i * c, this._z = r * u + o * c + i * l - n * a, this._w = o * u - i * a - n * l - r * c, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x, n = this._y, r = this._z, o = this._w;
    let a = o * e._w + i * e._x + n * e._y + r * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
      return this._w = o, this._x = i, this._y = n, this._z = r, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * o + t * this._w, this._x = f * i + t * this._x, this._y = f * n + t * this._y, this._z = f * r + t * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(l), u = Math.atan2(c, a), h = Math.sin((1 - t) * u) / c, d = Math.sin(t * u) / c;
    return this._w = o * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = r * h + this._z * d, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), r = Math.sqrt(i);
    return this.set(
      n * Math.sin(e),
      n * Math.cos(e),
      r * Math.sin(t),
      r * Math.cos(t)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class H {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(e = 0, t = 0, i = 0) {
    H.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(e) {
    return this.applyQuaternion(hT.setFromEuler(e));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(e, t) {
    return this.applyQuaternion(hT.setFromAxisAngle(e, t));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements, o = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
    return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * o, this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(e) {
    const t = this.x, i = this.y, n = this.z, r = e.x, o = e.y, a = e.z, l = e.w, c = 2 * (o * n - a * i), u = 2 * (a * t - r * n), h = 2 * (r * i - o * t);
    return this.x = t + l * c + o * h - a * u, this.y = i + l * u + a * c - r * h, this.z = n + l * h + r * u - o * c, this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Qt(this.x, e.x, t.x), this.y = Qt(this.y, e.y, t.y), this.z = Qt(this.z, e.z, t.z), this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Qt(this.x, e, t), this.y = Qt(this.y, e, t), this.z = Qt(this.z, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Qt(i, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(e) {
    return this.crossVectors(this, e);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(e, t) {
    const i = e.x, n = e.y, r = e.z, o = t.x, a = t.y, l = t.z;
    return this.x = n * l - r * a, this.y = r * o - i * l, this.z = i * a - n * o, this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(e) {
    return ix.copy(this).projectOnVector(e), this.sub(ix);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(e) {
    return this.sub(ix.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Qt(i, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(e, t, i) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = n, this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, i = Math.sqrt(1 - t * t);
    return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const ix = /* @__PURE__ */ new H(), hT = /* @__PURE__ */ new En();
class yn {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new H(1 / 0, 1 / 0, 1 / 0), t = new H(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(lo.fromArray(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(lo.fromBufferAttribute(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(e, t) {
    const i = lo.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const r = i.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = r.count; o < a; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, lo) : lo.fromBufferAttribute(r, o), lo.applyMatrix4(e.matrixWorld), this.expandByPoint(lo);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Km.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Km.copy(i.boundingBox)), Km.applyMatrix4(e.matrixWorld), this.union(Km);
    }
    const n = e.children;
    for (let r = 0, o = n.length; r < o; r++)
      this.expandByObject(n[r], t);
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(e) {
    return this.clampPoint(e.center, lo), lo.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(tf), $m.subVectors(this.max, tf), Ku.subVectors(e.a, tf), $u.subVectors(e.b, tf), Ju.subVectors(e.c, tf), qa.subVectors($u, Ku), Za.subVectors(Ju, $u), tc.subVectors(Ku, Ju);
    let t = [
      0,
      -qa.z,
      qa.y,
      0,
      -Za.z,
      Za.y,
      0,
      -tc.z,
      tc.y,
      qa.z,
      0,
      -qa.x,
      Za.z,
      0,
      -Za.x,
      tc.z,
      0,
      -tc.x,
      -qa.y,
      qa.x,
      0,
      -Za.y,
      Za.x,
      0,
      -tc.y,
      tc.x,
      0
    ];
    return !rx(t, Ku, $u, Ju, $m) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !rx(t, Ku, $u, Ju, $m)) ? !1 : (Jm.crossVectors(qa, Za), t = [Jm.x, Jm.y, Jm.z], rx(t, Ku, $u, Ju, $m));
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, lo).distanceTo(e);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(lo).length() * 0.5), e;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(e) {
    return this.isEmpty() ? this : (aa[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), aa[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), aa[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), aa[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), aa[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), aa[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), aa[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), aa[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(aa), this);
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const aa = [
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H()
], lo = /* @__PURE__ */ new H(), Km = /* @__PURE__ */ new yn(), Ku = /* @__PURE__ */ new H(), $u = /* @__PURE__ */ new H(), Ju = /* @__PURE__ */ new H(), qa = /* @__PURE__ */ new H(), Za = /* @__PURE__ */ new H(), tc = /* @__PURE__ */ new H(), tf = /* @__PURE__ */ new H(), $m = /* @__PURE__ */ new H(), Jm = /* @__PURE__ */ new H(), nc = /* @__PURE__ */ new H();
function rx(s, e, t, i, n) {
  for (let r = 0, o = s.length - 3; r <= o; r += 3) {
    nc.fromArray(s, r);
    const a = n.x * Math.abs(nc.x) + n.y * Math.abs(nc.y) + n.z * Math.abs(nc.z), l = e.dot(nc), c = t.dot(nc), u = i.dot(nc);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
      return !1;
  }
  return !0;
}
const u4 = /* @__PURE__ */ new yn(), nf = /* @__PURE__ */ new H(), sx = /* @__PURE__ */ new H();
class fi {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(e = new H(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : u4.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let r = 0, o = e.length; r < o; r++)
      n = Math.max(n, i.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(n), this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(e) {
    return this.center.add(e), this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    nf.subVectors(e, this.center);
    const t = nf.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(nf, n / i), this.radius += n;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (sx.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(nf.copy(e.center).add(sx)), this.expandByPoint(nf.copy(e.center).sub(sx))), this);
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const la = /* @__PURE__ */ new H(), ox = /* @__PURE__ */ new H(), Qm = /* @__PURE__ */ new H(), Ka = /* @__PURE__ */ new H(), ax = /* @__PURE__ */ new H(), eg = /* @__PURE__ */ new H(), lx = /* @__PURE__ */ new H();
class Ol {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(e = new H(), t = new H(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(e) {
    return this.origin.copy(this.at(e, la)), this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(e) {
    const t = la.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (la.copy(this.origin).addScaledVector(this.direction, t), la.distanceToSquared(e));
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(e, t, i, n) {
    ox.copy(e).add(t).multiplyScalar(0.5), Qm.copy(t).sub(e).normalize(), Ka.copy(this.origin).sub(ox);
    const r = e.distanceTo(t) * 0.5, o = -this.direction.dot(Qm), a = Ka.dot(this.direction), l = -Ka.dot(Qm), c = Ka.lengthSq(), u = Math.abs(1 - o * o);
    let h, d, f, m;
    if (u > 0)
      if (h = o * l - a, d = o * a - l, m = r * u, h >= 0)
        if (d >= -m)
          if (d <= m) {
            const g = 1 / u;
            h *= g, d *= g, f = h * (h + o * d + 2 * a) + d * (o * h + d + 2 * l) + c;
          } else
            d = r, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + c;
        else
          d = -r, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + c;
      else
        d <= -m ? (h = Math.max(0, -(-o * r + a)), d = h > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -h * h + d * (d + 2 * l) + c) : d <= m ? (h = 0, d = Math.min(Math.max(-r, -l), r), f = d * (d + 2 * l) + c) : (h = Math.max(0, -(o * r + a)), d = h > 0 ? r : Math.min(Math.max(-r, -l), r), f = -h * h + d * (d + 2 * l) + c);
    else
      d = o > 0 ? -r : r, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + c;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(ox).addScaledVector(Qm, d), f;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(e, t) {
    la.subVectors(e.center, this.origin);
    const i = la.dot(this.direction), n = la.dot(la) - i * i, r = e.radius * e.radius;
    if (n > r) return null;
    const o = Math.sqrt(r - n), a = i - o, l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(e, t) {
    let i, n, r, o, a, l;
    const c = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (i = (e.min.x - d.x) * c, n = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c, n = (e.min.x - d.x) * c), u >= 0 ? (r = (e.min.y - d.y) * u, o = (e.max.y - d.y) * u) : (r = (e.max.y - d.y) * u, o = (e.min.y - d.y) * u), i > o || r > n || ((r > i || isNaN(i)) && (i = r), (o < n || isNaN(n)) && (n = o), h >= 0 ? (a = (e.min.z - d.z) * h, l = (e.max.z - d.z) * h) : (a = (e.max.z - d.z) * h, l = (e.min.z - d.z) * h), i > l || a > n) || ((a > i || i !== i) && (i = a), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, t);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(e) {
    return this.intersectBox(e, la) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(e, t, i, n, r) {
    ax.subVectors(t, e), eg.subVectors(i, e), lx.crossVectors(ax, eg);
    let o = this.direction.dot(lx), a;
    if (o > 0) {
      if (n) return null;
      a = 1;
    } else if (o < 0)
      a = -1, o = -o;
    else
      return null;
    Ka.subVectors(this.origin, e);
    const l = a * this.direction.dot(eg.crossVectors(Ka, eg));
    if (l < 0)
      return null;
    const c = a * this.direction.dot(ax.cross(Ka));
    if (c < 0 || l + c > o)
      return null;
    const u = -a * Ka.dot(lx);
    return u < 0 ? null : this.at(u / o, r);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class _t {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(e, t, i, n, r, o, a, l, c, u, h, d, f, m, g, v) {
    _t.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, n, r, o, a, l, c, u, h, d, f, m, g, v);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(e, t, i, n, r, o, a, l, c, u, h, d, f, m, g, v) {
    const _ = this.elements;
    return _[0] = e, _[4] = t, _[8] = i, _[12] = n, _[1] = r, _[5] = o, _[9] = a, _[13] = l, _[2] = c, _[6] = u, _[10] = h, _[14] = d, _[3] = f, _[7] = m, _[11] = g, _[15] = v, this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new _t().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(e) {
    const t = this.elements, i = e.elements, n = 1 / Qu.setFromMatrixColumn(e, 0).length(), r = 1 / Qu.setFromMatrixColumn(e, 1).length(), o = 1 / Qu.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, n = e.y, r = e.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(n), c = Math.sin(n), u = Math.cos(r), h = Math.sin(r);
    if (e.order === "XYZ") {
      const d = o * u, f = o * h, m = a * u, g = a * h;
      t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = f + m * c, t[5] = d - g * c, t[9] = -a * l, t[2] = g - d * c, t[6] = m + f * c, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const d = l * u, f = l * h, m = c * u, g = c * h;
      t[0] = d + g * a, t[4] = m * a - f, t[8] = o * c, t[1] = o * h, t[5] = o * u, t[9] = -a, t[2] = f * a - m, t[6] = g + d * a, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const d = l * u, f = l * h, m = c * u, g = c * h;
      t[0] = d - g * a, t[4] = -o * h, t[8] = m + f * a, t[1] = f + m * a, t[5] = o * u, t[9] = g - d * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const d = o * u, f = o * h, m = a * u, g = a * h;
      t[0] = l * u, t[4] = m * c - f, t[8] = d * c + g, t[1] = l * h, t[5] = g * c + d, t[9] = f * c - m, t[2] = -c, t[6] = a * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const d = o * l, f = o * c, m = a * l, g = a * c;
      t[0] = l * u, t[4] = g - d * h, t[8] = m * h + f, t[1] = h, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = f * h + m, t[10] = d - g * h;
    } else if (e.order === "XZY") {
      const d = o * l, f = o * c, m = a * l, g = a * c;
      t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = d * h + g, t[5] = o * u, t[9] = f * h - m, t[2] = m * h - f, t[6] = a * u, t[10] = g * h + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(e) {
    return this.compose(h4, e, d4);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(e, t, i) {
    const n = this.elements;
    return vs.subVectors(e, t), vs.lengthSq() === 0 && (vs.z = 1), vs.normalize(), $a.crossVectors(i, vs), $a.lengthSq() === 0 && (Math.abs(i.z) === 1 ? vs.x += 1e-4 : vs.z += 1e-4, vs.normalize(), $a.crossVectors(i, vs)), $a.normalize(), tg.crossVectors(vs, $a), n[0] = $a.x, n[4] = tg.x, n[8] = vs.x, n[1] = $a.y, n[5] = tg.y, n[9] = vs.y, n[2] = $a.z, n[6] = tg.z, n[10] = vs.z, this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, o = i[0], a = i[4], l = i[8], c = i[12], u = i[1], h = i[5], d = i[9], f = i[13], m = i[2], g = i[6], v = i[10], _ = i[14], y = i[3], w = i[7], x = i[11], M = i[15], A = n[0], E = n[4], C = n[8], P = n[12], T = n[1], I = n[5], D = n[9], U = n[13], L = n[2], k = n[6], B = n[10], j = n[14], q = n[3], Z = n[7], N = n[11], z = n[15];
    return r[0] = o * A + a * T + l * L + c * q, r[4] = o * E + a * I + l * k + c * Z, r[8] = o * C + a * D + l * B + c * N, r[12] = o * P + a * U + l * j + c * z, r[1] = u * A + h * T + d * L + f * q, r[5] = u * E + h * I + d * k + f * Z, r[9] = u * C + h * D + d * B + f * N, r[13] = u * P + h * U + d * j + f * z, r[2] = m * A + g * T + v * L + _ * q, r[6] = m * E + g * I + v * k + _ * Z, r[10] = m * C + g * D + v * B + _ * N, r[14] = m * P + g * U + v * j + _ * z, r[3] = y * A + w * T + x * L + M * q, r[7] = y * E + w * I + x * k + M * Z, r[11] = y * C + w * D + x * B + M * N, r[15] = y * P + w * U + x * j + M * z, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], o = e[1], a = e[5], l = e[9], c = e[13], u = e[2], h = e[6], d = e[10], f = e[14], m = e[3], g = e[7], v = e[11], _ = e[15];
    return m * (+r * l * h - n * c * h - r * a * d + i * c * d + n * a * f - i * l * f) + g * (+t * l * f - t * c * d + r * o * d - n * o * f + n * c * u - r * l * u) + v * (+t * c * h - t * a * f - r * o * h + i * o * f + r * a * u - i * c * u) + _ * (-n * a * u - t * l * h + t * a * d + n * o * h - i * o * d + i * l * u);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(e, t, i) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = e[9], d = e[10], f = e[11], m = e[12], g = e[13], v = e[14], _ = e[15], y = h * v * c - g * d * c + g * l * f - a * v * f - h * l * _ + a * d * _, w = m * d * c - u * v * c - m * l * f + o * v * f + u * l * _ - o * d * _, x = u * g * c - m * h * c + m * a * f - o * g * f - u * a * _ + o * h * _, M = m * h * l - u * g * l - m * a * d + o * g * d + u * a * v - o * h * v, A = t * y + i * w + n * x + r * M;
    if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / A;
    return e[0] = y * E, e[1] = (g * d * r - h * v * r - g * n * f + i * v * f + h * n * _ - i * d * _) * E, e[2] = (a * v * r - g * l * r + g * n * c - i * v * c - a * n * _ + i * l * _) * E, e[3] = (h * l * r - a * d * r - h * n * c + i * d * c + a * n * f - i * l * f) * E, e[4] = w * E, e[5] = (u * v * r - m * d * r + m * n * f - t * v * f - u * n * _ + t * d * _) * E, e[6] = (m * l * r - o * v * r - m * n * c + t * v * c + o * n * _ - t * l * _) * E, e[7] = (o * d * r - u * l * r + u * n * c - t * d * c - o * n * f + t * l * f) * E, e[8] = x * E, e[9] = (m * h * r - u * g * r - m * i * f + t * g * f + u * i * _ - t * h * _) * E, e[10] = (o * g * r - m * a * r + m * i * c - t * g * c - o * i * _ + t * a * _) * E, e[11] = (u * a * r - o * h * r - u * i * c + t * h * c + o * i * f - t * a * f) * E, e[12] = M * E, e[13] = (u * g * n - m * h * n + m * i * d - t * g * d - u * i * v + t * h * v) * E, e[14] = (m * a * n - o * g * n - m * i * l + t * g * l + o * i * v - t * a * v) * E, e[15] = (o * h * n - u * a * n + u * i * l - t * h * l - o * i * d + t * a * d) * E, this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(e) {
    const t = this.elements, i = e.x, n = e.y, r = e.z;
    return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(e, t, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = 1 - i, o = e.x, a = e.y, l = e.z, c = r * o, u = r * a;
    return this.set(
      c * o + i,
      c * a - n * l,
      c * l + n * a,
      0,
      c * a + n * l,
      u * a + i,
      u * l - n * o,
      0,
      c * l - n * a,
      u * l + n * o,
      r * l * l + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(e, t, i, n, r, o) {
    return this.set(
      1,
      i,
      r,
      0,
      e,
      1,
      o,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(e, t, i) {
    const n = this.elements, r = t._x, o = t._y, a = t._z, l = t._w, c = r + r, u = o + o, h = a + a, d = r * c, f = r * u, m = r * h, g = o * u, v = o * h, _ = a * h, y = l * c, w = l * u, x = l * h, M = i.x, A = i.y, E = i.z;
    return n[0] = (1 - (g + _)) * M, n[1] = (f + x) * M, n[2] = (m - w) * M, n[3] = 0, n[4] = (f - x) * A, n[5] = (1 - (d + _)) * A, n[6] = (v + y) * A, n[7] = 0, n[8] = (m + w) * E, n[9] = (v - y) * E, n[10] = (1 - (d + g)) * E, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(e, t, i) {
    const n = this.elements;
    let r = Qu.set(n[0], n[1], n[2]).length();
    const o = Qu.set(n[4], n[5], n[6]).length(), a = Qu.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], co.copy(this);
    const c = 1 / r, u = 1 / o, h = 1 / a;
    return co.elements[0] *= c, co.elements[1] *= c, co.elements[2] *= c, co.elements[4] *= u, co.elements[5] *= u, co.elements[6] *= u, co.elements[8] *= h, co.elements[9] *= h, co.elements[10] *= h, t.setFromRotationMatrix(co), i.x = r, i.y = o, i.z = a, this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(e, t, i, n, r, o, a = _o) {
    const l = this.elements, c = 2 * r / (t - e), u = 2 * r / (i - n), h = (t + e) / (t - e), d = (i + n) / (i - n);
    let f, m;
    if (a === _o)
      f = -(o + r) / (o - r), m = -2 * o * r / (o - r);
    else if (a === Vp)
      f = -o / (o - r), m = -o * r / (o - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
    return l[0] = c, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = u, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(e, t, i, n, r, o, a = _o) {
    const l = this.elements, c = 1 / (t - e), u = 1 / (i - n), h = 1 / (o - r), d = (t + e) * c, f = (i + n) * u;
    let m, g;
    if (a === _o)
      m = (o + r) * h, g = -2 * h;
    else if (a === Vp)
      m = r * h, g = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const Qu = /* @__PURE__ */ new H(), co = /* @__PURE__ */ new _t(), h4 = /* @__PURE__ */ new H(0, 0, 0), d4 = /* @__PURE__ */ new H(1, 1, 1), $a = /* @__PURE__ */ new H(), tg = /* @__PURE__ */ new H(), vs = /* @__PURE__ */ new H(), dT = /* @__PURE__ */ new _t(), fT = /* @__PURE__ */ new En();
class fs {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(e = 0, t = 0, i = 0, n = fs.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = n;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(e, t, i, n = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const n = e.elements, r = n[0], o = n[4], a = n[8], l = n[1], c = n[5], u = n[9], h = n[2], d = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Qt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Qt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Qt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-Qt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(Qt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, f));
        break;
      case "XZY":
        this._z = Math.asin(-Qt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(e, t, i) {
    return dT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(dT, t, i);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(e) {
    return fT.setFromEuler(this), this.setFromQuaternion(fT, e);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
fs.DEFAULT_ORDER = "XYZ";
class S_ {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let f4 = 0;
const pT = /* @__PURE__ */ new H(), eh = /* @__PURE__ */ new En(), ca = /* @__PURE__ */ new _t(), ng = /* @__PURE__ */ new H(), rf = /* @__PURE__ */ new H(), p4 = /* @__PURE__ */ new H(), m4 = /* @__PURE__ */ new En(), mT = /* @__PURE__ */ new H(1, 0, 0), gT = /* @__PURE__ */ new H(0, 1, 0), vT = /* @__PURE__ */ new H(0, 0, 1), _T = { type: "added" }, g4 = { type: "removed" }, th = { type: "childadded", child: null }, cx = { type: "childremoved", child: null };
class tn extends Qo {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: f4++ }), this.uuid = Ls(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = tn.DEFAULT_UP.clone();
    const e = new H(), t = new fs(), i = new En(), n = new H(1, 1, 1);
    function r() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(r), i._onChange(o), Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new _t()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new Jt()
      }
    }), this.matrix = new _t(), this.matrixWorld = new _t(), this.matrixAutoUpdate = tn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = tn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new S_(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(e, t) {
    return eh.setFromAxisAngle(e, t), this.quaternion.multiply(eh), this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(e, t) {
    return eh.setFromAxisAngle(e, t), this.quaternion.premultiply(eh), this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(e) {
    return this.rotateOnAxis(mT, e);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(e) {
    return this.rotateOnAxis(gT, e);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(e) {
    return this.rotateOnAxis(vT, e);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(e, t) {
    return pT.copy(e).applyQuaternion(this.quaternion), this.position.add(pT.multiplyScalar(t)), this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(e) {
    return this.translateOnAxis(mT, e);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(e) {
    return this.translateOnAxis(gT, e);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(e) {
    return this.translateOnAxis(vT, e);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ca.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(e, t, i) {
    e.isVector3 ? ng.copy(e) : ng.set(e, t, i);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), rf.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ca.lookAt(rf, ng, this.up) : ca.lookAt(ng, rf, this.up), this.quaternion.setFromRotationMatrix(ca), n && (ca.extractRotation(n.matrixWorld), eh.setFromRotationMatrix(ca), this.quaternion.premultiply(eh.invert()));
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(_T), th.child = e, this.dispatchEvent(th), th.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(g4), cx.child = e, this.dispatchEvent(cx), cx.child = null), this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(e) {
    return this.updateWorldMatrix(!0, !1), ca.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ca.multiply(e.parent.matrixWorld)), e.applyMatrix4(ca), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(_T), th.child = e, this.dispatchEvent(th), th.child = null, this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const n = this.children;
    for (let r = 0, o = n.length; r < o; r++)
      n[r].getObjectsByProperty(e, t, i);
    return i;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rf, e, p4), e;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rf, m4, e), e;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverse(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverseVisible(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].updateMatrixWorld(e);
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const n = this.children;
      for (let r = 0, o = n.length; r < o; r++)
        n[r].updateWorldMatrix(!1, !0);
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((a) => ({
      boxInitialized: a.boxInitialized,
      boxMin: a.box.min.toArray(),
      boxMax: a.box.max.toArray(),
      sphereInitialized: a.sphereInitialized,
      sphereRadius: a.sphere.radius,
      sphereCenter: a.sphere.center.toArray()
    })), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (n.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (n.boundingSphere = {
      center: n.boundingSphere.center.toArray(),
      radius: n.boundingSphere.radius
    }), this.boundingBox !== null && (n.boundingBox = {
      min: n.boundingBox.min.toArray(),
      max: n.boundingBox.max.toArray()
    }));
    function r(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = r(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const h = l[c];
            r(e.shapes, h);
          }
        else
          r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(r(e.materials, this.material[l]));
        n.material = a;
      } else
        n.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let a = 0; a < this.children.length; a++)
        n.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        n.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries), l = o(e.materials), c = o(e.textures), u = o(e.images), h = o(e.shapes), d = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), h.length > 0 && (i.shapes = h), d.length > 0 && (i.skeletons = d), f.length > 0 && (i.animations = f), m.length > 0 && (i.nodes = m);
    }
    return i.object = n, i;
    function o(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        this.add(n.clone());
      }
    return this;
  }
}
tn.DEFAULT_UP = /* @__PURE__ */ new H(0, 1, 0);
tn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
tn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const uo = /* @__PURE__ */ new H(), ua = /* @__PURE__ */ new H(), ux = /* @__PURE__ */ new H(), ha = /* @__PURE__ */ new H(), nh = /* @__PURE__ */ new H(), ih = /* @__PURE__ */ new H(), yT = /* @__PURE__ */ new H(), hx = /* @__PURE__ */ new H(), dx = /* @__PURE__ */ new H(), fx = /* @__PURE__ */ new H(), px = /* @__PURE__ */ new Kt(), mx = /* @__PURE__ */ new Kt(), gx = /* @__PURE__ */ new Kt();
class Xi {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(e = new H(), t = new H(), i = new H()) {
    this.a = e, this.b = t, this.c = i;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), uo.subVectors(e, t), n.cross(uo);
    const r = n.lengthSq();
    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(e, t, i, n, r) {
    uo.subVectors(n, t), ua.subVectors(i, t), ux.subVectors(e, t);
    const o = uo.dot(uo), a = uo.dot(ua), l = uo.dot(ux), c = ua.dot(ua), u = ua.dot(ux), h = o * c - a * a;
    if (h === 0)
      return r.set(0, 0, 0), null;
    const d = 1 / h, f = (c * l - a * u) * d, m = (o * u - a * l) * d;
    return r.set(1 - f - m, m, f);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(e, t, i, n) {
    return this.getBarycoord(e, t, i, n, ha) === null ? !1 : ha.x >= 0 && ha.y >= 0 && ha.x + ha.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(e, t, i, n, r, o, a, l) {
    return this.getBarycoord(e, t, i, n, ha) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, ha.x), l.addScaledVector(o, ha.y), l.addScaledVector(a, ha.z), l);
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(e, t, i, n, r, o) {
    return px.setScalar(0), mx.setScalar(0), gx.setScalar(0), px.fromBufferAttribute(e, t), mx.fromBufferAttribute(e, i), gx.fromBufferAttribute(e, n), o.setScalar(0), o.addScaledVector(px, r.x), o.addScaledVector(mx, r.y), o.addScaledVector(gx, r.z), o;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(e, t, i, n) {
    return uo.subVectors(i, t), ua.subVectors(e, t), uo.cross(ua).dot(n) < 0;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(e, t, i, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    return uo.subVectors(this.c, this.b), ua.subVectors(this.a, this.b), uo.cross(ua).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(e) {
    return Xi.getNormal(this.a, this.b, this.c, e);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(e, t) {
    return Xi.getBarycoord(e, this.a, this.b, this.c, t);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(e, t, i, n, r) {
    return Xi.getInterpolation(e, this.a, this.b, this.c, t, i, n, r);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(e) {
    return Xi.containsPoint(e, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(e) {
    return Xi.isFrontFacing(this.a, this.b, this.c, e);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(e, t) {
    const i = this.a, n = this.b, r = this.c;
    let o, a;
    nh.subVectors(n, i), ih.subVectors(r, i), hx.subVectors(e, i);
    const l = nh.dot(hx), c = ih.dot(hx);
    if (l <= 0 && c <= 0)
      return t.copy(i);
    dx.subVectors(e, n);
    const u = nh.dot(dx), h = ih.dot(dx);
    if (u >= 0 && h <= u)
      return t.copy(n);
    const d = l * h - u * c;
    if (d <= 0 && l >= 0 && u <= 0)
      return o = l / (l - u), t.copy(i).addScaledVector(nh, o);
    fx.subVectors(e, r);
    const f = nh.dot(fx), m = ih.dot(fx);
    if (m >= 0 && f <= m)
      return t.copy(r);
    const g = f * c - l * m;
    if (g <= 0 && c >= 0 && m <= 0)
      return a = c / (c - m), t.copy(i).addScaledVector(ih, a);
    const v = u * m - f * h;
    if (v <= 0 && h - u >= 0 && f - m >= 0)
      return yT.subVectors(r, n), a = (h - u) / (h - u + (f - m)), t.copy(n).addScaledVector(yT, a);
    const _ = 1 / (v + g + d);
    return o = g * _, a = d * _, t.copy(i).addScaledVector(nh, o).addScaledVector(ih, a);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const jD = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ja = { h: 0, s: 0, l: 0 }, ig = { h: 0, s: 0, l: 0 };
function vx(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
}
class rt {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(e, t, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const n = e;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(e, t, i);
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(e, t = Oi) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, vn.toWorkingColorSpace(this, t), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(e, t, i, n = vn.workingColorSpace) {
    return this.r = e, this.g = t, this.b = i, vn.toWorkingColorSpace(this, n), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(e, t, i, n = vn.workingColorSpace) {
    if (e = Qw(e, 1), t = Qt(t, 0, 1), i = Qt(i, 0, 1), t === 0)
      this.r = this.g = this.b = i;
    else {
      const r = i <= 0.5 ? i * (1 + t) : i + t - i * t, o = 2 * i - r;
      this.r = vx(o, r, e + 1 / 3), this.g = vx(o, r, e), this.b = vx(o, r, e - 1 / 3);
    }
    return vn.toWorkingColorSpace(this, n), this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(e, t = Oi) {
    function i(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const o = n[1], a = n[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return i(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return i(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return i(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = n[1], o = r.length;
      if (o === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (o === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(e, t = Oi) {
    const i = jD[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(e) {
    return this.r = Ca(e.r), this.g = Ca(e.g), this.b = Ca(e.b), this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(e) {
    return this.r = Kh(e.r), this.g = Kh(e.g), this.b = Kh(e.b), this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(e = Oi) {
    return vn.fromWorkingColorSpace(Er.copy(this), e), Math.round(Qt(Er.r * 255, 0, 255)) * 65536 + Math.round(Qt(Er.g * 255, 0, 255)) * 256 + Math.round(Qt(Er.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(e = Oi) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:0,s:0,l:0}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(e, t = vn.workingColorSpace) {
    vn.fromWorkingColorSpace(Er.copy(this), t);
    const i = Er.r, n = Er.g, r = Er.b, o = Math.max(i, n, r), a = Math.min(i, n, r);
    let l, c;
    const u = (a + o) / 2;
    if (a === o)
      l = 0, c = 0;
    else {
      const h = o - a;
      switch (c = u <= 0.5 ? h / (o + a) : h / (2 - o - a), o) {
        case i:
          l = (n - r) / h + (n < r ? 6 : 0);
          break;
        case n:
          l = (r - i) / h + 2;
          break;
        case r:
          l = (i - n) / h + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = u, e;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(e, t = vn.workingColorSpace) {
    return vn.fromWorkingColorSpace(Er.copy(this), t), e.r = Er.r, e.g = Er.g, e.b = Er.b, e;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(e = Oi) {
    vn.fromWorkingColorSpace(Er.copy(this), e);
    const t = Er.r, i = Er.g, n = Er.b;
    return e !== Oi ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(e, t, i) {
    return this.getHSL(Ja), this.setHSL(Ja.h + e, Ja.s + t, Ja.l + i);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(e, t) {
    this.getHSL(Ja), e.getHSL(ig);
    const i = up(Ja.h, ig.h, t), n = up(Ja.s, ig.s, t), r = up(Ja.l, ig.l, t);
    return this.setHSL(i, n, r), this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(e) {
    const t = this.r, i = this.g, n = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * i + r[6] * n, this.g = r[1] * t + r[4] * i + r[7] * n, this.b = r[2] * t + r[5] * i + r[8] * n, this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Er = /* @__PURE__ */ new rt();
rt.NAMES = jD;
let v4 = 0;
class ji extends Qo {
  /**
   * Constructs a new material.
   */
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: v4++ }), this.uuid = Ls(), this.name = "", this.type = "Material", this.blending = Jc, this.side = Fs, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = u0, this.blendDst = h0, this.blendEquation = hl, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new rt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = fu, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = j0, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Tc, this.stencilZFail = Tc, this.stencilZPass = Tc, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  /**
   * Sets the alpha value to be used when running an alpha test. The material
   * will not be rendered if the opacity is lower than this value.
   *
   * @type {number}
   * @readonly
   * @default 0
   */
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  /**
   * An optional callback that is executed immediately before the material is used to render a 3D object.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Object3D} object - The 3D object.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * An optional callback that is executed immediately before the shader
   * program is compiled. This function is called with the shader source code
   * as a parameter. Useful for the modification of built-in materials.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}. The
   * recommended approach when customizing materials is to use `WebGPURenderer` with the new
   * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
   *
   * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
   * @param {WebGLRenderer} renderer - A reference to the renderer.
   */
  onBeforeCompile() {
  }
  /**
   * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
   * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
   * shader or recompile the shader for this material as needed.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @return {string} The custom program cache key.
   */
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const n = this[t];
        if (n === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i;
      }
  }
  /**
   * Serializes the material into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized material.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Jc && (i.blending = this.blending), this.side !== Fs && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== u0 && (i.blendSrc = this.blendSrc), this.blendDst !== h0 && (i.blendDst = this.blendDst), this.blendEquation !== hl && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== fu && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== j0 && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Tc && (i.stencilFail = this.stencilFail), this.stencilZFail !== Tc && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Tc && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(r) {
      const o = [];
      for (const a in r) {
        const l = r[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const r = n(e.textures), o = n(e.images);
      r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o);
    }
    return i;
  }
  /**
   * Returns a new material with copied values from this instance.
   *
   * @return {Material} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given material to this instance.
   *
   * @param {Material} source - The material to copy.
   * @return {Material} A reference to this instance.
   */
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const n = t.length;
      i = new Array(n);
      for (let r = 0; r !== n; ++r)
        i[r] = t[r].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Material#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Setting this property to `true` indicates the engine the material
   * needs to be recompiled.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class qn extends ji {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new fs(), this.combine = sm, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const ba = /* @__PURE__ */ _4();
function _4() {
  const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), i = new Uint32Array(512), n = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (i[l] = 0, i[l | 256] = 32768, n[l] = 24, n[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14, i[l | 256] = 1024 >> -c - 14 | 32768, n[l] = -c - 1, n[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10, i[l | 256] = c + 15 << 10 | 32768, n[l] = 13, n[l | 256] = 13) : c < 128 ? (i[l] = 31744, i[l | 256] = 64512, n[l] = 24, n[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, n[l] = 13, n[l | 256] = 13);
  }
  const r = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, u = 0;
    for (; !(c & 8388608); )
      c <<= 1, u -= 8388608;
    c &= -8388609, u += 947912704, r[l] = c | u;
  }
  for (let l = 1024; l < 2048; ++l)
    r[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    o[l] = l << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    o[l] = 2147483648 + (l - 32 << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: n,
    mantissaTable: r,
    exponentTable: o,
    offsetTable: a
  };
}
function is(s) {
  Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = Qt(s, -65504, 65504), ba.floatView[0] = s;
  const e = ba.uint32View[0], t = e >> 23 & 511;
  return ba.baseTable[t] + ((e & 8388607) >> ba.shiftTable[t]);
}
function Of(s) {
  const e = s >> 10;
  return ba.uint32View[0] = ba.mantissaTable[ba.offsetTable[e] + (s & 1023)] + ba.exponentTable[e], ba.floatView[0];
}
class Gc {
  /**
   * Returns a half precision floating point value (FP16) from the given single
   * precision floating point value (FP32).
   *
   * @param {number} val - A single precision floating point value.
   * @return {number} The FP16 value.
   */
  static toHalfFloat(e) {
    return is(e);
  }
  /**
   * Returns a single precision floating point value (FP32) from the given half
   * precision floating point value (FP16).
   *
   * @param {number} val - A half precision floating point value.
   * @return {number} The FP32 value.
   */
  static fromHalfFloat(e) {
    return Of(e);
  }
}
const Ri = /* @__PURE__ */ new H(), rg = /* @__PURE__ */ new Be();
let y4 = 0;
class Nt {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: y4++ }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = zp, this.updateRanges = [], this.gpuType = Un, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let n = 0, r = this.itemSize; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        rg.fromBufferAttribute(this, t), rg.applyMatrix3(e), this.setXY(t, rg.x, rg.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Ri.fromBufferAttribute(this, t), Ri.applyMatrix3(e), this.setXYZ(t, Ri.x, Ri.y, Ri.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ri.fromBufferAttribute(this, t), Ri.applyMatrix4(e), this.setXYZ(t, Ri.x, Ri.y, Ri.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ri.fromBufferAttribute(this, t), Ri.applyNormalMatrix(e), this.setXYZ(t, Ri.x, Ri.y, Ri.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ri.fromBufferAttribute(this, t), Ri.transformDirection(e), this.setXYZ(t, Ri.x, Ri.y, Ri.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = qr(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = rn(i, this.array)), this.array[e * this.itemSize + t] = i, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = rn(t, this.array), i = rn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e *= this.itemSize, this.normalized && (t = rn(t, this.array), i = rn(i, this.array), n = rn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e *= this.itemSize, this.normalized && (t = rn(t, this.array), i = rn(i, this.array), n = rn(n, this.array), r = rn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== zp && (e.usage = this.usage), e;
  }
}
class x4 extends Nt {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class b4 extends Nt {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class w4 extends Nt {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class S4 extends Nt {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class eS extends Nt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class M4 extends Nt {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class tS extends Nt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class E4 extends Nt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = Of(this.array[e * this.itemSize]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize] = is(t), this;
  }
  getY(e) {
    let t = Of(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize + 1] = is(t), this;
  }
  getZ(e) {
    let t = Of(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize + 2] = is(t), this;
  }
  getW(e) {
    let t = Of(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.array[e * this.itemSize + 3] = is(t), this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = rn(t, this.array), i = rn(i, this.array)), this.array[e + 0] = is(t), this.array[e + 1] = is(i), this;
  }
  setXYZ(e, t, i, n) {
    return e *= this.itemSize, this.normalized && (t = rn(t, this.array), i = rn(i, this.array), n = rn(n, this.array)), this.array[e + 0] = is(t), this.array[e + 1] = is(i), this.array[e + 2] = is(n), this;
  }
  setXYZW(e, t, i, n, r) {
    return e *= this.itemSize, this.normalized && (t = rn(t, this.array), i = rn(i, this.array), n = rn(n, this.array), r = rn(r, this.array)), this.array[e + 0] = is(t), this.array[e + 1] = is(i), this.array[e + 2] = is(n), this.array[e + 3] = is(r), this;
  }
}
class Tt extends Nt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let T4 = 0;
const Hs = /* @__PURE__ */ new _t(), _x = /* @__PURE__ */ new tn(), rh = /* @__PURE__ */ new H(), _s = /* @__PURE__ */ new yn(), sf = /* @__PURE__ */ new yn(), er = /* @__PURE__ */ new H();
class Gt extends Qo {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: T4++ }), this.uuid = Ls(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (WD(e) ? tS : eS)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const r = new Jt().getNormalMatrix(e);
      i.applyNormalMatrix(r), i.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Hs.makeRotationFromQuaternion(e), this.applyMatrix4(Hs), this;
  }
  rotateX(e) {
    return Hs.makeRotationX(e), this.applyMatrix4(Hs), this;
  }
  rotateY(e) {
    return Hs.makeRotationY(e), this.applyMatrix4(Hs), this;
  }
  rotateZ(e) {
    return Hs.makeRotationZ(e), this.applyMatrix4(Hs), this;
  }
  translate(e, t, i) {
    return Hs.makeTranslation(e, t, i), this.applyMatrix4(Hs), this;
  }
  scale(e, t, i) {
    return Hs.makeScale(e, t, i), this.applyMatrix4(Hs), this;
  }
  lookAt(e) {
    return _x.lookAt(e), _x.updateMatrix(), this.applyMatrix4(_x.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(rh).negate(), this.translate(rh.x, rh.y, rh.z), this;
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const i = [];
      for (let n = 0, r = e.length; n < r; n++) {
        const o = e[n];
        i.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new Tt(i, 3));
    } else {
      const i = Math.min(e.length, t.count);
      for (let n = 0; n < i; n++) {
        const r = e[n];
        t.setXYZ(n, r.x, r.y, r.z || 0);
      }
      e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new yn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new H(-1 / 0, -1 / 0, -1 / 0),
        new H(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let i = 0, n = t.length; i < n; i++) {
          const r = t[i];
          _s.setFromBufferAttribute(r), this.morphTargetsRelative ? (er.addVectors(this.boundingBox.min, _s.min), this.boundingBox.expandByPoint(er), er.addVectors(this.boundingBox.max, _s.max), this.boundingBox.expandByPoint(er)) : (this.boundingBox.expandByPoint(_s.min), this.boundingBox.expandByPoint(_s.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new H(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (_s.setFromBufferAttribute(e), t)
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r];
          sf.setFromBufferAttribute(a), this.morphTargetsRelative ? (er.addVectors(_s.min, sf.min), _s.expandByPoint(er), er.addVectors(_s.max, sf.max), _s.expandByPoint(er)) : (_s.expandByPoint(sf.min), _s.expandByPoint(sf.max));
        }
      _s.getCenter(i);
      let n = 0;
      for (let r = 0, o = e.count; r < o; r++)
        er.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(er));
      if (t)
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r], l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            er.fromBufferAttribute(a, c), l && (rh.fromBufferAttribute(e, c), er.add(rh)), n = Math.max(n, i.distanceToSquared(er));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = t.position, n = t.normal, r = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Nt(new Float32Array(4 * i.count), 4));
    const o = this.getAttribute("tangent"), a = [], l = [];
    for (let C = 0; C < i.count; C++)
      a[C] = new H(), l[C] = new H();
    const c = new H(), u = new H(), h = new H(), d = new Be(), f = new Be(), m = new Be(), g = new H(), v = new H();
    function _(C, P, T) {
      c.fromBufferAttribute(i, C), u.fromBufferAttribute(i, P), h.fromBufferAttribute(i, T), d.fromBufferAttribute(r, C), f.fromBufferAttribute(r, P), m.fromBufferAttribute(r, T), u.sub(c), h.sub(c), f.sub(d), m.sub(d);
      const I = 1 / (f.x * m.y - m.x * f.y);
      isFinite(I) && (g.copy(u).multiplyScalar(m.y).addScaledVector(h, -f.y).multiplyScalar(I), v.copy(h).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(I), a[C].add(g), a[P].add(g), a[T].add(g), l[C].add(v), l[P].add(v), l[T].add(v));
    }
    let y = this.groups;
    y.length === 0 && (y = [{
      start: 0,
      count: e.count
    }]);
    for (let C = 0, P = y.length; C < P; ++C) {
      const T = y[C], I = T.start, D = T.count;
      for (let U = I, L = I + D; U < L; U += 3)
        _(
          e.getX(U + 0),
          e.getX(U + 1),
          e.getX(U + 2)
        );
    }
    const w = new H(), x = new H(), M = new H(), A = new H();
    function E(C) {
      M.fromBufferAttribute(n, C), A.copy(M);
      const P = a[C];
      w.copy(P), w.sub(M.multiplyScalar(M.dot(P))).normalize(), x.crossVectors(A, P);
      const I = x.dot(l[C]) < 0 ? -1 : 1;
      o.setXYZW(C, w.x, w.y, w.z, I);
    }
    for (let C = 0, P = y.length; C < P; ++C) {
      const T = y[C], I = T.start, D = T.count;
      for (let U = I, L = I + D; U < L; U += 3)
        E(e.getX(U + 0)), E(e.getX(U + 1)), E(e.getX(U + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Nt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let d = 0, f = i.count; d < f; d++)
          i.setXYZ(d, 0, 0, 0);
      const n = new H(), r = new H(), o = new H(), a = new H(), l = new H(), c = new H(), u = new H(), h = new H();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const m = e.getX(d + 0), g = e.getX(d + 1), v = e.getX(d + 2);
          n.fromBufferAttribute(t, m), r.fromBufferAttribute(t, g), o.fromBufferAttribute(t, v), u.subVectors(o, r), h.subVectors(n, r), u.cross(h), a.fromBufferAttribute(i, m), l.fromBufferAttribute(i, g), c.fromBufferAttribute(i, v), a.add(u), l.add(u), c.add(u), i.setXYZ(m, a.x, a.y, a.z), i.setXYZ(g, l.x, l.y, l.z), i.setXYZ(v, c.x, c.y, c.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          n.fromBufferAttribute(t, d + 0), r.fromBufferAttribute(t, d + 1), o.fromBufferAttribute(t, d + 2), u.subVectors(o, r), h.subVectors(n, r), u.cross(h), i.setXYZ(d + 0, u.x, u.y, u.z), i.setXYZ(d + 1, u.x, u.y, u.z), i.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      er.fromBufferAttribute(e, t), er.normalize(), e.setXYZ(t, er.x, er.y, er.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array, u = a.itemSize, h = a.normalized, d = new c.constructor(l.length * u);
      let f = 0, m = 0;
      for (let g = 0, v = l.length; g < v; g++) {
        a.isInterleavedBufferAttribute ? f = l[g] * a.data.stride + a.offset : f = l[g] * u;
        for (let _ = 0; _ < u; _++)
          d[m++] = c[f++];
      }
      return new Nt(d, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Gt(), i = this.index.array, n = this.attributes;
    for (const a in n) {
      const l = n[a], c = e(l, i);
      t.setAttribute(a, c);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const l = [], c = r[a];
      for (let u = 0, h = c.length; u < h; u++) {
        const d = c[u], f = e(d, i);
        l.push(f);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const n = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], u = [];
      for (let h = 0, d = c.length; h < d; h++) {
        const f = c[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && (n[l] = u, r = !0);
    }
    r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = {
      center: a.center.toArray(),
      radius: a.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const n = e.attributes;
    for (const c in n) {
      const u = n[c];
      this.setAttribute(c, u.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const u = [], h = r[c];
      for (let d = 0, f = h.length; d < f; d++)
        u.push(h[d].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, u = o.length; c < u; c++) {
      const h = o[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const xT = /* @__PURE__ */ new _t(), ic = /* @__PURE__ */ new Ol(), sg = /* @__PURE__ */ new fi(), bT = /* @__PURE__ */ new H(), og = /* @__PURE__ */ new H(), ag = /* @__PURE__ */ new H(), lg = /* @__PURE__ */ new H(), yx = /* @__PURE__ */ new H(), cg = /* @__PURE__ */ new H(), wT = /* @__PURE__ */ new H(), ug = /* @__PURE__ */ new H();
class it extends tn {
  /**
   * Constructs a new mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e = new Gt(), t = new qn()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = n.length; r < o; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
  /**
   * Returns the local-space position of the vertex at the given index, taking into
   * account the current animation state of both morph targets and skinning.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * @return {Vector3} The vertex position in local space.
   */
  getVertexPosition(e, t) {
    const i = this.geometry, n = i.attributes.position, r = i.morphAttributes.position, o = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    const a = this.morphTargetInfluences;
    if (r && a) {
      cg.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const u = a[l], h = r[l];
        u !== 0 && (yx.fromBufferAttribute(h, e), o ? cg.addScaledVector(yx, u) : cg.addScaledVector(yx.sub(t), u));
      }
      t.add(cg);
    }
    return t;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const i = this.geometry, n = this.material, r = this.matrixWorld;
    n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), sg.copy(i.boundingSphere), sg.applyMatrix4(r), ic.copy(e.ray).recast(e.near), !(sg.containsPoint(ic.origin) === !1 && (ic.intersectSphere(sg, bT) === null || ic.origin.distanceToSquared(bT) > (e.far - e.near) ** 2)) && (xT.copy(r).invert(), ic.copy(e.ray).applyMatrix4(xT), !(i.boundingBox !== null && ic.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, ic)));
  }
  _computeIntersections(e, t, i) {
    let n;
    const r = this.geometry, o = this.material, a = r.index, l = r.attributes.position, c = r.attributes.uv, u = r.attributes.uv1, h = r.attributes.normal, d = r.groups, f = r.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let m = 0, g = d.length; m < g; m++) {
          const v = d[m], _ = o[v.materialIndex], y = Math.max(v.start, f.start), w = Math.min(a.count, Math.min(v.start + v.count, f.start + f.count));
          for (let x = y, M = w; x < M; x += 3) {
            const A = a.getX(x), E = a.getX(x + 1), C = a.getX(x + 2);
            n = hg(this, _, e, i, c, u, h, A, E, C), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = v.materialIndex, t.push(n));
          }
        }
      else {
        const m = Math.max(0, f.start), g = Math.min(a.count, f.start + f.count);
        for (let v = m, _ = g; v < _; v += 3) {
          const y = a.getX(v), w = a.getX(v + 1), x = a.getX(v + 2);
          n = hg(this, o, e, i, c, u, h, y, w, x), n && (n.faceIndex = Math.floor(v / 3), t.push(n));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let m = 0, g = d.length; m < g; m++) {
          const v = d[m], _ = o[v.materialIndex], y = Math.max(v.start, f.start), w = Math.min(l.count, Math.min(v.start + v.count, f.start + f.count));
          for (let x = y, M = w; x < M; x += 3) {
            const A = x, E = x + 1, C = x + 2;
            n = hg(this, _, e, i, c, u, h, A, E, C), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = v.materialIndex, t.push(n));
          }
        }
      else {
        const m = Math.max(0, f.start), g = Math.min(l.count, f.start + f.count);
        for (let v = m, _ = g; v < _; v += 3) {
          const y = v, w = v + 1, x = v + 2;
          n = hg(this, o, e, i, c, u, h, y, w, x), n && (n.faceIndex = Math.floor(v / 3), t.push(n));
        }
      }
  }
}
function A4(s, e, t, i, n, r, o, a) {
  let l;
  if (e.side === Yi ? l = i.intersectTriangle(o, r, n, !0, a) : l = i.intersectTriangle(n, r, o, e.side === Fs, a), l === null) return null;
  ug.copy(a), ug.applyMatrix4(s.matrixWorld);
  const c = t.ray.origin.distanceTo(ug);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: ug.clone(),
    object: s
  };
}
function hg(s, e, t, i, n, r, o, a, l, c) {
  s.getVertexPosition(a, og), s.getVertexPosition(l, ag), s.getVertexPosition(c, lg);
  const u = A4(s, e, t, i, og, ag, lg, wT);
  if (u) {
    const h = new H();
    Xi.getBarycoord(wT, og, ag, lg, h), n && (u.uv = Xi.getInterpolatedAttribute(n, a, l, c, h, new Be())), r && (u.uv1 = Xi.getInterpolatedAttribute(r, a, l, c, h, new Be())), o && (u.normal = Xi.getInterpolatedAttribute(o, a, l, c, h, new H()), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = {
      a,
      b: l,
      c,
      normal: new H(),
      materialIndex: 0
    };
    Xi.getNormal(og, ag, lg, d.normal), u.face = d, u.barycoord = h;
  }
  return u;
}
class pi extends Gt {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(e = 1, t = 1, i = 1, n = 1, r = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: i,
      widthSegments: n,
      heightSegments: r,
      depthSegments: o
    };
    const a = this;
    n = Math.floor(n), r = Math.floor(r), o = Math.floor(o);
    const l = [], c = [], u = [], h = [];
    let d = 0, f = 0;
    m("z", "y", "x", -1, -1, i, t, e, o, r, 0), m("z", "y", "x", 1, -1, i, t, -e, o, r, 1), m("x", "z", "y", 1, 1, e, i, t, n, o, 2), m("x", "z", "y", 1, -1, e, i, -t, n, o, 3), m("x", "y", "z", 1, -1, e, t, i, n, r, 4), m("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(l), this.setAttribute("position", new Tt(c, 3)), this.setAttribute("normal", new Tt(u, 3)), this.setAttribute("uv", new Tt(h, 2));
    function m(g, v, _, y, w, x, M, A, E, C, P) {
      const T = x / E, I = M / C, D = x / 2, U = M / 2, L = A / 2, k = E + 1, B = C + 1;
      let j = 0, q = 0;
      const Z = new H();
      for (let N = 0; N < B; N++) {
        const z = N * I - U;
        for (let J = 0; J < k; J++) {
          const se = J * T - D;
          Z[g] = se * y, Z[v] = z * w, Z[_] = L, c.push(Z.x, Z.y, Z.z), Z[g] = 0, Z[v] = 0, Z[_] = A > 0 ? 1 : -1, u.push(Z.x, Z.y, Z.z), h.push(J / E), h.push(1 - N / C), j += 1;
        }
      }
      for (let N = 0; N < C; N++)
        for (let z = 0; z < E; z++) {
          const J = d + z + k * N, se = d + z + k * (N + 1), K = d + (z + 1) + k * (N + 1), Q = d + (z + 1) + k * N;
          l.push(J, se, Q), l.push(se, K, Q), q += 6;
        }
      a.addGroup(f, q, P), f += q, d += j;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(e) {
    return new pi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function fd(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const i in s[t]) {
      const n = s[t][i];
      n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
    }
  }
  return e;
}
function zr(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const i = fd(s[t]);
    for (const n in i)
      e[n] = i[n];
  }
  return e;
}
function C4(s) {
  const e = [];
  for (let t = 0; t < s.length; t++)
    e.push(s[t].clone());
  return e;
}
function qD(s) {
  const e = s.getRenderTarget();
  return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : vn.workingColorSpace;
}
const Fl = { clone: fd, merge: zr };
var P4 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, R4 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Mi extends ji {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = P4, this.fragmentShader = R4, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = fd(e.uniforms), this.uniformsGroups = C4(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const n in this.uniforms) {
      const o = this.uniforms[n].value;
      o && o.isTexture ? t.uniforms[n] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[n] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[n] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[n] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[n] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[n] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[n] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[n] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class M_ extends tn {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new _t(), this.projectionMatrix = new _t(), this.projectionMatrixInverse = new _t(), this.coordinateSystem = _o;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Qa = /* @__PURE__ */ new H(), ST = /* @__PURE__ */ new Be(), MT = /* @__PURE__ */ new Be();
class Fi extends M_ {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = dd * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const e = Math.tan(tu * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return dd * 2 * Math.atan(
      Math.tan(tu * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(e, t, i) {
    Qa.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Qa.x, Qa.y).multiplyScalar(-e / Qa.z), Qa.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Qa.x, Qa.y).multiplyScalar(-e / Qa.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, ST, MT), t.subVectors(MT, ST);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(e, t, i, n, r, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(tu * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -0.5 * n;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, c = o.fullHeight;
      r += o.offsetX * n / l, t -= o.offsetY * i / c, n *= o.width / l, i *= o.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const sh = -90, oh = 1;
let E_ = class extends tn {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const n = new Fi(sh, oh, e, t);
    n.layers = this.layers, this.add(n);
    const r = new Fi(sh, oh, e, t);
    r.layers = this.layers, this.add(r);
    const o = new Fi(sh, oh, e, t);
    o.layers = this.layers, this.add(o);
    const a = new Fi(sh, oh, e, t);
    a.layers = this.layers, this.add(a);
    const l = new Fi(sh, oh, e, t);
    l.layers = this.layers, this.add(l);
    const c = new Fi(sh, oh, e, t);
    c.layers = this.layers, this.add(c);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [i, n, r, o, a, l] = t;
    for (const c of t) this.remove(c);
    if (e === _o)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === Vp)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of t)
      this.add(c), c.updateMatrixWorld();
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, o, a, l, c, u] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const g = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, n), e.render(t, r), e.setRenderTarget(i, 1, n), e.render(t, o), e.setRenderTarget(i, 2, n), e.render(t, a), e.setRenderTarget(i, 3, n), e.render(t, l), e.setRenderTarget(i, 4, n), e.render(t, c), i.texture.generateMipmaps = g, e.setRenderTarget(i, 5, n), e.render(t, u), e.setRenderTarget(h, d, f), e.xr.enabled = m, i.texture.needsPMREMUpdate = !0;
  }
};
class Ed extends ei {
  constructor(e, t, i, n, r, o, a, l, c, u) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Ia, super(e, t, i, n, r, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class T_ extends Bs {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new Ed(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Sn;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new pi(5, 5, 5), r = new Mi({
      name: "CubemapFromEquirect",
      uniforms: fd(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Yi,
      blending: Aa
    });
    r.uniforms.tEquirect.value = t;
    const o = new it(n, r), a = t.minFilter;
    return t.minFilter === As && (t.minFilter = Sn), new E_(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, i, n) {
    const r = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, i, n);
    e.setRenderTarget(r);
  }
}
class Zn extends tn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const D4 = { type: "move" };
class Fv {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Zn(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Zn(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new H(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new H()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Zn(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new H(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new H()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const i of e.hand.values())
          this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, i) {
    let n = null, r = null, o = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const g of e.hand.values()) {
          const v = t.getJointPose(g, i), _ = this._getHandJoint(c, g);
          v !== null && (_.matrix.fromArray(v.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.matrixWorldNeedsUpdate = !0, _.jointRadius = v.radius), _.visible = v !== null;
        }
        const u = c.joints["index-finger-tip"], h = c.joints["thumb-tip"], d = u.position.distanceTo(h.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && d > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && d <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
      a !== null && (n = t.getPose(e.targetRaySpace, i), n === null && r !== null && (n = r), n !== null && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(D4)));
    }
    return a !== null && (a.visible = n !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Zn();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class A_ {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [density=0.00025] - Defines how fast the fog will grow dense.
   */
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new rt(e), this.density = t;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {FogExp2} A clone of this instance.
   */
  clone() {
    return new A_(this.color, this.density);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class C_ {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [near=1] - The minimum distance to start applying fog.
   * @param {number} [far=1000] - The maximum distance at which fog stops being calculated and applied.
   */
  constructor(e, t = 1, i = 1e3) {
    this.isFog = !0, this.name = "", this.color = new rt(e), this.near = t, this.far = i;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {Fog} A clone of this instance.
   */
  clone() {
    return new C_(this.color, this.near, this.far);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class am extends tn {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new fs(), this.environmentIntensity = 1, this.environmentRotation = new fs(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class lm {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = zp, this.updateRanges = [], this.version = 0, this.uuid = Ls();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let n = 0, r = this.stride; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ls()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ls()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Nr = /* @__PURE__ */ new H();
class ss {
  constructor(e, t, i, n = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      Nr.fromBufferAttribute(this, t), Nr.applyMatrix4(e), this.setXYZ(t, Nr.x, Nr.y, Nr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Nr.fromBufferAttribute(this, t), Nr.applyNormalMatrix(e), this.setXYZ(t, Nr.x, Nr.y, Nr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Nr.fromBufferAttribute(this, t), Nr.transformDirection(e), this.setXYZ(t, Nr.x, Nr.y, Nr.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = qr(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = rn(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
  }
  setX(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = rn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = rn(t, this.array), i = rn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = rn(t, this.array), i = rn(i, this.array), n = rn(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = rn(t, this.array), i = rn(i, this.array), n = rn(n, this.array), r = rn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[n + r]);
      }
      return new Nt(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ss(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[n + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Pu extends ji {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let ah;
const of = /* @__PURE__ */ new H(), lh = /* @__PURE__ */ new H(), ch = /* @__PURE__ */ new H(), uh = /* @__PURE__ */ new Be(), af = /* @__PURE__ */ new Be(), ZD = /* @__PURE__ */ new _t(), dg = /* @__PURE__ */ new H(), lf = /* @__PURE__ */ new H(), fg = /* @__PURE__ */ new H(), ET = /* @__PURE__ */ new Be(), xx = /* @__PURE__ */ new Be(), TT = /* @__PURE__ */ new Be();
class cm extends tn {
  /**
   * Constructs a new sprite.
   *
   * @param {SpriteMaterial} [material] - The sprite material.
   */
  constructor(e = new Pu()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", ah === void 0) {
      ah = new Gt();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), i = new lm(t, 5);
      ah.setIndex([0, 1, 2, 0, 2, 3]), ah.setAttribute("position", new ss(i, 3, 0, !1)), ah.setAttribute("uv", new ss(i, 2, 3, !1));
    }
    this.geometry = ah, this.material = e, this.center = new Be(0.5, 0.5);
  }
  /**
   * Computes intersection points between a casted ray and this sprite.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), lh.setFromMatrixScale(this.matrixWorld), ZD.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ch.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && lh.multiplyScalar(-ch.z);
    const i = this.material.rotation;
    let n, r;
    i !== 0 && (r = Math.cos(i), n = Math.sin(i));
    const o = this.center;
    pg(dg.set(-0.5, -0.5, 0), ch, o, lh, n, r), pg(lf.set(0.5, -0.5, 0), ch, o, lh, n, r), pg(fg.set(0.5, 0.5, 0), ch, o, lh, n, r), ET.set(0, 0), xx.set(1, 0), TT.set(1, 1);
    let a = e.ray.intersectTriangle(dg, lf, fg, !1, of);
    if (a === null && (pg(lf.set(-0.5, 0.5, 0), ch, o, lh, n, r), xx.set(0, 1), a = e.ray.intersectTriangle(dg, fg, lf, !1, of), a === null))
      return;
    const l = e.ray.origin.distanceTo(of);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: of.clone(),
      uv: Xi.getInterpolation(of, dg, lf, fg, ET, xx, TT, new Be()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function pg(s, e, t, i, n, r) {
  uh.subVectors(s, t).addScalar(0.5).multiply(i), n !== void 0 ? (af.x = r * uh.x - n * uh.y, af.y = n * uh.x + r * uh.y) : af.copy(uh), s.copy(e), s.x += af.x, s.y += af.y, s.applyMatrix4(ZD);
}
const mg = /* @__PURE__ */ new H(), AT = /* @__PURE__ */ new H();
class nS extends tn {
  /**
   * Constructs a new LOD.
   */
  constructor() {
    super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      /**
       * This array holds the LOD levels.
       *
       * @name LOD#levels
       * @type {Array<{object:Object3D,distance:number,hysteresis:number}>}
       */
      levels: {
        enumerable: !0,
        value: []
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  /**
   * Adds a mesh that will display at a certain distance and greater. Typically
   * the further away the distance, the lower the detail on the mesh.
   *
   * @param {Object3D} object - The 3D object to display at this level.
   * @param {number} [distance=0] - The distance at which to display this level of detail.
   * @param {number} [hysteresis=0] - Threshold used to avoid flickering at LOD boundaries, as a fraction of distance.
   * @return {LOD} A reference to this instance.
   */
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const n = this.levels;
    let r;
    for (r = 0; r < n.length && !(t < n[r].distance); r++)
      ;
    return n.splice(r, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
  }
  /**
   * Removes an existing level, based on the distance from the camera.
   * Returns `true` when the level has been removed. Otherwise `false`.
   *
   * @param {number} distance - Distance of the level to remove.
   * @return {boolean} Whether the level has been removed or not.
   */
  removeLevel(e) {
    const t = this.levels;
    for (let i = 0; i < t.length; i++)
      if (t[i].distance === e) {
        const n = t.splice(i, 1);
        return this.remove(n[0].object), !0;
      }
    return !1;
  }
  /**
   * Returns the currently active LOD level index.
   *
   * @return {number} The current active LOD level index.
   */
  getCurrentLevel() {
    return this._currentLevel;
  }
  /**
   * Returns a reference to the first 3D object that is greater than
   * the given distance.
   *
   * @param {number} distance - The LOD distance.
   * @return {Object3D|null} The found 3D object. `null` if no 3D object has been found.
   */
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, n;
      for (i = 1, n = t.length; i < n; i++) {
        let r = t[i].distance;
        if (t[i].object.visible && (r -= r * t[i].hysteresis), e < r)
          break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  /**
   * Computes intersection points between a casted ray and this LOD.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    if (this.levels.length > 0) {
      mg.setFromMatrixPosition(this.matrixWorld);
      const n = e.ray.origin.distanceTo(mg);
      this.getObjectForDistance(n).raycast(e, t);
    }
  }
  /**
   * Updates the LOD by computing which LOD level should be visible according
   * to the current distance of the given camera.
   *
   * @param {Camera} camera - The camera the scene is renderd with.
   */
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      mg.setFromMatrixPosition(e.matrixWorld), AT.setFromMatrixPosition(this.matrixWorld);
      const i = mg.distanceTo(AT) / e.zoom;
      t[0].object.visible = !0;
      let n, r;
      for (n = 1, r = t.length; n < r; n++) {
        let o = t[n].distance;
        if (t[n].object.visible && (o -= o * t[n].hysteresis), i >= o)
          t[n - 1].object.visible = !1, t[n].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = n - 1; n < r; n++)
        t[n].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const i = this.levels;
    for (let n = 0, r = i.length; n < r; n++) {
      const o = i[n];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis
      });
    }
    return t;
  }
}
const CT = /* @__PURE__ */ new H(), PT = /* @__PURE__ */ new Kt(), RT = /* @__PURE__ */ new Kt(), I4 = /* @__PURE__ */ new H(), DT = /* @__PURE__ */ new _t(), gg = /* @__PURE__ */ new H(), bx = /* @__PURE__ */ new fi(), IT = /* @__PURE__ */ new _t(), wx = /* @__PURE__ */ new Ol();
class P_ extends it {
  /**
   * Constructs a new skinned mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = _1, this.bindMatrix = new _t(), this.bindMatrixInverse = new _t(), this.boundingBox = null, this.boundingSphere = null;
  }
  /**
   * Computes the bounding box of the skinned mesh, and updates {@link SkinnedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
   * the current animation state.
   */
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new yn()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, gg), this.boundingBox.expandByPoint(gg);
  }
  /**
   * Computes the bounding sphere of the skinned mesh, and updates {@link SkinnedMesh#boundingSphere}.
   * The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
   * and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
   * per frame in order to reflect the current animation state.
   */
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new fi()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, gg), this.boundingSphere.expandByPoint(gg);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const i = this.material, n = this.matrixWorld;
    i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), bx.copy(this.boundingSphere), bx.applyMatrix4(n), e.ray.intersectsSphere(bx) !== !1 && (IT.copy(n).invert(), wx.copy(e.ray).applyMatrix4(IT), !(this.boundingBox !== null && wx.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, wx)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  /**
   * Binds the given skeleton to the skinned mesh.
   *
   * @param {Skeleton} skeleton - The skeleton to bind.
   * @param {Matrix4} [bindMatrix] - The bind matrix. If no bind matrix is provided,
   * the skinned mesh's world matrix will be used instead.
   */
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  /**
   * This method sets the skinned mesh in the rest pose).
   */
  pose() {
    this.skeleton.pose();
  }
  /**
   * Normalizes the skin weights which are defined as a buffer attribute
   * in the skinned mesh's geometry.
   */
  normalizeSkinWeights() {
    const e = new Kt(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, n = t.count; i < n; i++) {
      e.fromBufferAttribute(t, i);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === _1 ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === RD ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  /**
   * Applies the bone transform associated with the given index to the given
   * vertex position. Returns the updated vector.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * the skinned mesh's world matrix will be used instead.
   * @return {Vector3} The updated vertex position.
   */
  applyBoneTransform(e, t) {
    const i = this.skeleton, n = this.geometry;
    PT.fromBufferAttribute(n.attributes.skinIndex, e), RT.fromBufferAttribute(n.attributes.skinWeight, e), CT.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const o = RT.getComponent(r);
      if (o !== 0) {
        const a = PT.getComponent(r);
        DT.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(I4.copy(CT).applyMatrix4(DT), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class R_ extends tn {
  /**
   * Constructs a new bone.
   */
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class yr extends ei {
  constructor(e = null, t = 1, i = 1, n, r, o, a, l, c = Tn, u = Tn, h, d) {
    super(null, o, a, l, c, u, n, r, h, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const LT = /* @__PURE__ */ new _t(), L4 = /* @__PURE__ */ new _t();
class um {
  /**
   * Constructs a new skeleton.
   *
   * @param {Array<Bone>} [bones] - An array of bones.
   * @param {Array<Matrix4>} [boneInverses] - An array of bone inverse matrices.
   * If not provided, these matrices will be computed automatically via {@link Skeleton#calculateInverses}.
   */
  constructor(e = [], t = []) {
    this.uuid = Ls(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  /**
   * Initializes the skeleton. This method gets automatically called by the constructor
   * but depending on how the skeleton is created it might be necessary to call this method
   * manually.
   */
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, n = this.bones.length; i < n; i++)
        this.boneInverses.push(new _t());
    }
  }
  /**
   * Computes the bone inverse matrices. This method resets {@link Skeleton#boneInverses}
   * and fills it with new matrices.
   */
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new _t();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture;
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r] ? e[r].matrixWorld : L4;
      LT.multiplyMatrices(a, t[r]), LT.toArray(i, r * 16);
    }
    n !== null && (n.needsUpdate = !0);
  }
  /**
   * Returns a new skeleton with copied values from this instance.
   *
   * @return {Skeleton} A clone of this instance.
   */
  clone() {
    return new um(this.bones, this.boneInverses);
  }
  /**
   * Computes a data texture for passing bone data to the vertex shader.
   *
   * @return {Skeleton} A reference of this instance.
   */
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new yr(t, e, e, di, Un);
    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this;
  }
  /**
   * Searches through the skeleton's bone array and returns the first with a
   * matching name.
   *
   * @param {string} name - The name of the bone.
   * @return {Bone|undefined} The found bone. `undefined` if no bone has been found.
   */
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const n = this.bones[t];
      if (n.name === e)
        return n;
    }
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  /**
   * Setups the skeleton by the given JSON and bones.
   *
   * @param {Object} json - The skeleton as serialized JSON.
   * @param {Array<Bone>} bones - An array of bones.
   * @return {Skeleton} A reference of this instance.
   */
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, n = e.bones.length; i < n; i++) {
      const r = e.bones[i];
      let o = t[r];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new R_()), this.bones.push(o), this.boneInverses.push(new _t().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  /**
   * Serializes the skeleton into JSON.
   *
   * @return {Object} A JSON object representing the serialized skeleton.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let n = 0, r = t.length; n < r; n++) {
      const o = t[n];
      e.bones.push(o.uuid);
      const a = i[n];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Jo extends Nt {
  constructor(e, t, i, n = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const hh = /* @__PURE__ */ new _t(), UT = /* @__PURE__ */ new _t(), vg = [], kT = /* @__PURE__ */ new yn(), U4 = /* @__PURE__ */ new _t(), cf = /* @__PURE__ */ new it(), uf = /* @__PURE__ */ new fi();
class Td extends it {
  /**
   * Constructs a new instanced mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   * @param {number} count - The number of instances.
   */
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Jo(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
    for (let n = 0; n < i; n++)
      this.setMatrixAt(n, U4);
  }
  /**
   * Computes the bounding box of the instanced mesh, and updates {@link InstancedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * You may need to recompute the bounding box if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new yn()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, hh), kT.copy(e.boundingBox).applyMatrix4(hh), this.boundingBox.union(kT);
  }
  /**
   * Computes the bounding sphere of the instanced mesh, and updates {@link InstancedMesh#boundingSphere}
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new fi()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, hh), uf.copy(e.boundingSphere).applyMatrix4(hh), this.boundingSphere.union(uf);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  /**
   * Gets the color of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The target object that is used to store the method's result.
   */
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  /**
   * Gets the local transformation matrix of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The target object that is used to store the method's result.
   */
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  /**
   * Gets the morph target weights of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object - The target object that is used to store the method's result.
   */
  getMorphAt(e, t) {
    const i = t.morphTargetInfluences, n = this.morphTexture.source.data.data, r = i.length + 1, o = e * r + 1;
    for (let a = 0; a < i.length; a++)
      i[a] = n[o + a];
  }
  raycast(e, t) {
    const i = this.matrixWorld, n = this.count;
    if (cf.geometry = this.geometry, cf.material = this.material, cf.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), uf.copy(this.boundingSphere), uf.applyMatrix4(i), e.ray.intersectsSphere(uf) !== !1))
      for (let r = 0; r < n; r++) {
        this.getMatrixAt(r, hh), UT.multiplyMatrices(i, hh), cf.matrixWorld = UT, cf.raycast(e, vg);
        for (let o = 0, a = vg.length; o < a; o++) {
          const l = vg[o];
          l.instanceId = r, l.object = this, t.push(l);
        }
        vg.length = 0;
      }
  }
  /**
   * Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceColor} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The instance color.
   */
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Jo(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  /**
   * Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceMatrix} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The the local transformation.
   */
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  /**
   * Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#morphTexture} to `true` after updating all the influences.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object -  A mesh which `morphTargetInfluences` property containing the morph target weights
   * of a single instance.
   */
  setMorphAt(e, t) {
    const i = t.morphTargetInfluences, n = i.length + 1;
    this.morphTexture === null && (this.morphTexture = new yr(new Float32Array(n * this.count), n, this.count, bd, Un));
    const r = this.morphTexture.source.data.data;
    let o = 0;
    for (let c = 0; c < i.length; c++)
      o += i[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o, l = n * e;
    r[l] = a, r.set(i, l + 1);
  }
  updateMorphTargets() {
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
  }
}
const Sx = /* @__PURE__ */ new H(), k4 = /* @__PURE__ */ new H(), O4 = /* @__PURE__ */ new Jt();
class $s {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(e = new H(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), this.constant = n, this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(e, t, i) {
    const n = Sx.subVectors(i, t).cross(k4.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(e, t) {
    const i = e.delta(Sx), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / n;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(e, t) {
    const i = t || O4.getNormalMatrix(e), n = this.coplanarPoint(Sx).applyMatrix4(e), r = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(r), this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const rc = /* @__PURE__ */ new fi(), _g = /* @__PURE__ */ new H();
class hm {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(e = new $s(), t = new $s(), i = new $s(), n = new $s(), r = new $s(), o = new $s()) {
    this.planes = [e, t, i, n, r, o];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(e, t, i, n, r, o) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(e, t = _o) {
    const i = this.planes, n = e.elements, r = n[0], o = n[1], a = n[2], l = n[3], c = n[4], u = n[5], h = n[6], d = n[7], f = n[8], m = n[9], g = n[10], v = n[11], _ = n[12], y = n[13], w = n[14], x = n[15];
    if (i[0].setComponents(l - r, d - c, v - f, x - _).normalize(), i[1].setComponents(l + r, d + c, v + f, x + _).normalize(), i[2].setComponents(l + o, d + u, v + m, x + y).normalize(), i[3].setComponents(l - o, d - u, v - m, x - y).normalize(), i[4].setComponents(l - a, d - h, v - g, x - w).normalize(), t === _o)
      i[5].setComponents(l + a, d + h, v + g, x + w).normalize();
    else if (t === Vp)
      i[5].setComponents(a, h, g, w).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), rc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), rc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(rc);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(e) {
    return rc.center.set(0, 0, 0), rc.radius = 0.7071067811865476, rc.applyMatrix4(e.matrixWorld), this.intersectsSphere(rc);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(e) {
    const t = this.planes, i = e.center, n = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (_g.x = n.normal.x > 0 ? e.max.x : e.min.x, _g.y = n.normal.y > 0 ? e.max.y : e.min.y, _g.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(_g) < 0)
        return !1;
    }
    return !0;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
function Mx(s, e) {
  return s - e;
}
function F4(s, e) {
  return s.z - e.z;
}
function N4(s, e) {
  return e.z - s.z;
}
class B4 {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t, i, n) {
    const r = this.pool, o = this.list;
    this.index >= r.length && r.push({
      start: -1,
      count: -1,
      z: -1,
      index: -1
    });
    const a = r[this.index];
    o.push(a), this.index++, a.start = e, a.count = t, a.z = i, a.index = n;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const es = /* @__PURE__ */ new _t(), z4 = /* @__PURE__ */ new rt(1, 1, 1), Ex = /* @__PURE__ */ new hm(), yg = /* @__PURE__ */ new yn(), sc = /* @__PURE__ */ new fi(), hf = /* @__PURE__ */ new H(), OT = /* @__PURE__ */ new H(), V4 = /* @__PURE__ */ new H(), Tx = /* @__PURE__ */ new B4(), Tr = /* @__PURE__ */ new it(), xg = [];
function G4(s, e, t = 0) {
  const i = e.itemSize;
  if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
    const n = s.count;
    for (let r = 0; r < n; r++)
      for (let o = 0; o < i; o++)
        e.setComponent(r + t, o, s.getComponent(r, o));
  } else
    e.array.set(s.array, t * i);
  e.needsUpdate = !0;
}
function oc(s, e) {
  if (s.constructor !== e.constructor) {
    const t = Math.min(s.length, e.length);
    for (let i = 0; i < t; i++)
      e[i] = s[i];
  } else {
    const t = Math.min(s.length, e.length);
    e.set(new s.constructor(s.buffer, 0, t));
  }
}
class KD extends it {
  /**
   * Constructs a new batched mesh.
   *
   * @param {number} maxInstanceCount - The maximum number of individual instances planned to be added and rendered.
   * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries.
   * @param {number} [maxIndexCount=maxVertexCount*2] - The maximum number of indices to be used by all unique geometries
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e, t, i = t * 2, n) {
    super(new Gt(), n), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = i, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
  }
  /**
   * The maximum number of individual instances that can be stored in the batch.
   *
   * @type {number}
   * @readonly
   */
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  /**
   * The instance count.
   *
   * @type {number}
   * @readonly
   */
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  /**
   * The number of unused vertices.
   *
   * @type {number}
   * @readonly
   */
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  /**
   * The number of unused indices.
   *
   * @type {number}
   * @readonly
   */
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), i = new yr(t, e, e, di, Un);
    this._matricesTexture = i;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e), i = new yr(t, e, e, wd, hs);
    this._indirectTexture = i;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), i = new yr(t, e, e, di, Un);
    i.colorSpace = vn.workingColorSpace, this._colorsTexture = i;
  }
  _initializeGeometry(e) {
    const t = this.geometry, i = this._maxVertexCount, n = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const r in e.attributes) {
        const o = e.getAttribute(r), { array: a, itemSize: l, normalized: c } = o, u = new a.constructor(i * l), h = new Nt(u, l, c);
        t.setAttribute(r, h);
      }
      if (e.getIndex() !== null) {
        const r = i > 65535 ? new Uint32Array(n) : new Uint16Array(n);
        t.setIndex(new Nt(r, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
    for (const i in t.attributes) {
      if (!e.hasAttribute(i))
        throw new Error(`THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
      const n = e.getAttribute(i), r = t.getAttribute(i);
      if (n.itemSize !== r.itemSize || n.normalized !== r.normalized)
        throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  /**
   * Validates the instance defined by the given ID.
   *
   * @param {number} instanceId - The the instance to validate.
   */
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`);
  }
  /**
   * Validates the geometry defined by the given ID.
   *
   * @param {number} geometryId - The the geometry to validate.
   */
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`);
  }
  /**
   * Takes a sort a function that is run before render. The function takes a list of instances to
   * sort and a camera. The objects in the list include a "z" field to perform a depth-ordered sort with.
   *
   * @param {Function} func - The custom sort function.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  /**
   * Computes the bounding box, updating {@link BatchedMesh#boundingBox}.
   * Bounding boxes aren't computed by default. They need to be explicitly computed,
   * otherwise they are `null`.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new yn());
    const e = this.boundingBox, t = this._instanceInfo;
    e.makeEmpty();
    for (let i = 0, n = t.length; i < n; i++) {
      if (t[i].active === !1) continue;
      const r = t[i].geometryIndex;
      this.getMatrixAt(i, es), this.getBoundingBoxAt(r, yg).applyMatrix4(es), e.union(yg);
    }
  }
  /**
   * Computes the bounding sphere, updating {@link BatchedMesh#boundingSphere}.
   * Bounding spheres aren't computed by default. They need to be explicitly computed,
   * otherwise they are `null`.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fi());
    const e = this.boundingSphere, t = this._instanceInfo;
    e.makeEmpty();
    for (let i = 0, n = t.length; i < n; i++) {
      if (t[i].active === !1) continue;
      const r = t[i].geometryIndex;
      this.getMatrixAt(i, es), this.getBoundingSphereAt(r, sc).applyMatrix4(es), e.union(sc);
    }
  }
  /**
   * Adds a new instance to the batch using the geometry of the given ID and returns
   * a new id referring to the new instance to be used by other functions.
   *
   * @param {number} geometryId - The ID of a previously added geometry via {@link BatchedMesh#addGeometry}.
   * @return {number} The instance ID.
   */
  addInstance(e) {
    if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const i = {
      visible: !0,
      active: !0,
      geometryIndex: e
    };
    let n = null;
    this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(Mx), n = this._availableInstanceIds.shift(), this._instanceInfo[n] = i) : (n = this._instanceInfo.length, this._instanceInfo.push(i));
    const r = this._matricesTexture;
    es.identity().toArray(r.image.data, n * 16), r.needsUpdate = !0;
    const o = this._colorsTexture;
    return o && (z4.toArray(o.image.data, n * 4), o.needsUpdate = !0), this._visibilityChanged = !0, n;
  }
  /**
   * Adds the given geometry to the batch and returns the associated
   * geometry id referring to it to be used in other functions.
   *
   * @param {BufferGeometry} geometry - The geometry to add.
   * @param {number} [reservedVertexCount=-1] - Optional parameter specifying the amount of
   * vertex buffer space to reserve for the added geometry. This is necessary if it is planned
   * to set a new geometry at this index at a later time that is larger than the original geometry.
   * Defaults to the length of the given geometry vertex buffer.
   * @param {number} [reservedIndexCount=-1] - Optional parameter specifying the amount of index
   * buffer space to reserve for the added geometry. This is necessary if it is planned to set a
   * new geometry at this index at a later time that is larger than the original geometry. Defaults to
   * the length of the given geometry index buffer.
   * @return {number} The geometry ID.
   */
  addGeometry(e, t = -1, i = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const n = {
      // geometry information
      vertexStart: -1,
      vertexCount: -1,
      reservedVertexCount: -1,
      indexStart: -1,
      indexCount: -1,
      reservedIndexCount: -1,
      // draw range information
      start: -1,
      count: -1,
      // state
      boundingBox: null,
      boundingSphere: null,
      active: !0
    }, r = this._geometryInfo;
    n.vertexStart = this._nextVertexStart, n.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
    const o = e.getIndex();
    if (o !== null && (n.indexStart = this._nextIndexStart, n.reservedIndexCount = i === -1 ? o.count : i), n.indexStart !== -1 && n.indexStart + n.reservedIndexCount > this._maxIndexCount || n.vertexStart + n.reservedVertexCount > this._maxVertexCount)
      throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    let l;
    return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(Mx), l = this._availableGeometryIds.shift(), r[l] = n) : (l = this._geometryCount, this._geometryCount++, r.push(n)), this.setGeometryAt(l, e), this._nextIndexStart = n.indexStart + n.reservedIndexCount, this._nextVertexStart = n.vertexStart + n.reservedVertexCount, l;
  }
  /**
   * Replaces the geometry at the given ID with the provided geometry. Throws an error if there
   * is not enough space reserved for geometry. Calling this will change all instances that are
   * rendering that geometry.
   *
   * @param {number} geometryId - The ID of the geomtry that should be replaced with the given geometry.
   * @param {BufferGeometry} geometry - The new geometry.
   * @return {number} The geometry ID.
   */
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const i = this.geometry, n = i.getIndex() !== null, r = i.getIndex(), o = t.getIndex(), a = this._geometryInfo[e];
    if (n && o.count > a.reservedIndexCount || t.attributes.position.count > a.reservedVertexCount)
      throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
    const l = a.vertexStart, c = a.reservedVertexCount;
    a.vertexCount = t.getAttribute("position").count;
    for (const u in i.attributes) {
      const h = t.getAttribute(u), d = i.getAttribute(u);
      G4(h, d, l);
      const f = h.itemSize;
      for (let m = h.count, g = c; m < g; m++) {
        const v = l + m;
        for (let _ = 0; _ < f; _++)
          d.setComponent(v, _, 0);
      }
      d.needsUpdate = !0, d.addUpdateRange(l * f, c * f);
    }
    if (n) {
      const u = a.indexStart, h = a.reservedIndexCount;
      a.indexCount = t.getIndex().count;
      for (let d = 0; d < o.count; d++)
        r.setX(u + d, l + o.getX(d));
      for (let d = o.count, f = h; d < f; d++)
        r.setX(u + d, l);
      r.needsUpdate = !0, r.addUpdateRange(u, a.reservedIndexCount);
    }
    return a.start = n ? a.indexStart : a.vertexStart, a.count = n ? a.indexCount : a.vertexCount, a.boundingBox = null, t.boundingBox !== null && (a.boundingBox = t.boundingBox.clone()), a.boundingSphere = null, t.boundingSphere !== null && (a.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e;
  }
  /**
   * Deletes the geometry defined by the given ID from this batch. Any instances referencing
   * this geometry will also be removed as a side effect.
   *
   * @param {number} geometryId - The ID of the geomtry to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1)
      return this;
    const i = this._instanceInfo;
    for (let n = 0, r = i.length; n < r; n++)
      i[n].active && i[n].geometryIndex === e && this.deleteInstance(n);
    return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this;
  }
  /**
   * Deletes an existing instance from the batch using the given ID.
   *
   * @param {number} instanceId - The ID of the instance to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  deleteInstance(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this;
  }
  /**
   * Repacks the sub geometries in [name] to remove any unused space remaining from
   * previously deleted geometry, freeing up space to add new geometry.
   *
   * @param {number} instanceId - The ID of the instance to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  optimize() {
    let e = 0, t = 0;
    const i = this._geometryInfo, n = i.map((o, a) => a).sort((o, a) => i[o].vertexStart - i[a].vertexStart), r = this.geometry;
    for (let o = 0, a = i.length; o < a; o++) {
      const l = n[o], c = i[l];
      if (c.active !== !1) {
        if (r.index !== null) {
          if (c.indexStart !== t) {
            const { indexStart: u, vertexStart: h, reservedIndexCount: d } = c, f = r.index, m = f.array, g = e - h;
            for (let v = u; v < u + d; v++)
              m[v] = m[v] + g;
            f.array.copyWithin(t, u, u + d), f.addUpdateRange(t, d), c.indexStart = t;
          }
          t += c.reservedIndexCount;
        }
        if (c.vertexStart !== e) {
          const { vertexStart: u, reservedVertexCount: h } = c, d = r.attributes;
          for (const f in d) {
            const m = d[f], { array: g, itemSize: v } = m;
            g.copyWithin(e * v, u * v, (u + h) * v), m.addUpdateRange(e * v, h * v);
          }
          c.vertexStart = e;
        }
        e += c.reservedVertexCount, c.start = r.index ? c.indexStart : c.vertexStart, this._nextIndexStart = r.index ? c.indexStart + c.reservedIndexCount : 0, this._nextVertexStart = c.vertexStart + c.reservedVertexCount;
      }
    }
    return this;
  }
  /**
   * Returns the bounding box for the given geometry.
   *
   * @param {number} geometryId - The ID of the geometry to return the bounding box for.
   * @param {Box3} target - The target object that is used to store the method's result.
   * @return {Box3|null} The geometry's bounding box. Returns `null` if no geometry has been found for the given ID.
   */
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const i = this.geometry, n = this._geometryInfo[e];
    if (n.boundingBox === null) {
      const r = new yn(), o = i.index, a = i.attributes.position;
      for (let l = n.start, c = n.start + n.count; l < c; l++) {
        let u = l;
        o && (u = o.getX(u)), r.expandByPoint(hf.fromBufferAttribute(a, u));
      }
      n.boundingBox = r;
    }
    return t.copy(n.boundingBox), t;
  }
  /**
   * Returns the bounding sphere for the given geometry.
   *
   * @param {number} geometryId - The ID of the geometry to return the bounding sphere for.
   * @param {Sphere} target - The target object that is used to store the method's result.
   * @return {Sphere|null} The geometry's bounding sphere. Returns `null` if no geometry has been found for the given ID.
   */
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const i = this.geometry, n = this._geometryInfo[e];
    if (n.boundingSphere === null) {
      const r = new fi();
      this.getBoundingBoxAt(e, yg), yg.getCenter(r.center);
      const o = i.index, a = i.attributes.position;
      let l = 0;
      for (let c = n.start, u = n.start + n.count; c < u; c++) {
        let h = c;
        o && (h = o.getX(h)), hf.fromBufferAttribute(a, h), l = Math.max(l, r.center.distanceToSquared(hf));
      }
      r.radius = Math.sqrt(l), n.boundingSphere = r;
    }
    return t.copy(n.boundingSphere), t;
  }
  /**
   * Sets the given local transformation matrix to the defined instance.
   * Negatively scaled matrices are not supported.
   *
   * @param {number} instanceId - The ID of an instance to set the matrix of.
   * @param {Matrix4} matrix - A 4x4 matrix representing the local transformation of a single instance.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const i = this._matricesTexture, n = this._matricesTexture.image.data;
    return t.toArray(n, e * 16), i.needsUpdate = !0, this;
  }
  /**
   * Returns the local transformation matrix of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the matrix of.
   * @param {Matrix4} matrix - The target object that is used to store the method's result.
   * @return {Matrix4} The instance's local transformation matrix.
   */
  getMatrixAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, e * 16);
  }
  /**
   * Sets the given color to the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to set the color of.
   * @param {Color} color - The color to set the instance to.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setColorAt(e, t) {
    return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), t.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this;
  }
  /**
   * Returns the color of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the color of.
   * @param {Color} color - The target object that is used to store the method's result.
   * @return {Color} The instance's color.
   */
  getColorAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, e * 4);
  }
  /**
   * Sets the visibility of the instance.
   *
   * @param {number} instanceId - The id of the instance to set the visibility of.
   * @param {boolean} visible - Whether the instance is visible or not.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setVisibleAt(e, t) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t, this._visibilityChanged = !0, this);
  }
  /**
   * Returns the visibility state of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the visibility state of.
   * @return {boolean} Whether the instance is visible or not.
   */
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  /**
   * Sets the geometry ID of the instance at the given index.
   *
   * @param {number} instanceId - The ID of the instance to set the geometry ID of.
   * @param {number} geometryId - The geometry ID to be use by the instance.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setGeometryIdAt(e, t) {
    return this.validateInstanceId(e), this.validateGeometryId(t), this._instanceInfo[e].geometryIndex = t, this;
  }
  /**
   * Returns the geometry ID of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the geometry ID of.
   * @return {number} The instance's geometry ID.
   */
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  /**
   * Get the range representing the subset of triangles related to the attached geometry,
   * indicating the starting offset and count, or `null` if invalid.
   *
   * @param {number} geometryId - The id of the geometry to get the range of.
   * @param {Object} [target] - The target object that is used to store the method's result.
   * @return {{
   * 	vertexStart:number,vertexCount:number,reservedVertexCount:number,
   * 	indexStart:number,indexCount:number,reservedIndexCount:number,
   * 	start:number,count:number
   * }} The result object with range data.
   */
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const i = this._geometryInfo[e];
    return t.vertexStart = i.vertexStart, t.vertexCount = i.vertexCount, t.reservedVertexCount = i.reservedVertexCount, t.indexStart = i.indexStart, t.indexCount = i.indexCount, t.reservedIndexCount = i.reservedIndexCount, t.start = i.start, t.count = i.count, t;
  }
  /**
   * Resizes the necessary buffers to support the provided number of instances.
   * If the provided arguments shrink the number of instances but there are not enough
   * unused Ids at the end of the list then an error is thrown.
   *
   * @param {number} maxInstanceCount - The max number of individual instances that can be added and rendered by the batch.
  */
  setInstanceCount(e) {
    const t = this._availableInstanceIds, i = this._instanceInfo;
    for (t.sort(Mx); t[t.length - 1] === i.length; )
      i.pop(), t.pop();
    if (e < i.length)
      throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
    const n = new Int32Array(e), r = new Int32Array(e);
    oc(this._multiDrawCounts, n), oc(this._multiDrawStarts, r), this._multiDrawCounts = n, this._multiDrawStarts = r, this._maxInstanceCount = e;
    const o = this._indirectTexture, a = this._matricesTexture, l = this._colorsTexture;
    o.dispose(), this._initIndirectTexture(), oc(o.image.data, this._indirectTexture.image.data), a.dispose(), this._initMatricesTexture(), oc(a.image.data, this._matricesTexture.image.data), l && (l.dispose(), this._initColorsTexture(), oc(l.image.data, this._colorsTexture.image.data));
  }
  /**
   * Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes.
   * If the provided arguments shrink the geometry buffers but there is not enough unused space at the
   * end of the geometry attributes then an error is thrown.
   *
   * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries to resize to.
   * @param {number} maxIndexCount - The maximum number of indices to be used by all unique geometries to resize to.
  */
  setGeometrySize(e, t) {
    const i = [...this._geometryInfo].filter((a) => a.active);
    if (Math.max(...i.map((a) => a.vertexStart + a.reservedVertexCount)) > e)
      throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
    if (this.geometry.index && Math.max(...i.map((l) => l.indexStart + l.reservedIndexCount)) > t)
      throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
    const r = this.geometry;
    r.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new Gt(), this._initializeGeometry(r));
    const o = this.geometry;
    r.index && oc(r.index.array, o.index.array);
    for (const a in r.attributes)
      oc(r.attributes[a].array, o.attributes[a].array);
  }
  raycast(e, t) {
    const i = this._instanceInfo, n = this._geometryInfo, r = this.matrixWorld, o = this.geometry;
    Tr.material = this.material, Tr.geometry.index = o.index, Tr.geometry.attributes = o.attributes, Tr.geometry.boundingBox === null && (Tr.geometry.boundingBox = new yn()), Tr.geometry.boundingSphere === null && (Tr.geometry.boundingSphere = new fi());
    for (let a = 0, l = i.length; a < l; a++) {
      if (!i[a].visible || !i[a].active)
        continue;
      const c = i[a].geometryIndex, u = n[c];
      Tr.geometry.setDrawRange(u.start, u.count), this.getMatrixAt(a, Tr.matrixWorld).premultiply(r), this.getBoundingBoxAt(c, Tr.geometry.boundingBox), this.getBoundingSphereAt(c, Tr.geometry.boundingSphere), Tr.raycast(e, xg);
      for (let h = 0, d = xg.length; h < d; h++) {
        const f = xg[h];
        f.object = this, f.batchId = a, t.push(f);
      }
      xg.length = 0;
    }
    Tr.material = null, Tr.geometry.index = null, Tr.geometry.attributes = {}, Tr.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map((t) => ({
      ...t,
      boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
      boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
    })), this._instanceInfo = e._instanceInfo.map((t) => ({ ...t })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null);
  }
  onBeforeRender(e, t, i, n, r) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const o = n.getIndex(), a = o === null ? 1 : o.array.BYTES_PER_ELEMENT, l = this._instanceInfo, c = this._multiDrawStarts, u = this._multiDrawCounts, h = this._geometryInfo, d = this.perObjectFrustumCulled, f = this._indirectTexture, m = f.image.data;
    d && (es.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), Ex.setFromProjectionMatrix(
      es,
      e.coordinateSystem
    ));
    let g = 0;
    if (this.sortObjects) {
      es.copy(this.matrixWorld).invert(), hf.setFromMatrixPosition(i.matrixWorld).applyMatrix4(es), OT.set(0, 0, -1).transformDirection(i.matrixWorld).transformDirection(es);
      for (let y = 0, w = l.length; y < w; y++)
        if (l[y].visible && l[y].active) {
          const x = l[y].geometryIndex;
          this.getMatrixAt(y, es), this.getBoundingSphereAt(x, sc).applyMatrix4(es);
          let M = !1;
          if (d && (M = !Ex.intersectsSphere(sc)), !M) {
            const A = h[x], E = V4.subVectors(sc.center, hf).dot(OT);
            Tx.push(A.start, A.count, E, y);
          }
        }
      const v = Tx.list, _ = this.customSort;
      _ === null ? v.sort(r.transparent ? N4 : F4) : _.call(this, v, i);
      for (let y = 0, w = v.length; y < w; y++) {
        const x = v[y];
        c[g] = x.start * a, u[g] = x.count, m[g] = x.index, g++;
      }
      Tx.reset();
    } else
      for (let v = 0, _ = l.length; v < _; v++)
        if (l[v].visible && l[v].active) {
          const y = l[v].geometryIndex;
          let w = !1;
          if (d && (this.getMatrixAt(v, es), this.getBoundingSphereAt(y, sc).applyMatrix4(es), w = !Ex.intersectsSphere(sc)), !w) {
            const x = h[y];
            c[g] = x.start * a, u[g] = x.count, m[g] = v, g++;
          }
        }
    f.needsUpdate = !0, this._multiDrawCount = g, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, i, n, r, o) {
    this.onBeforeRender(e, null, n, r, o);
  }
}
class Bi extends ji {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new rt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const q0 = /* @__PURE__ */ new H(), Z0 = /* @__PURE__ */ new H(), FT = /* @__PURE__ */ new _t(), df = /* @__PURE__ */ new Ol(), bg = /* @__PURE__ */ new fi(), Ax = /* @__PURE__ */ new H(), NT = /* @__PURE__ */ new H();
class Ui extends tn {
  /**
   * Constructs a new line.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e = new Gt(), t = new Bi()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {Line} A reference to this line.
   */
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let n = 1, r = t.count; n < r; n++)
        q0.fromBufferAttribute(t, n - 1), Z0.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += q0.distanceTo(Z0);
      e.setAttribute("lineDistance", new Tt(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Line.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), bg.copy(i.boundingSphere), bg.applyMatrix4(n), bg.radius += r, e.ray.intersectsSphere(bg) === !1) return;
    FT.copy(n).invert(), df.copy(e.ray).applyMatrix4(FT);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = this.isLineSegments ? 2 : 1, u = i.index, d = i.attributes.position;
    if (u !== null) {
      const f = Math.max(0, o.start), m = Math.min(u.count, o.start + o.count);
      for (let g = f, v = m - 1; g < v; g += c) {
        const _ = u.getX(g), y = u.getX(g + 1), w = wg(this, e, df, l, _, y, g);
        w && t.push(w);
      }
      if (this.isLineLoop) {
        const g = u.getX(m - 1), v = u.getX(f), _ = wg(this, e, df, l, g, v, m - 1);
        _ && t.push(_);
      }
    } else {
      const f = Math.max(0, o.start), m = Math.min(d.count, o.start + o.count);
      for (let g = f, v = m - 1; g < v; g += c) {
        const _ = wg(this, e, df, l, g, g + 1, g);
        _ && t.push(_);
      }
      if (this.isLineLoop) {
        const g = wg(this, e, df, l, m - 1, f, m - 1);
        g && t.push(g);
      }
    }
  }
  /**
   * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = n.length; r < o; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function wg(s, e, t, i, n, r, o) {
  const a = s.geometry.attributes.position;
  if (q0.fromBufferAttribute(a, n), Z0.fromBufferAttribute(a, r), t.distanceSqToSegment(q0, Z0, Ax, NT) > i) return;
  Ax.applyMatrix4(s.matrixWorld);
  const c = e.ray.origin.distanceTo(Ax);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: NT.clone().applyMatrix4(s.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s
    };
}
const BT = /* @__PURE__ */ new H(), zT = /* @__PURE__ */ new H();
class so extends Ui {
  /**
   * Constructs a new line segments.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let n = 0, r = t.count; n < r; n += 2)
        BT.fromBufferAttribute(t, n), zT.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + BT.distanceTo(zT);
      e.setAttribute("lineDistance", new Tt(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class iS extends Ui {
  /**
   * Constructs a new line loop.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class D_ extends ji {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const VT = /* @__PURE__ */ new _t(), x1 = /* @__PURE__ */ new Ol(), Sg = /* @__PURE__ */ new fi(), Mg = /* @__PURE__ */ new H();
class I_ extends tn {
  /**
   * Constructs a new point cloud.
   *
   * @param {BufferGeometry} [geometry] - The points geometry.
   * @param {Material|Array<Material>} [material] - The points material.
   */
  constructor(e = new Gt(), t = new D_()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Computes intersection points between a casted ray and this point cloud.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Points.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Sg.copy(i.boundingSphere), Sg.applyMatrix4(n), Sg.radius += r, e.ray.intersectsSphere(Sg) === !1) return;
    VT.copy(n).invert(), x1.copy(e.ray).applyMatrix4(VT);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = i.index, h = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, o.start), f = Math.min(c.count, o.start + o.count);
      for (let m = d, g = f; m < g; m++) {
        const v = c.getX(m);
        Mg.fromBufferAttribute(h, v), GT(Mg, v, l, n, e, t, this);
      }
    } else {
      const d = Math.max(0, o.start), f = Math.min(h.count, o.start + o.count);
      for (let m = d, g = f; m < g; m++)
        Mg.fromBufferAttribute(h, m), GT(Mg, m, l, n, e, t, this);
    }
  }
  /**
   * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = n.length; r < o; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function GT(s, e, t, i, n, r, o) {
  const a = x1.distanceSqToPoint(s);
  if (a < t) {
    const l = new H();
    x1.closestPointToPoint(s, l), l.applyMatrix4(i);
    const c = n.ray.origin.distanceTo(l);
    if (c < n.near || c > n.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o
    });
  }
}
class $D extends ei {
  constructor(e, t, i, n, r, o, a, l, c) {
    super(e, t, i, n, r, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Sn, this.magFilter = r !== void 0 ? r : Sn, this.generateMipmaps = !1;
    const u = this;
    function h() {
      u.needsUpdate = !0, e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class H4 extends $D {
  constructor(e, t, i, n, r, o, a, l) {
    super({}, e, t, i, n, r, o, a, l), this.isVideoFrameTexture = !0;
  }
  update() {
  }
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(e) {
    this.image = e, this.needsUpdate = !0;
  }
}
class W4 extends ei {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Tn, this.minFilter = Tn, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class L_ extends ei {
  constructor(e, t, i, n, r, o, a, l, c, u, h, d) {
    super(null, o, a, l, c, u, n, r, h, d), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class X4 extends L_ {
  constructor(e, t, i, n, r, o) {
    super(e, t, i, r, o), this.isCompressedArrayTexture = !0, this.image.depth = n, this.wrapR = gr, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Y4 extends L_ {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, Ia), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class U_ extends ei {
  constructor(e, t, i, n, r, o, a, l, c) {
    super(e, t, i, n, r, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class rS extends ei {
  constructor(e, t, i, n, r, o, a, l, c, u = eu) {
    if (u !== eu && u !== gu)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && u === eu && (i = hs), i === void 0 && u === gu && (i = mu), super(null, n, r, o, a, l, u, i, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : Tn, this.minFilter = l !== void 0 ? l : Tn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.source = new yl(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class Mo {
  /**
   * Constructs a new curve.
   */
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor.
   *
   * @abstract
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor. Unlike {@link Curve#getPoint}, this method honors the length
   * of the curve which equidistant samples.
   *
   * @param {number} u - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  /**
   * This method samples the curve via {@link Curve#getPoint} and returns an array of points representing
   * the curve shape.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  /**
   * This method samples the curve via {@link Curve#getPointAt} and returns an array of points representing
   * the curve shape. Unlike {@link Curve#getPoints}, this method returns equi-spaced points across the entire
   * curve.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  }
  /**
   * Returns the total arc length of the curve.
   *
   * @return {number} The length of the curve.
   */
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  /**
   * Returns an array of cumulative segment lengths of the curve.
   *
   * @param {number} [divisions=this.arcLengthDivisions] - The number of divisions.
   * @return {Array<number>} An array holding the cumulative segment lengths.
   */
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i, n = this.getPoint(0), r = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      i = this.getPoint(o / e), r += i.distanceTo(n), t.push(r), n = i;
    return this.cacheArcLengths = t, t;
  }
  /**
   * Update the cumulative segment distance cache. The method must be called
   * every time curve parameters are changed. If an updated curve is part of a
   * composed curve like {@link CurvePath}, this method must be called on the
   * composed curve, too.
   */
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  /**
   * Given an interpolation factor in the range `[0,1]`, this method returns an updated
   * interpolation factor in the same range that can be ued to sample equidistant points
   * from a curve.
   *
   * @param {number} u - The interpolation factor.
   * @param {?number} distance - An optional distance on the curve.
   * @return {number} The updated interpolation factor.
   */
  getUtoTmapping(e, t = null) {
    const i = this.getLengths();
    let n = 0;
    const r = i.length;
    let o;
    t ? o = t : o = e * i[r - 1];
    let a = 0, l = r - 1, c;
    for (; a <= l; )
      if (n = Math.floor(a + (l - a) / 2), c = i[n] - o, c < 0)
        a = n + 1;
      else if (c > 0)
        l = n - 1;
      else {
        l = n;
        break;
      }
    if (n = l, i[n] === o)
      return n / (r - 1);
    const u = i[n], d = i[n + 1] - u, f = (o - u) / d;
    return (n + f) / (r - 1);
  }
  /**
   * Returns a unit vector tangent for the given interpolation factor.
   * If the derived curve does not implement its tangent derivation,
   * two points a small delta apart will be used to find its gradient
   * which seems to give a reasonable approximation.
   *
   * @param {number} t - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   */
  getTangent(e, t) {
    let n = e - 1e-4, r = e + 1e-4;
    n < 0 && (n = 0), r > 1 && (r = 1);
    const o = this.getPoint(n), a = this.getPoint(r), l = t || (o.isVector2 ? new Be() : new H());
    return l.copy(a).sub(o).normalize(), l;
  }
  /**
   * Same as {@link Curve#getTangent} but with equidistant samples.
   *
   * @param {number} u - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   * @see {@link Curve#getPointAt}
   */
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  /**
   * Generates the Frenet Frames. Requires a curve definition in 3D space. Used
   * in geometries like {@link TubeGeometry} or {@link ExtrudeGeometry}.
   *
   * @param {number} segments - The number of segments.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @return {{tangents: Array<Vector3>, normals: Array<Vector3>, binormals: Array<Vector3>}} The Frenet Frames.
   */
  computeFrenetFrames(e, t = !1) {
    const i = new H(), n = [], r = [], o = [], a = new H(), l = new _t();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      n[f] = this.getTangentAt(m, new H());
    }
    r[0] = new H(), o[0] = new H();
    let c = Number.MAX_VALUE;
    const u = Math.abs(n[0].x), h = Math.abs(n[0].y), d = Math.abs(n[0].z);
    u <= c && (c = u, i.set(1, 0, 0)), h <= c && (c = h, i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), o[0].crossVectors(n[0], r[0]);
    for (let f = 1; f <= e; f++) {
      if (r[f] = r[f - 1].clone(), o[f] = o[f - 1].clone(), a.crossVectors(n[f - 1], n[f]), a.length() > Number.EPSILON) {
        a.normalize();
        const m = Math.acos(Qt(n[f - 1].dot(n[f]), -1, 1));
        r[f].applyMatrix4(l.makeRotationAxis(a, m));
      }
      o[f].crossVectors(n[f], r[f]);
    }
    if (t === !0) {
      let f = Math.acos(Qt(r[0].dot(r[e]), -1, 1));
      f /= e, n[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        r[m].applyMatrix4(l.makeRotationAxis(n[m], f * m)), o[m].crossVectors(n[m], r[m]);
    }
    return {
      tangents: n,
      normals: r,
      binormals: o
    };
  }
  /**
   * Returns a new curve with copied values from this instance.
   *
   * @return {Curve} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given curve to this instance.
   *
   * @param {Curve} source - The curve to copy.
   * @return {Curve} A reference to this curve.
   */
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  /**
   * Serializes the curve into JSON.
   *
   * @return {Object} A JSON object representing the serialized curve.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  /**
   * Deserializes the curve from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized curve.
   * @return {Curve} A reference to this curve.
   */
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class k_ extends Mo {
  /**
   * Constructs a new ellipse curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   */
  constructor(e = 0, t = 0, i = 1, n = 1, r = 0, o = Math.PI * 2, a = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Be()) {
    const i = t, n = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += n;
    for (; r > n; ) r -= n;
    r < Number.EPSILON && (o ? r = 0 : r = n), this.aClockwise === !0 && !o && (r === n ? r = -n : r = r - n);
    const a = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = l - this.aX, f = c - this.aY;
      l = d * u - f * h + this.aX, c = d * h + f * u + this.aY;
    }
    return i.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class JD extends k_ {
  /**
   * Constructs a new arc curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [aRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   */
  constructor(e, t, i, n, r, o) {
    super(e, t, i, i, n, r, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function sS() {
  let s = 0, e = 0, t = 0, i = 0;
  function n(r, o, a, l) {
    s = r, e = a, t = -3 * r + 3 * o - 2 * a - l, i = 2 * r - 2 * o + a + l;
  }
  return {
    initCatmullRom: function(r, o, a, l, c) {
      n(o, a, c * (a - r), c * (l - o));
    },
    initNonuniformCatmullRom: function(r, o, a, l, c, u, h) {
      let d = (o - r) / c - (a - r) / (c + u) + (a - o) / u, f = (a - o) / u - (l - o) / (u + h) + (l - a) / h;
      d *= u, f *= u, n(o, a, d, f);
    },
    calc: function(r) {
      const o = r * r, a = o * r;
      return s + e * r + t * o + i * a;
    }
  };
}
const Eg = /* @__PURE__ */ new H(), Cx = /* @__PURE__ */ new sS(), Px = /* @__PURE__ */ new sS(), Rx = /* @__PURE__ */ new sS();
class QD extends Mo {
  /**
   * Constructs a new Catmull-Rom curve.
   *
   * @param {Array<Vector3>} [points] - An array of 3D points defining the curve.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @param {('centripetal'|'chordal'|'catmullrom')} [curveType='centripetal'] - The curve type.
   * @param {number} [tension=0.5] - Tension of the curve.
   */
  constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new H()) {
    const i = t, n = this.points, r = n.length, o = (r - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o), l = o - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
    let c, u;
    this.closed || a > 0 ? c = n[(a - 1) % r] : (Eg.subVectors(n[0], n[1]).add(n[0]), c = Eg);
    const h = n[a % r], d = n[(a + 1) % r];
    if (this.closed || a + 2 < r ? u = n[(a + 2) % r] : (Eg.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), u = Eg), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(h), f), g = Math.pow(h.distanceToSquared(d), f), v = Math.pow(d.distanceToSquared(u), f);
      g < 1e-4 && (g = 1), m < 1e-4 && (m = g), v < 1e-4 && (v = g), Cx.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, m, g, v), Px.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, m, g, v), Rx.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, m, g, v);
    } else this.curveType === "catmullrom" && (Cx.initCatmullRom(c.x, h.x, d.x, u.x, this.tension), Px.initCatmullRom(c.y, h.y, d.y, u.y, this.tension), Rx.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
    return i.set(
      Cx.calc(l),
      Px.calc(l),
      Rx.calc(l)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new H().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function HT(s, e, t, i, n) {
  const r = (i - e) * 0.5, o = (n - t) * 0.5, a = s * s, l = s * a;
  return (2 * t - 2 * i + r + o) * l + (-3 * t + 3 * i - 2 * r - o) * a + r * s + t;
}
function j4(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function q4(s, e) {
  return 2 * (1 - s) * s * e;
}
function Z4(s, e) {
  return s * s * e;
}
function hp(s, e, t, i) {
  return j4(s, e) + q4(s, t) + Z4(s, i);
}
function K4(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function $4(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function J4(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function Q4(s, e) {
  return s * s * s * e;
}
function dp(s, e, t, i, n) {
  return K4(s, e) + $4(s, t) + J4(s, i) + Q4(s, n);
}
class oS extends Mo {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The first control point.
   * @param {Vector2} [v2] - The second control point.
   * @param {Vector2} [v3] - The end point.
   */
  constructor(e = new Be(), t = new Be(), i = new Be(), n = new Be()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Be()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2, a = this.v3;
    return i.set(
      dp(e, n.x, r.x, o.x, a.x),
      dp(e, n.y, r.y, o.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class eI extends Mo {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The first control point.
   * @param {Vector3} [v2] - The second control point.
   * @param {Vector3} [v3] - The end point.
   */
  constructor(e = new H(), t = new H(), i = new H(), n = new H()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new H()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2, a = this.v3;
    return i.set(
      dp(e, n.x, r.x, o.x, a.x),
      dp(e, n.y, r.y, o.y, a.y),
      dp(e, n.z, r.z, o.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class aS extends Mo {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector2} [v1] - The start point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new Be(), t = new Be()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the line.
   */
  getPoint(e, t = new Be()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Be()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class tI extends Mo {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector3} [v1] - The start point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new H(), t = new H()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the line.
   */
  getPoint(e, t = new H()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new H()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class lS extends Mo {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The control point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new Be(), t = new Be(), i = new Be()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Be()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2;
    return i.set(
      hp(e, n.x, r.x, o.x),
      hp(e, n.y, r.y, o.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class cS extends Mo {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The control point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new H(), t = new H(), i = new H()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new H()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2;
    return i.set(
      hp(e, n.x, r.x, o.x),
      hp(e, n.y, r.y, o.y),
      hp(e, n.z, r.z, o.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class uS extends Mo {
  /**
   * Constructs a new 2D spline curve.
   *
   * @param {Array<Vector2>} [points] -  An array of 2D points defining the curve.
   */
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Be()) {
    const i = t, n = this.points, r = (n.length - 1) * e, o = Math.floor(r), a = r - o, l = n[o === 0 ? o : o - 1], c = n[o], u = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
    return i.set(
      HT(a, l.x, c.x, u.x, h.x),
      HT(a, l.y, c.y, u.y, h.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new Be().fromArray(n));
    }
    return this;
  }
}
var K0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: JD,
  CatmullRomCurve3: QD,
  CubicBezierCurve: oS,
  CubicBezierCurve3: eI,
  EllipseCurve: k_,
  LineCurve: aS,
  LineCurve3: tI,
  QuadraticBezierCurve: lS,
  QuadraticBezierCurve3: cS,
  SplineCurve: uS
});
class nI extends Mo {
  /**
   * Constructs a new curve path.
   */
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  /**
   * Adds a curve to this curve path.
   *
   * @param {Curve} curve - The curve to add.
   */
  add(e) {
    this.curves.push(e);
  }
  /**
   * Adds a line curve to close the path.
   *
   * @return {CurvePath} A reference to this curve path.
   */
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new K0[i](t, e));
    }
    return this;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definitions)
   * for the given interpolation factor.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint(e, t) {
    const i = e * this.getLength(), n = this.getCurveLengths();
    let r = 0;
    for (; r < n.length; ) {
      if (n[r] >= i) {
        const o = n[r] - i, a = this.curves[r], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(c, t);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  /**
   * Returns list of cumulative curve lengths of the defined curves.
   *
   * @return {Array<number>} The curve lengths.
   */
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, n = this.curves.length; i < n; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let n = 0, r = this.curves; n < r.length; n++) {
      const o = r[n], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        i && i.equals(u) || (t.push(u), i = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(new K0[n.type]().fromJSON(n));
    }
    return this;
  }
}
class Hp extends nI {
  /**
   * Constructs a new path.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the path.
   */
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Be(), e && this.setFromPoints(e);
  }
  /**
   * Creates a path from the given list of points. The points are added
   * to the path as instances of {@link LineCurve}.
   *
   * @param {Array<Vector2>} points - An array of 2D points.
   * @return {Path} A reference to this path.
   */
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  /**
   * Moves {@link Path#currentPoint} to the given point.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {Path} A reference to this path.
   */
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  lineTo(e, t) {
    const i = new aS(this.currentPoint.clone(), new Be(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  quadraticCurveTo(e, t, i, n) {
    const r = new lS(
      this.currentPoint.clone(),
      new Be(e, t),
      new Be(i, n)
    );
    return this.curves.push(r), this.currentPoint.set(i, n), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  bezierCurveTo(e, t, i, n, r, o) {
    const a = new oS(
      this.currentPoint.clone(),
      new Be(e, t),
      new Be(i, n),
      new Be(r, o)
    );
    return this.curves.push(a), this.currentPoint.set(r, o), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {Path} A reference to this path.
   */
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new uS(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  /**
   * Adds an arc as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point.
   *
   * @param {number} aX - The x coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} aY - The y coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} aRadius - The radius of the arc.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  arc(e, t, i, n, r, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + a,
      t + l,
      i,
      n,
      r,
      o
    ), this;
  }
  /**
   * Adds an absolutely positioned arc as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} aX - The x coordinate of the center of the arc.
   * @param {number} aY - The y coordinate of the center of the arc.
   * @param {number} aRadius - The radius of the arc.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  absarc(e, t, i, n, r, o) {
    return this.absellipse(e, t, i, i, n, r, o), this;
  }
  /**
   * Adds an ellipse as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point
   *
   * @param {number} aX - The x coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} aY - The y coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} xRadius - The radius of the ellipse in the x axis.
   * @param {number} yRadius - The radius of the ellipse in the y axis.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {boolean} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  ellipse(e, t, i, n, r, o, a, l) {
    const c = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + c, t + u, i, n, r, o, a, l), this;
  }
  /**
   * Adds an absolutely positioned ellipse as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} aX - The x coordinate of the absolute center of the ellipse.
   * @param {number} aY - The y coordinate of the absolute center of the ellipse.
   * @param {number} xRadius - The radius of the ellipse in the x axis.
   * @param {number} yRadius - The radius of the ellipse in the y axis.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  absellipse(e, t, i, n, r, o, a, l) {
    const c = new k_(e, t, i, n, r, o, a, l);
    if (this.curves.length > 0) {
      const h = c.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class dm extends Gt {
  /**
   * Constructs a new lathe geometry.
   *
   * @param {Array<Vector2>} [points] - An array of points in 2D space. The x-coordinate of each point
   * must be greater than zero.
   * @param {number} [segments=12] - The number of circumference segments to generate.
   * @param {number} [phiStart=0] - The starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The radian (0 to 2PI) range of the lathed section 2PI is a
   * closed lathe, less than 2PI is a portion.
   */
  constructor(e = [new Be(0, -0.5), new Be(0.5, 0), new Be(0, 0.5)], t = 12, i = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: i,
      phiLength: n
    }, t = Math.floor(t), n = Qt(n, 0, Math.PI * 2);
    const r = [], o = [], a = [], l = [], c = [], u = 1 / t, h = new H(), d = new Be(), f = new H(), m = new H(), g = new H();
    let v = 0, _ = 0;
    for (let y = 0; y <= e.length - 1; y++)
      switch (y) {
        case 0:
          v = e[y + 1].x - e[y].x, _ = e[y + 1].y - e[y].y, f.x = _ * 1, f.y = -v, f.z = _ * 0, g.copy(f), f.normalize(), l.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          l.push(g.x, g.y, g.z);
          break;
        default:
          v = e[y + 1].x - e[y].x, _ = e[y + 1].y - e[y].y, f.x = _ * 1, f.y = -v, f.z = _ * 0, m.copy(f), f.x += g.x, f.y += g.y, f.z += g.z, f.normalize(), l.push(f.x, f.y, f.z), g.copy(m);
      }
    for (let y = 0; y <= t; y++) {
      const w = i + y * u * n, x = Math.sin(w), M = Math.cos(w);
      for (let A = 0; A <= e.length - 1; A++) {
        h.x = e[A].x * x, h.y = e[A].y, h.z = e[A].x * M, o.push(h.x, h.y, h.z), d.x = y / t, d.y = A / (e.length - 1), a.push(d.x, d.y);
        const E = l[3 * A + 0] * x, C = l[3 * A + 1], P = l[3 * A + 0] * M;
        c.push(E, C, P);
      }
    }
    for (let y = 0; y < t; y++)
      for (let w = 0; w < e.length - 1; w++) {
        const x = w + y * e.length, M = x, A = x + e.length, E = x + e.length + 1, C = x + 1;
        r.push(M, A, C), r.push(E, C, A);
      }
    this.setIndex(r), this.setAttribute("position", new Tt(o, 3)), this.setAttribute("uv", new Tt(a, 2)), this.setAttribute("normal", new Tt(c, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {LatheGeometry} A new instance.
   */
  static fromJSON(e) {
    return new dm(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class O_ extends dm {
  /**
   * Constructs a new capsule geometry.
   *
   * @param {number} [radius=1] - Radius of the capsule.
   * @param {number} [length=1] - Length of the middle section.
   * @param {number} [capSegments=4] - Number of curve segments used to build the caps.
   * @param {number} [radialSegments=8] - Number of segmented faces around the circumference of the capsule.
   */
  constructor(e = 1, t = 1, i = 4, n = 8) {
    const r = new Hp();
    r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: i,
      radialSegments: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CapsuleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new O_(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class F_ extends Gt {
  /**
   * Constructs a new circle geometry.
   *
   * @param {number} [radius=1] - Radius of the circle.
   * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.
   * @param {number} [thetaStart=0] - Start angle for first segment in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,
   * of the circular sector in radians. The default value results in a complete circle.
   */
  constructor(e = 1, t = 32, i = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: i,
      thetaLength: n
    }, t = Math.max(3, t);
    const r = [], o = [], a = [], l = [], c = new H(), u = new Be();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let h = 0, d = 3; h <= t; h++, d += 3) {
      const f = i + h / t * n;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), o.push(c.x, c.y, c.z), a.push(0, 0, 1), u.x = (o[d] / e + 1) / 2, u.y = (o[d + 1] / e + 1) / 2, l.push(u.x, u.y);
    }
    for (let h = 1; h <= t; h++)
      r.push(h, h + 1, 0);
    this.setIndex(r), this.setAttribute("position", new Tt(o, 3)), this.setAttribute("normal", new Tt(a, 3)), this.setAttribute("uv", new Tt(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CircleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new F_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Di extends Gt {
  /**
   * Constructs a new cylinder geometry.
   *
   * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
   * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
   * @param {number} [height=1] - Height of the cylinder.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
   * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
   * @param {boolean} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {boolean} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cylinder.
   */
  constructor(e = 1, t = 1, i = 1, n = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: i,
      radialSegments: n,
      heightSegments: r,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
    const c = this;
    n = Math.floor(n), r = Math.floor(r);
    const u = [], h = [], d = [], f = [];
    let m = 0;
    const g = [], v = i / 2;
    let _ = 0;
    y(), o === !1 && (e > 0 && w(!0), t > 0 && w(!1)), this.setIndex(u), this.setAttribute("position", new Tt(h, 3)), this.setAttribute("normal", new Tt(d, 3)), this.setAttribute("uv", new Tt(f, 2));
    function y() {
      const x = new H(), M = new H();
      let A = 0;
      const E = (t - e) / i;
      for (let C = 0; C <= r; C++) {
        const P = [], T = C / r, I = T * (t - e) + e;
        for (let D = 0; D <= n; D++) {
          const U = D / n, L = U * l + a, k = Math.sin(L), B = Math.cos(L);
          M.x = I * k, M.y = -T * i + v, M.z = I * B, h.push(M.x, M.y, M.z), x.set(k, E, B).normalize(), d.push(x.x, x.y, x.z), f.push(U, 1 - T), P.push(m++);
        }
        g.push(P);
      }
      for (let C = 0; C < n; C++)
        for (let P = 0; P < r; P++) {
          const T = g[P][C], I = g[P + 1][C], D = g[P + 1][C + 1], U = g[P][C + 1];
          (e > 0 || P !== 0) && (u.push(T, I, U), A += 3), (t > 0 || P !== r - 1) && (u.push(I, D, U), A += 3);
        }
      c.addGroup(_, A, 0), _ += A;
    }
    function w(x) {
      const M = m, A = new Be(), E = new H();
      let C = 0;
      const P = x === !0 ? e : t, T = x === !0 ? 1 : -1;
      for (let D = 1; D <= n; D++)
        h.push(0, v * T, 0), d.push(0, T, 0), f.push(0.5, 0.5), m++;
      const I = m;
      for (let D = 0; D <= n; D++) {
        const L = D / n * l + a, k = Math.cos(L), B = Math.sin(L);
        E.x = P * B, E.y = v * T, E.z = P * k, h.push(E.x, E.y, E.z), d.push(0, T, 0), A.x = k * 0.5 + 0.5, A.y = B * 0.5 * T + 0.5, f.push(A.x, A.y), m++;
      }
      for (let D = 0; D < n; D++) {
        const U = M + D, L = I + D;
        x === !0 ? u.push(L, L + 1, U) : u.push(L + 1, L, U), C += 3;
      }
      c.addGroup(_, C, x === !0 ? 1 : 2), _ += C;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CylinderGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Di(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class N_ extends Di {
  /**
   * Constructs a new cone geometry.
   *
   * @param {number} [radius=1] - Radius of the cone base.
   * @param {number} [height=1] - Height of the cone.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cone.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cone.
   * @param {boolean} [openEnded=false] - Whether the base of the cone is open or capped.
   * @param {boolean} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {boolean} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cone.
   */
  constructor(e = 1, t = 1, i = 32, n = 1, r = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: i,
      heightSegments: n,
      openEnded: r,
      thetaStart: o,
      thetaLength: a
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {ConeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new N_(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Nl extends Gt {
  /**
   * Constructs a new polyhedron geometry.
   *
   * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.
   * @param {Array<number>} [indices] - A flat array of indices describing the base shape.
   * @param {number} [radius=1] - The radius of the shape.
   * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.
   */
  constructor(e = [], t = [], i = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: i,
      detail: n
    };
    const r = [], o = [];
    a(n), c(i), u(), this.setAttribute("position", new Tt(r, 3)), this.setAttribute("normal", new Tt(r.slice(), 3)), this.setAttribute("uv", new Tt(o, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(y) {
      const w = new H(), x = new H(), M = new H();
      for (let A = 0; A < t.length; A += 3)
        f(t[A + 0], w), f(t[A + 1], x), f(t[A + 2], M), l(w, x, M, y);
    }
    function l(y, w, x, M) {
      const A = M + 1, E = [];
      for (let C = 0; C <= A; C++) {
        E[C] = [];
        const P = y.clone().lerp(x, C / A), T = w.clone().lerp(x, C / A), I = A - C;
        for (let D = 0; D <= I; D++)
          D === 0 && C === A ? E[C][D] = P : E[C][D] = P.clone().lerp(T, D / I);
      }
      for (let C = 0; C < A; C++)
        for (let P = 0; P < 2 * (A - C) - 1; P++) {
          const T = Math.floor(P / 2);
          P % 2 === 0 ? (d(E[C][T + 1]), d(E[C + 1][T]), d(E[C][T])) : (d(E[C][T + 1]), d(E[C + 1][T + 1]), d(E[C + 1][T]));
        }
    }
    function c(y) {
      const w = new H();
      for (let x = 0; x < r.length; x += 3)
        w.x = r[x + 0], w.y = r[x + 1], w.z = r[x + 2], w.normalize().multiplyScalar(y), r[x + 0] = w.x, r[x + 1] = w.y, r[x + 2] = w.z;
    }
    function u() {
      const y = new H();
      for (let w = 0; w < r.length; w += 3) {
        y.x = r[w + 0], y.y = r[w + 1], y.z = r[w + 2];
        const x = v(y) / 2 / Math.PI + 0.5, M = _(y) / Math.PI + 0.5;
        o.push(x, 1 - M);
      }
      m(), h();
    }
    function h() {
      for (let y = 0; y < o.length; y += 6) {
        const w = o[y + 0], x = o[y + 2], M = o[y + 4], A = Math.max(w, x, M), E = Math.min(w, x, M);
        A > 0.9 && E < 0.1 && (w < 0.2 && (o[y + 0] += 1), x < 0.2 && (o[y + 2] += 1), M < 0.2 && (o[y + 4] += 1));
      }
    }
    function d(y) {
      r.push(y.x, y.y, y.z);
    }
    function f(y, w) {
      const x = y * 3;
      w.x = e[x + 0], w.y = e[x + 1], w.z = e[x + 2];
    }
    function m() {
      const y = new H(), w = new H(), x = new H(), M = new H(), A = new Be(), E = new Be(), C = new Be();
      for (let P = 0, T = 0; P < r.length; P += 9, T += 6) {
        y.set(r[P + 0], r[P + 1], r[P + 2]), w.set(r[P + 3], r[P + 4], r[P + 5]), x.set(r[P + 6], r[P + 7], r[P + 8]), A.set(o[T + 0], o[T + 1]), E.set(o[T + 2], o[T + 3]), C.set(o[T + 4], o[T + 5]), M.copy(y).add(w).add(x).divideScalar(3);
        const I = v(M);
        g(A, T + 0, y, I), g(E, T + 2, w, I), g(C, T + 4, x, I);
      }
    }
    function g(y, w, x, M) {
      M < 0 && y.x === 1 && (o[w] = y.x - 1), x.x === 0 && x.z === 0 && (o[w] = M / 2 / Math.PI + 0.5);
    }
    function v(y) {
      return Math.atan2(y.z, -y.x);
    }
    function _(y) {
      return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PolyhedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Nl(e.vertices, e.indices, e.radius, e.details);
  }
}
class B_ extends Nl {
  /**
   * Constructs a new dodecahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the dodecahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron.
   */
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = 1 / i, r = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      // (1/, , 0)
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      0,
      // (, 0, 1/)
      -i,
      0,
      -n,
      i,
      0,
      -n,
      -i,
      0,
      n,
      i,
      0,
      n
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {DodecahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new B_(e.radius, e.detail);
  }
}
const Tg = /* @__PURE__ */ new H(), Ag = /* @__PURE__ */ new H(), Dx = /* @__PURE__ */ new H(), Cg = /* @__PURE__ */ new Xi();
class iI extends Gt {
  /**
   * Constructs a new edges geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   * @param {number} [thresholdAngle=1] - An edge is only rendered if the angle (in degrees)
   * between the face normals of the adjoining faces exceeds this value.
   */
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const n = Math.pow(10, 4), r = Math.cos(tu * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, c = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), d = {}, f = [];
      for (let m = 0; m < l; m += 3) {
        o ? (c[0] = o.getX(m), c[1] = o.getX(m + 1), c[2] = o.getX(m + 2)) : (c[0] = m, c[1] = m + 1, c[2] = m + 2);
        const { a: g, b: v, c: _ } = Cg;
        if (g.fromBufferAttribute(a, c[0]), v.fromBufferAttribute(a, c[1]), _.fromBufferAttribute(a, c[2]), Cg.getNormal(Dx), h[0] = `${Math.round(g.x * n)},${Math.round(g.y * n)},${Math.round(g.z * n)}`, h[1] = `${Math.round(v.x * n)},${Math.round(v.y * n)},${Math.round(v.z * n)}`, h[2] = `${Math.round(_.x * n)},${Math.round(_.y * n)},${Math.round(_.z * n)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
          for (let y = 0; y < 3; y++) {
            const w = (y + 1) % 3, x = h[y], M = h[w], A = Cg[u[y]], E = Cg[u[w]], C = `${x}_${M}`, P = `${M}_${x}`;
            P in d && d[P] ? (Dx.dot(d[P].normal) <= r && (f.push(A.x, A.y, A.z), f.push(E.x, E.y, E.z)), d[P] = null) : C in d || (d[C] = {
              index0: c[y],
              index1: c[w],
              normal: Dx.clone()
            });
          }
      }
      for (const m in d)
        if (d[m]) {
          const { index0: g, index1: v } = d[m];
          Tg.fromBufferAttribute(a, g), Ag.fromBufferAttribute(a, v), f.push(Tg.x, Tg.y, Tg.z), f.push(Ag.x, Ag.y, Ag.z);
        }
      this.setAttribute("position", new Tt(f, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class El extends Hp {
  /**
   * Constructs a new shape.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the shape.
   */
  constructor(e) {
    super(e), this.uuid = Ls(), this.type = "Shape", this.holes = [];
  }
  /**
   * Returns an array representing each contour of the holes
   * as a list of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {Array<Array<Vector2>>} The holes as a series of 2D points.
   */
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, n = this.holes.length; i < n; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  /**
   * Returns an object that holds contour data for the shape and its holes as
   * arrays of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {{shape:Array<Vector2>,holes:Array<Array<Vector2>>}} An object with contour data.
   */
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(new Hp().fromJSON(n));
    }
    return this;
  }
}
class e5 {
  /**
   * Triangulates the given shape definition by returning an array of triangles.
   *
   * @param {Array<number>} data - An array with 2D points.
   * @param {Array<number>} holeIndices - An array with indices defining holes.
   * @param {number} [dim=2] - The number of coordinates per vertex in the input array.
   * @return {Array<number>} An array representing the triangulated faces. Each face is defined by three consecutive numbers
   * representing vertex indices.
   */
  static triangulate(e, t, i = 2) {
    const n = t && t.length, r = n ? t[0] * i : e.length;
    let o = rI(e, 0, r, i, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let l, c, u, h, d, f, m;
    if (n && (o = s5(e, t, o, i)), e.length > 80 * i) {
      l = u = e[0], c = h = e[1];
      for (let g = i; g < r; g += i)
        d = e[g], f = e[g + 1], d < l && (l = d), f < c && (c = f), d > u && (u = d), f > h && (h = f);
      m = Math.max(u - l, h - c), m = m !== 0 ? 32767 / m : 0;
    }
    return Wp(o, a, i, l, c, m, 0), a;
  }
}
function rI(s, e, t, i, n) {
  let r, o;
  if (n === g5(s, e, t, i) > 0)
    for (r = e; r < t; r += i) o = WT(r, s[r], s[r + 1], o);
  else
    for (r = t - i; r >= e; r -= i) o = WT(r, s[r], s[r + 1], o);
  return o && z_(o, o.next) && (Yp(o), o = o.next), o;
}
function _u(s, e) {
  if (!s) return s;
  e || (e = s);
  let t = s, i;
  do
    if (i = !1, !t.steiner && (z_(t, t.next) || vi(t.prev, t, t.next) === 0)) {
      if (Yp(t), t = e = t.prev, t === t.next) break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Wp(s, e, t, i, n, r, o) {
  if (!s) return;
  !o && r && u5(s, i, n, r);
  let a = s, l, c;
  for (; s.prev !== s.next; ) {
    if (l = s.prev, c = s.next, r ? n5(s, i, n, r) : t5(s)) {
      e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), Yp(s), s = c.next, a = c.next;
      continue;
    }
    if (s = c, s === a) {
      o ? o === 1 ? (s = i5(_u(s), e, t), Wp(s, e, t, i, n, r, 2)) : o === 2 && r5(s, e, t, i, n, r) : Wp(_u(s), e, t, i, n, r, 1);
      break;
    }
  }
}
function t5(s) {
  const e = s.prev, t = s, i = s.next;
  if (vi(e, t, i) >= 0) return !1;
  const n = e.x, r = t.x, o = i.x, a = e.y, l = t.y, c = i.y, u = n < r ? n < o ? n : o : r < o ? r : o, h = a < l ? a < c ? a : c : l < c ? l : c, d = n > r ? n > o ? n : o : r > o ? r : o, f = a > l ? a > c ? a : c : l > c ? l : c;
  let m = i.next;
  for (; m !== e; ) {
    if (m.x >= u && m.x <= d && m.y >= h && m.y <= f && Uh(n, a, r, l, o, c, m.x, m.y) && vi(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function n5(s, e, t, i) {
  const n = s.prev, r = s, o = s.next;
  if (vi(n, r, o) >= 0) return !1;
  const a = n.x, l = r.x, c = o.x, u = n.y, h = r.y, d = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, m = u < h ? u < d ? u : d : h < d ? h : d, g = a > l ? a > c ? a : c : l > c ? l : c, v = u > h ? u > d ? u : d : h > d ? h : d, _ = b1(f, m, e, t, i), y = b1(g, v, e, t, i);
  let w = s.prevZ, x = s.nextZ;
  for (; w && w.z >= _ && x && x.z <= y; ) {
    if (w.x >= f && w.x <= g && w.y >= m && w.y <= v && w !== n && w !== o && Uh(a, u, l, h, c, d, w.x, w.y) && vi(w.prev, w, w.next) >= 0 || (w = w.prevZ, x.x >= f && x.x <= g && x.y >= m && x.y <= v && x !== n && x !== o && Uh(a, u, l, h, c, d, x.x, x.y) && vi(x.prev, x, x.next) >= 0)) return !1;
    x = x.nextZ;
  }
  for (; w && w.z >= _; ) {
    if (w.x >= f && w.x <= g && w.y >= m && w.y <= v && w !== n && w !== o && Uh(a, u, l, h, c, d, w.x, w.y) && vi(w.prev, w, w.next) >= 0) return !1;
    w = w.prevZ;
  }
  for (; x && x.z <= y; ) {
    if (x.x >= f && x.x <= g && x.y >= m && x.y <= v && x !== n && x !== o && Uh(a, u, l, h, c, d, x.x, x.y) && vi(x.prev, x, x.next) >= 0) return !1;
    x = x.nextZ;
  }
  return !0;
}
function i5(s, e, t) {
  let i = s;
  do {
    const n = i.prev, r = i.next.next;
    !z_(n, r) && sI(n, i, i.next, r) && Xp(n, r) && Xp(r, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(r.i / t | 0), Yp(i), Yp(i.next), i = s = r), i = i.next;
  } while (i !== s);
  return _u(i);
}
function r5(s, e, t, i, n, r) {
  let o = s;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && f5(o, a)) {
        let l = oI(o, a);
        o = _u(o, o.next), l = _u(l, l.next), Wp(o, e, t, i, n, r, 0), Wp(l, e, t, i, n, r, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== s);
}
function s5(s, e, t, i) {
  const n = [];
  let r, o, a, l, c;
  for (r = 0, o = e.length; r < o; r++)
    a = e[r] * i, l = r < o - 1 ? e[r + 1] * i : s.length, c = rI(s, a, l, i, !1), c === c.next && (c.steiner = !0), n.push(d5(c));
  for (n.sort(o5), r = 0; r < n.length; r++)
    t = a5(n[r], t);
  return t;
}
function o5(s, e) {
  return s.x - e.x;
}
function a5(s, e) {
  const t = l5(s, e);
  if (!t)
    return e;
  const i = oI(t, s);
  return _u(i, i.next), _u(t, t.next);
}
function l5(s, e) {
  let t = e, i = -1 / 0, n;
  const r = s.x, o = s.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= r && d > i && (i = d, n = t.x < t.next.x ? t : t.next, d === r))
        return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n) return null;
  const a = n, l = n.x, c = n.y;
  let u = 1 / 0, h;
  t = n;
  do
    r >= t.x && t.x >= l && r !== t.x && Uh(o < c ? r : i, o, l, c, o < c ? i : r, o, t.x, t.y) && (h = Math.abs(o - t.y) / (r - t.x), Xp(t, s) && (h < u || h === u && (t.x > n.x || t.x === n.x && c5(n, t))) && (n = t, u = h)), t = t.next;
  while (t !== a);
  return n;
}
function c5(s, e) {
  return vi(s.prev, s, e.prev) < 0 && vi(e.next, s, s.next) < 0;
}
function u5(s, e, t, i) {
  let n = s;
  do
    n.z === 0 && (n.z = b1(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== s);
  n.prevZ.nextZ = null, n.prevZ = null, h5(n);
}
function h5(s) {
  let e, t, i, n, r, o, a, l, c = 1;
  do {
    for (t = s, s = null, r = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++)
        ;
      for (l = c; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, a--) : (n = i, i = i.nextZ, l--), r ? r.nextZ = n : s = n, n.prevZ = r, r = n;
      t = i;
    }
    r.nextZ = null, c *= 2;
  } while (o > 1);
  return s;
}
function b1(s, e, t, i, n) {
  return s = (s - t) * n | 0, e = (e - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function d5(s) {
  let e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function Uh(s, e, t, i, n, r, o, a) {
  return (n - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (n - o) * (i - a);
}
function f5(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !p5(s, e) && // doesn't intersect other edges
  (Xp(s, e) && Xp(e, s) && m5(s, e) && // locally visible
  (vi(s.prev, s, e.prev) || vi(s, e.prev, e)) || // does not create opposite-facing sectors
  z_(s, e) && vi(s.prev, s, s.next) > 0 && vi(e.prev, e, e.next) > 0);
}
function vi(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function z_(s, e) {
  return s.x === e.x && s.y === e.y;
}
function sI(s, e, t, i) {
  const n = Rg(vi(s, e, t)), r = Rg(vi(s, e, i)), o = Rg(vi(t, i, s)), a = Rg(vi(t, i, e));
  return !!(n !== r && o !== a || n === 0 && Pg(s, t, e) || r === 0 && Pg(s, i, e) || o === 0 && Pg(t, s, i) || a === 0 && Pg(t, e, i));
}
function Pg(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function Rg(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function p5(s, e) {
  let t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && sI(t, t.next, s, e)) return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function Xp(s, e) {
  return vi(s.prev, s, s.next) < 0 ? vi(s, e, s.next) >= 0 && vi(s, s.prev, e) >= 0 : vi(s, e, s.prev) < 0 || vi(s, s.next, e) < 0;
}
function m5(s, e) {
  let t = s, i = !1;
  const n = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && n < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== s);
  return i;
}
function oI(s, e) {
  const t = new w1(s.i, s.x, s.y), i = new w1(e.i, e.x, e.y), n = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = n, n.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i;
}
function WT(s, e, t, i) {
  const n = new w1(s, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function Yp(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function w1(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function g5(s, e, t, i) {
  let n = 0;
  for (let r = e, o = t - i; r < t; r += i)
    n += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
  return n;
}
class Zo {
  /**
   * Calculate area of a ( 2D ) contour polygon.
   *
   * @param {Array<Vector2>} contour - An array of 2D points.
   * @return {number} The area.
   */
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let n = t - 1, r = 0; r < t; n = r++)
      i += e[n].x * e[r].y - e[r].x * e[n].y;
    return i * 0.5;
  }
  /**
   * Returns `true` if the given contour uses a clockwise winding order.
   *
   * @param {Array<Vector2>} pts - An array of 2D points defining a polygon.
   * @return {boolean} Whether the given contour uses a clockwise winding order or not.
   */
  static isClockWise(e) {
    return Zo.area(e) < 0;
  }
  /**
   * Triangulates the given shape definition.
   *
   * @param {Array<Vector2>} contour - An array of 2D points defining the contour.
   * @param {Array<Array<Vector2>>} holes - An array that holds arrays of 2D points defining the holes.
   * @return {Array<Array<number>>} An array that holds for each face definition an array with three indices.
   */
  static triangulateShape(e, t) {
    const i = [], n = [], r = [];
    XT(e), YT(i, e);
    let o = e.length;
    t.forEach(XT);
    for (let l = 0; l < t.length; l++)
      n.push(o), o += t[l].length, YT(i, t[l]);
    const a = e5.triangulate(i, n);
    for (let l = 0; l < a.length; l += 3)
      r.push(a.slice(l, l + 3));
    return r;
  }
}
function XT(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function YT(s, e) {
  for (let t = 0; t < e.length; t++)
    s.push(e[t].x), s.push(e[t].y);
}
class Ad extends Gt {
  /**
   * Constructs a new extrude geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {Object} [options={}] - The extrude settings.
   * @param {number} [options.curveSegments=12] - Number of points on the curves.
   * @param {number} [options.steps=1] - Number of points used for subdividing segments along the depth of the extruded spline.
   * @param {number} [options.depth=1] - Depth to extrude the shape.
   * @param {boolean} [options.bevelEnabled=true] - Whether to beveling to the shape or not.
   * @param {number} [options.bevelThickness=0.2] - How deep into the original shape the bevel goes.
   * @param {number} [options.bevelSize=bevelThickness-0.1] - Distance from the shape outline that the bevel extends.
   * @param {number} [options.bevelOffset=0] - Distance from the shape outline that the bevel starts.
   * @param {number} [options.bevelSegments=3] - Number of bevel layers.
   * @param {Curve} [options.extrudePath=3] - A 3D spline path along which the shape should be extruded. Bevels not supported for path extrusion.
   * @param {Object} [options.UVGenerator] - An object that provides UV generator functions for custom UV generation.
   */
  constructor(e = new El([new Be(0.5, 0.5), new Be(-0.5, 0.5), new Be(-0.5, -0.5), new Be(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const i = this, n = [], r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      o(c);
    }
    this.setAttribute("position", new Tt(n, 3)), this.setAttribute("uv", new Tt(r, 2)), this.computeVertexNormals();
    function o(a) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, g = t.bevelOffset !== void 0 ? t.bevelOffset : 0, v = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const _ = t.extrudePath, y = t.UVGenerator !== void 0 ? t.UVGenerator : v5;
      let w, x = !1, M, A, E, C;
      _ && (w = _.getSpacedPoints(u), x = !0, d = !1, M = _.computeFrenetFrames(u, !1), A = new H(), E = new H(), C = new H()), d || (v = 0, f = 0, m = 0, g = 0);
      const P = a.extractPoints(c);
      let T = P.shape;
      const I = P.holes;
      if (!Zo.isClockWise(T)) {
        T = T.reverse();
        for (let me = 0, xe = I.length; me < xe; me++) {
          const $ = I[me];
          Zo.isClockWise($) && (I[me] = $.reverse());
        }
      }
      const U = Zo.triangulateShape(T, I), L = T;
      for (let me = 0, xe = I.length; me < xe; me++) {
        const $ = I[me];
        T = T.concat($);
      }
      function k(me, xe, $) {
        return xe || console.error("THREE.ExtrudeGeometry: vec does not exist"), me.clone().addScaledVector(xe, $);
      }
      const B = T.length, j = U.length;
      function q(me, xe, $) {
        let Ue, Me, oe;
        const Te = me.x - xe.x, Ye = me.y - xe.y, Oe = $.x - me.x, X = $.y - me.y, Y = Te * Te + Ye * Ye, fe = Te * X - Ye * Oe;
        if (Math.abs(fe) > Number.EPSILON) {
          const ue = Math.sqrt(Y), te = Math.sqrt(Oe * Oe + X * X), Se = xe.x - Ye / ue, ye = xe.y + Te / ue, Ae = $.x - X / te, Ce = $.y + Oe / te, Ge = ((Ae - Se) * X - (Ce - ye) * Oe) / (Te * X - Ye * Oe);
          Ue = Se + Te * Ge - me.x, Me = ye + Ye * Ge - me.y;
          const De = Ue * Ue + Me * Me;
          if (De <= 2)
            return new Be(Ue, Me);
          oe = Math.sqrt(De / 2);
        } else {
          let ue = !1;
          Te > Number.EPSILON ? Oe > Number.EPSILON && (ue = !0) : Te < -Number.EPSILON ? Oe < -Number.EPSILON && (ue = !0) : Math.sign(Ye) === Math.sign(X) && (ue = !0), ue ? (Ue = -Ye, Me = Te, oe = Math.sqrt(Y)) : (Ue = Te, Me = Ye, oe = Math.sqrt(Y / 2));
        }
        return new Be(Ue / oe, Me / oe);
      }
      const Z = [];
      for (let me = 0, xe = L.length, $ = xe - 1, Ue = me + 1; me < xe; me++, $++, Ue++)
        $ === xe && ($ = 0), Ue === xe && (Ue = 0), Z[me] = q(L[me], L[$], L[Ue]);
      const N = [];
      let z, J = Z.concat();
      for (let me = 0, xe = I.length; me < xe; me++) {
        const $ = I[me];
        z = [];
        for (let Ue = 0, Me = $.length, oe = Me - 1, Te = Ue + 1; Ue < Me; Ue++, oe++, Te++)
          oe === Me && (oe = 0), Te === Me && (Te = 0), z[Ue] = q($[Ue], $[oe], $[Te]);
        N.push(z), J = J.concat(z);
      }
      for (let me = 0; me < v; me++) {
        const xe = me / v, $ = f * Math.cos(xe * Math.PI / 2), Ue = m * Math.sin(xe * Math.PI / 2) + g;
        for (let Me = 0, oe = L.length; Me < oe; Me++) {
          const Te = k(L[Me], Z[Me], Ue);
          ce(Te.x, Te.y, -$);
        }
        for (let Me = 0, oe = I.length; Me < oe; Me++) {
          const Te = I[Me];
          z = N[Me];
          for (let Ye = 0, Oe = Te.length; Ye < Oe; Ye++) {
            const X = k(Te[Ye], z[Ye], Ue);
            ce(X.x, X.y, -$);
          }
        }
      }
      const se = m + g;
      for (let me = 0; me < B; me++) {
        const xe = d ? k(T[me], J[me], se) : T[me];
        x ? (E.copy(M.normals[0]).multiplyScalar(xe.x), A.copy(M.binormals[0]).multiplyScalar(xe.y), C.copy(w[0]).add(E).add(A), ce(C.x, C.y, C.z)) : ce(xe.x, xe.y, 0);
      }
      for (let me = 1; me <= u; me++)
        for (let xe = 0; xe < B; xe++) {
          const $ = d ? k(T[xe], J[xe], se) : T[xe];
          x ? (E.copy(M.normals[me]).multiplyScalar($.x), A.copy(M.binormals[me]).multiplyScalar($.y), C.copy(w[me]).add(E).add(A), ce(C.x, C.y, C.z)) : ce($.x, $.y, h / u * me);
        }
      for (let me = v - 1; me >= 0; me--) {
        const xe = me / v, $ = f * Math.cos(xe * Math.PI / 2), Ue = m * Math.sin(xe * Math.PI / 2) + g;
        for (let Me = 0, oe = L.length; Me < oe; Me++) {
          const Te = k(L[Me], Z[Me], Ue);
          ce(Te.x, Te.y, h + $);
        }
        for (let Me = 0, oe = I.length; Me < oe; Me++) {
          const Te = I[Me];
          z = N[Me];
          for (let Ye = 0, Oe = Te.length; Ye < Oe; Ye++) {
            const X = k(Te[Ye], z[Ye], Ue);
            x ? ce(X.x, X.y + w[u - 1].y, w[u - 1].x + $) : ce(X.x, X.y, h + $);
          }
        }
      }
      K(), Q();
      function K() {
        const me = n.length / 3;
        if (d) {
          let xe = 0, $ = B * xe;
          for (let Ue = 0; Ue < j; Ue++) {
            const Me = U[Ue];
            _e(Me[2] + $, Me[1] + $, Me[0] + $);
          }
          xe = u + v * 2, $ = B * xe;
          for (let Ue = 0; Ue < j; Ue++) {
            const Me = U[Ue];
            _e(Me[0] + $, Me[1] + $, Me[2] + $);
          }
        } else {
          for (let xe = 0; xe < j; xe++) {
            const $ = U[xe];
            _e($[2], $[1], $[0]);
          }
          for (let xe = 0; xe < j; xe++) {
            const $ = U[xe];
            _e($[0] + B * u, $[1] + B * u, $[2] + B * u);
          }
        }
        i.addGroup(me, n.length / 3 - me, 0);
      }
      function Q() {
        const me = n.length / 3;
        let xe = 0;
        de(L, xe), xe += L.length;
        for (let $ = 0, Ue = I.length; $ < Ue; $++) {
          const Me = I[$];
          de(Me, xe), xe += Me.length;
        }
        i.addGroup(me, n.length / 3 - me, 1);
      }
      function de(me, xe) {
        let $ = me.length;
        for (; --$ >= 0; ) {
          const Ue = $;
          let Me = $ - 1;
          Me < 0 && (Me = me.length - 1);
          for (let oe = 0, Te = u + v * 2; oe < Te; oe++) {
            const Ye = B * oe, Oe = B * (oe + 1), X = xe + Ue + Ye, Y = xe + Me + Ye, fe = xe + Me + Oe, ue = xe + Ue + Oe;
            Fe(X, Y, fe, ue);
          }
        }
      }
      function ce(me, xe, $) {
        l.push(me), l.push(xe), l.push($);
      }
      function _e(me, xe, $) {
        Ie(me), Ie(xe), Ie($);
        const Ue = n.length / 3, Me = y.generateTopUV(i, n, Ue - 3, Ue - 2, Ue - 1);
        Ee(Me[0]), Ee(Me[1]), Ee(Me[2]);
      }
      function Fe(me, xe, $, Ue) {
        Ie(me), Ie(xe), Ie(Ue), Ie(xe), Ie($), Ie(Ue);
        const Me = n.length / 3, oe = y.generateSideWallUV(i, n, Me - 6, Me - 3, Me - 2, Me - 1);
        Ee(oe[0]), Ee(oe[1]), Ee(oe[3]), Ee(oe[1]), Ee(oe[2]), Ee(oe[3]);
      }
      function Ie(me) {
        n.push(l[me * 3 + 0]), n.push(l[me * 3 + 1]), n.push(l[me * 3 + 2]);
      }
      function Ee(me) {
        r.push(me.x), r.push(me.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return _5(t, i, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ExtrudeGeometry} A new instance.
   */
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const a = t[e.shapes[r]];
      i.push(a);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new K0[n.type]().fromJSON(n)), new Ad(i, e.options);
  }
}
const v5 = {
  generateTopUV: function(s, e, t, i, n) {
    const r = e[t * 3], o = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], c = e[n * 3], u = e[n * 3 + 1];
    return [
      new Be(r, o),
      new Be(a, l),
      new Be(c, u)
    ];
  },
  generateSideWallUV: function(s, e, t, i, n, r) {
    const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], u = e[i * 3 + 1], h = e[i * 3 + 2], d = e[n * 3], f = e[n * 3 + 1], m = e[n * 3 + 2], g = e[r * 3], v = e[r * 3 + 1], _ = e[r * 3 + 2];
    return Math.abs(a - u) < Math.abs(o - c) ? [
      new Be(o, 1 - l),
      new Be(c, 1 - h),
      new Be(d, 1 - m),
      new Be(g, 1 - _)
    ] : [
      new Be(a, 1 - l),
      new Be(u, 1 - h),
      new Be(f, 1 - m),
      new Be(v, 1 - _)
    ];
  }
};
function _5(s, e, t) {
  if (t.shapes = [], Array.isArray(s))
    for (let i = 0, n = s.length; i < n; i++) {
      const r = s[i];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(s.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class V_ extends Nl {
  /**
   * Constructs a new icosahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the icosahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a icosahedron.
   */
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      0,
      0,
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      i,
      0,
      -1,
      i,
      0,
      1,
      -i,
      0,
      -1,
      -i,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {IcosahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new V_(e.radius, e.detail);
  }
}
class Ma extends Nl {
  /**
   * Constructs a new octahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the octahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a octahedron.
   */
  constructor(e = 1, t = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {OctahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Ma(e.radius, e.detail);
  }
}
class $r extends Gt {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: i,
      heightSegments: n
    };
    const r = e / 2, o = t / 2, a = Math.floor(i), l = Math.floor(n), c = a + 1, u = l + 1, h = e / a, d = t / l, f = [], m = [], g = [], v = [];
    for (let _ = 0; _ < u; _++) {
      const y = _ * d - o;
      for (let w = 0; w < c; w++) {
        const x = w * h - r;
        m.push(x, -y, 0), g.push(0, 0, 1), v.push(w / a), v.push(1 - _ / l);
      }
    }
    for (let _ = 0; _ < l; _++)
      for (let y = 0; y < a; y++) {
        const w = y + c * _, x = y + c * (_ + 1), M = y + 1 + c * (_ + 1), A = y + 1 + c * _;
        f.push(w, x, A), f.push(x, M, A);
      }
    this.setIndex(f), this.setAttribute("position", new Tt(m, 3)), this.setAttribute("normal", new Tt(g, 3)), this.setAttribute("uv", new Tt(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(e) {
    return new $r(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class G_ extends Gt {
  /**
   * Constructs a new ring geometry.
   *
   * @param {number} [innerRadius=0.5] - The inner radius of the ring.
   * @param {number} [outerRadius=1] - The outer radius of the ring.
   * @param {number} [thetaSegments=32] - Number of segments. A higher number means the ring will be more round. Minimum is `3`.
   * @param {number} [phiSegments=1] - Number of segments per ring segment. Minimum is `1`.
   * @param {number} [thetaStart=0] - Starting angle in radians.
   * @param {number} [thetaLength=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 0.5, t = 1, i = 32, n = 1, r = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: r,
      thetaLength: o
    }, i = Math.max(3, i), n = Math.max(1, n);
    const a = [], l = [], c = [], u = [];
    let h = e;
    const d = (t - e) / n, f = new H(), m = new Be();
    for (let g = 0; g <= n; g++) {
      for (let v = 0; v <= i; v++) {
        const _ = r + v / i * o;
        f.x = h * Math.cos(_), f.y = h * Math.sin(_), l.push(f.x, f.y, f.z), c.push(0, 0, 1), m.x = (f.x / t + 1) / 2, m.y = (f.y / t + 1) / 2, u.push(m.x, m.y);
      }
      h += d;
    }
    for (let g = 0; g < n; g++) {
      const v = g * (i + 1);
      for (let _ = 0; _ < i; _++) {
        const y = _ + v, w = y, x = y + i + 1, M = y + i + 2, A = y + 1;
        a.push(w, x, A), a.push(x, M, A);
      }
    }
    this.setIndex(a), this.setAttribute("position", new Tt(l, 3)), this.setAttribute("normal", new Tt(c, 3)), this.setAttribute("uv", new Tt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {RingGeometry} A new instance.
   */
  static fromJSON(e) {
    return new G_(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class H_ extends Gt {
  /**
   * Constructs a new shape geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {number} [curveSegments=12] - Number of segments per shape.
   */
  constructor(e = new El([new Be(0, 0.5), new Be(-0.5, -0.5), new Be(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const i = [], n = [], r = [], o = [];
    let a = 0, l = 0;
    if (Array.isArray(e) === !1)
      c(e);
    else
      for (let u = 0; u < e.length; u++)
        c(e[u]), this.addGroup(a, l, u), a += l, l = 0;
    this.setIndex(i), this.setAttribute("position", new Tt(n, 3)), this.setAttribute("normal", new Tt(r, 3)), this.setAttribute("uv", new Tt(o, 2));
    function c(u) {
      const h = n.length / 3, d = u.extractPoints(t);
      let f = d.shape;
      const m = d.holes;
      Zo.isClockWise(f) === !1 && (f = f.reverse());
      for (let v = 0, _ = m.length; v < _; v++) {
        const y = m[v];
        Zo.isClockWise(y) === !0 && (m[v] = y.reverse());
      }
      const g = Zo.triangulateShape(f, m);
      for (let v = 0, _ = m.length; v < _; v++) {
        const y = m[v];
        f = f.concat(y);
      }
      for (let v = 0, _ = f.length; v < _; v++) {
        const y = f[v];
        n.push(y.x, y.y, 0), r.push(0, 0, 1), o.push(y.x, y.y);
      }
      for (let v = 0, _ = g.length; v < _; v++) {
        const y = g[v], w = y[0] + h, x = y[1] + h, M = y[2] + h;
        i.push(w, x, M), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return y5(t, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ShapeGeometry} A new instance.
   */
  static fromJSON(e, t) {
    const i = [];
    for (let n = 0, r = e.shapes.length; n < r; n++) {
      const o = t[e.shapes[n]];
      i.push(o);
    }
    return new H_(i, e.curveSegments);
  }
}
function y5(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let t = 0, i = s.length; t < i; t++) {
      const n = s[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class Bl extends Gt {
  /**
   * Constructs a new sphere geometry.
   *
   * @param {number} [radius=1] - The sphere radius.
   * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
   * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
   * @param {number} [phiStart=0] - The horizontal starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
   * @param {number} [thetaStart=0] - The vertical starting angle in radians.
   * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
   */
  constructor(e = 1, t = 32, i = 16, n = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: i,
      phiStart: n,
      phiLength: r,
      thetaStart: o,
      thetaLength: a
    }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const l = Math.min(o + a, Math.PI);
    let c = 0;
    const u = [], h = new H(), d = new H(), f = [], m = [], g = [], v = [];
    for (let _ = 0; _ <= i; _++) {
      const y = [], w = _ / i;
      let x = 0;
      _ === 0 && o === 0 ? x = 0.5 / t : _ === i && l === Math.PI && (x = -0.5 / t);
      for (let M = 0; M <= t; M++) {
        const A = M / t;
        h.x = -e * Math.cos(n + A * r) * Math.sin(o + w * a), h.y = e * Math.cos(o + w * a), h.z = e * Math.sin(n + A * r) * Math.sin(o + w * a), m.push(h.x, h.y, h.z), d.copy(h).normalize(), g.push(d.x, d.y, d.z), v.push(A + x, 1 - w), y.push(c++);
      }
      u.push(y);
    }
    for (let _ = 0; _ < i; _++)
      for (let y = 0; y < t; y++) {
        const w = u[_][y + 1], x = u[_][y], M = u[_ + 1][y], A = u[_ + 1][y + 1];
        (_ !== 0 || o > 0) && f.push(w, x, A), (_ !== i - 1 || l < Math.PI) && f.push(x, M, A);
      }
    this.setIndex(f), this.setAttribute("position", new Tt(m, 3)), this.setAttribute("normal", new Tt(g, 3)), this.setAttribute("uv", new Tt(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {SphereGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Bl(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class W_ extends Nl {
  /**
   * Constructs a new tetrahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the tetrahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron.
   */
  constructor(e = 1, t = 0) {
    const i = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(i, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TetrahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new W_(e.radius, e.detail);
  }
}
class wa extends Gt {
  /**
   * Constructs a new torus geometry.
   *
   * @param {number} [radius=1] - Radius of the torus, from the center of the torus to the center of the tube.
   * @param {number} [tube=0.4] - Radius of the tube. Must be smaller than `radius`.
   * @param {number} [radialSegments=12] - The number of radial segments.
   * @param {number} [tubularSegments=48] - The number of tubular segments.
   * @param {number} [arc=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 1, t = 0.4, i = 12, n = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: i,
      tubularSegments: n,
      arc: r
    }, i = Math.floor(i), n = Math.floor(n);
    const o = [], a = [], l = [], c = [], u = new H(), h = new H(), d = new H();
    for (let f = 0; f <= i; f++)
      for (let m = 0; m <= n; m++) {
        const g = m / n * r, v = f / i * Math.PI * 2;
        h.x = (e + t * Math.cos(v)) * Math.cos(g), h.y = (e + t * Math.cos(v)) * Math.sin(g), h.z = t * Math.sin(v), a.push(h.x, h.y, h.z), u.x = e * Math.cos(g), u.y = e * Math.sin(g), d.subVectors(h, u).normalize(), l.push(d.x, d.y, d.z), c.push(m / n), c.push(f / i);
      }
    for (let f = 1; f <= i; f++)
      for (let m = 1; m <= n; m++) {
        const g = (n + 1) * f + m - 1, v = (n + 1) * (f - 1) + m - 1, _ = (n + 1) * (f - 1) + m, y = (n + 1) * f + m;
        o.push(g, v, y), o.push(v, _, y);
      }
    this.setIndex(o), this.setAttribute("position", new Tt(a, 3)), this.setAttribute("normal", new Tt(l, 3)), this.setAttribute("uv", new Tt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusGeometry} A new instance.
   */
  static fromJSON(e) {
    return new wa(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class X_ extends Gt {
  /**
   * Constructs a new torus knot geometry.
   *
   * @param {number} [radius=1] - Radius of the torus knot.
   * @param {number} [tube=0.4] - Radius of the tube.
   * @param {number} [tubularSegments=64] - The number of tubular segments.
   * @param {number} [radialSegments=8] - The number of radial segments.
   * @param {number} [p=2] - This value determines, how many times the geometry winds around its axis of rotational symmetry.
   * @param {number} [q=3] - This value determines, how many times the geometry winds around a circle in the interior of the torus.
   */
  constructor(e = 1, t = 0.4, i = 64, n = 8, r = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: i,
      radialSegments: n,
      p: r,
      q: o
    }, i = Math.floor(i), n = Math.floor(n);
    const a = [], l = [], c = [], u = [], h = new H(), d = new H(), f = new H(), m = new H(), g = new H(), v = new H(), _ = new H();
    for (let w = 0; w <= i; ++w) {
      const x = w / i * r * Math.PI * 2;
      y(x, r, o, e, f), y(x + 0.01, r, o, e, m), v.subVectors(m, f), _.addVectors(m, f), g.crossVectors(v, _), _.crossVectors(g, v), g.normalize(), _.normalize();
      for (let M = 0; M <= n; ++M) {
        const A = M / n * Math.PI * 2, E = -t * Math.cos(A), C = t * Math.sin(A);
        h.x = f.x + (E * _.x + C * g.x), h.y = f.y + (E * _.y + C * g.y), h.z = f.z + (E * _.z + C * g.z), l.push(h.x, h.y, h.z), d.subVectors(h, f).normalize(), c.push(d.x, d.y, d.z), u.push(w / i), u.push(M / n);
      }
    }
    for (let w = 1; w <= i; w++)
      for (let x = 1; x <= n; x++) {
        const M = (n + 1) * (w - 1) + (x - 1), A = (n + 1) * w + (x - 1), E = (n + 1) * w + x, C = (n + 1) * (w - 1) + x;
        a.push(M, A, C), a.push(A, E, C);
      }
    this.setIndex(a), this.setAttribute("position", new Tt(l, 3)), this.setAttribute("normal", new Tt(c, 3)), this.setAttribute("uv", new Tt(u, 2));
    function y(w, x, M, A, E) {
      const C = Math.cos(w), P = Math.sin(w), T = M / x * w, I = Math.cos(T);
      E.x = A * (2 + I) * 0.5 * C, E.y = A * (2 + I) * P * 0.5, E.z = A * Math.sin(T) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusKnotGeometry} A new instance.
   */
  static fromJSON(e) {
    return new X_(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Y_ extends Gt {
  /**
   * Constructs a new tube geometry.
   *
   * @param {Curve} [path=QuadraticBezierCurve3] - A 3D curve defining the path of the tube.
   * @param {number} [tubularSegments=64] - The number of segments that make up the tube.
   * @param {number} [radius=1] -The radius of the tube.
   * @param {number} [radialSegments=8] - The number of segments that make up the cross-section.
   * @param {boolean} [closed=false] - Whether the tube is closed or not.
   */
  constructor(e = new cS(new H(-1, -1, 0), new H(-1, 1, 0), new H(1, 1, 0)), t = 64, i = 1, n = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: i,
      radialSegments: n,
      closed: r
    };
    const o = e.computeFrenetFrames(t, r);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const a = new H(), l = new H(), c = new Be();
    let u = new H();
    const h = [], d = [], f = [], m = [];
    g(), this.setIndex(m), this.setAttribute("position", new Tt(h, 3)), this.setAttribute("normal", new Tt(d, 3)), this.setAttribute("uv", new Tt(f, 2));
    function g() {
      for (let w = 0; w < t; w++)
        v(w);
      v(r === !1 ? t : 0), y(), _();
    }
    function v(w) {
      u = e.getPointAt(w / t, u);
      const x = o.normals[w], M = o.binormals[w];
      for (let A = 0; A <= n; A++) {
        const E = A / n * Math.PI * 2, C = Math.sin(E), P = -Math.cos(E);
        l.x = P * x.x + C * M.x, l.y = P * x.y + C * M.y, l.z = P * x.z + C * M.z, l.normalize(), d.push(l.x, l.y, l.z), a.x = u.x + i * l.x, a.y = u.y + i * l.y, a.z = u.z + i * l.z, h.push(a.x, a.y, a.z);
      }
    }
    function _() {
      for (let w = 1; w <= t; w++)
        for (let x = 1; x <= n; x++) {
          const M = (n + 1) * (w - 1) + (x - 1), A = (n + 1) * w + (x - 1), E = (n + 1) * w + x, C = (n + 1) * (w - 1) + x;
          m.push(M, A, C), m.push(A, E, C);
        }
    }
    function y() {
      for (let w = 0; w <= t; w++)
        for (let x = 0; x <= n; x++)
          c.x = w / t, c.y = x / n, f.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TubeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Y_(
      new K0[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class hS extends Gt {
  /**
   * Constructs a new wireframe geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   */
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), n = new H(), r = new H();
      if (e.index !== null) {
        const o = e.attributes.position, a = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const h = l[c], d = h.start, f = h.count;
          for (let m = d, g = d + f; m < g; m += 3)
            for (let v = 0; v < 3; v++) {
              const _ = a.getX(m + v), y = a.getX(m + (v + 1) % 3);
              n.fromBufferAttribute(o, _), r.fromBufferAttribute(o, y), jT(n, r, i) === !0 && (t.push(n.x, n.y, n.z), t.push(r.x, r.y, r.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * a + c, h = 3 * a + (c + 1) % 3;
            n.fromBufferAttribute(o, u), r.fromBufferAttribute(o, h), jT(n, r, i) === !0 && (t.push(n.x, n.y, n.z), t.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new Tt(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function jT(s, e, t) {
  const i = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, n = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return t.has(i) === !0 || t.has(n) === !0 ? !1 : (t.add(i), t.add(n), !0);
}
var qT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: pi,
  CapsuleGeometry: O_,
  CircleGeometry: F_,
  ConeGeometry: N_,
  CylinderGeometry: Di,
  DodecahedronGeometry: B_,
  EdgesGeometry: iI,
  ExtrudeGeometry: Ad,
  IcosahedronGeometry: V_,
  LatheGeometry: dm,
  OctahedronGeometry: Ma,
  PlaneGeometry: $r,
  PolyhedronGeometry: Nl,
  RingGeometry: G_,
  ShapeGeometry: H_,
  SphereGeometry: Bl,
  TetrahedronGeometry: W_,
  TorusGeometry: wa,
  TorusKnotGeometry: X_,
  TubeGeometry: Y_,
  WireframeGeometry: hS
});
class aI extends ji {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new rt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class lI extends Mi {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class fm extends ji {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new rt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new fs(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class oo extends fm {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Be(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Qt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new rt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new rt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new rt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class cI extends ji {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new rt(16777215), this.specular = new rt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new fs(), this.combine = sm, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class uI extends ji {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new rt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class hI extends ji {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class dI extends ji {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new fs(), this.combine = sm, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Ru extends ji {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = kD, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Cd extends ji {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
class fI extends ji {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new rt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class pI extends Bi {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function Hc(s, e, t) {
  return !s || // let 'undefined' and 'null' pass
  !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
}
function mI(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function gI(s) {
  function e(n, r) {
    return s[n] - s[r];
  }
  const t = s.length, i = new Array(t);
  for (let n = 0; n !== t; ++n) i[n] = n;
  return i.sort(e), i;
}
function S1(s, e, t) {
  const i = s.length, n = new s.constructor(i);
  for (let r = 0, o = 0; o !== i; ++r) {
    const a = t[r] * e;
    for (let l = 0; l !== e; ++l)
      n[o++] = s[a + l];
  }
  return n;
}
function dS(s, e, t, i) {
  let n = 1, r = s[0];
  for (; r !== void 0 && r[i] === void 0; )
    r = s[n++];
  if (r === void 0) return;
  let o = r[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = r[i], o !== void 0 && (e.push(r.time), t.push(...o)), r = s[n++];
      while (r !== void 0);
    else if (o.toArray !== void 0)
      do
        o = r[i], o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), r = s[n++];
      while (r !== void 0);
    else
      do
        o = r[i], o !== void 0 && (e.push(r.time), t.push(o)), r = s[n++];
      while (r !== void 0);
}
function x5(s, e, t, i, n = 30) {
  const r = s.clone();
  r.name = e;
  const o = [];
  for (let l = 0; l < r.tracks.length; ++l) {
    const c = r.tracks[l], u = c.getValueSize(), h = [], d = [];
    for (let f = 0; f < c.times.length; ++f) {
      const m = c.times[f] * n;
      if (!(m < t || m >= i)) {
        h.push(c.times[f]);
        for (let g = 0; g < u; ++g)
          d.push(c.values[f * u + g]);
      }
    }
    h.length !== 0 && (c.times = Hc(h, c.times.constructor), c.values = Hc(d, c.values.constructor), o.push(c));
  }
  r.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < r.tracks.length; ++l)
    a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
  for (let l = 0; l < r.tracks.length; ++l)
    r.tracks[l].shift(-1 * a);
  return r.resetDuration(), r;
}
function b5(s, e = 0, t = s, i = 30) {
  i <= 0 && (i = 30);
  const n = t.tracks.length, r = e / i;
  for (let o = 0; o < n; ++o) {
    const a = t.tracks[o], l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = s.tracks.find(function(_) {
      return _.name === a.name && _.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let u = 0;
    const h = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = h / 3);
    let d = 0;
    const f = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = f / 3);
    const m = a.times.length - 1;
    let g;
    if (r <= a.times[0]) {
      const _ = u, y = h - u;
      g = a.values.slice(_, y);
    } else if (r >= a.times[m]) {
      const _ = m * h + u, y = _ + h - u;
      g = a.values.slice(_, y);
    } else {
      const _ = a.createInterpolant(), y = u, w = h - u;
      _.evaluate(r), g = _.resultBuffer.slice(y, w);
    }
    l === "quaternion" && new En().fromArray(g).normalize().conjugate().toArray(g);
    const v = c.times.length;
    for (let _ = 0; _ < v; ++_) {
      const y = _ * f + d;
      if (l === "quaternion")
        En.multiplyQuaternionsFlat(
          c.values,
          y,
          g,
          0,
          c.values,
          y
        );
      else {
        const w = f - d * 2;
        for (let x = 0; x < w; ++x)
          c.values[y + x] -= g[x];
      }
    }
  }
  return s.blendMode = Kw, s;
}
const w5 = {
  convertArray: Hc,
  isTypedArray: mI,
  getKeyframeOrder: gI,
  sortedArray: S1,
  flattenJSON: dS,
  subclip: x5,
  makeClipAdditive: b5
};
class Pd {
  /**
   * Constructs a new interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, i, n) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  /**
   * Evaluate the interpolant at position `t`.
   *
   * @param {number} t - The interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, n = t[i], r = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < n)) {
            for (let a = i + 2; ; ) {
              if (n === void 0) {
                if (e < r) break i;
                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
              }
              if (i === a) break;
              if (r = n, n = t[++i], e < n)
                break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= r)) {
            const a = t[1];
            e < a && (i = 2, r = a);
            for (let l = i - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === l) break;
              if (n = r, r = t[--i - 1], e >= r)
                break t;
            }
            o = i, i = 0;
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = i + o >>> 1;
          e < t[a] ? o = a : i = a + 1;
        }
        if (n = t[i], r = t[i - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (n === void 0)
          return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, r, n);
    }
    return this.interpolate_(i, r, e, n);
  }
  /**
   * Returns the interpolation settings.
   *
   * @return {Object} The interpolation settings.
   */
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @param {number} index - An index into the sample value buffer.
   * @return {TypedArray} The result buffer.
   */
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n;
    for (let o = 0; o !== n; ++o)
      t[o] = i[r + o];
    return t;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @abstract
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   * @param {number} t1 - The next interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  interpolate_() {
    throw new Error("call to abstract method");
  }
  /**
   * Optional method that is executed when the interval has changed.
   *
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   */
  intervalChanged_() {
  }
}
class vI extends Pd {
  /**
   * Constructs a new cubic interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: zc,
      endingEnd: zc
    };
  }
  intervalChanged_(e, t, i) {
    const n = this.parameterPositions;
    let r = e - 2, o = e + 1, a = n[r], l = n[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Vc:
          r = e, a = 2 * t - i;
          break;
        case Np:
          r = n.length - 2, a = t + n[r] - n[r + 1];
          break;
        default:
          r = e, a = i;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Vc:
          o = e, l = 2 * i - t;
          break;
        case Np:
          o = 1, l = i + n[1] - n[0];
          break;
        default:
          o = e - 1, l = t;
      }
    const c = (i - t) * 0.5, u = this.valueSize;
    this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = r * u, this._offsetNext = o * u;
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = this._offsetPrev, h = this._offsetNext, d = this._weightPrev, f = this._weightNext, m = (i - t) / (n - t), g = m * m, v = g * m, _ = -d * v + 2 * d * g - d * m, y = (1 + d) * v + (-1.5 - 2 * d) * g + (-0.5 + d) * m + 1, w = (-1 - f) * v + (1.5 + f) * g + 0.5 * m, x = f * v - f * g;
    for (let M = 0; M !== a; ++M)
      r[M] = _ * o[u + M] + y * o[c + M] + w * o[l + M] + x * o[h + M];
    return r;
  }
}
class fS extends Pd {
  /**
   * Constructs a new linear interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = (i - t) / (n - t), h = 1 - u;
    for (let d = 0; d !== a; ++d)
      r[d] = o[c + d] * h + o[l + d] * u;
    return r;
  }
}
class _I extends Pd {
  /**
   * Constructs a new discrete interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Eo {
  constructor(e, t, i, n) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = Hc(t, this.TimeBufferType), this.values = Hc(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON)
      i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: Hc(e.times, Array),
        values: Hc(e.values, Array)
      };
      const n = e.getInterpolation();
      n !== e.DefaultInterpolation && (i.interpolation = n);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new _I(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new fS(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new vI(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case ud:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case hd:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case kv:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return ud;
      case this.InterpolantFactoryMethodLinear:
        return hd;
      case this.InterpolantFactoryMethodSmooth:
        return kv;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const i = this.times, n = i.length;
    let r = 0, o = n - 1;
    for (; r !== n && i[r] < e; )
      ++r;
    for (; o !== -1 && i[o] > t; )
      --o;
    if (++o, r !== 0 || o !== n) {
      r >= o && (o = Math.max(o, 1), r = o - 1);
      const a = this.getValueSize();
      this.times = i.slice(r, o), this.values = this.values.slice(r * a, o * a);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const i = this.times, n = this.values, r = i.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let a = 0; a !== r; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
        break;
      }
      o = l;
    }
    if (n !== void 0 && mI(n))
      for (let a = 0, l = n.length; a !== l; ++a) {
        const c = n[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), n = this.getInterpolation() === kv, r = e.length - 1;
    let o = 1;
    for (let a = 1; a < r; ++a) {
      let l = !1;
      const c = e[a], u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (n)
          l = !0;
        else {
          const h = a * i, d = h - i, f = h + i;
          for (let m = 0; m !== i; ++m) {
            const g = t[h + m];
            if (g !== t[d + m] || g !== t[f + m]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const h = a * i, d = o * i;
          for (let f = 0; f !== i; ++f)
            t[d + f] = t[h + f];
        }
        ++o;
      }
    }
    if (r > 0) {
      e[o] = e[r];
      for (let a = r * i, l = o * i, c = 0; c !== i; ++c)
        t[l + c] = t[a + c];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), i = this.constructor, n = new i(this.name, e, t);
    return n.createInterpolant = this.createInterpolant, n;
  }
}
Eo.prototype.TimeBufferType = Float32Array;
Eo.prototype.ValueBufferType = Float32Array;
Eo.prototype.DefaultInterpolation = hd;
class Du extends Eo {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, i) {
    super(e, t, i);
  }
}
Du.prototype.ValueTypeName = "bool";
Du.prototype.ValueBufferType = Array;
Du.prototype.DefaultInterpolation = ud;
Du.prototype.InterpolantFactoryMethodLinear = void 0;
Du.prototype.InterpolantFactoryMethodSmooth = void 0;
class pS extends Eo {
}
pS.prototype.ValueTypeName = "color";
class yu extends Eo {
}
yu.prototype.ValueTypeName = "number";
class yI extends Pd {
  /**
   * Constructs a new SLERP interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (i - t) / (n - t);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4)
      En.slerpFlat(r, 0, o, c - a, o, c, l);
    return r;
  }
}
class xu extends Eo {
  InterpolantFactoryMethodLinear(e) {
    return new yI(this.times, this.values, this.getValueSize(), e);
  }
}
xu.prototype.ValueTypeName = "quaternion";
xu.prototype.InterpolantFactoryMethodSmooth = void 0;
class Iu extends Eo {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, i) {
    super(e, t, i);
  }
}
Iu.prototype.ValueTypeName = "string";
Iu.prototype.ValueBufferType = Array;
Iu.prototype.DefaultInterpolation = ud;
Iu.prototype.InterpolantFactoryMethodLinear = void 0;
Iu.prototype.InterpolantFactoryMethodSmooth = void 0;
class bu extends Eo {
}
bu.prototype.ValueTypeName = "vector";
class pd {
  constructor(e = "", t = -1, i = [], n = x_) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = Ls(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, n = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o)
      t.push(M5(i[o]).scale(n));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, n = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, o = i.length; r !== o; ++r)
      t.push(Eo.toJSON(i[r]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, t, i, n) {
    const r = t.length, o = [];
    for (let a = 0; a < r; a++) {
      let l = [], c = [];
      l.push(
        (a + r - 1) % r,
        a,
        (a + 1) % r
      ), c.push(0, 1, 0);
      const u = gI(l);
      l = S1(l, 1, u), c = S1(c, 1, u), !n && l[0] === 0 && (l.push(r), c.push(c[0])), o.push(
        new yu(
          ".morphTargetInfluences[" + t[a].name + "]",
          l,
          c
        ).scale(1 / i)
      );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const n = e;
      i = n.geometry && n.geometry.animations || n.animations;
    }
    for (let n = 0; n < i.length; n++)
      if (i[n].name === t)
        return i[n];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const n = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], u = c.name.match(r);
      if (u && u.length > 1) {
        const h = u[1];
        let d = n[h];
        d || (n[h] = d = []), d.push(c);
      }
    }
    const o = [];
    for (const a in n)
      o.push(this.CreateFromMorphTargetSequence(a, n[a], t, i));
    return o;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(h, d, f, m, g) {
      if (f.length !== 0) {
        const v = [], _ = [];
        dS(f, v, _, m), v.length !== 0 && g.push(new h(d, v, _));
      }
    }, n = [], r = e.name || "default", o = e.fps || 30, a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let h = 0; h < c.length; h++) {
      const d = c[h].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let m;
          for (m = 0; m < d.length; m++)
            if (d[m].morphTargets)
              for (let g = 0; g < d[m].morphTargets.length; g++)
                f[d[m].morphTargets[g]] = -1;
          for (const g in f) {
            const v = [], _ = [];
            for (let y = 0; y !== d[m].morphTargets.length; ++y) {
              const w = d[m];
              v.push(w.time), _.push(w.morphTarget === g ? 1 : 0);
            }
            n.push(new yu(".morphTargetInfluence[" + g + "]", v, _));
          }
          l = f.length * o;
        } else {
          const f = ".bones[" + t[h].name + "]";
          i(
            bu,
            f + ".position",
            d,
            "pos",
            n
          ), i(
            xu,
            f + ".quaternion",
            d,
            "rot",
            n
          ), i(
            bu,
            f + ".scale",
            d,
            "scl",
            n
          );
        }
    }
    return n.length === 0 ? null : new this(r, l, n, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, n = e.length; i !== n; ++i) {
      const r = this.tracks[i];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function S5(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return yu;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return bu;
    case "color":
      return pS;
    case "quaternion":
      return xu;
    case "bool":
    case "boolean":
      return Du;
    case "string":
      return Iu;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function M5(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = S5(s.type);
  if (s.times === void 0) {
    const t = [], i = [];
    dS(s.keys, t, i, "value"), s.times = t, s.values = i;
  }
  return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
}
const Ea = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class mS {
  constructor(e, t, i) {
    const n = this;
    let r = !1, o = 0, a = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(u) {
      a++, r === !1 && n.onStart !== void 0 && n.onStart(u, o, a), r = !0;
    }, this.itemEnd = function(u) {
      o++, n.onProgress !== void 0 && n.onProgress(u, o, a), o === a && (r = !1, n.onLoad !== void 0 && n.onLoad());
    }, this.itemError = function(u) {
      n.onError !== void 0 && n.onError(u);
    }, this.resolveURL = function(u) {
      return l ? l(u) : u;
    }, this.setURLModifier = function(u) {
      return l = u, this;
    }, this.addHandler = function(u, h) {
      return c.push(u, h), this;
    }, this.removeHandler = function(u) {
      const h = c.indexOf(u);
      return h !== -1 && c.splice(h, 2), this;
    }, this.getHandler = function(u) {
      for (let h = 0, d = c.length; h < d; h += 2) {
        const f = c[h], m = c[h + 1];
        if (f.global && (f.lastIndex = 0), f.test(u))
          return m;
      }
      return null;
    };
  }
}
const Lu = /* @__PURE__ */ new mS();
class br {
  /**
   * Constructs a new loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    this.manager = e !== void 0 ? e : Lu, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for loading assets from the backend.
   *
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {Function} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load() {
  }
  /**
   * A async version of {@link Loader#load}.
   *
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @return {Promise} A Promise that resolves when the asset has been loaded.
   */
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(n, r) {
      i.load(e, n, t, r);
    });
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for parsing the asset into three.js entities.
   *
   * @param {any} data - The data to parse.
   */
  parse() {
  }
  /**
   * Sets the `crossOrigin` String to implement CORS for loading the URL
   * from a different domain that allows CORS.
   *
   * @param {string} crossOrigin - The `crossOrigin` value.
   * @return {Loader} A reference to this instance.
   */
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  /**
   * Whether the XMLHttpRequest uses credentials such as cookies, authorization
   * headers or TLS client certificates, see [XMLHttpRequest.withCredentials]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials}.
   *
   * Note: This setting has no effect if you are loading files locally or from the same domain.
   *
   * @param {boolean} value - The `withCredentials` value.
   * @return {Loader} A reference to this instance.
   */
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  /**
   * Sets the base path for the asset.
   *
   * @param {string} path - The base path.
   * @return {Loader} A reference to this instance.
   */
  setPath(e) {
    return this.path = e, this;
  }
  /**
   * Sets the base path for dependent resources like textures.
   *
   * @param {string} resourcePath - The resource path.
   * @return {Loader} A reference to this instance.
   */
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  /**
   * Sets the given request header.
   *
   * @param {Object} requestHeader - A [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}
   * for configuring the HTTP request.
   * @return {Loader} A reference to this instance.
   */
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
br.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const da = {};
class E5 extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class ps extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = Ea.get(e);
    if (r !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
    if (da[e] !== void 0) {
      da[e].push({
        onLoad: t,
        onProgress: i,
        onError: n
      });
      return;
    }
    da[e] = [], da[e].push({
      onLoad: t,
      onProgress: i,
      onError: n
    });
    const o = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), a = this.mimeType, l = this.responseType;
    fetch(o).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const u = da[e], h = c.body.getReader(), d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), f = d ? parseInt(d) : 0, m = f !== 0;
        let g = 0;
        const v = new ReadableStream({
          start(_) {
            y();
            function y() {
              h.read().then(({ done: w, value: x }) => {
                if (w)
                  _.close();
                else {
                  g += x.byteLength;
                  const M = new ProgressEvent("progress", { lengthComputable: m, loaded: g, total: f });
                  for (let A = 0, E = u.length; A < E; A++) {
                    const C = u[A];
                    C.onProgress && C.onProgress(M);
                  }
                  _.enqueue(x), y();
                }
              }, (w) => {
                _.error(w);
              });
            }
          }
        });
        return new Response(v);
      } else
        throw new E5(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((u) => new DOMParser().parseFromString(u, a));
        case "json":
          return c.json();
        default:
          if (a === void 0)
            return c.text();
          {
            const h = /charset="?([^;"\s]*)"?/i.exec(a), d = h && h[1] ? h[1].toLowerCase() : void 0, f = new TextDecoder(d);
            return c.arrayBuffer().then((m) => f.decode(m));
          }
      }
    }).then((c) => {
      Ea.add(e, c);
      const u = da[e];
      delete da[e];
      for (let h = 0, d = u.length; h < d; h++) {
        const f = u[h];
        f.onLoad && f.onLoad(c);
      }
    }).catch((c) => {
      const u = da[e];
      if (u === void 0)
        throw this.manager.itemError(e), c;
      delete da[e];
      for (let h = 0, d = u.length; h < d; h++) {
        const f = u[h];
        f.onError && f.onError(c);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class T5 extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, o = new ps(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = pd.parse(e[i]);
      t.push(n);
    }
    return t;
  }
}
class A5 extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, o = [], a = new L_(), l = new ps(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
    let c = 0;
    function u(h) {
      l.load(e[h], function(d) {
        const f = r.parse(d, !0);
        o[h] = {
          width: f.width,
          height: f.height,
          format: f.format,
          mipmaps: f.mipmaps
        }, c += 1, c === 6 && (f.mipmapCount === 1 && (a.minFilter = Sn), a.image = o, a.format = f.format, a.needsUpdate = !0, t && t(a));
      }, i, n);
    }
    if (Array.isArray(e))
      for (let h = 0, d = e.length; h < d; ++h)
        u(h);
    else
      l.load(e, function(h) {
        const d = r.parse(h, !0);
        if (d.isCubemap) {
          const f = d.mipmaps.length / d.mipmapCount;
          for (let m = 0; m < f; m++) {
            o[m] = { mipmaps: [] };
            for (let g = 0; g < d.mipmapCount; g++)
              o[m].mipmaps.push(d.mipmaps[m * d.mipmapCount + g]), o[m].format = d.format, o[m].width = d.width, o[m].height = d.height;
          }
          a.image = o;
        } else
          a.image.width = d.width, a.image.height = d.height, a.mipmaps = d.mipmaps;
        d.mipmapCount === 1 && (a.minFilter = Sn), a.format = d.format, a.needsUpdate = !0, t && t(a);
      }, i, n);
    return a;
  }
}
class jp extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, o = Ea.get(e);
    if (o !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
    const a = Gp("img");
    function l() {
      u(), Ea.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(h) {
      u(), n && n(h), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a;
  }
}
class xI extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = new Ed();
    r.colorSpace = Oi;
    const o = new jp(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(e[c], function(u) {
        r.images[c] = u, a++, a === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, n);
    }
    for (let c = 0; c < e.length; ++c)
      l(c);
    return r;
  }
}
class gS extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, o = new yr(), a = new ps(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, function(l) {
      let c;
      try {
        c = r.parse(l);
      } catch (u) {
        if (n !== void 0)
          n(u);
        else {
          console.error(u);
          return;
        }
      }
      c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : gr, o.wrapT = c.wrapT !== void 0 ? c.wrapT : gr, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Sn, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Sn, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = As), c.mipmapCount === 1 && (o.minFilter = Sn), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c);
    }, i, n), o;
  }
}
class j_ extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = new ei(), o = new jp(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
      r.image = a, r.needsUpdate = !0, t !== void 0 && t(r);
    }, i, n), r;
  }
}
class zl extends tn {
  /**
   * Constructs a new light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new rt(e), this.intensity = t;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
class bI extends zl {
  /**
   * Constructs a new hemisphere light.
   *
   * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
   * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(tn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new rt(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Ix = /* @__PURE__ */ new _t(), ZT = /* @__PURE__ */ new H(), KT = /* @__PURE__ */ new H();
class vS {
  /**
   * Constructs a new light shadow.
   *
   * @param {Camera} camera - The light's view of the world.
   */
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Be(512, 512), this.map = null, this.mapPass = null, this.matrix = new _t(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new hm(), this._frameExtents = new Be(1, 1), this._viewportCount = 1, this._viewports = [
      new Kt(0, 0, 1, 1)
    ];
  }
  /**
   * Used internally by the renderer to get the number of viewports that need
   * to be rendered for this shadow.
   *
   * @return {number} The viewport count.
   */
  getViewportCount() {
    return this._viewportCount;
  }
  /**
   * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
   *
   * @return {Frustum} The shadow camera frustum.
   */
  getFrustum() {
    return this._frustum;
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   */
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    ZT.setFromMatrixPosition(e.matrixWorld), t.position.copy(ZT), KT.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(KT), t.updateMatrixWorld(), Ix.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ix), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Ix);
  }
  /**
   * Returns a viewport definition for the given viewport index.
   *
   * @param {number} viewportIndex - The viewport index.
   * @return {Vector4} The viewport.
   */
  getViewport(e) {
    return this._viewports[e];
  }
  /**
   * Returns the frame extends.
   *
   * @return {Vector2} The frame extends.
   */
  getFrameExtents() {
    return this._frameExtents;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  /**
   * Copies the values of the given light shadow instance to this instance.
   *
   * @param {LightShadow} source - The light shadow to copy.
   * @return {LightShadow} A reference to this light shadow instance.
   */
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  /**
   * Returns a new light shadow instance with copied values from this instance.
   *
   * @return {LightShadow} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Serializes the light shadow into JSON.
   *
   * @return {Object} A JSON object representing the serialized light shadow.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class C5 extends vS {
  /**
   * Constructs a new spot light shadow.
   */
  constructor() {
    super(new Fi(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = dd * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class _S extends zl {
  /**
   * Constructs a new spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, i = 0, n = Math.PI / 3, r = 0, o = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(tn.DEFAULT_UP), this.updateMatrix(), this.target = new tn(), this.distance = i, this.angle = n, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new C5();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   *  Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const $T = /* @__PURE__ */ new _t(), ff = /* @__PURE__ */ new H(), Lx = /* @__PURE__ */ new H();
class P5 extends vS {
  /**
   * Constructs a new point light shadow.
   */
  constructor() {
    super(new Fi(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Be(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Kt(2, 1, 1, 1),
      // negative X
      new Kt(0, 1, 1, 1),
      // positive Z
      new Kt(3, 1, 1, 1),
      // negative Z
      new Kt(1, 1, 1, 1),
      // positive Y
      new Kt(3, 0, 1, 1),
      // negative Y
      new Kt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new H(1, 0, 0),
      new H(-1, 0, 0),
      new H(0, 0, 1),
      new H(0, 0, -1),
      new H(0, 1, 0),
      new H(0, -1, 0)
    ], this._cubeUps = [
      new H(0, 1, 0),
      new H(0, 1, 0),
      new H(0, 1, 0),
      new H(0, 1, 0),
      new H(0, 0, 1),
      new H(0, 0, -1)
    ];
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   * @param {number} [viewportIndex=0] - The viewport index.
   */
  updateMatrices(e, t = 0) {
    const i = this.camera, n = this.matrix, r = e.distance || i.far;
    r !== i.far && (i.far = r, i.updateProjectionMatrix()), ff.setFromMatrixPosition(e.matrixWorld), i.position.copy(ff), Lx.copy(i.position), Lx.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(Lx), i.updateMatrixWorld(), n.makeTranslation(-ff.x, -ff.y, -ff.z), $T.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix($T);
  }
}
class yS extends zl {
  /**
   * Constructs a new point light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, i = 0, n = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new P5();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class Ua extends M_ {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = -1, t = 1, i = 1, n = -1, r = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(e, t, i, n, r, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let r = i - e, o = i + e, a = n + t, l = n - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += c * this.view.offsetX, o = r + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
class R5 extends vS {
  /**
   * Constructs a new directional light shadow.
   */
  constructor() {
    super(new Ua(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class q_ extends zl {
  /**
   * Constructs a new directional light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(tn.DEFAULT_UP), this.updateMatrix(), this.target = new tn(), this.shadow = new R5();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class wI extends zl {
  /**
   * Constructs a new ambient light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class SI extends zl {
  /**
   * Constructs a new area light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   * @param {number} [width=10] - The width of the light.
   * @param {number} [height=10] - The height of the light.
   */
  constructor(e, t, i = 10, n = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = n;
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class MI {
  /**
   * Constructs a new spherical harmonics.
   */
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new H());
  }
  /**
   * Sets the given SH coefficients to this instance by copying
   * the values.
   *
   * @param {Array<Vector3>} coefficients - The SH coefficients.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  /**
   * Sets all SH coefficients to `0`.
   *
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  /**
   * Returns the radiance in the direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The radiance.
   */
  getAt(e, t) {
    const i = e.x, n = e.y, r = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * n), t.addScaledVector(o[2], 0.488603 * r), t.addScaledVector(o[3], 0.488603 * i), t.addScaledVector(o[4], 1.092548 * (i * n)), t.addScaledVector(o[5], 1.092548 * (n * r)), t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(o[7], 1.092548 * (i * r)), t.addScaledVector(o[8], 0.546274 * (i * i - n * n)), t;
  }
  /**
   * Returns the irradiance (radiance convolved with cosine lobe) in the
   * direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The irradiance.
   */
  getIrradianceAt(e, t) {
    const i = e.x, n = e.y, r = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * n), t.addScaledVector(o[2], 2 * 0.511664 * r), t.addScaledVector(o[3], 2 * 0.511664 * i), t.addScaledVector(o[4], 2 * 0.429043 * i * n), t.addScaledVector(o[5], 2 * 0.429043 * n * r), t.addScaledVector(o[6], 0.743125 * r * r - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * i * r), t.addScaledVector(o[8], 0.429043 * (i * i - n * n)), t;
  }
  /**
   * Adds the given SH to this instance.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  /**
   * A convenience method for performing {@link SphericalHarmonics3#add} and
   * {@link SphericalHarmonics3#scale} at once.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  /**
   * Scales this SH by the given scale factor.
   *
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  /**
   * Linear interpolates between the given SH and this instance by the given
   * alpha factor.
   *
   * @param {SphericalHarmonics3} sh - The SH to interpolate with.
   * @param {number} alpha - The alpha factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  lerp(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  /**
   * Returns `true` if this spherical harmonics is equal with the given one.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
   * @return {boolean} Whether this spherical harmonics is equal with the given one.
   */
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  /**
   * Copies the values of the given spherical harmonics to this instance.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  copy(e) {
    return this.set(e.coefficients);
  }
  /**
   * Returns a new spherical harmonics with copied values from this instance.
   *
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the SH coefficients of this instance from the given array.
   *
   * @param {Array<number>} array - An array holding the SH coefficients.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].fromArray(e, t + n * 3);
    return this;
  }
  /**
   * Returns an array with the SH coefficients, or copies them into the provided
   * array. The coefficients are represented as numbers.
   *
   * @param {Array<number>} [array=[]] - The target array.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {Array<number>} An array with flat SH coefficients.
   */
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].toArray(e, t + n * 3);
    return e;
  }
  /**
   * Computes the SH basis for the given normal vector.
   *
   * @param {Vector3} normal - The normal.
   * @param {Array<number>} shBasis - The target array holding the SH basis.
   */
  static getBasisAt(e, t) {
    const i = e.x, n = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * n, t[2] = 0.488603 * r, t[3] = 0.488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * i * r, t[8] = 0.546274 * (i * i - n * n);
  }
}
class EI extends zl {
  /**
   * Constructs a new light probe.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e = new MI(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  /**
   * Deserializes the light prove from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized light probe.
   * @return {LightProbe} A reference to this light probe.
   */
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Z_ extends br {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, n) {
    const r = this, o = new ps(r.manager);
    o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = this.textures;
    function i(r) {
      return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
    }
    const n = this.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (n.uuid = e.uuid), e.name !== void 0 && (n.name = e.name), e.color !== void 0 && n.color !== void 0 && n.color.setHex(e.color), e.roughness !== void 0 && (n.roughness = e.roughness), e.metalness !== void 0 && (n.metalness = e.metalness), e.sheen !== void 0 && (n.sheen = e.sheen), e.sheenColor !== void 0 && (n.sheenColor = new rt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (n.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && n.emissive !== void 0 && n.emissive.setHex(e.emissive), e.specular !== void 0 && n.specular !== void 0 && n.specular.setHex(e.specular), e.specularIntensity !== void 0 && (n.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && n.specularColor !== void 0 && n.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (n.shininess = e.shininess), e.clearcoat !== void 0 && (n.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (n.dispersion = e.dispersion), e.iridescence !== void 0 && (n.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (n.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (n.transmission = e.transmission), e.thickness !== void 0 && (n.thickness = e.thickness), e.attenuationDistance !== void 0 && (n.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && n.attenuationColor !== void 0 && n.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (n.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (n.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (n.fog = e.fog), e.flatShading !== void 0 && (n.flatShading = e.flatShading), e.blending !== void 0 && (n.blending = e.blending), e.combine !== void 0 && (n.combine = e.combine), e.side !== void 0 && (n.side = e.side), e.shadowSide !== void 0 && (n.shadowSide = e.shadowSide), e.opacity !== void 0 && (n.opacity = e.opacity), e.transparent !== void 0 && (n.transparent = e.transparent), e.alphaTest !== void 0 && (n.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (n.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (n.depthFunc = e.depthFunc), e.depthTest !== void 0 && (n.depthTest = e.depthTest), e.depthWrite !== void 0 && (n.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (n.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (n.blendSrc = e.blendSrc), e.blendDst !== void 0 && (n.blendDst = e.blendDst), e.blendEquation !== void 0 && (n.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (n.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (n.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (n.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && n.blendColor !== void 0 && n.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (n.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (n.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (n.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (n.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (n.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (n.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (n.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (n.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (n.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (n.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (n.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (n.rotation = e.rotation), e.linewidth !== void 0 && (n.linewidth = e.linewidth), e.dashSize !== void 0 && (n.dashSize = e.dashSize), e.gapSize !== void 0 && (n.gapSize = e.gapSize), e.scale !== void 0 && (n.scale = e.scale), e.polygonOffset !== void 0 && (n.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (n.dithering = e.dithering), e.alphaToCoverage !== void 0 && (n.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (n.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (n.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (n.visible = e.visible), e.toneMapped !== void 0 && (n.toneMapped = e.toneMapped), e.userData !== void 0 && (n.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? n.vertexColors = e.vertexColors > 0 : n.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const r in e.uniforms) {
        const o = e.uniforms[r];
        switch (n.uniforms[r] = {}, o.type) {
          case "t":
            n.uniforms[r].value = i(o.value);
            break;
          case "c":
            n.uniforms[r].value = new rt().setHex(o.value);
            break;
          case "v2":
            n.uniforms[r].value = new Be().fromArray(o.value);
            break;
          case "v3":
            n.uniforms[r].value = new H().fromArray(o.value);
            break;
          case "v4":
            n.uniforms[r].value = new Kt().fromArray(o.value);
            break;
          case "m3":
            n.uniforms[r].value = new Jt().fromArray(o.value);
            break;
          case "m4":
            n.uniforms[r].value = new _t().fromArray(o.value);
            break;
          default:
            n.uniforms[r].value = o.value;
        }
      }
    if (e.defines !== void 0 && (n.defines = e.defines), e.vertexShader !== void 0 && (n.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (n.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (n.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const r in e.extensions)
        n.extensions[r] = e.extensions[r];
    if (e.lights !== void 0 && (n.lights = e.lights), e.clipping !== void 0 && (n.clipping = e.clipping), e.size !== void 0 && (n.size = e.size), e.sizeAttenuation !== void 0 && (n.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (n.map = i(e.map)), e.matcap !== void 0 && (n.matcap = i(e.matcap)), e.alphaMap !== void 0 && (n.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (n.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (n.bumpScale = e.bumpScale), e.normalMap !== void 0 && (n.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (n.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), n.normalScale = new Be().fromArray(r);
    }
    return e.displacementMap !== void 0 && (n.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (n.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (n.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (n.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (n.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (n.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (n.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (n.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (n.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (n.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (n.envMap = i(e.envMap)), e.envMapRotation !== void 0 && n.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (n.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (n.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (n.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (n.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (n.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (n.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (n.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (n.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (n.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (n.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (n.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (n.clearcoatNormalScale = new Be().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (n.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (n.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (n.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (n.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (n.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (n.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (n.sheenRoughnessMap = i(e.sheenRoughnessMap)), n;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  createMaterialFromType(e) {
    return Z_.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: aI,
      SpriteMaterial: Pu,
      RawShaderMaterial: lI,
      ShaderMaterial: Mi,
      PointsMaterial: D_,
      MeshPhysicalMaterial: oo,
      MeshStandardMaterial: fm,
      MeshPhongMaterial: cI,
      MeshToonMaterial: uI,
      MeshNormalMaterial: hI,
      MeshLambertMaterial: dI,
      MeshDepthMaterial: Ru,
      MeshDistanceMaterial: Cd,
      MeshBasicMaterial: qn,
      MeshMatcapMaterial: fI,
      LineDashedMaterial: pI,
      LineBasicMaterial: Bi,
      Material: ji
    };
    return new t[e]();
  }
}
class Tl {
  static decodeText(e) {
    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e.length; i < n; i++)
      t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class pm extends Gt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class TI extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, o = new ps(r.manager);
    o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = {}, i = {};
    function n(f, m) {
      if (t[m] !== void 0) return t[m];
      const v = f.interleavedBuffers[m], _ = r(f, v.buffer), y = Lh(v.type, _), w = new lm(y, v.stride);
      return w.uuid = v.uuid, t[m] = w, w;
    }
    function r(f, m) {
      if (i[m] !== void 0) return i[m];
      const v = f.arrayBuffers[m], _ = new Uint32Array(v).buffer;
      return i[m] = _, _;
    }
    const o = e.isInstancedBufferGeometry ? new pm() : new Gt(), a = e.data.index;
    if (a !== void 0) {
      const f = Lh(a.type, a.array);
      o.setIndex(new Nt(f, 1));
    }
    const l = e.data.attributes;
    for (const f in l) {
      const m = l[f];
      let g;
      if (m.isInterleavedBufferAttribute) {
        const v = n(e.data, m.data);
        g = new ss(v, m.itemSize, m.offset, m.normalized);
      } else {
        const v = Lh(m.type, m.array), _ = m.isInstancedBufferAttribute ? Jo : Nt;
        g = new _(v, m.itemSize, m.normalized);
      }
      m.name !== void 0 && (g.name = m.name), m.usage !== void 0 && g.setUsage(m.usage), o.setAttribute(f, g);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const f in c) {
        const m = c[f], g = [];
        for (let v = 0, _ = m.length; v < _; v++) {
          const y = m[v];
          let w;
          if (y.isInterleavedBufferAttribute) {
            const x = n(e.data, y.data);
            w = new ss(x, y.itemSize, y.offset, y.normalized);
          } else {
            const x = Lh(y.type, y.array);
            w = new Nt(x, y.itemSize, y.normalized);
          }
          y.name !== void 0 && (w.name = y.name), g.push(w);
        }
        o.morphAttributes[f] = g;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const h = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (h !== void 0)
      for (let f = 0, m = h.length; f !== m; ++f) {
        const g = h[f];
        o.addGroup(g.start, g.count, g.materialIndex);
      }
    const d = e.data.boundingSphere;
    if (d !== void 0) {
      const f = new H();
      d.center !== void 0 && f.fromArray(d.center), o.boundingSphere = new fi(f, d.radius);
    }
    return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class D5 extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, o = this.path === "" ? Tl.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new ps(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      let c = null;
      try {
        c = JSON.parse(l);
      } catch (h) {
        n !== void 0 && n(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
        return;
      }
      const u = c.metadata;
      if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
        n !== void 0 && n(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(c, t);
    }, i, n);
  }
  async loadAsync(e, t) {
    const i = this, n = this.path === "" ? Tl.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || n;
    const r = new ps(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const o = await r.loadAsync(e, t), a = JSON.parse(o), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), o = this.parseImages(e.images, function() {
      t !== void 0 && t(c);
    }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, r, l, a, i), u = this.parseSkeletons(e.skeletons, c);
    if (this.bindSkeletons(c, u), this.bindLightTargets(c), t !== void 0) {
      let h = !1;
      for (const d in o)
        if (o[d].data instanceof HTMLImageElement) {
          h = !0;
          break;
        }
      h === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, i), r = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, r), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, n, a, o, t), c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), this.bindLightTargets(l), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, n = e.length; i < n; i++) {
        const r = new El().fromJSON(e[i]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {}, n = {};
    if (t.traverse(function(r) {
      r.isBone && (n[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, o = e.length; r < o; r++) {
        const a = new um().fromJSON(e[r], n);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const n = new TI();
      for (let r = 0, o = e.length; r < o; r++) {
        let a;
        const l = e[r];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = n.parse(l);
            break;
          default:
            l.type in qT ? a = qT[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a;
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {}, n = {};
    if (e !== void 0) {
      const r = new Z_();
      r.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        i[l.uuid] === void 0 && (i[l.uuid] = r.parse(l)), n[l.uuid] = i[l.uuid];
      }
    }
    return n;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const n = e[i], r = pd.parse(n);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this, n = {};
    let r;
    function o(l) {
      return i.manager.itemStart(l), r.load(l, function() {
        i.manager.itemEnd(l);
      }, void 0, function() {
        i.manager.itemError(l), i.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const c = l, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
        return o(u);
      } else
        return l.data ? {
          data: Lh(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new mS(t);
      r = new jp(l), r.setCrossOrigin(this.crossOrigin);
      for (let c = 0, u = e.length; c < u; c++) {
        const h = e[c], d = h.url;
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, g = d.length; m < g; m++) {
            const v = d[m], _ = a(v);
            _ !== null && (_ instanceof HTMLImageElement ? f.push(_) : f.push(new yr(_.data, _.width, _.height)));
          }
          n[h.uuid] = new yl(f);
        } else {
          const f = a(h.url);
          n[h.uuid] = new yl(f);
        }
      }
    }
    return n;
  }
  async parseImagesAsync(e) {
    const t = this, i = {};
    let n;
    async function r(o) {
      if (typeof o == "string") {
        const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await n.loadAsync(l);
      } else
        return o.data ? {
          data: Lh(o.type, o.data),
          width: o.width,
          height: o.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      n = new jp(this.manager), n.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o], c = l.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let h = 0, d = c.length; h < d; h++) {
            const f = c[h], m = await r(f);
            m !== null && (m instanceof HTMLImageElement ? u.push(m) : u.push(new yr(m.data, m.width, m.height)));
          }
          i[l.uuid] = new yl(u);
        } else {
          const u = await r(l.url);
          i[l.uuid] = new yl(u);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(r, o) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), o[r]);
    }
    const n = {};
    if (e !== void 0)
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image], c = l.data;
        let u;
        Array.isArray(c) ? (u = new Ed(), c.length === 6 && (u.needsUpdate = !0)) : (c && c.data ? u = new yr() : u = new ei(), c && (u.needsUpdate = !0)), u.source = l, u.uuid = a.uuid, a.name !== void 0 && (u.name = a.name), a.mapping !== void 0 && (u.mapping = i(a.mapping, I5)), a.channel !== void 0 && (u.channel = a.channel), a.offset !== void 0 && u.offset.fromArray(a.offset), a.repeat !== void 0 && u.repeat.fromArray(a.repeat), a.center !== void 0 && u.center.fromArray(a.center), a.rotation !== void 0 && (u.rotation = a.rotation), a.wrap !== void 0 && (u.wrapS = i(a.wrap[0], JT), u.wrapT = i(a.wrap[1], JT)), a.format !== void 0 && (u.format = a.format), a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat), a.type !== void 0 && (u.type = a.type), a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace), a.minFilter !== void 0 && (u.minFilter = i(a.minFilter, QT)), a.magFilter !== void 0 && (u.magFilter = i(a.magFilter, QT)), a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy), a.flipY !== void 0 && (u.flipY = a.flipY), a.generateMipmaps !== void 0 && (u.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (u.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (u.compareFunction = a.compareFunction), a.userData !== void 0 && (u.userData = a.userData), n[a.uuid] = u;
      }
    return n;
  }
  parseObject(e, t, i, n, r) {
    let o;
    function a(d) {
      return t[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), t[d];
    }
    function l(d) {
      if (d !== void 0) {
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, g = d.length; m < g; m++) {
            const v = d[m];
            i[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), f.push(i[v]);
          }
          return f;
        }
        return i[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), i[d];
      }
    }
    function c(d) {
      return n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), n[d];
    }
    let u, h;
    switch (e.type) {
      case "Scene":
        o = new am(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new rt(e.background) : o.background = c(e.background)), e.environment !== void 0 && (o.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new C_(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new A_(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        o = new Fi(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new Ua(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new wI(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new q_(e.color, e.intensity), o.target = e.target || "";
        break;
      case "PointLight":
        o = new yS(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new SI(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new _S(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), o.target = e.target || "";
        break;
      case "HemisphereLight":
        o = new bI(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new EI().fromJSON(e);
        break;
      case "SkinnedMesh":
        u = a(e.geometry), h = l(e.material), o = new P_(u, h), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        u = a(e.geometry), h = l(e.material), o = new it(u, h);
        break;
      case "InstancedMesh":
        u = a(e.geometry), h = l(e.material);
        const d = e.count, f = e.instanceMatrix, m = e.instanceColor;
        o = new Td(u, h, d), o.instanceMatrix = new Jo(new Float32Array(f.array), 16), m !== void 0 && (o.instanceColor = new Jo(new Float32Array(m.array), m.itemSize));
        break;
      case "BatchedMesh":
        u = a(e.geometry), h = l(e.material), o = new KD(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, h), o.geometry = u, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((g) => {
          const v = new yn();
          v.min.fromArray(g.boxMin), v.max.fromArray(g.boxMax);
          const _ = new fi();
          return _.radius = g.sphereRadius, _.center.fromArray(g.sphereCenter), {
            boxInitialized: g.boxInitialized,
            box: v,
            sphereInitialized: g.sphereInitialized,
            sphere: _
          };
        }), o._maxInstanceCount = e.maxInstanceCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = c(e.matricesTexture.uuid), e.colorsTexture !== void 0 && (o._colorsTexture = c(e.colorsTexture.uuid));
        break;
      case "LOD":
        o = new nS();
        break;
      case "Line":
        o = new Ui(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new iS(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new so(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new I_(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new cm(l(e.material));
        break;
      case "Group":
        o = new Zn();
        break;
      case "Bone":
        o = new R_();
        break;
      default:
        o = new tn();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (o.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const d = e.children;
      for (let f = 0; f < d.length; f++)
        o.add(this.parseObject(d[f], t, i, n, r));
    }
    if (e.animations !== void 0) {
      const d = e.animations;
      for (let f = 0; f < d.length; f++) {
        const m = d[f];
        o.animations.push(r[m]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const d = e.levels;
      for (let f = 0; f < d.length; f++) {
        const m = d[f], g = o.getObjectByProperty("uuid", m.object);
        g !== void 0 && o.addLevel(g, m.distance, m.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(i) {
      if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
        const n = t[i.skeleton];
        n === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(n, i.bindMatrix);
      }
    });
  }
  bindLightTargets(e) {
    e.traverse(function(t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const i = t.target, n = e.getObjectByProperty("uuid", i);
        n !== void 0 ? t.target = n : t.target = new tn();
      }
    });
  }
}
const I5 = {
  UVMapping: p_,
  CubeReflectionMapping: Ia,
  CubeRefractionMapping: Il,
  EquirectangularReflectionMapping: ld,
  EquirectangularRefractionMapping: Op,
  CubeUVReflectionMapping: xd
}, JT = {
  RepeatWrapping: Ns,
  ClampToEdgeWrapping: gr,
  MirroredRepeatWrapping: cd
}, QT = {
  NearestFilter: Tn,
  NearestMipmapNearestFilter: m_,
  NearestMipmapLinearFilter: Bc,
  LinearFilter: Sn,
  LinearMipmapNearestFilter: qh,
  LinearMipmapLinearFilter: As
};
class AI extends br {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, o = Ea.get(e);
    if (o !== void 0) {
      if (r.manager.itemStart(e), o.then) {
        o.then((c) => {
          t && t(c), r.manager.itemEnd(e);
        }).catch((c) => {
          n && n(c);
        });
        return;
      }
      return setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
    }
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
    const l = fetch(e, a).then(function(c) {
      return c.blob();
    }).then(function(c) {
      return createImageBitmap(c, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(c) {
      return Ea.add(e, c), t && t(c), r.manager.itemEnd(e), c;
    }).catch(function(c) {
      n && n(c), Ea.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
    });
    Ea.add(e, l), r.manager.itemStart(e);
  }
}
let Dg;
class xS {
  /**
   * Returns the global native audio context.
   *
   * @return {AudioContext} The native audio context.
   */
  static getContext() {
    return Dg === void 0 && (Dg = new (window.AudioContext || window.webkitAudioContext)()), Dg;
  }
  /**
   * Allows to set the global native audio context from outside.
   *
   * @param {AudioContext} value - The native context to set.
   */
  static setContext(e) {
    Dg = e;
  }
}
class CI extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, o = new ps(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        const c = l.slice(0);
        xS.getContext().decodeAudioData(c, function(h) {
          t(h);
        }).catch(a);
      } catch (c) {
        a(c);
      }
    }, i, n);
    function a(l) {
      n ? n(l) : console.error(l), r.manager.itemError(e);
    }
  }
}
const eA = /* @__PURE__ */ new _t(), tA = /* @__PURE__ */ new _t(), ac = /* @__PURE__ */ new _t();
class L5 {
  /**
   * Constructs a new stereo camera.
   */
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Fi(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Fi(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  /**
   * Updates the stereo camera based on the given perspective camera.
   *
   * @param {PerspectiveCamera} camera - The perspective camera.
   */
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ac.copy(e.projectionMatrix);
      const n = t.eyeSep / 2, r = n * t.near / t.focus, o = t.near * Math.tan(tu * t.fov * 0.5) / t.zoom;
      let a, l;
      tA.elements[12] = -n, eA.elements[12] = n, a = -o * t.aspect + r, l = o * t.aspect + r, ac.elements[0] = 2 * t.near / (l - a), ac.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(ac), a = -o * t.aspect - r, l = o * t.aspect - r, ac.elements[0] = 2 * t.near / (l - a), ac.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(ac);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(tA), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(eA);
  }
}
class PI extends Fi {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0;
  }
}
class bS {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = nA(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = nA();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function nA() {
  return performance.now();
}
const lc = /* @__PURE__ */ new H(), iA = /* @__PURE__ */ new En(), U5 = /* @__PURE__ */ new H(), cc = /* @__PURE__ */ new H();
let RI = class extends tn {
  /**
   * Constructs a new audio listener.
   */
  constructor() {
    super(), this.type = "AudioListener", this.context = xS.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new bS();
  }
  /**
   * Returns the listener's input node.
   *
   * This method is used by other audio nodes to connect to this listener.
   *
   * @return {GainNode} The input node.
   */
  getInput() {
    return this.gain;
  }
  /**
   * Removes the current filter from this listener.
   *
   * @return {AudioListener} A reference to this listener.
   */
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  /**
   * Returns the current set filter.
   *
   * @return {AudioNode} The filter.
   */
  getFilter() {
    return this.filter;
  }
  /**
   * Sets the given filter to this listener.
   *
   * @param {AudioNode} value - The filter to set.
   * @return {AudioListener} A reference to this listener.
   */
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  /**
   * Returns the applications master volume.
   *
   * @return {number} The master volume.
   */
  getMasterVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the applications master volume. This volume setting affects
   * all audio nodes in the scene.
   *
   * @param {number} value - The master volume to set.
   * @return {AudioListener} A reference to this listener.
   */
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, i = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(lc, iA, U5), cc.set(0, 0, -1).applyQuaternion(iA), t.positionX) {
      const n = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(lc.x, n), t.positionY.linearRampToValueAtTime(lc.y, n), t.positionZ.linearRampToValueAtTime(lc.z, n), t.forwardX.linearRampToValueAtTime(cc.x, n), t.forwardY.linearRampToValueAtTime(cc.y, n), t.forwardZ.linearRampToValueAtTime(cc.z, n), t.upX.linearRampToValueAtTime(i.x, n), t.upY.linearRampToValueAtTime(i.y, n), t.upZ.linearRampToValueAtTime(i.z, n);
    } else
      t.setPosition(lc.x, lc.y, lc.z), t.setOrientation(cc.x, cc.y, cc.z, i.x, i.y, i.z);
  }
}, wS = class extends tn {
  /**
   * Constructs a new audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  /**
   * Returns the output audio node.
   *
   * @return {GainNode} The output node.
   */
  getOutput() {
    return this.gain;
  }
  /**
   * Sets the given audio node as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `audioNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {AudioNode} audioNode - The audio node like an instance of `OscillatorNode`.
   * @return {Audio} A reference to this instance.
   */
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  /**
   * Sets the given media element as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {HTMLMediaElement} mediaElement - The media element.
   * @return {Audio} A reference to this instance.
   */
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  /**
   * Sets the given media stream as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaStreamNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {MediaStream} mediaStream - The media stream.
   * @return {Audio} A reference to this instance.
   */
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  /**
   * Sets the given audio buffer as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `buffer` and {@link Audio#hasPlaybackControl} to `true`.
   *
   * @param {AudioBuffer} audioBuffer - The audio buffer.
   * @return {Audio} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  /**
   * Starts the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should start playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  /**
   * Pauses the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  /**
   * Stops the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should stop playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this;
  }
  /**
   * Connects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio} A reference to this instance.
   */
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  /**
   * Disconnects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  /**
   * Returns the current set filters.
   *
   * @return {Array<AudioNode>} The list of filters.
   */
  getFilters() {
    return this.filters;
  }
  /**
   * Sets an array of filters and connects them with the audio source.
   *
   * @param {Array<AudioNode>} [value] - A list of filters.
   * @return {Audio} A reference to this instance.
   */
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  /**
   * Defines the detuning of oscillation in cents.
   *
   * @param {number} value - The detuning of oscillation in cents.
   * @return {Audio} A reference to this instance.
   */
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  /**
   * Returns the detuning of oscillation in cents.
   *
   * @return {number} The detuning of oscillation in cents.
   */
  getDetune() {
    return this.detune;
  }
  /**
   * Returns the first filter in the list of filters.
   *
   * @return {AudioNode|undefined} The first filter in the list of filters.
   */
  getFilter() {
    return this.getFilters()[0];
  }
  /**
   * Applies a single filter node to the audio.
   *
   * @param {AudioNode} [filter] - The filter to set.
   * @return {Audio} A reference to this instance.
   */
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  /**
   * Sets the playback rate.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [value] - The playback rate to set.
   * @return {Audio|undefined} A reference to this instance.
   */
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  /**
  	 * Returns the current playback rate.
  
  	 * @return {number} The playback rate.
  	 */
  getPlaybackRate() {
    return this.playbackRate;
  }
  /**
   * Automatically called when playback finished.
   */
  onEnded() {
    this.isPlaying = !1, this._progress = 0;
  }
  /**
   * Returns the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {boolean} Whether the audio should loop or not.
   */
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  /**
   * Sets the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {boolean} value - Whether the audio should loop or not.
   * @return {Audio|undefined} A reference to this instance.
   */
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  /**
   * Sets the loop start value which defines where in the audio buffer the replay should
   * start, in seconds.
   *
   * @param {number} value - The loop start value.
   * @return {Audio} A reference to this instance.
   */
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  /**
   * Sets the loop end value which defines where in the audio buffer the replay should
   * stop, in seconds.
   *
   * @param {number} value - The loop end value.
   * @return {Audio} A reference to this instance.
   */
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  /**
   * Returns the volume.
   *
   * @return {number} The volume.
   */
  getVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the volume.
   *
   * @param {number} value - The volume to set.
   * @return {Audio} A reference to this instance.
   */
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  copy(e, t) {
    return super.copy(e, t), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this);
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
};
const uc = /* @__PURE__ */ new H(), rA = /* @__PURE__ */ new En(), k5 = /* @__PURE__ */ new H(), hc = /* @__PURE__ */ new H();
let DI = class extends wS {
  /**
   * Constructs a positional audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  /**
   * Returns the current reference distance.
   *
   * @return {number} The reference distance.
   */
  getRefDistance() {
    return this.panner.refDistance;
  }
  /**
   * Defines the reference distance for reducing volume as the audio source moves
   * further from the listener  i.e. the distance at which the volume reduction
   * starts taking effect.
   *
   * @param {number} value - The reference distance to set.
   * @return {Audio} A reference to this instance.
   */
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  /**
   * Returns the current rolloff factor.
   *
   * @return {number} The rolloff factor.
   */
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  /**
   * Defines how quickly the volume is reduced as the source moves away from the listener.
   *
   * @param {number} value - The rolloff factor.
   * @return {Audio} A reference to this instance.
   */
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  /**
   * Returns the current distance model.
   *
   * @return {('linear'|'inverse'|'exponential')} The distance model.
   */
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  /**
   * Defines which algorithm to use to reduce the volume of the audio source
   * as it moves away from the listener.
   *
   * Read [the spec]{@link https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype}
   * for more details.
   *
   * @param {('linear'|'inverse'|'exponential')} value - The distance model to set.
   * @return {Audio} A reference to this instance.
   */
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  /**
   * Returns the current max distance.
   *
   * @return {number} The max distance.
   */
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  /**
   * Defines the maximum distance between the audio source and the listener,
   * after which the volume is not reduced any further.
   *
   * This value is used only by the `linear` distance model.
   *
   * @param {number} value - The max distance.
   * @return {Audio} A reference to this instance.
   */
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  /**
   * Sets the directional cone in which the audio can be listened.
   *
   * @param {number} coneInnerAngle - An angle, in degrees, of a cone inside of which there will be no volume reduction.
   * @param {number} coneOuterAngle - An angle, in degrees, of a cone outside of which the volume will be reduced by a constant value, defined by the `coneOuterGain` parameter.
   * @param {number} coneOuterGain - The amount of volume reduction outside the cone defined by the `coneOuterAngle`. When set to `0`, no sound can be heard.
   * @return {Audio} A reference to this instance.
   */
  setDirectionalCone(e, t, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(uc, rA, k5), hc.set(0, 0, 1).applyQuaternion(rA);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(uc.x, i), t.positionY.linearRampToValueAtTime(uc.y, i), t.positionZ.linearRampToValueAtTime(uc.z, i), t.orientationX.linearRampToValueAtTime(hc.x, i), t.orientationY.linearRampToValueAtTime(hc.y, i), t.orientationZ.linearRampToValueAtTime(hc.z, i);
    } else
      t.setPosition(uc.x, uc.y, uc.z), t.setOrientation(hc.x, hc.y, hc.z);
  }
};
class O5 {
  /**
   * Constructs a new audio analyzer.
   *
   * @param {Audio} audio - The audio to analyze.
   * @param {Audio} [fftSize=2048] - The window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data.
   */
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  /**
   * Returns an array with frequency data of the audio.
   *
   * Each item in the array represents the decibel value for a specific frequency.
   * The frequencies are spread linearly from 0 to 1/2 of the sample rate.
   * For example, for 48000 sample rate, the last item of the array will represent
   * the decibel value for 24000 Hz.
   *
   * @return {Uint8Array} The frequency data.
   */
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  /**
   * Returns the average of the frequencies returned by {@link AudioAnalyser#getFrequencyData}.
   *
   * @return {number} The average frequency.
   */
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++)
      e += t[i];
    return e / t.length;
  }
}
class II {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let n, r, o;
    switch (t) {
      case "quaternion":
        n = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        n = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        n = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const i = this.buffer, n = this.valueSize, r = e * n + n;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== n; ++a)
        i[r + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, r, 0, a, n);
    }
    this.cumulativeWeight = o;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, n = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        i,
        n,
        l,
        1 - r,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, n);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, n = i * this._origIndex;
    e.getValue(t, n);
    for (let r = i, o = n; r !== o; ++r)
      t[r] = t[n + r % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++)
      this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  // mix functions
  _select(e, t, i, n, r) {
    if (n >= 0.5)
      for (let o = 0; o !== r; ++o)
        e[t + o] = e[i + o];
  }
  _slerp(e, t, i, n) {
    En.slerpFlat(e, t, e, t, e, i, n);
  }
  _slerpAdditive(e, t, i, n, r) {
    const o = this._workIndex * r;
    En.multiplyQuaternionsFlat(e, o, e, t, e, i), En.slerpFlat(e, t, e, t, e, o, n);
  }
  _lerp(e, t, i, n, r) {
    const o = 1 - n;
    for (let a = 0; a !== r; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * n;
    }
  }
  _lerpAdditive(e, t, i, n, r) {
    for (let o = 0; o !== r; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * n;
    }
  }
}
const SS = "\\[\\]\\.:\\/", F5 = new RegExp("[" + SS + "]", "g"), MS = "[^" + SS + "]", N5 = "[^" + SS.replace("\\.", "") + "]", B5 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", MS), z5 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", N5), V5 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", MS), G5 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", MS), H5 = new RegExp(
  "^" + B5 + z5 + V5 + G5 + "$"
), W5 = ["material", "materials", "bones", "map"];
class X5 {
  constructor(e, t, i) {
    const n = i || Mn.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, n);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
    n !== void 0 && n.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
      i[n].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class Mn {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || Mn.parseTrackName(t), this.node = Mn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new Mn.Composite(e, t, i) : new Mn(e, t, i);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(F5, "");
  }
  static parseTrackName(e) {
    const t = H5.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (n !== void 0 && n !== -1) {
      const r = i.nodeName.substring(n + 1);
      W5.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(r) {
        for (let o = 0; o < r.length; o++) {
          const a = r[o];
          if (a.name === t || a.uuid === t)
            return a;
          const l = i(a.children);
          if (l) return l;
        }
        return null;
      }, n = i(e.children);
      if (n)
        return n;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      e[t++] = i[n];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, n = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = Mn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const o = e[n];
    if (o === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.isMaterial === !0 ? a = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Mn.Composite = X5;
Mn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Mn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Mn.prototype.GetterByBindingType = [
  Mn.prototype._getValue_direct,
  Mn.prototype._getValue_array,
  Mn.prototype._getValue_arrayElement,
  Mn.prototype._getValue_toArray
];
Mn.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Mn.prototype._setValue_direct,
    Mn.prototype._setValue_direct_setNeedsUpdate,
    Mn.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Mn.prototype._setValue_array,
    Mn.prototype._setValue_array_setNeedsUpdate,
    Mn.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Mn.prototype._setValue_arrayElement,
    Mn.prototype._setValue_arrayElement_setNeedsUpdate,
    Mn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Mn.prototype._setValue_fromArray,
    Mn.prototype._setValue_fromArray_setNeedsUpdate,
    Mn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class Y5 {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = Ls(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, n = arguments.length; i !== n; ++i)
      e[arguments[i].uuid] = i;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, i = this._paths, n = this._parsedPaths, r = this._bindings, o = r.length;
    let a, l = e.length, c = this.nCachedObjects_;
    for (let u = 0, h = arguments.length; u !== h; ++u) {
      const d = arguments[u], f = d.uuid;
      let m = t[f];
      if (m === void 0) {
        m = l++, t[f] = m, e.push(d);
        for (let g = 0, v = o; g !== v; ++g)
          r[g].push(new Mn(d, i[g], n[g]));
      } else if (m < c) {
        a = e[m];
        const g = --c, v = e[g];
        t[v.uuid] = m, e[m] = v, t[f] = g, e[g] = d;
        for (let _ = 0, y = o; _ !== y; ++_) {
          const w = r[_], x = w[g];
          let M = w[m];
          w[m] = x, M === void 0 && (M = new Mn(d, i[_], n[_])), w[g] = M;
        }
      } else e[m] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, n = i.length;
    let r = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o], c = l.uuid, u = t[c];
      if (u !== void 0 && u >= r) {
        const h = r++, d = e[h];
        t[d.uuid] = u, e[u] = d, t[c] = h, e[h] = l;
        for (let f = 0, m = n; f !== m; ++f) {
          const g = i[f], v = g[h], _ = g[u];
          g[u] = v, g[h] = _;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, n = i.length;
    let r = this.nCachedObjects_, o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a], u = c.uuid, h = t[u];
      if (h !== void 0)
        if (delete t[u], h < r) {
          const d = --r, f = e[d], m = --o, g = e[m];
          t[f.uuid] = h, e[h] = f, t[g.uuid] = d, e[d] = g, e.pop();
          for (let v = 0, _ = n; v !== _; ++v) {
            const y = i[v], w = y[d], x = y[m];
            y[h] = w, y[d] = x, y.pop();
          }
        } else {
          const d = --o, f = e[d];
          d > 0 && (t[f.uuid] = h), e[h] = f, e.pop();
          for (let m = 0, g = n; m !== g; ++m) {
            const v = i[m];
            v[h] = v[d], v.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let n = i[e];
    const r = this._bindings;
    if (n !== void 0) return r[n];
    const o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, u = this.nCachedObjects_, h = new Array(c);
    n = r.length, i[e] = n, o.push(e), a.push(t), r.push(h);
    for (let d = u, f = l.length; d !== f; ++d) {
      const m = l[d];
      h[d] = new Mn(m, e, t);
    }
    return h;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, i = t[e];
    if (i !== void 0) {
      const n = this._paths, r = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = e[a];
      t[c] = i, o[i] = l, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop();
    }
  }
}
class LI {
  constructor(e, t, i = null, n = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n;
    const r = t.tracks, o = r.length, a = new Array(o), l = {
      endingStart: zc,
      endingEnd: zc
    };
    for (let c = 0; c !== o; ++c) {
      const u = r[c].createInterpolant(null);
      a[c] = u, u.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ID, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const n = this._clip.duration, r = e._clip.duration, o = r / n, a = n / r;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const n = this._mixer, r = n.time, o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const l = a.parameterPositions, c = a.sampleValues;
    return l[0] = r, l[1] = r + i, c[0] = e / o, c[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, i, n) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const l = (e - r) * i;
      l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case Kw:
          for (let u = 0, h = l.length; u !== h; ++u)
            l[u].evaluate(o), c[u].accumulateAdditive(a);
          break;
        case x_:
        default:
          for (let u = 0, h = l.length; u !== h; ++u)
            l[u].evaluate(o), c[u].accumulate(n, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let n = this.time + e, r = this._loopCount;
    const o = i === LD;
    if (e === 0)
      return r === -1 ? n : o && (r & 1) === 1 ? t - n : n;
    if (i === DD) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (n >= t)
          n = t;
        else if (n < 0)
          n = 0;
        else {
          this.time = n;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = n, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), n >= t || n < 0) {
        const a = Math.floor(n / t);
        n -= t * a, r += Math.abs(a);
        const l = this.repetitions - r;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: a
          });
        }
      } else
        this.time = n;
      if (o && (r & 1) === 1)
        return t - n;
    }
    return n;
  }
  _setEndings(e, t, i) {
    const n = this._interpolantSettings;
    i ? (n.endingStart = Vc, n.endingEnd = Vc) : (e ? n.endingStart = this.zeroSlopeAtStart ? Vc : zc : n.endingStart = Np, t ? n.endingEnd = this.zeroSlopeAtEnd ? Vc : zc : n.endingEnd = Np);
  }
  _scheduleFading(e, t, i) {
    const n = this._mixer, r = n.time;
    let o = this._weightInterpolant;
    o === null && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
    const a = o.parameterPositions, l = o.sampleValues;
    return a[0] = r, l[0] = t, a[1] = r + e, l[1] = i, this;
  }
}
const j5 = new Float32Array(1);
class q5 extends Qo {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, o = e._propertyBindings, a = e._interpolants, l = i.uuid, c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && (u = {}, c[l] = u);
    for (let h = 0; h !== r; ++h) {
      const d = n[h], f = d.name;
      let m = u[f];
      if (m !== void 0)
        ++m.referenceCount, o[h] = m;
      else {
        if (m = o[h], m !== void 0) {
          m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, f));
          continue;
        }
        const g = t && t._propertyBindings[h].binding.parsedPath;
        m = new II(
          Mn.create(i, f, g),
          d.ValueTypeName,
          d.getValueSize()
        ), ++m.referenceCount, this._addInactiveBinding(m, l, f), o[h] = m;
      }
      a[h].resultBuffer = m.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, n, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const r = t[i];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const r = t[i];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const n = this._actions, r = this._actionsByClip;
    let o = r[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = o;
    else {
      const a = o.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = n.length, n.push(e), o.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], n = e._cacheIndex;
    i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, o = this._actionsByClip, a = o[r], l = a.knownActions, c = l[l.length - 1], u = e._byClipCacheIndex;
    c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
    const h = a.actionByRoot, d = (e._localRoot || this._root).uuid;
    delete h[d], l.length === 0 && delete o[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, n = t.length; i !== n; ++i) {
      const r = t[i];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, i) {
    const n = this._bindingsByRootAndName, r = this._bindings;
    let o = n[t];
    o === void 0 && (o = {}, n[t] = o), o[i] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, o = this._bindingsByRootAndName, a = o[n], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete a[r], Object.keys(a).length === 0 && delete o[n];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new fS(
      new Float32Array(2),
      new Float32Array(2),
      1,
      j5
    ), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n];
    e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, i) {
    const n = t || this._root, r = n.uuid;
    let o = typeof e == "string" ? pd.findByName(n, e) : e;
    const a = o !== null ? o.uuid : e, l = this._actionsByClip[a];
    let c = null;
    if (i === void 0 && (o !== null ? i = o.blendMode : i = x_), l !== void 0) {
      const h = l.actionByRoot[r];
      if (h !== void 0 && h.blendMode === i)
        return h;
      c = l.knownActions[0], o === null && (o = c._clip);
    }
    if (o === null) return null;
    const u = new LI(this, o, t, i);
    return this._bindAction(u, c), this._addInactiveAction(u, a, r), u;
  }
  // get an existing action
  existingAction(e, t) {
    const i = t || this._root, n = i.uuid, r = typeof e == "string" ? pd.findByName(i, e) : e, o = r ? r.uuid : e, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[n] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i)
      e[i].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1;
    for (let c = 0; c !== i; ++c)
      t[c]._update(n, e, r, o);
    const a = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      a[c].apply(o);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i];
    if (r !== void 0) {
      const o = r.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const u = c._cacheIndex, h = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = u, t[u] = h, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete n[i];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot, l = a[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const n = this._bindingsByRootAndName, r = n[t];
    if (r !== void 0)
      for (const o in r) {
        const a = r[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class Z5 extends b_ {
  constructor(e = 1, t = 1, i = 1, n = {}) {
    super(e, t, n), this.isRenderTarget3D = !0, this.depth = i, this.texture = new w_(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class K5 extends b_ {
  constructor(e = 1, t = 1, i = 1, n = {}) {
    super(e, t, n), this.isRenderTargetArray = !0, this.depth = i, this.texture = new om(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class ES {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new ES(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let $5 = 0;
class J5 extends Qo {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: $5++ }), this.name = "", this.usage = zp, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, n = t.length; i < n; i++) {
      const r = Array.isArray(t[i]) ? t[i] : [t[i]];
      for (let o = 0; o < r.length; o++)
        this.uniforms.push(r[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class $0 extends lm {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class Q5 {
  constructor(e, t, i, n, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = n, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
const sA = /* @__PURE__ */ new _t();
class K_ {
  constructor(e, t, i = 0, n = 1 / 0) {
    this.ray = new Ol(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new S_(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return sA.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(sA), this;
  }
  intersectObject(e, t = !0, i = []) {
    return M1(e, this, i, t), i.sort(oA), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let n = 0, r = e.length; n < r; n++)
      M1(e[n], this, i, t);
    return i.sort(oA), i;
  }
}
function oA(s, e) {
  return s.distance - e.distance;
}
function M1(s, e, t, i) {
  let n = !0;
  if (s.layers.test(e.layers) && s.raycast(e, t) === !1 && (n = !1), n === !0 && i === !0) {
    const r = s.children;
    for (let o = 0, a = r.length; o < a; o++)
      M1(r[o], e, t, !0);
  }
}
class md {
  /**
   * Constructs a new spherical.
   *
   * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
   * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
   * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
   */
  constructor(e = 1, t = 0, i = 0) {
    this.radius = e, this.phi = t, this.theta = i;
  }
  /**
   * Sets the spherical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The polar angle.
   * @param {number} theta - The azimuthal angle.
   * @return {Spherical} A reference to this spherical.
   */
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  /**
   * Copies the values of the given spherical to this instance.
   *
   * @param {Spherical} other - The spherical to copy.
   * @return {Spherical} A reference to this spherical.
   */
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  /**
   * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
   * `0.000001`.
   *
   * @return {Spherical} A reference to this spherical.
   */
  makeSafe() {
    return this.phi = Qt(this.phi, 1e-6, Math.PI - 1e-6), this;
  }
  /**
   * Sets the spherical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Spherical} A reference to this spherical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the spherical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Spherical} A reference to this spherical.
   */
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(Qt(t / this.radius, -1, 1))), this;
  }
  /**
   * Returns a new spherical with copied values from this instance.
   *
   * @return {Spherical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class eV {
  /**
   * Constructs a new cylindrical.
   *
   * @param {number} [radius=1] - The distance from the origin to a point in the x-z plane.
   * @param {number} [theta=0] - A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.
   * @param {number} [y=0] - The height above the x-z plane.
   */
  constructor(e = 1, t = 0, i = 0) {
    this.radius = e, this.theta = t, this.y = i;
  }
  /**
   * Sets the cylindrical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle.
   * @param {number} y - The height value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  set(e, t, i) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  /**
   * Copies the values of the given cylindrical to this instance.
   *
   * @param {Cylindrical} other - The cylindrical to copy.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  /**
   * Sets the cylindrical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the cylindrical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this;
  }
  /**
   * Returns a new cylindrical with copied values from this instance.
   *
   * @return {Cylindrical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class TS {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(e, t, i, n) {
    TS.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, n);
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let i = 0; i < 4; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(e, t, i, n) {
    const r = this.elements;
    return r[0] = e, r[2] = t, r[1] = i, r[3] = n, this;
  }
}
const aA = /* @__PURE__ */ new Be();
class tV {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector2} [min=(Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector2} [max=(-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new Be(1 / 0, 1 / 0), t = new Be(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector2} min - The lower boundary of the box.
   * @param {Vector2} max - The upper boundary of the box.
   * @return {Box2} A reference to this bounding box.
   */
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector2>} points - An array holding 2D position data as instances of {@link Vector2}.
   * @return {Box2} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector2} center - The center of the box.
   * @param {Vector2} size - The x and y dimensions of the box.
   * @return {Box2} A reference to this bounding box.
   */
  setFromCenterAndSize(e, t) {
    const i = aA.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box2} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box2} box - The box to copy.
   * @return {Box2} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 2D.
   *
   * @return {Box2} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector2} point - The point that should be included by the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions.
   *
   * @param {Vector2} vector - The vector that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector2} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  /**
   * Returns a point as a proportion of this box's width and height.
   *
   * @param {Vector2} point - A point in 2D space.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} A point as a proportion of this box's width and height.
   */
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector2} point - The point to clamp.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The clamped point.
   */
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector2} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, aA).distanceTo(e);
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box2} box - The bounding box to intersect with.
   * @return {Box2} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box2} box - The bounding box that will be unioned with this instance.
   * @return {Box2} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 2D space.
   *
   * @param {Vector2} offset - The offset that should be used to translate the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box2} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const lA = /* @__PURE__ */ new H(), Ig = /* @__PURE__ */ new H();
class xo {
  /**
   * Constructs a new line segment.
   *
   * @param {Vector3} [start=(0,0,0)] - Start of the line segment.
   * @param {Vector3} [end=(0,0,0)] - End of the line segment.
   */
  constructor(e = new H(), t = new H()) {
    this.start = e, this.end = t;
  }
  /**
   * Sets the start and end values by copying the given vectors.
   *
   * @param {Vector3} start - The start point.
   * @param {Vector3} end - The end point.
   * @return {Line3} A reference to this line segment.
   */
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  /**
   * Copies the values of the given line segment to this instance.
   *
   * @param {Line3} line - The line segment to copy.
   * @return {Line3} A reference to this line segment.
   */
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  /**
   * Returns the center of the line segment.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  /**
   * Returns the delta vector of the line segment's start and end point.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  /**
   * Returns the squared Euclidean distance between the line' start and end point.
   *
   * @return {number} The squared Euclidean distance.
   */
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  /**
   * Returns the Euclidean distance between the line' start and end point.
   *
   * @return {number} The Euclidean distance.
   */
  distance() {
    return this.start.distanceTo(this.end);
  }
  /**
   * Returns a vector at a certain position along the line segment.
   *
   * @param {number} t - A value between `[0,1]` to represent a position along the line segment.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  /**
   * Returns a point parameter based on the closest point as projected on the line segment.
   *
   * @param {Vector3} point - The point for which to return a point parameter.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @return {number} The point parameter.
   */
  closestPointToPointParameter(e, t) {
    lA.subVectors(e, this.start), Ig.subVectors(this.end, this.start);
    const i = Ig.dot(Ig);
    let r = Ig.dot(lA) / i;
    return t && (r = Qt(r, 0, 1)), r;
  }
  /**
   * Returns the closets point on the line for a given point.
   *
   * @param {Vector3} point - The point to compute the closest point on the line for.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @param {Vector3} target -  The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the line.
   */
  closestPointToPoint(e, t, i) {
    const n = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(n).add(this.start);
  }
  /**
   * Applies a 4x4 transformation matrix to this line segment.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Line3} A reference to this line segment.
   */
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  /**
   * Returns `true` if this line segment is equal with the given one.
   *
   * @param {Line3} line - The line segment to test for equality.
   * @return {boolean} Whether this line segment is equal with the given one.
   */
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  /**
   * Returns a new line segment with copied values from this instance.
   *
   * @return {Line3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const cA = /* @__PURE__ */ new H();
class nV extends tn {
  /**
   * Constructs a new spot light helper.
   *
   * @param {HemisphereLight} light - The light to be visualized.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const i = new Gt(), n = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const c = o / l * Math.PI * 2, u = a / l * Math.PI * 2;
      n.push(
        Math.cos(c),
        Math.sin(c),
        1,
        Math.cos(u),
        Math.sin(u),
        1
      );
    }
    i.setAttribute("position", new Tt(n, 3));
    const r = new Bi({ fog: !1, toneMapped: !1 });
    this.cone = new so(i, r), this.add(this.cone), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), cA.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(cA), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const el = /* @__PURE__ */ new H(), Lg = /* @__PURE__ */ new _t(), Ux = /* @__PURE__ */ new _t();
class iV extends so {
  /**
   * Constructs a new hemisphere light helper.
   *
   * @param {Object3D} object -  Usually an instance of {@link SkinnedMesh}. However, any 3D object
   * can be used if it represents a hierarchy of bones (see {@link Bone}).
   */
  constructor(e) {
    const t = UI(e), i = new Gt(), n = [], r = [], o = new rt(0, 0, 1), a = new rt(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const u = t[c];
      u.parent && u.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new Tt(n, 3)), i.setAttribute("color", new Tt(r, 3));
    const l = new Bi({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(i, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, i = this.geometry, n = i.getAttribute("position");
    Ux.copy(this.root.matrixWorld).invert();
    for (let r = 0, o = 0; r < t.length; r++) {
      const a = t[r];
      a.parent && a.parent.isBone && (Lg.multiplyMatrices(Ux, a.matrixWorld), el.setFromMatrixPosition(Lg), n.setXYZ(o, el.x, el.y, el.z), Lg.multiplyMatrices(Ux, a.parent.matrixWorld), el.setFromMatrixPosition(Lg), n.setXYZ(o + 1, el.x, el.y, el.z), o += 2);
    }
    i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function UI(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push(...UI(s.children[t]));
  return e;
}
class rV extends it {
  /**
   * Constructs a new point light helper.
   *
   * @param {PointLight} light - The light to be visualized.
   * @param {number} [sphereSize=1] - The size of the sphere helper.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, i) {
    const n = new Bl(t, 4, 2), r = new qn({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(n, r), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  /**
   * Updates the helper to match the position of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const sV = /* @__PURE__ */ new H(), uA = /* @__PURE__ */ new rt(), hA = /* @__PURE__ */ new rt();
class oV extends tn {
  /**
   * Constructs a new hemisphere light helper.
   *
   * @param {HemisphereLight} light - The light to be visualized.
   * @param {number} [size=1] - The size of the mesh used to visualize the light.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper";
    const n = new Ma(t);
    n.rotateY(Math.PI * 0.5), this.material = new qn({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = n.getAttribute("position"), o = new Float32Array(r.count * 3);
    n.setAttribute("color", new Nt(o, 3)), this.add(new it(n, this.material)), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      uA.copy(this.light.color), hA.copy(this.light.groundColor);
      for (let i = 0, n = t.count; i < n; i++) {
        const r = i < n / 2 ? uA : hA;
        t.setXYZ(i, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(sV.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class aV extends so {
  /**
   * Constructs a new grid helper.
   *
   * @param {number} [size=10] - The size of the grid.
   * @param {number} [divisions=10] - The number of divisions across the grid.
   * @param {number|Color|string} [color1=0x444444] - The color of the center line.
   * @param {number|Color|string} [color2=0x888888] - The color of the lines of the grid.
   */
  constructor(e = 10, t = 10, i = 4473924, n = 8947848) {
    i = new rt(i), n = new rt(n);
    const r = t / 2, o = e / t, a = e / 2, l = [], c = [];
    for (let d = 0, f = 0, m = -a; d <= t; d++, m += o) {
      l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
      const g = d === r ? i : n;
      g.toArray(c, f), f += 3, g.toArray(c, f), f += 3, g.toArray(c, f), f += 3, g.toArray(c, f), f += 3;
    }
    const u = new Gt();
    u.setAttribute("position", new Tt(l, 3)), u.setAttribute("color", new Tt(c, 3));
    const h = new Bi({ vertexColors: !0, toneMapped: !1 });
    super(u, h), this.type = "GridHelper";
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class lV extends so {
  /**
   * Constructs a new polar grid helper.
   *
   * @param {number} [radius=10] - The radius of the polar grid. This can be any positive number.
   * @param {number} [sectors=16] - The number of sectors the grid will be divided into. This can be any positive integer.
   * @param {number} [rings=16] - The number of rings. This can be any positive integer.
   * @param {number} [divisions=64] - The number of line segments used for each circle. This can be any positive integer.
   * @param {number|Color|string} [color1=0x444444] - The first color used for grid elements.
   * @param {number|Color|string} [color2=0x888888] -  The second color used for grid elements.
   */
  constructor(e = 10, t = 16, i = 8, n = 64, r = 4473924, o = 8947848) {
    r = new rt(r), o = new rt(o);
    const a = [], l = [];
    if (t > 1)
      for (let h = 0; h < t; h++) {
        const d = h / t * (Math.PI * 2), f = Math.sin(d) * e, m = Math.cos(d) * e;
        a.push(0, 0, 0), a.push(f, 0, m);
        const g = h & 1 ? r : o;
        l.push(g.r, g.g, g.b), l.push(g.r, g.g, g.b);
      }
    for (let h = 0; h < i; h++) {
      const d = h & 1 ? r : o, f = e - e / i * h;
      for (let m = 0; m < n; m++) {
        let g = m / n * (Math.PI * 2), v = Math.sin(g) * f, _ = Math.cos(g) * f;
        a.push(v, 0, _), l.push(d.r, d.g, d.b), g = (m + 1) / n * (Math.PI * 2), v = Math.sin(g) * f, _ = Math.cos(g) * f, a.push(v, 0, _), l.push(d.r, d.g, d.b);
      }
    }
    const c = new Gt();
    c.setAttribute("position", new Tt(a, 3)), c.setAttribute("color", new Tt(l, 3));
    const u = new Bi({ vertexColors: !0, toneMapped: !1 });
    super(c, u), this.type = "PolarGridHelper";
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const dA = /* @__PURE__ */ new H(), Ug = /* @__PURE__ */ new H(), fA = /* @__PURE__ */ new H();
class cV extends tn {
  /**
   * Constructs a new directional light helper.
   *
   * @param {DirectionalLight} light - The light to be visualized.
   * @param {number} [size=1] - The dimensions of the plane.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let n = new Gt();
    n.setAttribute("position", new Tt([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new Bi({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Ui(n, r), this.add(this.lightPlane), n = new Gt(), n.setAttribute("position", new Tt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ui(n, r), this.add(this.targetLine), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), dA.setFromMatrixPosition(this.light.matrixWorld), Ug.setFromMatrixPosition(this.light.target.matrixWorld), fA.subVectors(Ug, dA), this.lightPlane.lookAt(Ug), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Ug), this.targetLine.scale.z = fA.length();
  }
}
const kg = /* @__PURE__ */ new H(), xi = /* @__PURE__ */ new M_();
class uV extends so {
  /**
   * Constructs a new arrow helper.
   *
   * @param {Camera} camera - The camera to visualize.
   */
  constructor(e) {
    const t = new Gt(), i = new Bi({ color: 16777215, vertexColors: !0, toneMapped: !1 }), n = [], r = [], o = {};
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
    function a(m, g) {
      l(m), l(g);
    }
    function l(m) {
      n.push(0, 0, 0), r.push(0, 0, 0), o[m] === void 0 && (o[m] = []), o[m].push(n.length / 3 - 1);
    }
    t.setAttribute("position", new Tt(n, 3)), t.setAttribute("color", new Tt(r, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    const c = new rt(16755200), u = new rt(16711680), h = new rt(43775), d = new rt(16777215), f = new rt(3355443);
    this.setColors(c, u, h, d, f);
  }
  /**
   * Defines the colors of the helper.
   *
   * @param {Color} frustum - The frustum line color.
   * @param {Color} cone - The cone line color.
   * @param {Color} up - The up line color.
   * @param {Color} target - The target line color.
   * @param {Color} cross - The cross line color.
   */
  setColors(e, t, i, n, r) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, i.r, i.g, i.b), a.setXYZ(33, i.r, i.g, i.b), a.setXYZ(34, i.r, i.g, i.b), a.setXYZ(35, i.r, i.g, i.b), a.setXYZ(36, i.r, i.g, i.b), a.setXYZ(37, i.r, i.g, i.b), a.setXYZ(38, n.r, n.g, n.b), a.setXYZ(39, n.r, n.g, n.b), a.setXYZ(40, r.r, r.g, r.b), a.setXYZ(41, r.r, r.g, r.b), a.setXYZ(42, r.r, r.g, r.b), a.setXYZ(43, r.r, r.g, r.b), a.setXYZ(44, r.r, r.g, r.b), a.setXYZ(45, r.r, r.g, r.b), a.setXYZ(46, r.r, r.g, r.b), a.setXYZ(47, r.r, r.g, r.b), a.setXYZ(48, r.r, r.g, r.b), a.setXYZ(49, r.r, r.g, r.b), a.needsUpdate = !0;
  }
  /**
   * Updates the helper based on the projection matrix of the camera.
   */
  update() {
    const e = this.geometry, t = this.pointMap, i = 1, n = 1;
    xi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const r = this.camera.coordinateSystem === _o ? -1 : 0;
    Ei("c", t, e, xi, 0, 0, r), Ei("t", t, e, xi, 0, 0, 1), Ei("n1", t, e, xi, -1, -1, r), Ei("n2", t, e, xi, i, -1, r), Ei("n3", t, e, xi, -1, n, r), Ei("n4", t, e, xi, i, n, r), Ei("f1", t, e, xi, -1, -1, 1), Ei("f2", t, e, xi, i, -1, 1), Ei("f3", t, e, xi, -1, n, 1), Ei("f4", t, e, xi, i, n, 1), Ei("u1", t, e, xi, i * 0.7, n * 1.1, r), Ei("u2", t, e, xi, -1 * 0.7, n * 1.1, r), Ei("u3", t, e, xi, 0, n * 2, r), Ei("cf1", t, e, xi, -1, 0, 1), Ei("cf2", t, e, xi, i, 0, 1), Ei("cf3", t, e, xi, 0, -1, 1), Ei("cf4", t, e, xi, 0, n, 1), Ei("cn1", t, e, xi, -1, 0, r), Ei("cn2", t, e, xi, i, 0, r), Ei("cn3", t, e, xi, 0, -1, r), Ei("cn4", t, e, xi, 0, n, r), e.getAttribute("position").needsUpdate = !0;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Ei(s, e, t, i, n, r, o) {
  kg.set(n, r, o).unproject(i);
  const a = e[s];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, u = a.length; c < u; c++)
      l.setXYZ(a[c], kg.x, kg.y, kg.z);
  }
}
const Og = /* @__PURE__ */ new yn();
class hV extends so {
  /**
   * Constructs a new box helper.
   *
   * @param {Object3D} [object] - The 3D object to show the world-axis-aligned bounding box.
   * @param {number|Color|string} [color=0xffff00] - The box's color.
   */
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), r = new Gt();
    r.setIndex(new Nt(i, 1)), r.setAttribute("position", new Nt(n, 3)), super(r, new Bi({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  /**
   * Updates the helper's geometry to match the dimensions of the object,
   * including any children.
   */
  update() {
    if (this.object !== void 0 && Og.setFromObject(this.object), Og.isEmpty()) return;
    const e = Og.min, t = Og.max, i = this.geometry.attributes.position, n = i.array;
    n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = e.x, n[4] = t.y, n[5] = t.z, n[6] = e.x, n[7] = e.y, n[8] = t.z, n[9] = t.x, n[10] = e.y, n[11] = t.z, n[12] = t.x, n[13] = t.y, n[14] = e.z, n[15] = e.x, n[16] = t.y, n[17] = e.z, n[18] = e.x, n[19] = e.y, n[20] = e.z, n[21] = t.x, n[22] = e.y, n[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  /**
   * Updates the wireframe box for the passed object.
   *
   * @param {Object3D} object - The 3D object to create the helper for.
   * @return {BoxHelper} A reference to this instance.
   */
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class dV extends so {
  /**
   * Constructs a new box3 helper.
   *
   * @param {Box3} box - The box to visualize.
   * @param {number|Color|string} [color=0xffff00] - The box's color.
   */
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new Gt();
    r.setIndex(new Nt(i, 1)), r.setAttribute("position", new Tt(n, 3)), super(r, new Bi({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class fV extends Ui {
  /**
   * Constructs a new plane helper.
   *
   * @param {Plane} plane - The plane to be visualized.
   * @param {number} [size=1] - The side length of plane helper.
   * @param {number|Color|string} [hex=0xffff00] - The helper's color.
   */
  constructor(e, t = 1, i = 16776960) {
    const n = i, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Gt();
    o.setAttribute("position", new Tt(r, 3)), o.computeBoundingSphere(), super(o, new Bi({ color: n, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Gt();
    l.setAttribute("position", new Tt(a, 3)), l.computeBoundingSphere(), this.add(new it(l, new qn({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const pA = /* @__PURE__ */ new H();
let Fg, kx;
class pV extends tn {
  /**
   * Constructs a new arrow helper.
   *
   * @param {Vector3} [dir=(0, 0, 1)] - The (normalized) direction vector.
   * @param {Vector3} [origin=(0, 0, 0)] - Point at which the arrow starts.
   * @param {number} [length=1] - Length of the arrow in world units.
   * @param {(number|Color|string)} [color=0xffff00] - Color of the arrow.
   * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
   * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
   */
  constructor(e = new H(0, 0, 1), t = new H(0, 0, 0), i = 1, n = 16776960, r = i * 0.2, o = r * 0.2) {
    super(), this.type = "ArrowHelper", Fg === void 0 && (Fg = new Gt(), Fg.setAttribute("position", new Tt([0, 0, 0, 0, 1, 0], 3)), kx = new Di(0, 0.5, 1, 5, 1), kx.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Ui(Fg, new Bi({ color: n, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new it(kx, new qn({ color: n, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, o);
  }
  /**
   * Sets the direction of the helper.
   *
   * @param {Vector3} dir - The normalized direction vector.
   */
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      pA.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(pA, t);
    }
  }
  /**
   * Sets the length of the helper.
   *
   * @param {number} length - Length of the arrow in world units.
   * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
   * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
   */
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
  }
  /**
   * Sets the color of the helper.
   *
   * @param {number|Color|string} color - The color to set.
   */
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class mV extends so {
  /**
   * Constructs a new axes helper.
   *
   * @param {number} [size=1] - Size of the lines representing the axes.
   */
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], n = new Gt();
    n.setAttribute("position", new Tt(t, 3)), n.setAttribute("color", new Tt(i, 3));
    const r = new Bi({ vertexColors: !0, toneMapped: !1 });
    super(n, r), this.type = "AxesHelper";
  }
  /**
   * Defines the colors of the axes helper.
   *
   * @param {number|Color|string} xAxisColor - The color for the x axis.
   * @param {number|Color|string} yAxisColor - The color for the y axis.
   * @param {number|Color|string} zAxisColor - The color for the z axis.
   * @return {AxesHelper} A reference to this axes helper.
   */
  setColors(e, t, i) {
    const n = new rt(), r = this.geometry.attributes.color.array;
    return n.set(e), n.toArray(r, 0), n.toArray(r, 3), n.set(t), n.toArray(r, 6), n.toArray(r, 9), n.set(i), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class kI {
  /**
   * Constructs a new shape path.
   */
  constructor() {
    this.type = "ShapePath", this.color = new rt(), this.subPaths = [], this.currentPath = null;
  }
  /**
   * Creates a new path and moves it current point to the given one.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {ShapePath} A reference to this shape path.
   */
  moveTo(e, t) {
    return this.currentPath = new Hp(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  quadraticCurveTo(e, t, i, n) {
    return this.currentPath.quadraticCurveTo(e, t, i, n), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  bezierCurveTo(e, t, i, n, r, o) {
    return this.currentPath.bezierCurveTo(e, t, i, n, r, o), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {ShapePath} A reference to this shape path.
   */
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  /**
   * Converts the paths into an array of shapes.
   *
   * @param {boolean} isCCW - By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW).
   * If this flag is set to `true`, then those are flipped.
   * @return {Array<Shape>} An array of shapes.
   */
  toShapes(e) {
    function t(_) {
      const y = [];
      for (let w = 0, x = _.length; w < x; w++) {
        const M = _[w], A = new El();
        A.curves = M.curves, y.push(A);
      }
      return y;
    }
    function i(_, y) {
      const w = y.length;
      let x = !1;
      for (let M = w - 1, A = 0; A < w; M = A++) {
        let E = y[M], C = y[A], P = C.x - E.x, T = C.y - E.y;
        if (Math.abs(T) > Number.EPSILON) {
          if (T < 0 && (E = y[A], P = -P, C = y[M], T = -T), _.y < E.y || _.y > C.y) continue;
          if (_.y === E.y) {
            if (_.x === E.x) return !0;
          } else {
            const I = T * (_.x - E.x) - P * (_.y - E.y);
            if (I === 0) return !0;
            if (I < 0) continue;
            x = !x;
          }
        } else {
          if (_.y !== E.y) continue;
          if (C.x <= _.x && _.x <= E.x || E.x <= _.x && _.x <= C.x) return !0;
        }
      }
      return x;
    }
    const n = Zo.isClockWise, r = this.subPaths;
    if (r.length === 0) return [];
    let o, a, l;
    const c = [];
    if (r.length === 1)
      return a = r[0], l = new El(), l.curves = a.curves, c.push(l), c;
    let u = !n(r[0].getPoints());
    u = e ? !u : u;
    const h = [], d = [];
    let f = [], m = 0, g;
    d[m] = void 0, f[m] = [];
    for (let _ = 0, y = r.length; _ < y; _++)
      a = r[_], g = a.getPoints(), o = n(g), o = e ? !o : o, o ? (!u && d[m] && m++, d[m] = { s: new El(), p: g }, d[m].s.curves = a.curves, u && m++, f[m] = []) : f[m].push({ h: a, p: g[0] });
    if (!d[0]) return t(r);
    if (d.length > 1) {
      let _ = !1, y = 0;
      for (let w = 0, x = d.length; w < x; w++)
        h[w] = [];
      for (let w = 0, x = d.length; w < x; w++) {
        const M = f[w];
        for (let A = 0; A < M.length; A++) {
          const E = M[A];
          let C = !0;
          for (let P = 0; P < d.length; P++)
            i(E.p, d[P].p) && (w !== P && y++, C ? (C = !1, h[P].push(E)) : _ = !0);
          C && h[w].push(E);
        }
      }
      y > 0 && _ === !1 && (f = h);
    }
    let v;
    for (let _ = 0, y = d.length; _ < y; _++) {
      l = d[_].s, c.push(l), v = f[_];
      for (let w = 0, x = v.length; w < x; w++)
        l.holes.push(v[w].h);
    }
    return c;
  }
}
class $_ extends Qo {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  /**
   * Connects the controls to the DOM. This method has so called "side effects" since
   * it adds the module's event listeners to the DOM.
   */
  connect() {
  }
  /**
   * Disconnects the controls from the DOM.
   */
  disconnect() {
  }
  /**
   * Call this method if you no longer want use to the controls. It frees all internal
   * resources and removes all event listeners.
   */
  dispose() {
  }
  /**
   * Controls should implement this method if they have to update their internal state
   * per simulation step.
   *
   * @param {number} [delta] - The time delta in seconds.
   */
  update() {
  }
}
function gV(s, e) {
  const t = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return t > e ? (s.repeat.x = 1, s.repeat.y = t / e, s.offset.x = 0, s.offset.y = (1 - s.repeat.y) / 2) : (s.repeat.x = e / t, s.repeat.y = 1, s.offset.x = (1 - s.repeat.x) / 2, s.offset.y = 0), s;
}
function vV(s, e) {
  const t = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return t > e ? (s.repeat.x = e / t, s.repeat.y = 1, s.offset.x = (1 - s.repeat.x) / 2, s.offset.y = 0) : (s.repeat.x = 1, s.repeat.y = t / e, s.offset.x = 0, s.offset.y = (1 - s.repeat.y) / 2), s;
}
function _V(s) {
  return s.repeat.x = 1, s.repeat.y = 1, s.offset.x = 0, s.offset.y = 0, s;
}
function E1(s, e, t, i) {
  const n = yV(i);
  switch (t) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case Xw:
      return s * e;
    case jw:
      return s * e;
    case qw:
      return s * e * 2;
    case bd:
      return s * e / n.components * n.byteLength;
    case wd:
      return s * e / n.components * n.byteLength;
    case y_:
      return s * e * 2 / n.components * n.byteLength;
    case Sd:
      return s * e * 2 / n.components * n.byteLength;
    case Yw:
      return s * e * 3 / n.components * n.byteLength;
    case di:
      return s * e * 4 / n.components * n.byteLength;
    case vu:
      return s * e * 4 / n.components * n.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case sp:
    case op:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case ap:
    case lp:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case b0:
    case S0:
      return Math.max(s, 16) * Math.max(e, 8) / 4;
    case x0:
    case w0:
      return Math.max(s, 8) * Math.max(e, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case M0:
    case E0:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case T0:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case A0:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case C0:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case P0:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case R0:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case D0:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case I0:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case L0:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case U0:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case k0:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case O0:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case F0:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case N0:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case B0:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case z0:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case cp:
    case V0:
    case G0:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case Zw:
    case H0:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case W0:
    case X0:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${t} format.`
  );
}
function yV(s) {
  switch (s) {
    case ro:
    case Fp:
      return { byteLength: 1, components: 1 };
    case pu:
    case g_:
    case vr:
      return { byteLength: 2, components: 1 };
    case v_:
    case __:
      return { byteLength: 2, components: 4 };
    case hs:
    case Qc:
    case Un:
      return { byteLength: 4, components: 1 };
    case Ww:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
class xV {
  /**
   * Scales the texture as large as possible within its surface without cropping
   * or stretching the texture. The method preserves the original aspect ratio of
   * the texture. Akin to CSS `object-fit: contain`
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static contain(e, t) {
    return gV(e, t);
  }
  /**
   * Scales the texture to the smallest possible size to fill the surface, leaving
   * no empty space. The method preserves the original aspect ratio of the texture.
   * Akin to CSS `object-fit: cover`.
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static cover(e, t) {
    return vV(e, t);
  }
  /**
   * Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.
   *
   * @param {Texture} texture - The texture.
   * @return {Texture} The updated texture.
   */
  static fill(e) {
    return _V(e);
  }
  /**
   * Determines how many bytes must be used to represent the texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} format - The texture's format.
   * @param {number} type - The texture's type.
   * @return {number} The byte length.
   */
  static getByteLength(e, t, i, n) {
    return E1(e, t, i, n);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: yd
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = yd);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function OI() {
  let s = null, e = !1, t = null, i = null;
  function n(r, o) {
    t(r, o), i = s.requestAnimationFrame(n);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (i = s.requestAnimationFrame(n), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      s = r;
    }
  };
}
function bV(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(a, l) {
    const c = a.array, u = a.usage, h = c.byteLength, d = s.createBuffer();
    s.bindBuffer(l, d), s.bufferData(l, c, u), a.onUploadCallback();
    let f;
    if (c instanceof Float32Array)
      f = s.FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? f = s.HALF_FLOAT : f = s.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      f = s.SHORT;
    else if (c instanceof Uint32Array)
      f = s.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      f = s.INT;
    else if (c instanceof Int8Array)
      f = s.BYTE;
    else if (c instanceof Uint8Array)
      f = s.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      f = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: d,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: h
    };
  }
  function i(a, l, c) {
    const u = l.array, h = l.updateRanges;
    if (s.bindBuffer(c, a), h.length === 0)
      s.bufferSubData(c, 0, u);
    else {
      h.sort((f, m) => f.start - m.start);
      let d = 0;
      for (let f = 1; f < h.length; f++) {
        const m = h[d], g = h[f];
        g.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          g.start + g.count - m.start
        ) : (++d, h[d] = g);
      }
      h.length = d + 1;
      for (let f = 0, m = h.length; f < m; f++) {
        const g = h[f];
        s.bufferSubData(
          c,
          g.start * u.BYTES_PER_ELEMENT,
          u,
          g.start,
          g.count
        );
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function n(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function r(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (s.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
      const u = e.get(a);
      (!u || u.version < a.version) && e.set(a, {
        buffer: a.buffer,
        type: a.type,
        bytesPerElement: a.elementSize,
        version: a.version
      });
      return;
    }
    const c = e.get(a);
    if (c === void 0)
      e.set(a, t(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      i(c.buffer, a, l), c.version = a.version;
    }
  }
  return {
    get: n,
    remove: r,
    update: o
  };
}
var wV = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, SV = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, MV = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, EV = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, TV = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, AV = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, CV = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, PV = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, RV = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, DV = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, IV = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, LV = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, UV = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, kV = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, OV = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, FV = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, NV = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, BV = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, zV = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, VV = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, GV = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, HV = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, WV = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, XV = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, YV = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, jV = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, qV = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, ZV = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, KV = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, $V = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, JV = "gl_FragColor = linearToOutputTexel( gl_FragColor );", QV = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, eG = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, tG = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, nG = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, iG = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, rG = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, sG = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, oG = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, aG = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, lG = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, cG = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, uG = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, hG = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, dG = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, fG = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, pG = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, mG = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, gG = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, vG = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, _G = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, yG = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, xG = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, bG = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, wG = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, SG = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, MG = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, EG = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, TG = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, AG = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, CG = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, PG = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, RG = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, DG = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, IG = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, LG = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, UG = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, kG = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, OG = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, FG = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, NG = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, BG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, zG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, VG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, GG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, HG = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, WG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, XG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, YG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, jG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, qG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, ZG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, KG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, $G = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, JG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, QG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, eH = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, tH = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, nH = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, iH = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, rH = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, sH = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, oH = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, aH = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, lH = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, cH = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, uH = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, hH = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, dH = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, fH = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, pH = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, mH = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, gH = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, vH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, _H = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, yH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, xH = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const bH = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, wH = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, SH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, MH = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, EH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, TH = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, AH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, CH = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, PH = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, RH = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, DH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, IH = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, LH = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, UH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, kH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, OH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, FH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, NH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, BH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, zH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, VH = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, GH = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, HH = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, WH = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, XH = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, YH = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, jH = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, qH = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ZH = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, KH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, $H = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, JH = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, QH = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, e6 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ft = {
  alphahash_fragment: wV,
  alphahash_pars_fragment: SV,
  alphamap_fragment: MV,
  alphamap_pars_fragment: EV,
  alphatest_fragment: TV,
  alphatest_pars_fragment: AV,
  aomap_fragment: CV,
  aomap_pars_fragment: PV,
  batching_pars_vertex: RV,
  batching_vertex: DV,
  begin_vertex: IV,
  beginnormal_vertex: LV,
  bsdfs: UV,
  iridescence_fragment: kV,
  bumpmap_pars_fragment: OV,
  clipping_planes_fragment: FV,
  clipping_planes_pars_fragment: NV,
  clipping_planes_pars_vertex: BV,
  clipping_planes_vertex: zV,
  color_fragment: VV,
  color_pars_fragment: GV,
  color_pars_vertex: HV,
  color_vertex: WV,
  common: XV,
  cube_uv_reflection_fragment: YV,
  defaultnormal_vertex: jV,
  displacementmap_pars_vertex: qV,
  displacementmap_vertex: ZV,
  emissivemap_fragment: KV,
  emissivemap_pars_fragment: $V,
  colorspace_fragment: JV,
  colorspace_pars_fragment: QV,
  envmap_fragment: eG,
  envmap_common_pars_fragment: tG,
  envmap_pars_fragment: nG,
  envmap_pars_vertex: iG,
  envmap_physical_pars_fragment: pG,
  envmap_vertex: rG,
  fog_vertex: sG,
  fog_pars_vertex: oG,
  fog_fragment: aG,
  fog_pars_fragment: lG,
  gradientmap_pars_fragment: cG,
  lightmap_pars_fragment: uG,
  lights_lambert_fragment: hG,
  lights_lambert_pars_fragment: dG,
  lights_pars_begin: fG,
  lights_toon_fragment: mG,
  lights_toon_pars_fragment: gG,
  lights_phong_fragment: vG,
  lights_phong_pars_fragment: _G,
  lights_physical_fragment: yG,
  lights_physical_pars_fragment: xG,
  lights_fragment_begin: bG,
  lights_fragment_maps: wG,
  lights_fragment_end: SG,
  logdepthbuf_fragment: MG,
  logdepthbuf_pars_fragment: EG,
  logdepthbuf_pars_vertex: TG,
  logdepthbuf_vertex: AG,
  map_fragment: CG,
  map_pars_fragment: PG,
  map_particle_fragment: RG,
  map_particle_pars_fragment: DG,
  metalnessmap_fragment: IG,
  metalnessmap_pars_fragment: LG,
  morphinstance_vertex: UG,
  morphcolor_vertex: kG,
  morphnormal_vertex: OG,
  morphtarget_pars_vertex: FG,
  morphtarget_vertex: NG,
  normal_fragment_begin: BG,
  normal_fragment_maps: zG,
  normal_pars_fragment: VG,
  normal_pars_vertex: GG,
  normal_vertex: HG,
  normalmap_pars_fragment: WG,
  clearcoat_normal_fragment_begin: XG,
  clearcoat_normal_fragment_maps: YG,
  clearcoat_pars_fragment: jG,
  iridescence_pars_fragment: qG,
  opaque_fragment: ZG,
  packing: KG,
  premultiplied_alpha_fragment: $G,
  project_vertex: JG,
  dithering_fragment: QG,
  dithering_pars_fragment: eH,
  roughnessmap_fragment: tH,
  roughnessmap_pars_fragment: nH,
  shadowmap_pars_fragment: iH,
  shadowmap_pars_vertex: rH,
  shadowmap_vertex: sH,
  shadowmask_pars_fragment: oH,
  skinbase_vertex: aH,
  skinning_pars_vertex: lH,
  skinning_vertex: cH,
  skinnormal_vertex: uH,
  specularmap_fragment: hH,
  specularmap_pars_fragment: dH,
  tonemapping_fragment: fH,
  tonemapping_pars_fragment: pH,
  transmission_fragment: mH,
  transmission_pars_fragment: gH,
  uv_pars_fragment: vH,
  uv_pars_vertex: _H,
  uv_vertex: yH,
  worldpos_vertex: xH,
  background_vert: bH,
  background_frag: wH,
  backgroundCube_vert: SH,
  backgroundCube_frag: MH,
  cube_vert: EH,
  cube_frag: TH,
  depth_vert: AH,
  depth_frag: CH,
  distanceRGBA_vert: PH,
  distanceRGBA_frag: RH,
  equirect_vert: DH,
  equirect_frag: IH,
  linedashed_vert: LH,
  linedashed_frag: UH,
  meshbasic_vert: kH,
  meshbasic_frag: OH,
  meshlambert_vert: FH,
  meshlambert_frag: NH,
  meshmatcap_vert: BH,
  meshmatcap_frag: zH,
  meshnormal_vert: VH,
  meshnormal_frag: GH,
  meshphong_vert: HH,
  meshphong_frag: WH,
  meshphysical_vert: XH,
  meshphysical_frag: YH,
  meshtoon_vert: jH,
  meshtoon_frag: qH,
  points_vert: ZH,
  points_frag: KH,
  shadow_vert: $H,
  shadow_frag: JH,
  sprite_vert: QH,
  sprite_frag: e6
}, vt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new rt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Jt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Jt() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Jt() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Jt() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Jt() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Jt() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Jt() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Jt() },
    normalScale: { value: /* @__PURE__ */ new Be(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Jt() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Jt() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Jt() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Jt() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new rt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new rt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Jt() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Jt() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new rt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Be(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Jt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Jt() },
    alphaTest: { value: 0 }
  }
}, Dr = {
  basic: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.specularmap,
      vt.envmap,
      vt.aomap,
      vt.lightmap,
      vt.fog
    ]),
    vertexShader: Ft.meshbasic_vert,
    fragmentShader: Ft.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.specularmap,
      vt.envmap,
      vt.aomap,
      vt.lightmap,
      vt.emissivemap,
      vt.bumpmap,
      vt.normalmap,
      vt.displacementmap,
      vt.fog,
      vt.lights,
      {
        emissive: { value: /* @__PURE__ */ new rt(0) }
      }
    ]),
    vertexShader: Ft.meshlambert_vert,
    fragmentShader: Ft.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.specularmap,
      vt.envmap,
      vt.aomap,
      vt.lightmap,
      vt.emissivemap,
      vt.bumpmap,
      vt.normalmap,
      vt.displacementmap,
      vt.fog,
      vt.lights,
      {
        emissive: { value: /* @__PURE__ */ new rt(0) },
        specular: { value: /* @__PURE__ */ new rt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Ft.meshphong_vert,
    fragmentShader: Ft.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.envmap,
      vt.aomap,
      vt.lightmap,
      vt.emissivemap,
      vt.bumpmap,
      vt.normalmap,
      vt.displacementmap,
      vt.roughnessmap,
      vt.metalnessmap,
      vt.fog,
      vt.lights,
      {
        emissive: { value: /* @__PURE__ */ new rt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Ft.meshphysical_vert,
    fragmentShader: Ft.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.aomap,
      vt.lightmap,
      vt.emissivemap,
      vt.bumpmap,
      vt.normalmap,
      vt.displacementmap,
      vt.gradientmap,
      vt.fog,
      vt.lights,
      {
        emissive: { value: /* @__PURE__ */ new rt(0) }
      }
    ]),
    vertexShader: Ft.meshtoon_vert,
    fragmentShader: Ft.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.bumpmap,
      vt.normalmap,
      vt.displacementmap,
      vt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Ft.meshmatcap_vert,
    fragmentShader: Ft.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ zr([
      vt.points,
      vt.fog
    ]),
    vertexShader: Ft.points_vert,
    fragmentShader: Ft.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Ft.linedashed_vert,
    fragmentShader: Ft.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.displacementmap
    ]),
    vertexShader: Ft.depth_vert,
    fragmentShader: Ft.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.bumpmap,
      vt.normalmap,
      vt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ft.meshnormal_vert,
    fragmentShader: Ft.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ zr([
      vt.sprite,
      vt.fog
    ]),
    vertexShader: Ft.sprite_vert,
    fragmentShader: Ft.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Jt() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Ft.background_vert,
    fragmentShader: Ft.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Jt() }
    },
    vertexShader: Ft.backgroundCube_vert,
    fragmentShader: Ft.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Ft.cube_vert,
    fragmentShader: Ft.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Ft.equirect_vert,
    fragmentShader: Ft.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ zr([
      vt.common,
      vt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new H() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Ft.distanceRGBA_vert,
    fragmentShader: Ft.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ zr([
      vt.lights,
      vt.fog,
      {
        color: { value: /* @__PURE__ */ new rt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ft.shadow_vert,
    fragmentShader: Ft.shadow_frag
  }
};
Dr.physical = {
  uniforms: /* @__PURE__ */ zr([
    Dr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Jt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Jt() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Be(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Jt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Jt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Jt() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new rt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Jt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Jt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Jt() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Be() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Jt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new rt(0) },
      specularColor: { value: /* @__PURE__ */ new rt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Jt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Jt() },
      anisotropyVector: { value: /* @__PURE__ */ new Be() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Jt() }
    }
  ]),
  vertexShader: Ft.meshphysical_vert,
  fragmentShader: Ft.meshphysical_frag
};
const Ng = { r: 0, b: 0, g: 0 }, dc = /* @__PURE__ */ new fs(), t6 = /* @__PURE__ */ new _t();
function n6(s, e, t, i, n, r, o) {
  const a = new rt(0);
  let l = r === !0 ? 0 : 1, c, u, h = null, d = 0, f = null;
  function m(w) {
    let x = w.isScene === !0 ? w.background : null;
    return x && x.isTexture && (x = (w.backgroundBlurriness > 0 ? t : e).get(x)), x;
  }
  function g(w) {
    let x = !1;
    const M = m(w);
    M === null ? _(a, l) : M && M.isColor && (_(M, 1), x = !0);
    const A = s.xr.getEnvironmentBlendMode();
    A === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : A === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || x) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function v(w, x) {
    const M = m(x);
    M && (M.isCubeTexture || M.mapping === xd) ? (u === void 0 && (u = new it(
      new pi(1, 1, 1),
      new Mi({
        name: "BackgroundCubeMaterial",
        uniforms: fd(Dr.backgroundCube.uniforms),
        vertexShader: Dr.backgroundCube.vertexShader,
        fragmentShader: Dr.backgroundCube.fragmentShader,
        side: Yi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(A, E, C) {
      this.matrixWorld.copyPosition(C.matrixWorld);
    }, Object.defineProperty(u.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), n.update(u)), dc.copy(x.backgroundRotation), dc.x *= -1, dc.y *= -1, dc.z *= -1, M.isCubeTexture && M.isRenderTargetTexture === !1 && (dc.y *= -1, dc.z *= -1), u.material.uniforms.envMap.value = M, u.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(t6.makeRotationFromEuler(dc)), u.material.toneMapped = vn.getTransfer(M.colorSpace) !== Vn, (h !== M || d !== M.version || f !== s.toneMapping) && (u.material.needsUpdate = !0, h = M, d = M.version, f = s.toneMapping), u.layers.enableAll(), w.unshift(u, u.geometry, u.material, 0, 0, null)) : M && M.isTexture && (c === void 0 && (c = new it(
      new $r(2, 2),
      new Mi({
        name: "BackgroundMaterial",
        uniforms: fd(Dr.background.uniforms),
        vertexShader: Dr.background.vertexShader,
        fragmentShader: Dr.background.fragmentShader,
        side: Fs,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), n.update(c)), c.material.uniforms.t2D.value = M, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = vn.getTransfer(M.colorSpace) !== Vn, M.matrixAutoUpdate === !0 && M.updateMatrix(), c.material.uniforms.uvTransform.value.copy(M.matrix), (h !== M || d !== M.version || f !== s.toneMapping) && (c.material.needsUpdate = !0, h = M, d = M.version, f = s.toneMapping), c.layers.enableAll(), w.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function _(w, x) {
    w.getRGB(Ng, qD(s)), i.buffers.color.setClear(Ng.r, Ng.g, Ng.b, x, o);
  }
  function y() {
    u !== void 0 && (u.geometry.dispose(), u.material.dispose(), u = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
  }
  return {
    getClearColor: function() {
      return a;
    },
    setClearColor: function(w, x = 1) {
      a.set(w), l = x, _(a, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(w) {
      l = w, _(a, l);
    },
    render: g,
    addToRenderList: v,
    dispose: y
  };
}
function i6(s, e) {
  const t = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, n = d(null);
  let r = n, o = !1;
  function a(T, I, D, U, L) {
    let k = !1;
    const B = h(U, D, I);
    r !== B && (r = B, c(r.object)), k = f(T, U, D, L), k && m(T, U, D, L), L !== null && e.update(L, s.ELEMENT_ARRAY_BUFFER), (k || o) && (o = !1, x(T, I, D, U), L !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(L).buffer));
  }
  function l() {
    return s.createVertexArray();
  }
  function c(T) {
    return s.bindVertexArray(T);
  }
  function u(T) {
    return s.deleteVertexArray(T);
  }
  function h(T, I, D) {
    const U = D.wireframe === !0;
    let L = i[T.id];
    L === void 0 && (L = {}, i[T.id] = L);
    let k = L[I.id];
    k === void 0 && (k = {}, L[I.id] = k);
    let B = k[U];
    return B === void 0 && (B = d(l()), k[U] = B), B;
  }
  function d(T) {
    const I = [], D = [], U = [];
    for (let L = 0; L < t; L++)
      I[L] = 0, D[L] = 0, U[L] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: I,
      enabledAttributes: D,
      attributeDivisors: U,
      object: T,
      attributes: {},
      index: null
    };
  }
  function f(T, I, D, U) {
    const L = r.attributes, k = I.attributes;
    let B = 0;
    const j = D.getAttributes();
    for (const q in j)
      if (j[q].location >= 0) {
        const N = L[q];
        let z = k[q];
        if (z === void 0 && (q === "instanceMatrix" && T.instanceMatrix && (z = T.instanceMatrix), q === "instanceColor" && T.instanceColor && (z = T.instanceColor)), N === void 0 || N.attribute !== z || z && N.data !== z.data) return !0;
        B++;
      }
    return r.attributesNum !== B || r.index !== U;
  }
  function m(T, I, D, U) {
    const L = {}, k = I.attributes;
    let B = 0;
    const j = D.getAttributes();
    for (const q in j)
      if (j[q].location >= 0) {
        let N = k[q];
        N === void 0 && (q === "instanceMatrix" && T.instanceMatrix && (N = T.instanceMatrix), q === "instanceColor" && T.instanceColor && (N = T.instanceColor));
        const z = {};
        z.attribute = N, N && N.data && (z.data = N.data), L[q] = z, B++;
      }
    r.attributes = L, r.attributesNum = B, r.index = U;
  }
  function g() {
    const T = r.newAttributes;
    for (let I = 0, D = T.length; I < D; I++)
      T[I] = 0;
  }
  function v(T) {
    _(T, 0);
  }
  function _(T, I) {
    const D = r.newAttributes, U = r.enabledAttributes, L = r.attributeDivisors;
    D[T] = 1, U[T] === 0 && (s.enableVertexAttribArray(T), U[T] = 1), L[T] !== I && (s.vertexAttribDivisor(T, I), L[T] = I);
  }
  function y() {
    const T = r.newAttributes, I = r.enabledAttributes;
    for (let D = 0, U = I.length; D < U; D++)
      I[D] !== T[D] && (s.disableVertexAttribArray(D), I[D] = 0);
  }
  function w(T, I, D, U, L, k, B) {
    B === !0 ? s.vertexAttribIPointer(T, I, D, L, k) : s.vertexAttribPointer(T, I, D, U, L, k);
  }
  function x(T, I, D, U) {
    g();
    const L = U.attributes, k = D.getAttributes(), B = I.defaultAttributeValues;
    for (const j in k) {
      const q = k[j];
      if (q.location >= 0) {
        let Z = L[j];
        if (Z === void 0 && (j === "instanceMatrix" && T.instanceMatrix && (Z = T.instanceMatrix), j === "instanceColor" && T.instanceColor && (Z = T.instanceColor)), Z !== void 0) {
          const N = Z.normalized, z = Z.itemSize, J = e.get(Z);
          if (J === void 0) continue;
          const se = J.buffer, K = J.type, Q = J.bytesPerElement, de = K === s.INT || K === s.UNSIGNED_INT || Z.gpuType === Qc;
          if (Z.isInterleavedBufferAttribute) {
            const ce = Z.data, _e = ce.stride, Fe = Z.offset;
            if (ce.isInstancedInterleavedBuffer) {
              for (let Ie = 0; Ie < q.locationSize; Ie++)
                _(q.location + Ie, ce.meshPerAttribute);
              T.isInstancedMesh !== !0 && U._maxInstanceCount === void 0 && (U._maxInstanceCount = ce.meshPerAttribute * ce.count);
            } else
              for (let Ie = 0; Ie < q.locationSize; Ie++)
                v(q.location + Ie);
            s.bindBuffer(s.ARRAY_BUFFER, se);
            for (let Ie = 0; Ie < q.locationSize; Ie++)
              w(
                q.location + Ie,
                z / q.locationSize,
                K,
                N,
                _e * Q,
                (Fe + z / q.locationSize * Ie) * Q,
                de
              );
          } else {
            if (Z.isInstancedBufferAttribute) {
              for (let ce = 0; ce < q.locationSize; ce++)
                _(q.location + ce, Z.meshPerAttribute);
              T.isInstancedMesh !== !0 && U._maxInstanceCount === void 0 && (U._maxInstanceCount = Z.meshPerAttribute * Z.count);
            } else
              for (let ce = 0; ce < q.locationSize; ce++)
                v(q.location + ce);
            s.bindBuffer(s.ARRAY_BUFFER, se);
            for (let ce = 0; ce < q.locationSize; ce++)
              w(
                q.location + ce,
                z / q.locationSize,
                K,
                N,
                z * Q,
                z / q.locationSize * ce * Q,
                de
              );
          }
        } else if (B !== void 0) {
          const N = B[j];
          if (N !== void 0)
            switch (N.length) {
              case 2:
                s.vertexAttrib2fv(q.location, N);
                break;
              case 3:
                s.vertexAttrib3fv(q.location, N);
                break;
              case 4:
                s.vertexAttrib4fv(q.location, N);
                break;
              default:
                s.vertexAttrib1fv(q.location, N);
            }
        }
      }
    }
    y();
  }
  function M() {
    C();
    for (const T in i) {
      const I = i[T];
      for (const D in I) {
        const U = I[D];
        for (const L in U)
          u(U[L].object), delete U[L];
        delete I[D];
      }
      delete i[T];
    }
  }
  function A(T) {
    if (i[T.id] === void 0) return;
    const I = i[T.id];
    for (const D in I) {
      const U = I[D];
      for (const L in U)
        u(U[L].object), delete U[L];
      delete I[D];
    }
    delete i[T.id];
  }
  function E(T) {
    for (const I in i) {
      const D = i[I];
      if (D[T.id] === void 0) continue;
      const U = D[T.id];
      for (const L in U)
        u(U[L].object), delete U[L];
      delete D[T.id];
    }
  }
  function C() {
    P(), o = !0, r !== n && (r = n, c(r.object));
  }
  function P() {
    n.geometry = null, n.program = null, n.wireframe = !1;
  }
  return {
    setup: a,
    reset: C,
    resetDefaultState: P,
    dispose: M,
    releaseStatesOfGeometry: A,
    releaseStatesOfProgram: E,
    initAttributes: g,
    enableAttribute: v,
    disableUnusedAttributes: y
  };
}
function r6(s, e, t) {
  let i;
  function n(c) {
    i = c;
  }
  function r(c, u) {
    s.drawArrays(i, c, u), t.update(u, i, 1);
  }
  function o(c, u, h) {
    h !== 0 && (s.drawArraysInstanced(i, c, u, h), t.update(u, i, h));
  }
  function a(c, u, h) {
    if (h === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, h);
    let f = 0;
    for (let m = 0; m < h; m++)
      f += u[m];
    t.update(f, i, 1);
  }
  function l(c, u, h, d) {
    if (h === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let m = 0; m < c.length; m++)
        o(c[m], u[m], d[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, d, 0, h);
      let m = 0;
      for (let g = 0; g < h; g++)
        m += u[g] * d[g];
      t.update(m, i, 1);
    }
  }
  this.setMode = n, this.render = r, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = l;
}
function s6(s, e, t, i) {
  let n;
  function r() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const E = e.get("EXT_texture_filter_anisotropic");
      n = s.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function o(E) {
    return !(E !== di && i.convert(E) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function a(E) {
    const C = E === vr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(E !== ro && i.convert(E) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    E !== Un && !C);
  }
  function l(E) {
    if (E === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      E = "mediump";
    }
    return E === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const u = l(c);
  u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), c = u);
  const h = t.logarithmicDepthBuffer === !0, d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = s.getParameter(s.MAX_TEXTURE_SIZE), v = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), _ = s.getParameter(s.MAX_VERTEX_ATTRIBS), y = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), w = s.getParameter(s.MAX_VARYING_VECTORS), x = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), M = m > 0, A = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: r,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: h,
    reverseDepthBuffer: d,
    maxTextures: f,
    maxVertexTextures: m,
    maxTextureSize: g,
    maxCubemapSize: v,
    maxAttributes: _,
    maxVertexUniforms: y,
    maxVaryings: w,
    maxFragmentUniforms: x,
    vertexTextures: M,
    maxSamples: A
  };
}
function o6(s) {
  const e = this;
  let t = null, i = 0, n = !1, r = !1;
  const o = new $s(), a = new Jt(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, d) {
    const f = h.length !== 0 || d || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || n;
    return n = d, i = h.length, f;
  }, this.beginShadows = function() {
    r = !0, u(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(h, d) {
    t = u(h, d, 0);
  }, this.setState = function(h, d, f) {
    const m = h.clippingPlanes, g = h.clipIntersection, v = h.clipShadows, _ = s.get(h);
    if (!n || m === null || m.length === 0 || r && !v)
      r ? u(null) : c();
    else {
      const y = r ? 0 : i, w = y * 4;
      let x = _.clippingState || null;
      l.value = x, x = u(m, d, w, f);
      for (let M = 0; M !== w; ++M)
        x[M] = t[M];
      _.clippingState = x, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += y;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function u(h, d, f, m) {
    const g = h !== null ? h.length : 0;
    let v = null;
    if (g !== 0) {
      if (v = l.value, m !== !0 || v === null) {
        const _ = f + g * 4, y = d.matrixWorldInverse;
        a.getNormalMatrix(y), (v === null || v.length < _) && (v = new Float32Array(_));
        for (let w = 0, x = f; w !== g; ++w, x += 4)
          o.copy(h[w]).applyMatrix4(y, a), o.normal.toArray(v, x), v[x + 3] = o.constant;
      }
      l.value = v, l.needsUpdate = !0;
    }
    return e.numPlanes = g, e.numIntersection = 0, v;
  }
}
function a6(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, a) {
    return a === ld ? o.mapping = Ia : a === Op && (o.mapping = Il), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === ld || a === Op)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new T_(l.height);
            return c.fromEquirectangularTexture(s, o), e.set(o, c), o.addEventListener("dispose", n), t(c.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function n(o) {
    const a = o.target;
    a.removeEventListener("dispose", n);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: r
  };
}
const kh = 4, mA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Rc = 20, Ox = /* @__PURE__ */ new Ua(), gA = /* @__PURE__ */ new rt();
let Fx = null, Nx = 0, Bx = 0, zx = !1;
const Cc = (1 + Math.sqrt(5)) / 2, dh = 1 / Cc, vA = [
  /* @__PURE__ */ new H(-Cc, dh, 0),
  /* @__PURE__ */ new H(Cc, dh, 0),
  /* @__PURE__ */ new H(-dh, 0, Cc),
  /* @__PURE__ */ new H(dh, 0, Cc),
  /* @__PURE__ */ new H(0, Cc, -dh),
  /* @__PURE__ */ new H(0, Cc, dh),
  /* @__PURE__ */ new H(-1, 1, -1),
  /* @__PURE__ */ new H(1, 1, -1),
  /* @__PURE__ */ new H(-1, 1, 1),
  /* @__PURE__ */ new H(1, 1, 1)
], l6 = /* @__PURE__ */ new H();
class T1 {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene
   * @param {number} sigma
   * @param {number} near
   * @param {number} far
   * @param {Object} [options={}]
   * @return {WebGLRenderTarget}
   */
  fromScene(e, t = 0, i = 0.1, n = 100, r = {}) {
    const {
      size: o = 256,
      position: a = l6
    } = r;
    Fx = this._renderer.getRenderTarget(), Nx = this._renderer.getActiveCubeFace(), Bx = this._renderer.getActiveMipmapLevel(), zx = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(o);
    const l = this._allocateTargets();
    return l.depthBuffer = !0, this._sceneToCubeUV(e, i, n, l, a), t > 0 && this._blur(l, 0, 0, t), this._applyPMREM(l), this._cleanup(l), l;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   *
   * @param {Texture} equirectangular
   * @param {?WebGLRenderTarget} [renderTarget=null] - Optional render target.
   * @return {WebGLRenderTarget}
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   *
   * @param {Texture} cubemap
   * @param {null} [renderTarget=null] - Optional render target.
   * @return {WebGLRenderTarget}
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = xA(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = yA(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Fx, Nx, Bx), this._renderer.xr.enabled = zx, e.scissorTest = !1, Bg(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Ia || e.mapping === Il ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Fx = this._renderer.getRenderTarget(), Nx = this._renderer.getActiveCubeFace(), Bx = this._renderer.getActiveMipmapLevel(), zx = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
      magFilter: Sn,
      minFilter: Sn,
      generateMipmaps: !1,
      type: vr,
      format: di,
      colorSpace: Pi,
      depthBuffer: !1
    }, n = _A(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = _A(e, t, i);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = c6(r)), this._blurMaterial = u6(r, e, t);
    }
    return n;
  }
  _compileMaterial(e) {
    const t = new it(this._lodPlanes[0], e);
    this._renderer.compile(t, Ox);
  }
  _sceneToCubeUV(e, t, i, n, r) {
    const l = new Fi(90, 1, t, i), c = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], h = this._renderer, d = h.autoClear, f = h.toneMapping;
    h.getClearColor(gA), h.toneMapping = qo, h.autoClear = !1;
    const m = new qn({
      name: "PMREM.Background",
      side: Yi,
      depthWrite: !1,
      depthTest: !1
    }), g = new it(new pi(), m);
    let v = !1;
    const _ = e.background;
    _ ? _.isColor && (m.color.copy(_), e.background = null, v = !0) : (m.color.copy(gA), v = !0);
    for (let y = 0; y < 6; y++) {
      const w = y % 3;
      w === 0 ? (l.up.set(0, c[y], 0), l.position.set(r.x, r.y, r.z), l.lookAt(r.x + u[y], r.y, r.z)) : w === 1 ? (l.up.set(0, 0, c[y]), l.position.set(r.x, r.y, r.z), l.lookAt(r.x, r.y + u[y], r.z)) : (l.up.set(0, c[y], 0), l.position.set(r.x, r.y, r.z), l.lookAt(r.x, r.y, r.z + u[y]));
      const x = this._cubeSize;
      Bg(n, w * x, y > 2 ? x : 0, x, x), h.setRenderTarget(n), v && h.render(g, l), h.render(e, l);
    }
    g.geometry.dispose(), g.material.dispose(), h.toneMapping = f, h.autoClear = d, e.background = _;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, n = e.mapping === Ia || e.mapping === Il;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = xA()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = yA());
    const r = n ? this._cubemapMaterial : this._equirectMaterial, o = new it(this._lodPlanes[0], r), a = r.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Bg(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, Ox);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = !1;
    const n = this._lodPlanes.length;
    for (let r = 1; r < n; r++) {
      const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = vA[(n - r - 1) % vA.length];
      this._blur(e, r - 1, r, o, a);
    }
    t.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn
   * @param {number} lodOut
   * @param {number} sigma
   * @param {Vector3} [poleAxis]
   */
  _blur(e, t, i, n, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      i,
      n,
      "latitudinal",
      r
    ), this._halfBlur(
      o,
      e,
      i,
      i,
      n,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, i, n, r, o, a) {
    const l = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const u = 3, h = new it(this._lodPlanes[n], c), d = c.uniforms, f = this._sizeLods[i] - 1, m = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Rc - 1), g = r / m, v = isFinite(r) ? 1 + Math.floor(u * g) : Rc;
    v > Rc && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Rc}`);
    const _ = [];
    let y = 0;
    for (let E = 0; E < Rc; ++E) {
      const C = E / g, P = Math.exp(-C * C / 2);
      _.push(P), E === 0 ? y += P : E < v && (y += 2 * P);
    }
    for (let E = 0; E < _.length; E++)
      _[E] = _[E] / y;
    d.envMap.value = e.texture, d.samples.value = v, d.weights.value = _, d.latitudinal.value = o === "latitudinal", a && (d.poleAxis.value = a);
    const { _lodMax: w } = this;
    d.dTheta.value = m, d.mipInt.value = w - i;
    const x = this._sizeLods[n], M = 3 * x * (n > w - kh ? n - w + kh : 0), A = 4 * (this._cubeSize - x);
    Bg(t, M, A, 3 * x, 2 * x), l.setRenderTarget(t), l.render(h, Ox);
  }
}
function c6(s) {
  const e = [], t = [], i = [];
  let n = s;
  const r = s - kh + 1 + mA.length;
  for (let o = 0; o < r; o++) {
    const a = Math.pow(2, n);
    t.push(a);
    let l = 1 / a;
    o > s - kh ? l = mA[o - s + kh - 1] : o === 0 && (l = 0), i.push(l);
    const c = 1 / (a - 2), u = -c, h = 1 + c, d = [u, u, h, u, h, h, u, u, h, h, u, h], f = 6, m = 6, g = 3, v = 2, _ = 1, y = new Float32Array(g * m * f), w = new Float32Array(v * m * f), x = new Float32Array(_ * m * f);
    for (let A = 0; A < f; A++) {
      const E = A % 3 * 2 / 3 - 1, C = A > 2 ? 0 : -1, P = [
        E,
        C,
        0,
        E + 2 / 3,
        C,
        0,
        E + 2 / 3,
        C + 1,
        0,
        E,
        C,
        0,
        E + 2 / 3,
        C + 1,
        0,
        E,
        C + 1,
        0
      ];
      y.set(P, g * m * A), w.set(d, v * m * A);
      const T = [A, A, A, A, A, A];
      x.set(T, _ * m * A);
    }
    const M = new Gt();
    M.setAttribute("position", new Nt(y, g)), M.setAttribute("uv", new Nt(w, v)), M.setAttribute("faceIndex", new Nt(x, _)), e.push(M), n > kh && n--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function _A(s, e, t) {
  const i = new Bs(s, e, t);
  return i.texture.mapping = xd, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function Bg(s, e, t, i, n) {
  s.viewport.set(e, t, i, n), s.scissor.set(e, t, i, n);
}
function u6(s, e, t) {
  const i = new Float32Array(Rc), n = new H(0, 1, 0);
  return new Mi({
    name: "SphericalGaussianBlur",
    defines: {
      n: Rc,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: n }
    },
    vertexShader: AS(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Aa,
    depthTest: !1,
    depthWrite: !1
  });
}
function yA() {
  return new Mi({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: AS(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Aa,
    depthTest: !1,
    depthWrite: !1
  });
}
function xA() {
  return new Mi({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: AS(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Aa,
    depthTest: !1,
    depthWrite: !1
  });
}
function AS() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function h6(s) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping, c = l === ld || l === Op, u = l === Ia || l === Il;
      if (c || u) {
        let h = e.get(a);
        const d = h !== void 0 ? h.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== d)
          return t === null && (t = new T1(s)), h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h), h.texture.pmremVersion = a.pmremVersion, e.set(a, h), h.texture;
        if (h !== void 0)
          return h.texture;
        {
          const f = a.image;
          return c && f && f.height > 0 || u && f && n(f) ? (t === null && (t = new T1(s)), h = c ? t.fromEquirectangular(a) : t.fromCubemap(a), h.texture.pmremVersion = a.pmremVersion, e.set(a, h), a.addEventListener("dispose", r), h.texture) : null;
        }
      }
    }
    return a;
  }
  function n(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++)
      a[u] !== void 0 && l++;
    return l === c;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: i,
    dispose: o
  };
}
function d6(s) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0)
      return e[i];
    let n;
    switch (i) {
      case "WEBGL_depth_texture":
        n = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = s.getExtension(i);
    }
    return e[i] = n, n;
  }
  return {
    has: function(i) {
      return t(i) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(i) {
      const n = t(i);
      return n === null && Ac("THREE.WebGLRenderer: " + i + " extension not supported."), n;
    }
  };
}
function f6(s, e, t, i) {
  const n = {}, r = /* @__PURE__ */ new WeakMap();
  function o(h) {
    const d = h.target;
    d.index !== null && e.remove(d.index);
    for (const m in d.attributes)
      e.remove(d.attributes[m]);
    d.removeEventListener("dispose", o), delete n[d.id];
    const f = r.get(d);
    f && (e.remove(f), r.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
  }
  function a(h, d) {
    return n[d.id] === !0 || (d.addEventListener("dispose", o), n[d.id] = !0, t.memory.geometries++), d;
  }
  function l(h) {
    const d = h.attributes;
    for (const f in d)
      e.update(d[f], s.ARRAY_BUFFER);
  }
  function c(h) {
    const d = [], f = h.index, m = h.attributes.position;
    let g = 0;
    if (f !== null) {
      const y = f.array;
      g = f.version;
      for (let w = 0, x = y.length; w < x; w += 3) {
        const M = y[w + 0], A = y[w + 1], E = y[w + 2];
        d.push(M, A, A, E, E, M);
      }
    } else if (m !== void 0) {
      const y = m.array;
      g = m.version;
      for (let w = 0, x = y.length / 3 - 1; w < x; w += 3) {
        const M = w + 0, A = w + 1, E = w + 2;
        d.push(M, A, A, E, E, M);
      }
    } else
      return;
    const v = new (WD(d) ? tS : eS)(d, 1);
    v.version = g;
    const _ = r.get(h);
    _ && e.remove(_), r.set(h, v);
  }
  function u(h) {
    const d = r.get(h);
    if (d) {
      const f = h.index;
      f !== null && d.version < f.version && c(h);
    } else
      c(h);
    return r.get(h);
  }
  return {
    get: a,
    update: l,
    getWireframeAttribute: u
  };
}
function p6(s, e, t) {
  let i;
  function n(d) {
    i = d;
  }
  let r, o;
  function a(d) {
    r = d.type, o = d.bytesPerElement;
  }
  function l(d, f) {
    s.drawElements(i, f, r, d * o), t.update(f, i, 1);
  }
  function c(d, f, m) {
    m !== 0 && (s.drawElementsInstanced(i, f, r, d * o, m), t.update(f, i, m));
  }
  function u(d, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, r, d, 0, m);
    let v = 0;
    for (let _ = 0; _ < m; _++)
      v += f[_];
    t.update(v, i, 1);
  }
  function h(d, f, m, g) {
    if (m === 0) return;
    const v = e.get("WEBGL_multi_draw");
    if (v === null)
      for (let _ = 0; _ < d.length; _++)
        c(d[_] / o, f[_], g[_]);
    else {
      v.multiDrawElementsInstancedWEBGL(i, f, 0, r, d, 0, g, 0, m);
      let _ = 0;
      for (let y = 0; y < m; y++)
        _ += f[y] * g[y];
      t.update(_, i, 1);
    }
  }
  this.setMode = n, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = u, this.renderMultiDrawInstances = h;
}
function m6(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(r, o, a) {
    switch (t.calls++, o) {
      case s.TRIANGLES:
        t.triangles += a * (r / 3);
        break;
      case s.LINES:
        t.lines += a * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += a * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += a * r;
        break;
      case s.POINTS:
        t.points += a * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function n() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: n,
    update: i
  };
}
function g6(s, e, t) {
  const i = /* @__PURE__ */ new WeakMap(), n = new Kt();
  function r(o, a, l) {
    const c = o.morphTargetInfluences, u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, h = u !== void 0 ? u.length : 0;
    let d = i.get(a);
    if (d === void 0 || d.count !== h) {
      let P = function() {
        E.dispose(), i.delete(a), a.removeEventListener("dispose", P);
      };
      d !== void 0 && d.texture.dispose();
      const f = a.morphAttributes.position !== void 0, m = a.morphAttributes.normal !== void 0, g = a.morphAttributes.color !== void 0, v = a.morphAttributes.position || [], _ = a.morphAttributes.normal || [], y = a.morphAttributes.color || [];
      let w = 0;
      f === !0 && (w = 1), m === !0 && (w = 2), g === !0 && (w = 3);
      let x = a.attributes.position.count * w, M = 1;
      x > e.maxTextureSize && (M = Math.ceil(x / e.maxTextureSize), x = e.maxTextureSize);
      const A = new Float32Array(x * M * 4 * h), E = new om(A, x, M, h);
      E.type = Un, E.needsUpdate = !0;
      const C = w * 4;
      for (let T = 0; T < h; T++) {
        const I = v[T], D = _[T], U = y[T], L = x * M * 4 * T;
        for (let k = 0; k < I.count; k++) {
          const B = k * C;
          f === !0 && (n.fromBufferAttribute(I, k), A[L + B + 0] = n.x, A[L + B + 1] = n.y, A[L + B + 2] = n.z, A[L + B + 3] = 0), m === !0 && (n.fromBufferAttribute(D, k), A[L + B + 4] = n.x, A[L + B + 5] = n.y, A[L + B + 6] = n.z, A[L + B + 7] = 0), g === !0 && (n.fromBufferAttribute(U, k), A[L + B + 8] = n.x, A[L + B + 9] = n.y, A[L + B + 10] = n.z, A[L + B + 11] = U.itemSize === 4 ? n.w : 1);
        }
      }
      d = {
        count: h,
        texture: E,
        size: new Be(x, M)
      }, i.set(a, d), a.addEventListener("dispose", P);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(s, "morphTexture", o.morphTexture, t);
    else {
      let f = 0;
      for (let g = 0; g < c.length; g++)
        f += c[g];
      const m = a.morphTargetsRelative ? 1 : 1 - f;
      l.getUniforms().setValue(s, "morphTargetBaseInfluence", m), l.getUniforms().setValue(s, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(s, "morphTargetsTexture", d.texture, t), l.getUniforms().setValue(s, "morphTargetsTextureSize", d.size);
  }
  return {
    update: r
  };
}
function v6(s, e, t, i) {
  let n = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const c = i.render.frame, u = l.geometry, h = e.get(l, u);
    if (n.get(h) !== c && (e.update(h), n.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), n.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), n.set(l, c))), l.isSkinnedMesh) {
      const d = l.skeleton;
      n.get(d) !== c && (d.update(), n.set(d, c));
    }
    return h;
  }
  function o() {
    n = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: r,
    dispose: o
  };
}
const FI = /* @__PURE__ */ new ei(), bA = /* @__PURE__ */ new rS(1, 1), NI = /* @__PURE__ */ new om(), BI = /* @__PURE__ */ new w_(), zI = /* @__PURE__ */ new Ed(), wA = [], SA = [], MA = new Float32Array(16), EA = new Float32Array(9), TA = new Float32Array(4);
function Rd(s, e, t) {
  const i = s[0];
  if (i <= 0 || i > 0) return s;
  const n = e * t;
  let r = wA[n];
  if (r === void 0 && (r = new Float32Array(n), wA[n] = r), e !== 0) {
    i.toArray(r, 0);
    for (let o = 1, a = 0; o !== e; ++o)
      a += t, s[o].toArray(r, a);
  }
  return r;
}
function qi(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, i = s.length; t < i; t++)
    if (s[t] !== e[t]) return !1;
  return !0;
}
function Zi(s, e) {
  for (let t = 0, i = e.length; t < i; t++)
    s[t] = e[t];
}
function J_(s, e) {
  let t = SA[e];
  t === void 0 && (t = new Int32Array(e), SA[e] = t);
  for (let i = 0; i !== e; ++i)
    t[i] = s.allocateTextureUnit();
  return t;
}
function _6(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
}
function y6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (qi(t, e)) return;
    s.uniform2fv(this.addr, e), Zi(t, e);
  }
}
function x6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (qi(t, e)) return;
    s.uniform3fv(this.addr, e), Zi(t, e);
  }
}
function b6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (qi(t, e)) return;
    s.uniform4fv(this.addr, e), Zi(t, e);
  }
}
function w6(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (qi(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), Zi(t, e);
  } else {
    if (qi(t, i)) return;
    TA.set(i), s.uniformMatrix2fv(this.addr, !1, TA), Zi(t, i);
  }
}
function S6(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (qi(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), Zi(t, e);
  } else {
    if (qi(t, i)) return;
    EA.set(i), s.uniformMatrix3fv(this.addr, !1, EA), Zi(t, i);
  }
}
function M6(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (qi(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), Zi(t, e);
  } else {
    if (qi(t, i)) return;
    MA.set(i), s.uniformMatrix4fv(this.addr, !1, MA), Zi(t, i);
  }
}
function E6(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
}
function T6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (qi(t, e)) return;
    s.uniform2iv(this.addr, e), Zi(t, e);
  }
}
function A6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (qi(t, e)) return;
    s.uniform3iv(this.addr, e), Zi(t, e);
  }
}
function C6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (qi(t, e)) return;
    s.uniform4iv(this.addr, e), Zi(t, e);
  }
}
function P6(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
}
function R6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (qi(t, e)) return;
    s.uniform2uiv(this.addr, e), Zi(t, e);
  }
}
function D6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (qi(t, e)) return;
    s.uniform3uiv(this.addr, e), Zi(t, e);
  }
}
function I6(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (qi(t, e)) return;
    s.uniform4uiv(this.addr, e), Zi(t, e);
  }
}
function L6(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n);
  let r;
  this.type === s.SAMPLER_2D_SHADOW ? (bA.compareFunction = Jw, r = bA) : r = FI, t.setTexture2D(e || r, n);
}
function U6(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture3D(e || BI, n);
}
function k6(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTextureCube(e || zI, n);
}
function O6(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture2DArray(e || NI, n);
}
function F6(s) {
  switch (s) {
    case 5126:
      return _6;
    // FLOAT
    case 35664:
      return y6;
    // _VEC2
    case 35665:
      return x6;
    // _VEC3
    case 35666:
      return b6;
    // _VEC4
    case 35674:
      return w6;
    // _MAT2
    case 35675:
      return S6;
    // _MAT3
    case 35676:
      return M6;
    // _MAT4
    case 5124:
    case 35670:
      return E6;
    // INT, BOOL
    case 35667:
    case 35671:
      return T6;
    // _VEC2
    case 35668:
    case 35672:
      return A6;
    // _VEC3
    case 35669:
    case 35673:
      return C6;
    // _VEC4
    case 5125:
      return P6;
    // UINT
    case 36294:
      return R6;
    // _VEC2
    case 36295:
      return D6;
    // _VEC3
    case 36296:
      return I6;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return L6;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return U6;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return k6;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return O6;
  }
}
function N6(s, e) {
  s.uniform1fv(this.addr, e);
}
function B6(s, e) {
  const t = Rd(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function z6(s, e) {
  const t = Rd(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function V6(s, e) {
  const t = Rd(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function G6(s, e) {
  const t = Rd(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function H6(s, e) {
  const t = Rd(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function W6(s, e) {
  const t = Rd(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function X6(s, e) {
  s.uniform1iv(this.addr, e);
}
function Y6(s, e) {
  s.uniform2iv(this.addr, e);
}
function j6(s, e) {
  s.uniform3iv(this.addr, e);
}
function q6(s, e) {
  s.uniform4iv(this.addr, e);
}
function Z6(s, e) {
  s.uniform1uiv(this.addr, e);
}
function K6(s, e) {
  s.uniform2uiv(this.addr, e);
}
function $6(s, e) {
  s.uniform3uiv(this.addr, e);
}
function J6(s, e) {
  s.uniform4uiv(this.addr, e);
}
function Q6(s, e, t) {
  const i = this.cache, n = e.length, r = J_(t, n);
  qi(i, r) || (s.uniform1iv(this.addr, r), Zi(i, r));
  for (let o = 0; o !== n; ++o)
    t.setTexture2D(e[o] || FI, r[o]);
}
function eW(s, e, t) {
  const i = this.cache, n = e.length, r = J_(t, n);
  qi(i, r) || (s.uniform1iv(this.addr, r), Zi(i, r));
  for (let o = 0; o !== n; ++o)
    t.setTexture3D(e[o] || BI, r[o]);
}
function tW(s, e, t) {
  const i = this.cache, n = e.length, r = J_(t, n);
  qi(i, r) || (s.uniform1iv(this.addr, r), Zi(i, r));
  for (let o = 0; o !== n; ++o)
    t.setTextureCube(e[o] || zI, r[o]);
}
function nW(s, e, t) {
  const i = this.cache, n = e.length, r = J_(t, n);
  qi(i, r) || (s.uniform1iv(this.addr, r), Zi(i, r));
  for (let o = 0; o !== n; ++o)
    t.setTexture2DArray(e[o] || NI, r[o]);
}
function iW(s) {
  switch (s) {
    case 5126:
      return N6;
    // FLOAT
    case 35664:
      return B6;
    // _VEC2
    case 35665:
      return z6;
    // _VEC3
    case 35666:
      return V6;
    // _VEC4
    case 35674:
      return G6;
    // _MAT2
    case 35675:
      return H6;
    // _MAT3
    case 35676:
      return W6;
    // _MAT4
    case 5124:
    case 35670:
      return X6;
    // INT, BOOL
    case 35667:
    case 35671:
      return Y6;
    // _VEC2
    case 35668:
    case 35672:
      return j6;
    // _VEC3
    case 35669:
    case 35673:
      return q6;
    // _VEC4
    case 5125:
      return Z6;
    // UINT
    case 36294:
      return K6;
    // _VEC2
    case 36295:
      return $6;
    // _VEC3
    case 36296:
      return J6;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return Q6;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return eW;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return tW;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return nW;
  }
}
class rW {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = F6(t.type);
  }
}
class sW {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = iW(t.type);
  }
}
class oW {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const n = this.seq;
    for (let r = 0, o = n.length; r !== o; ++r) {
      const a = n[r];
      a.setValue(e, t[a.id], i);
    }
  }
}
const Vx = /(\w+)(\])?(\[|\.)?/g;
function AA(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function aW(s, e, t) {
  const i = s.name, n = i.length;
  for (Vx.lastIndex = 0; ; ) {
    const r = Vx.exec(i), o = Vx.lastIndex;
    let a = r[1];
    const l = r[2] === "]", c = r[3];
    if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === n) {
      AA(t, c === void 0 ? new rW(a, s, e) : new sW(a, s, e));
      break;
    } else {
      let h = t.map[a];
      h === void 0 && (h = new oW(a), AA(t, h)), t = h;
    }
  }
}
class Nv {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let n = 0; n < i; ++n) {
      const r = e.getActiveUniform(t, n), o = e.getUniformLocation(t, r.name);
      aW(r, o, this);
    }
  }
  setValue(e, t, i, n) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, i, n);
  }
  setOptional(e, t, i) {
    const n = t[i];
    n !== void 0 && this.setValue(e, i, n);
  }
  static upload(e, t, i, n) {
    for (let r = 0, o = t.length; r !== o; ++r) {
      const a = t[r], l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, n);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let n = 0, r = e.length; n !== r; ++n) {
      const o = e[n];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function CA(s, e, t) {
  const i = s.createShader(e);
  return s.shaderSource(i, t), s.compileShader(i), i;
}
const lW = 37297;
let cW = 0;
function uW(s, e) {
  const t = s.split(`
`), i = [], n = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let o = n; o < r; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
const PA = /* @__PURE__ */ new Jt();
function hW(s) {
  vn._getMatrix(PA, vn.workingColorSpace, s);
  const e = `mat3( ${PA.elements.map((t) => t.toFixed(4))} )`;
  switch (vn.getTransfer(s)) {
    case Bp:
      return [e, "LinearTransferOETF"];
    case Vn:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [e, "LinearTransferOETF"];
  }
}
function RA(s, e, t) {
  const i = s.getShaderParameter(e, s.COMPILE_STATUS), n = s.getShaderInfoLog(e).trim();
  if (i && n === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(n);
  if (r) {
    const o = parseInt(r[1]);
    return t.toUpperCase() + `

` + n + `

` + uW(s.getShaderSource(e), o);
  } else
    return n;
}
function dW(s, e) {
  const t = hW(e);
  return [
    `vec4 ${s}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function fW(s, e) {
  let t;
  switch (e) {
    case MD:
      t = "Linear";
      break;
    case ED:
      t = "Reinhard";
      break;
    case TD:
      t = "Cineon";
      break;
    case AD:
      t = "ACESFilmic";
      break;
    case y0:
      t = "AgX";
      break;
    case PD:
      t = "Neutral";
      break;
    case CD:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const zg = /* @__PURE__ */ new H();
function pW() {
  vn.getLuminanceCoefficients(zg);
  const s = zg.x.toFixed(4), e = zg.y.toFixed(4), t = zg.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function mW(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Ff).join(`
`);
}
function gW(s) {
  const e = [];
  for (const t in s) {
    const i = s[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function vW(s, e) {
  const t = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let n = 0; n < i; n++) {
    const r = s.getActiveAttrib(e, n), o = r.name;
    let a = 1;
    r.type === s.FLOAT_MAT2 && (a = 2), r.type === s.FLOAT_MAT3 && (a = 3), r.type === s.FLOAT_MAT4 && (a = 4), t[o] = {
      type: r.type,
      location: s.getAttribLocation(e, o),
      locationSize: a
    };
  }
  return t;
}
function Ff(s) {
  return s !== "";
}
function DA(s, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function IA(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const _W = /^[ \t]*#include +<([\w\d./]+)>/gm;
function A1(s) {
  return s.replace(_W, xW);
}
const yW = /* @__PURE__ */ new Map();
function xW(s, e) {
  let t = Ft[e];
  if (t === void 0) {
    const i = yW.get(e);
    if (i !== void 0)
      t = Ft[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return A1(t);
}
const bW = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function LA(s) {
  return s.replace(bW, wW);
}
function wW(s, e, t, i) {
  let n = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    n += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return n;
}
function UA(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function SW(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === Hw ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === rp ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === Lo && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function MW(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case Ia:
      case Il:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case xd:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function EW(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Il:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function TW(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case sm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case wD:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case SD:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function AW(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function CW(s, e, t, i) {
  const n = s.getContext(), r = t.defines;
  let o = t.vertexShader, a = t.fragmentShader;
  const l = SW(t), c = MW(t), u = EW(t), h = TW(t), d = AW(t), f = mW(t), m = gW(r), g = n.createProgram();
  let v, _, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (v = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(Ff).join(`
`), v.length > 0 && (v += `
`), _ = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(Ff).join(`
`), _.length > 0 && (_ += `
`)) : (v = [
    UA(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + u : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Ff).join(`
`), _ = [
    UA(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + u : "",
    t.envMap ? "#define " + h : "",
    d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
    d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
    d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== qo ? "#define TONE_MAPPING" : "",
    t.toneMapping !== qo ? Ft.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== qo ? fW("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Ft.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    dW("linearToOutputTexel", t.outputColorSpace),
    pW(),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(Ff).join(`
`)), o = A1(o), o = DA(o, t), o = IA(o, t), a = A1(a), a = DA(a, t), a = IA(a, t), o = LA(o), a = LA(a), t.isRawShaderMaterial !== !0 && (y = `#version 300 es
`, v = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, _ = [
    "#define varying in",
    t.glslVersion === y1 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === y1 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + _);
  const w = y + v + o, x = y + _ + a, M = CA(n, n.VERTEX_SHADER, w), A = CA(n, n.FRAGMENT_SHADER, x);
  n.attachShader(g, M), n.attachShader(g, A), t.index0AttributeName !== void 0 ? n.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && n.bindAttribLocation(g, 0, "position"), n.linkProgram(g);
  function E(I) {
    if (s.debug.checkShaderErrors) {
      const D = n.getProgramInfoLog(g).trim(), U = n.getShaderInfoLog(M).trim(), L = n.getShaderInfoLog(A).trim();
      let k = !0, B = !0;
      if (n.getProgramParameter(g, n.LINK_STATUS) === !1)
        if (k = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(n, g, M, A);
        else {
          const j = RA(n, M, "vertex"), q = RA(n, A, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(g, n.VALIDATE_STATUS) + `

Material Name: ` + I.name + `
Material Type: ` + I.type + `

Program Info Log: ` + D + `
` + j + `
` + q
          );
        }
      else D !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", D) : (U === "" || L === "") && (B = !1);
      B && (I.diagnostics = {
        runnable: k,
        programLog: D,
        vertexShader: {
          log: U,
          prefix: v
        },
        fragmentShader: {
          log: L,
          prefix: _
        }
      });
    }
    n.deleteShader(M), n.deleteShader(A), C = new Nv(n, g), P = vW(n, g);
  }
  let C;
  this.getUniforms = function() {
    return C === void 0 && E(this), C;
  };
  let P;
  this.getAttributes = function() {
    return P === void 0 && E(this), P;
  };
  let T = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return T === !1 && (T = n.getProgramParameter(g, lW)), T;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), n.deleteProgram(g), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = cW++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = M, this.fragmentShader = A, this;
}
let PW = 0;
class RW {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, n = this._getShaderStage(t), r = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e);
    return o.has(n) === !1 && (o.add(n), n.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new DW(e), t.set(e, i)), i;
  }
}
class DW {
  constructor(e) {
    this.id = PW++, this.code = e, this.usedTimes = 0;
  }
}
function IW(s, e, t, i, n, r, o) {
  const a = new S_(), l = new RW(), c = /* @__PURE__ */ new Set(), u = [], h = n.logarithmicDepthBuffer, d = n.vertexTextures;
  let f = n.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function g(P) {
    return c.add(P), P === 0 ? "uv" : `uv${P}`;
  }
  function v(P, T, I, D, U) {
    const L = D.fog, k = U.geometry, B = P.isMeshStandardMaterial ? D.environment : null, j = (P.isMeshStandardMaterial ? t : e).get(P.envMap || B), q = j && j.mapping === xd ? j.image.height : null, Z = m[P.type];
    P.precision !== null && (f = n.getMaxPrecision(P.precision), f !== P.precision && console.warn("THREE.WebGLProgram.getParameters:", P.precision, "not supported, using", f, "instead."));
    const N = k.morphAttributes.position || k.morphAttributes.normal || k.morphAttributes.color, z = N !== void 0 ? N.length : 0;
    let J = 0;
    k.morphAttributes.position !== void 0 && (J = 1), k.morphAttributes.normal !== void 0 && (J = 2), k.morphAttributes.color !== void 0 && (J = 3);
    let se, K, Q, de;
    if (Z) {
      const je = Dr[Z];
      se = je.vertexShader, K = je.fragmentShader;
    } else
      se = P.vertexShader, K = P.fragmentShader, l.update(P), Q = l.getVertexShaderID(P), de = l.getFragmentShaderID(P);
    const ce = s.getRenderTarget(), _e = s.state.buffers.depth.getReversed(), Fe = U.isInstancedMesh === !0, Ie = U.isBatchedMesh === !0, Ee = !!P.map, me = !!P.matcap, xe = !!j, $ = !!P.aoMap, Ue = !!P.lightMap, Me = !!P.bumpMap, oe = !!P.normalMap, Te = !!P.displacementMap, Ye = !!P.emissiveMap, Oe = !!P.metalnessMap, X = !!P.roughnessMap, Y = P.anisotropy > 0, fe = P.clearcoat > 0, ue = P.dispersion > 0, te = P.iridescence > 0, Se = P.sheen > 0, ye = P.transmission > 0, Ae = Y && !!P.anisotropyMap, Ce = fe && !!P.clearcoatMap, Ge = fe && !!P.clearcoatNormalMap, De = fe && !!P.clearcoatRoughnessMap, Ve = te && !!P.iridescenceMap, ze = te && !!P.iridescenceThicknessMap, Ze = Se && !!P.sheenColorMap, Le = Se && !!P.sheenRoughnessMap, ot = !!P.specularMap, tt = !!P.specularColorMap, mt = !!P.specularIntensityMap, le = ye && !!P.transmissionMap, ve = ye && !!P.thicknessMap, be = !!P.gradientMap, Xe = !!P.alphaMap, We = P.alphaTest > 0, Ne = !!P.alphaHash, ct = !!P.extensions;
    let gt = qo;
    P.toneMapped && (ce === null || ce.isXRRenderTarget === !0) && (gt = s.toneMapping);
    const nt = {
      shaderID: Z,
      shaderType: P.type,
      shaderName: P.name,
      vertexShader: se,
      fragmentShader: K,
      defines: P.defines,
      customVertexShaderID: Q,
      customFragmentShaderID: de,
      isRawShaderMaterial: P.isRawShaderMaterial === !0,
      glslVersion: P.glslVersion,
      precision: f,
      batching: Ie,
      batchingColor: Ie && U._colorsTexture !== null,
      instancing: Fe,
      instancingColor: Fe && U.instanceColor !== null,
      instancingMorph: Fe && U.morphTexture !== null,
      supportsVertexTextures: d,
      outputColorSpace: ce === null ? s.outputColorSpace : ce.isXRRenderTarget === !0 ? ce.texture.colorSpace : Pi,
      alphaToCoverage: !!P.alphaToCoverage,
      map: Ee,
      matcap: me,
      envMap: xe,
      envMapMode: xe && j.mapping,
      envMapCubeUVHeight: q,
      aoMap: $,
      lightMap: Ue,
      bumpMap: Me,
      normalMap: oe,
      displacementMap: d && Te,
      emissiveMap: Ye,
      normalMapObjectSpace: oe && P.normalMapType === OD,
      normalMapTangentSpace: oe && P.normalMapType === kl,
      metalnessMap: Oe,
      roughnessMap: X,
      anisotropy: Y,
      anisotropyMap: Ae,
      clearcoat: fe,
      clearcoatMap: Ce,
      clearcoatNormalMap: Ge,
      clearcoatRoughnessMap: De,
      dispersion: ue,
      iridescence: te,
      iridescenceMap: Ve,
      iridescenceThicknessMap: ze,
      sheen: Se,
      sheenColorMap: Ze,
      sheenRoughnessMap: Le,
      specularMap: ot,
      specularColorMap: tt,
      specularIntensityMap: mt,
      transmission: ye,
      transmissionMap: le,
      thicknessMap: ve,
      gradientMap: be,
      opaque: P.transparent === !1 && P.blending === Jc && P.alphaToCoverage === !1,
      alphaMap: Xe,
      alphaTest: We,
      alphaHash: Ne,
      combine: P.combine,
      //
      mapUv: Ee && g(P.map.channel),
      aoMapUv: $ && g(P.aoMap.channel),
      lightMapUv: Ue && g(P.lightMap.channel),
      bumpMapUv: Me && g(P.bumpMap.channel),
      normalMapUv: oe && g(P.normalMap.channel),
      displacementMapUv: Te && g(P.displacementMap.channel),
      emissiveMapUv: Ye && g(P.emissiveMap.channel),
      metalnessMapUv: Oe && g(P.metalnessMap.channel),
      roughnessMapUv: X && g(P.roughnessMap.channel),
      anisotropyMapUv: Ae && g(P.anisotropyMap.channel),
      clearcoatMapUv: Ce && g(P.clearcoatMap.channel),
      clearcoatNormalMapUv: Ge && g(P.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: De && g(P.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ve && g(P.iridescenceMap.channel),
      iridescenceThicknessMapUv: ze && g(P.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ze && g(P.sheenColorMap.channel),
      sheenRoughnessMapUv: Le && g(P.sheenRoughnessMap.channel),
      specularMapUv: ot && g(P.specularMap.channel),
      specularColorMapUv: tt && g(P.specularColorMap.channel),
      specularIntensityMapUv: mt && g(P.specularIntensityMap.channel),
      transmissionMapUv: le && g(P.transmissionMap.channel),
      thicknessMapUv: ve && g(P.thicknessMap.channel),
      alphaMapUv: Xe && g(P.alphaMap.channel),
      //
      vertexTangents: !!k.attributes.tangent && (oe || Y),
      vertexColors: P.vertexColors,
      vertexAlphas: P.vertexColors === !0 && !!k.attributes.color && k.attributes.color.itemSize === 4,
      pointsUvs: U.isPoints === !0 && !!k.attributes.uv && (Ee || Xe),
      fog: !!L,
      useFog: P.fog === !0,
      fogExp2: !!L && L.isFogExp2,
      flatShading: P.flatShading === !0,
      sizeAttenuation: P.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reverseDepthBuffer: _e,
      skinning: U.isSkinnedMesh === !0,
      morphTargets: k.morphAttributes.position !== void 0,
      morphNormals: k.morphAttributes.normal !== void 0,
      morphColors: k.morphAttributes.color !== void 0,
      morphTargetsCount: z,
      morphTextureStride: J,
      numDirLights: T.directional.length,
      numPointLights: T.point.length,
      numSpotLights: T.spot.length,
      numSpotLightMaps: T.spotLightMap.length,
      numRectAreaLights: T.rectArea.length,
      numHemiLights: T.hemi.length,
      numDirLightShadows: T.directionalShadowMap.length,
      numPointLightShadows: T.pointShadowMap.length,
      numSpotLightShadows: T.spotShadowMap.length,
      numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
      numLightProbes: T.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: P.dithering,
      shadowMapEnabled: s.shadowMap.enabled && I.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: gt,
      decodeVideoTexture: Ee && P.map.isVideoTexture === !0 && vn.getTransfer(P.map.colorSpace) === Vn,
      decodeVideoTextureEmissive: Ye && P.emissiveMap.isVideoTexture === !0 && vn.getTransfer(P.emissiveMap.colorSpace) === Vn,
      premultipliedAlpha: P.premultipliedAlpha,
      doubleSided: P.side === wi,
      flipSided: P.side === Yi,
      useDepthPacking: P.depthPacking >= 0,
      depthPacking: P.depthPacking || 0,
      index0AttributeName: P.index0AttributeName,
      extensionClipCullDistance: ct && P.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (ct && P.extensions.multiDraw === !0 || Ie) && i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: P.customProgramCacheKey()
    };
    return nt.vertexUv1s = c.has(1), nt.vertexUv2s = c.has(2), nt.vertexUv3s = c.has(3), c.clear(), nt;
  }
  function _(P) {
    const T = [];
    if (P.shaderID ? T.push(P.shaderID) : (T.push(P.customVertexShaderID), T.push(P.customFragmentShaderID)), P.defines !== void 0)
      for (const I in P.defines)
        T.push(I), T.push(P.defines[I]);
    return P.isRawShaderMaterial === !1 && (y(T, P), w(T, P), T.push(s.outputColorSpace)), T.push(P.customProgramCacheKey), T.join();
  }
  function y(P, T) {
    P.push(T.precision), P.push(T.outputColorSpace), P.push(T.envMapMode), P.push(T.envMapCubeUVHeight), P.push(T.mapUv), P.push(T.alphaMapUv), P.push(T.lightMapUv), P.push(T.aoMapUv), P.push(T.bumpMapUv), P.push(T.normalMapUv), P.push(T.displacementMapUv), P.push(T.emissiveMapUv), P.push(T.metalnessMapUv), P.push(T.roughnessMapUv), P.push(T.anisotropyMapUv), P.push(T.clearcoatMapUv), P.push(T.clearcoatNormalMapUv), P.push(T.clearcoatRoughnessMapUv), P.push(T.iridescenceMapUv), P.push(T.iridescenceThicknessMapUv), P.push(T.sheenColorMapUv), P.push(T.sheenRoughnessMapUv), P.push(T.specularMapUv), P.push(T.specularColorMapUv), P.push(T.specularIntensityMapUv), P.push(T.transmissionMapUv), P.push(T.thicknessMapUv), P.push(T.combine), P.push(T.fogExp2), P.push(T.sizeAttenuation), P.push(T.morphTargetsCount), P.push(T.morphAttributeCount), P.push(T.numDirLights), P.push(T.numPointLights), P.push(T.numSpotLights), P.push(T.numSpotLightMaps), P.push(T.numHemiLights), P.push(T.numRectAreaLights), P.push(T.numDirLightShadows), P.push(T.numPointLightShadows), P.push(T.numSpotLightShadows), P.push(T.numSpotLightShadowsWithMaps), P.push(T.numLightProbes), P.push(T.shadowMapType), P.push(T.toneMapping), P.push(T.numClippingPlanes), P.push(T.numClipIntersection), P.push(T.depthPacking);
  }
  function w(P, T) {
    a.disableAll(), T.supportsVertexTextures && a.enable(0), T.instancing && a.enable(1), T.instancingColor && a.enable(2), T.instancingMorph && a.enable(3), T.matcap && a.enable(4), T.envMap && a.enable(5), T.normalMapObjectSpace && a.enable(6), T.normalMapTangentSpace && a.enable(7), T.clearcoat && a.enable(8), T.iridescence && a.enable(9), T.alphaTest && a.enable(10), T.vertexColors && a.enable(11), T.vertexAlphas && a.enable(12), T.vertexUv1s && a.enable(13), T.vertexUv2s && a.enable(14), T.vertexUv3s && a.enable(15), T.vertexTangents && a.enable(16), T.anisotropy && a.enable(17), T.alphaHash && a.enable(18), T.batching && a.enable(19), T.dispersion && a.enable(20), T.batchingColor && a.enable(21), P.push(a.mask), a.disableAll(), T.fog && a.enable(0), T.useFog && a.enable(1), T.flatShading && a.enable(2), T.logarithmicDepthBuffer && a.enable(3), T.reverseDepthBuffer && a.enable(4), T.skinning && a.enable(5), T.morphTargets && a.enable(6), T.morphNormals && a.enable(7), T.morphColors && a.enable(8), T.premultipliedAlpha && a.enable(9), T.shadowMapEnabled && a.enable(10), T.doubleSided && a.enable(11), T.flipSided && a.enable(12), T.useDepthPacking && a.enable(13), T.dithering && a.enable(14), T.transmission && a.enable(15), T.sheen && a.enable(16), T.opaque && a.enable(17), T.pointsUvs && a.enable(18), T.decodeVideoTexture && a.enable(19), T.decodeVideoTextureEmissive && a.enable(20), T.alphaToCoverage && a.enable(21), P.push(a.mask);
  }
  function x(P) {
    const T = m[P.type];
    let I;
    if (T) {
      const D = Dr[T];
      I = Fl.clone(D.uniforms);
    } else
      I = P.uniforms;
    return I;
  }
  function M(P, T) {
    let I;
    for (let D = 0, U = u.length; D < U; D++) {
      const L = u[D];
      if (L.cacheKey === T) {
        I = L, ++I.usedTimes;
        break;
      }
    }
    return I === void 0 && (I = new CW(s, T, P, r), u.push(I)), I;
  }
  function A(P) {
    if (--P.usedTimes === 0) {
      const T = u.indexOf(P);
      u[T] = u[u.length - 1], u.pop(), P.destroy();
    }
  }
  function E(P) {
    l.remove(P);
  }
  function C() {
    l.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: _,
    getUniforms: x,
    acquireProgram: M,
    releaseProgram: A,
    releaseShaderCache: E,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: u,
    dispose: C
  };
}
function LW() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(o) {
    return s.has(o);
  }
  function t(o) {
    let a = s.get(o);
    return a === void 0 && (a = {}, s.set(o, a)), a;
  }
  function i(o) {
    s.delete(o);
  }
  function n(o, a, l) {
    s.get(o)[a] = l;
  }
  function r() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: t,
    remove: i,
    update: n,
    dispose: r
  };
}
function UW(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function kA(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function OA() {
  const s = [];
  let e = 0;
  const t = [], i = [], n = [];
  function r() {
    e = 0, t.length = 0, i.length = 0, n.length = 0;
  }
  function o(h, d, f, m, g, v) {
    let _ = s[e];
    return _ === void 0 ? (_ = {
      id: h.id,
      object: h,
      geometry: d,
      material: f,
      groupOrder: m,
      renderOrder: h.renderOrder,
      z: g,
      group: v
    }, s[e] = _) : (_.id = h.id, _.object = h, _.geometry = d, _.material = f, _.groupOrder = m, _.renderOrder = h.renderOrder, _.z = g, _.group = v), e++, _;
  }
  function a(h, d, f, m, g, v) {
    const _ = o(h, d, f, m, g, v);
    f.transmission > 0 ? i.push(_) : f.transparent === !0 ? n.push(_) : t.push(_);
  }
  function l(h, d, f, m, g, v) {
    const _ = o(h, d, f, m, g, v);
    f.transmission > 0 ? i.unshift(_) : f.transparent === !0 ? n.unshift(_) : t.unshift(_);
  }
  function c(h, d) {
    t.length > 1 && t.sort(h || UW), i.length > 1 && i.sort(d || kA), n.length > 1 && n.sort(d || kA);
  }
  function u() {
    for (let h = e, d = s.length; h < d; h++) {
      const f = s[h];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: n,
    init: r,
    push: a,
    unshift: l,
    finish: u,
    sort: c
  };
}
function kW() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(i, n) {
    const r = s.get(i);
    let o;
    return r === void 0 ? (o = new OA(), s.set(i, [o])) : n >= r.length ? (o = new OA(), r.push(o)) : o = r[n], o;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function OW() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new H(),
            color: new rt()
          };
          break;
        case "SpotLight":
          t = {
            position: new H(),
            direction: new H(),
            color: new rt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new H(),
            color: new rt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new H(),
            skyColor: new rt(),
            groundColor: new rt()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new rt(),
            position: new H(),
            halfWidth: new H(),
            halfHeight: new H()
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
function FW() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Be()
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Be()
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Be(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
let NW = 0;
function BW(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function zW(s) {
  const e = new OW(), t = FW(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++) i.probe.push(new H());
  const n = new H(), r = new _t(), o = new _t();
  function a(c) {
    let u = 0, h = 0, d = 0;
    for (let P = 0; P < 9; P++) i.probe[P].set(0, 0, 0);
    let f = 0, m = 0, g = 0, v = 0, _ = 0, y = 0, w = 0, x = 0, M = 0, A = 0, E = 0;
    c.sort(BW);
    for (let P = 0, T = c.length; P < T; P++) {
      const I = c[P], D = I.color, U = I.intensity, L = I.distance, k = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
      if (I.isAmbientLight)
        u += D.r * U, h += D.g * U, d += D.b * U;
      else if (I.isLightProbe) {
        for (let B = 0; B < 9; B++)
          i.probe[B].addScaledVector(I.sh.coefficients[B], U);
        E++;
      } else if (I.isDirectionalLight) {
        const B = e.get(I);
        if (B.color.copy(I.color).multiplyScalar(I.intensity), I.castShadow) {
          const j = I.shadow, q = t.get(I);
          q.shadowIntensity = j.intensity, q.shadowBias = j.bias, q.shadowNormalBias = j.normalBias, q.shadowRadius = j.radius, q.shadowMapSize = j.mapSize, i.directionalShadow[f] = q, i.directionalShadowMap[f] = k, i.directionalShadowMatrix[f] = I.shadow.matrix, y++;
        }
        i.directional[f] = B, f++;
      } else if (I.isSpotLight) {
        const B = e.get(I);
        B.position.setFromMatrixPosition(I.matrixWorld), B.color.copy(D).multiplyScalar(U), B.distance = L, B.coneCos = Math.cos(I.angle), B.penumbraCos = Math.cos(I.angle * (1 - I.penumbra)), B.decay = I.decay, i.spot[g] = B;
        const j = I.shadow;
        if (I.map && (i.spotLightMap[M] = I.map, M++, j.updateMatrices(I), I.castShadow && A++), i.spotLightMatrix[g] = j.matrix, I.castShadow) {
          const q = t.get(I);
          q.shadowIntensity = j.intensity, q.shadowBias = j.bias, q.shadowNormalBias = j.normalBias, q.shadowRadius = j.radius, q.shadowMapSize = j.mapSize, i.spotShadow[g] = q, i.spotShadowMap[g] = k, x++;
        }
        g++;
      } else if (I.isRectAreaLight) {
        const B = e.get(I);
        B.color.copy(D).multiplyScalar(U), B.halfWidth.set(I.width * 0.5, 0, 0), B.halfHeight.set(0, I.height * 0.5, 0), i.rectArea[v] = B, v++;
      } else if (I.isPointLight) {
        const B = e.get(I);
        if (B.color.copy(I.color).multiplyScalar(I.intensity), B.distance = I.distance, B.decay = I.decay, I.castShadow) {
          const j = I.shadow, q = t.get(I);
          q.shadowIntensity = j.intensity, q.shadowBias = j.bias, q.shadowNormalBias = j.normalBias, q.shadowRadius = j.radius, q.shadowMapSize = j.mapSize, q.shadowCameraNear = j.camera.near, q.shadowCameraFar = j.camera.far, i.pointShadow[m] = q, i.pointShadowMap[m] = k, i.pointShadowMatrix[m] = I.shadow.matrix, w++;
        }
        i.point[m] = B, m++;
      } else if (I.isHemisphereLight) {
        const B = e.get(I);
        B.skyColor.copy(I.color).multiplyScalar(U), B.groundColor.copy(I.groundColor).multiplyScalar(U), i.hemi[_] = B, _++;
      }
    }
    v > 0 && (s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = vt.LTC_FLOAT_1, i.rectAreaLTC2 = vt.LTC_FLOAT_2) : (i.rectAreaLTC1 = vt.LTC_HALF_1, i.rectAreaLTC2 = vt.LTC_HALF_2)), i.ambient[0] = u, i.ambient[1] = h, i.ambient[2] = d;
    const C = i.hash;
    (C.directionalLength !== f || C.pointLength !== m || C.spotLength !== g || C.rectAreaLength !== v || C.hemiLength !== _ || C.numDirectionalShadows !== y || C.numPointShadows !== w || C.numSpotShadows !== x || C.numSpotMaps !== M || C.numLightProbes !== E) && (i.directional.length = f, i.spot.length = g, i.rectArea.length = v, i.point.length = m, i.hemi.length = _, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = w, i.pointShadowMap.length = w, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = w, i.spotLightMatrix.length = x + M - A, i.spotLightMap.length = M, i.numSpotLightShadowsWithMaps = A, i.numLightProbes = E, C.directionalLength = f, C.pointLength = m, C.spotLength = g, C.rectAreaLength = v, C.hemiLength = _, C.numDirectionalShadows = y, C.numPointShadows = w, C.numSpotShadows = x, C.numSpotMaps = M, C.numLightProbes = E, i.version = NW++);
  }
  function l(c, u) {
    let h = 0, d = 0, f = 0, m = 0, g = 0;
    const v = u.matrixWorldInverse;
    for (let _ = 0, y = c.length; _ < y; _++) {
      const w = c[_];
      if (w.isDirectionalLight) {
        const x = i.directional[h];
        x.direction.setFromMatrixPosition(w.matrixWorld), n.setFromMatrixPosition(w.target.matrixWorld), x.direction.sub(n), x.direction.transformDirection(v), h++;
      } else if (w.isSpotLight) {
        const x = i.spot[f];
        x.position.setFromMatrixPosition(w.matrixWorld), x.position.applyMatrix4(v), x.direction.setFromMatrixPosition(w.matrixWorld), n.setFromMatrixPosition(w.target.matrixWorld), x.direction.sub(n), x.direction.transformDirection(v), f++;
      } else if (w.isRectAreaLight) {
        const x = i.rectArea[m];
        x.position.setFromMatrixPosition(w.matrixWorld), x.position.applyMatrix4(v), o.identity(), r.copy(w.matrixWorld), r.premultiply(v), o.extractRotation(r), x.halfWidth.set(w.width * 0.5, 0, 0), x.halfHeight.set(0, w.height * 0.5, 0), x.halfWidth.applyMatrix4(o), x.halfHeight.applyMatrix4(o), m++;
      } else if (w.isPointLight) {
        const x = i.point[d];
        x.position.setFromMatrixPosition(w.matrixWorld), x.position.applyMatrix4(v), d++;
      } else if (w.isHemisphereLight) {
        const x = i.hemi[g];
        x.direction.setFromMatrixPosition(w.matrixWorld), x.direction.transformDirection(v), g++;
      }
    }
  }
  return {
    setup: a,
    setupView: l,
    state: i
  };
}
function FA(s) {
  const e = new zW(s), t = [], i = [];
  function n(u) {
    c.camera = u, t.length = 0, i.length = 0;
  }
  function r(u) {
    t.push(u);
  }
  function o(u) {
    i.push(u);
  }
  function a() {
    e.setup(t);
  }
  function l(u) {
    e.setupView(t, u);
  }
  const c = {
    lightsArray: t,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: n,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: r,
    pushShadow: o
  };
}
function VW(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(n, r = 0) {
    const o = e.get(n);
    let a;
    return o === void 0 ? (a = new FA(s), e.set(n, [a])) : r >= o.length ? (a = new FA(s), o.push(a)) : a = o[r], a;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: i
  };
}
const GW = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, HW = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WW(s, e, t) {
  let i = new hm();
  const n = new Be(), r = new Be(), o = new Kt(), a = new Ru({ depthPacking: Md }), l = new Cd(), c = {}, u = t.maxTextureSize, h = { [Fs]: Yi, [Yi]: Fs, [wi]: wi }, d = new Mi({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Be() },
      radius: { value: 4 }
    },
    vertexShader: GW,
    fragmentShader: HW
  }), f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new Gt();
  m.setAttribute(
    "position",
    new Nt(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const g = new it(m, d), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Hw;
  let _ = this.type;
  this.render = function(A, E, C) {
    if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || A.length === 0) return;
    const P = s.getRenderTarget(), T = s.getActiveCubeFace(), I = s.getActiveMipmapLevel(), D = s.state;
    D.setBlending(Aa), D.buffers.color.setClear(1, 1, 1, 1), D.buffers.depth.setTest(!0), D.setScissorTest(!1);
    const U = _ !== Lo && this.type === Lo, L = _ === Lo && this.type !== Lo;
    for (let k = 0, B = A.length; k < B; k++) {
      const j = A[k], q = j.shadow;
      if (q === void 0) {
        console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
        continue;
      }
      if (q.autoUpdate === !1 && q.needsUpdate === !1) continue;
      n.copy(q.mapSize);
      const Z = q.getFrameExtents();
      if (n.multiply(Z), r.copy(q.mapSize), (n.x > u || n.y > u) && (n.x > u && (r.x = Math.floor(u / Z.x), n.x = r.x * Z.x, q.mapSize.x = r.x), n.y > u && (r.y = Math.floor(u / Z.y), n.y = r.y * Z.y, q.mapSize.y = r.y)), q.map === null || U === !0 || L === !0) {
        const z = this.type !== Lo ? { minFilter: Tn, magFilter: Tn } : {};
        q.map !== null && q.map.dispose(), q.map = new Bs(n.x, n.y, z), q.map.texture.name = j.name + ".shadowMap", q.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(q.map), s.clear();
      const N = q.getViewportCount();
      for (let z = 0; z < N; z++) {
        const J = q.getViewport(z);
        o.set(
          r.x * J.x,
          r.y * J.y,
          r.x * J.z,
          r.y * J.w
        ), D.viewport(o), q.updateMatrices(j, z), i = q.getFrustum(), x(E, C, q.camera, j, this.type);
      }
      q.isPointLightShadow !== !0 && this.type === Lo && y(q, C), q.needsUpdate = !1;
    }
    _ = this.type, v.needsUpdate = !1, s.setRenderTarget(P, T, I);
  };
  function y(A, E) {
    const C = e.update(g);
    d.defines.VSM_SAMPLES !== A.blurSamples && (d.defines.VSM_SAMPLES = A.blurSamples, f.defines.VSM_SAMPLES = A.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), A.mapPass === null && (A.mapPass = new Bs(n.x, n.y)), d.uniforms.shadow_pass.value = A.map.texture, d.uniforms.resolution.value = A.mapSize, d.uniforms.radius.value = A.radius, s.setRenderTarget(A.mapPass), s.clear(), s.renderBufferDirect(E, null, C, d, g, null), f.uniforms.shadow_pass.value = A.mapPass.texture, f.uniforms.resolution.value = A.mapSize, f.uniforms.radius.value = A.radius, s.setRenderTarget(A.map), s.clear(), s.renderBufferDirect(E, null, C, f, g, null);
  }
  function w(A, E, C, P) {
    let T = null;
    const I = C.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
    if (I !== void 0)
      T = I;
    else if (T = C.isPointLight === !0 ? l : a, s.localClippingEnabled && E.clipShadows === !0 && Array.isArray(E.clippingPlanes) && E.clippingPlanes.length !== 0 || E.displacementMap && E.displacementScale !== 0 || E.alphaMap && E.alphaTest > 0 || E.map && E.alphaTest > 0) {
      const D = T.uuid, U = E.uuid;
      let L = c[D];
      L === void 0 && (L = {}, c[D] = L);
      let k = L[U];
      k === void 0 && (k = T.clone(), L[U] = k, E.addEventListener("dispose", M)), T = k;
    }
    if (T.visible = E.visible, T.wireframe = E.wireframe, P === Lo ? T.side = E.shadowSide !== null ? E.shadowSide : E.side : T.side = E.shadowSide !== null ? E.shadowSide : h[E.side], T.alphaMap = E.alphaMap, T.alphaTest = E.alphaTest, T.map = E.map, T.clipShadows = E.clipShadows, T.clippingPlanes = E.clippingPlanes, T.clipIntersection = E.clipIntersection, T.displacementMap = E.displacementMap, T.displacementScale = E.displacementScale, T.displacementBias = E.displacementBias, T.wireframeLinewidth = E.wireframeLinewidth, T.linewidth = E.linewidth, C.isPointLight === !0 && T.isMeshDistanceMaterial === !0) {
      const D = s.properties.get(T);
      D.light = C;
    }
    return T;
  }
  function x(A, E, C, P, T) {
    if (A.visible === !1) return;
    if (A.layers.test(E.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || A.receiveShadow && T === Lo) && (!A.frustumCulled || i.intersectsObject(A))) {
      A.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, A.matrixWorld);
      const U = e.update(A), L = A.material;
      if (Array.isArray(L)) {
        const k = U.groups;
        for (let B = 0, j = k.length; B < j; B++) {
          const q = k[B], Z = L[q.materialIndex];
          if (Z && Z.visible) {
            const N = w(A, Z, P, T);
            A.onBeforeShadow(s, A, E, C, U, N, q), s.renderBufferDirect(C, null, U, N, A, q), A.onAfterShadow(s, A, E, C, U, N, q);
          }
        }
      } else if (L.visible) {
        const k = w(A, L, P, T);
        A.onBeforeShadow(s, A, E, C, U, k, null), s.renderBufferDirect(C, null, U, k, A, null), A.onAfterShadow(s, A, E, C, U, k, null);
      }
    }
    const D = A.children;
    for (let U = 0, L = D.length; U < L; U++)
      x(D[U], E, C, P, T);
  }
  function M(A) {
    A.target.removeEventListener("dispose", M);
    for (const C in c) {
      const P = c[C], T = A.target.uuid;
      T in P && (P[T].dispose(), delete P[T]);
    }
  }
}
const XW = {
  [d0]: f0,
  [p0]: v0,
  [m0]: _0,
  [fu]: g0,
  [f0]: d0,
  [v0]: p0,
  [_0]: m0,
  [g0]: fu
};
function YW(s, e) {
  function t() {
    let le = !1;
    const ve = new Kt();
    let be = null;
    const Xe = new Kt(0, 0, 0, 0);
    return {
      setMask: function(We) {
        be !== We && !le && (s.colorMask(We, We, We, We), be = We);
      },
      setLocked: function(We) {
        le = We;
      },
      setClear: function(We, Ne, ct, gt, nt) {
        nt === !0 && (We *= gt, Ne *= gt, ct *= gt), ve.set(We, Ne, ct, gt), Xe.equals(ve) === !1 && (s.clearColor(We, Ne, ct, gt), Xe.copy(ve));
      },
      reset: function() {
        le = !1, be = null, Xe.set(-1, 0, 0, 0);
      }
    };
  }
  function i() {
    let le = !1, ve = !1, be = null, Xe = null, We = null;
    return {
      setReversed: function(Ne) {
        if (ve !== Ne) {
          const ct = e.get("EXT_clip_control");
          ve ? ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.ZERO_TO_ONE_EXT) : ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.NEGATIVE_ONE_TO_ONE_EXT);
          const gt = We;
          We = null, this.setClear(gt);
        }
        ve = Ne;
      },
      getReversed: function() {
        return ve;
      },
      setTest: function(Ne) {
        Ne ? ce(s.DEPTH_TEST) : _e(s.DEPTH_TEST);
      },
      setMask: function(Ne) {
        be !== Ne && !le && (s.depthMask(Ne), be = Ne);
      },
      setFunc: function(Ne) {
        if (ve && (Ne = XW[Ne]), Xe !== Ne) {
          switch (Ne) {
            case d0:
              s.depthFunc(s.NEVER);
              break;
            case f0:
              s.depthFunc(s.ALWAYS);
              break;
            case p0:
              s.depthFunc(s.LESS);
              break;
            case fu:
              s.depthFunc(s.LEQUAL);
              break;
            case m0:
              s.depthFunc(s.EQUAL);
              break;
            case g0:
              s.depthFunc(s.GEQUAL);
              break;
            case v0:
              s.depthFunc(s.GREATER);
              break;
            case _0:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Xe = Ne;
        }
      },
      setLocked: function(Ne) {
        le = Ne;
      },
      setClear: function(Ne) {
        We !== Ne && (ve && (Ne = 1 - Ne), s.clearDepth(Ne), We = Ne);
      },
      reset: function() {
        le = !1, be = null, Xe = null, We = null, ve = !1;
      }
    };
  }
  function n() {
    let le = !1, ve = null, be = null, Xe = null, We = null, Ne = null, ct = null, gt = null, nt = null;
    return {
      setTest: function(je) {
        le || (je ? ce(s.STENCIL_TEST) : _e(s.STENCIL_TEST));
      },
      setMask: function(je) {
        ve !== je && !le && (s.stencilMask(je), ve = je);
      },
      setFunc: function(je, at, ft) {
        (be !== je || Xe !== at || We !== ft) && (s.stencilFunc(je, at, ft), be = je, Xe = at, We = ft);
      },
      setOp: function(je, at, ft) {
        (Ne !== je || ct !== at || gt !== ft) && (s.stencilOp(je, at, ft), Ne = je, ct = at, gt = ft);
      },
      setLocked: function(je) {
        le = je;
      },
      setClear: function(je) {
        nt !== je && (s.clearStencil(je), nt = je);
      },
      reset: function() {
        le = !1, ve = null, be = null, Xe = null, We = null, Ne = null, ct = null, gt = null, nt = null;
      }
    };
  }
  const r = new t(), o = new i(), a = new n(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
  let u = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), f = [], m = null, g = !1, v = null, _ = null, y = null, w = null, x = null, M = null, A = null, E = new rt(0, 0, 0), C = 0, P = !1, T = null, I = null, D = null, U = null, L = null;
  const k = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let B = !1, j = 0;
  const q = s.getParameter(s.VERSION);
  q.indexOf("WebGL") !== -1 ? (j = parseFloat(/^WebGL (\d)/.exec(q)[1]), B = j >= 1) : q.indexOf("OpenGL ES") !== -1 && (j = parseFloat(/^OpenGL ES (\d)/.exec(q)[1]), B = j >= 2);
  let Z = null, N = {};
  const z = s.getParameter(s.SCISSOR_BOX), J = s.getParameter(s.VIEWPORT), se = new Kt().fromArray(z), K = new Kt().fromArray(J);
  function Q(le, ve, be, Xe) {
    const We = new Uint8Array(4), Ne = s.createTexture();
    s.bindTexture(le, Ne), s.texParameteri(le, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(le, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let ct = 0; ct < be; ct++)
      le === s.TEXTURE_3D || le === s.TEXTURE_2D_ARRAY ? s.texImage3D(ve, 0, s.RGBA, 1, 1, Xe, 0, s.RGBA, s.UNSIGNED_BYTE, We) : s.texImage2D(ve + ct, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, We);
    return Ne;
  }
  const de = {};
  de[s.TEXTURE_2D] = Q(s.TEXTURE_2D, s.TEXTURE_2D, 1), de[s.TEXTURE_CUBE_MAP] = Q(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), de[s.TEXTURE_2D_ARRAY] = Q(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), de[s.TEXTURE_3D] = Q(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), ce(s.DEPTH_TEST), o.setFunc(fu), Me(!1), oe(m1), ce(s.CULL_FACE), $(Aa);
  function ce(le) {
    u[le] !== !0 && (s.enable(le), u[le] = !0);
  }
  function _e(le) {
    u[le] !== !1 && (s.disable(le), u[le] = !1);
  }
  function Fe(le, ve) {
    return h[le] !== ve ? (s.bindFramebuffer(le, ve), h[le] = ve, le === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = ve), le === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = ve), !0) : !1;
  }
  function Ie(le, ve) {
    let be = f, Xe = !1;
    if (le) {
      be = d.get(ve), be === void 0 && (be = [], d.set(ve, be));
      const We = le.textures;
      if (be.length !== We.length || be[0] !== s.COLOR_ATTACHMENT0) {
        for (let Ne = 0, ct = We.length; Ne < ct; Ne++)
          be[Ne] = s.COLOR_ATTACHMENT0 + Ne;
        be.length = We.length, Xe = !0;
      }
    } else
      be[0] !== s.BACK && (be[0] = s.BACK, Xe = !0);
    Xe && s.drawBuffers(be);
  }
  function Ee(le) {
    return m !== le ? (s.useProgram(le), m = le, !0) : !1;
  }
  const me = {
    [hl]: s.FUNC_ADD,
    [sD]: s.FUNC_SUBTRACT,
    [oD]: s.FUNC_REVERSE_SUBTRACT
  };
  me[aD] = s.MIN, me[lD] = s.MAX;
  const xe = {
    [cD]: s.ZERO,
    [uD]: s.ONE,
    [hD]: s.SRC_COLOR,
    [u0]: s.SRC_ALPHA,
    [vD]: s.SRC_ALPHA_SATURATE,
    [mD]: s.DST_COLOR,
    [fD]: s.DST_ALPHA,
    [dD]: s.ONE_MINUS_SRC_COLOR,
    [h0]: s.ONE_MINUS_SRC_ALPHA,
    [gD]: s.ONE_MINUS_DST_COLOR,
    [pD]: s.ONE_MINUS_DST_ALPHA,
    [_D]: s.CONSTANT_COLOR,
    [yD]: s.ONE_MINUS_CONSTANT_COLOR,
    [xD]: s.CONSTANT_ALPHA,
    [bD]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function $(le, ve, be, Xe, We, Ne, ct, gt, nt, je) {
    if (le === Aa) {
      g === !0 && (_e(s.BLEND), g = !1);
      return;
    }
    if (g === !1 && (ce(s.BLEND), g = !0), le !== rD) {
      if (le !== v || je !== P) {
        if ((_ !== hl || x !== hl) && (s.blendEquation(s.FUNC_ADD), _ = hl, x = hl), je)
          switch (le) {
            case Jc:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case kp:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case g1:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case v1:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", le);
              break;
          }
        else
          switch (le) {
            case Jc:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case kp:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case g1:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case v1:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", le);
              break;
          }
        y = null, w = null, M = null, A = null, E.set(0, 0, 0), C = 0, v = le, P = je;
      }
      return;
    }
    We = We || ve, Ne = Ne || be, ct = ct || Xe, (ve !== _ || We !== x) && (s.blendEquationSeparate(me[ve], me[We]), _ = ve, x = We), (be !== y || Xe !== w || Ne !== M || ct !== A) && (s.blendFuncSeparate(xe[be], xe[Xe], xe[Ne], xe[ct]), y = be, w = Xe, M = Ne, A = ct), (gt.equals(E) === !1 || nt !== C) && (s.blendColor(gt.r, gt.g, gt.b, nt), E.copy(gt), C = nt), v = le, P = !1;
  }
  function Ue(le, ve) {
    le.side === wi ? _e(s.CULL_FACE) : ce(s.CULL_FACE);
    let be = le.side === Yi;
    ve && (be = !be), Me(be), le.blending === Jc && le.transparent === !1 ? $(Aa) : $(le.blending, le.blendEquation, le.blendSrc, le.blendDst, le.blendEquationAlpha, le.blendSrcAlpha, le.blendDstAlpha, le.blendColor, le.blendAlpha, le.premultipliedAlpha), o.setFunc(le.depthFunc), o.setTest(le.depthTest), o.setMask(le.depthWrite), r.setMask(le.colorWrite);
    const Xe = le.stencilWrite;
    a.setTest(Xe), Xe && (a.setMask(le.stencilWriteMask), a.setFunc(le.stencilFunc, le.stencilRef, le.stencilFuncMask), a.setOp(le.stencilFail, le.stencilZFail, le.stencilZPass)), Ye(le.polygonOffset, le.polygonOffsetFactor, le.polygonOffsetUnits), le.alphaToCoverage === !0 ? ce(s.SAMPLE_ALPHA_TO_COVERAGE) : _e(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Me(le) {
    T !== le && (le ? s.frontFace(s.CW) : s.frontFace(s.CCW), T = le);
  }
  function oe(le) {
    le !== nD ? (ce(s.CULL_FACE), le !== I && (le === m1 ? s.cullFace(s.BACK) : le === iD ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : _e(s.CULL_FACE), I = le;
  }
  function Te(le) {
    le !== D && (B && s.lineWidth(le), D = le);
  }
  function Ye(le, ve, be) {
    le ? (ce(s.POLYGON_OFFSET_FILL), (U !== ve || L !== be) && (s.polygonOffset(ve, be), U = ve, L = be)) : _e(s.POLYGON_OFFSET_FILL);
  }
  function Oe(le) {
    le ? ce(s.SCISSOR_TEST) : _e(s.SCISSOR_TEST);
  }
  function X(le) {
    le === void 0 && (le = s.TEXTURE0 + k - 1), Z !== le && (s.activeTexture(le), Z = le);
  }
  function Y(le, ve, be) {
    be === void 0 && (Z === null ? be = s.TEXTURE0 + k - 1 : be = Z);
    let Xe = N[be];
    Xe === void 0 && (Xe = { type: void 0, texture: void 0 }, N[be] = Xe), (Xe.type !== le || Xe.texture !== ve) && (Z !== be && (s.activeTexture(be), Z = be), s.bindTexture(le, ve || de[le]), Xe.type = le, Xe.texture = ve);
  }
  function fe() {
    const le = N[Z];
    le !== void 0 && le.type !== void 0 && (s.bindTexture(le.type, null), le.type = void 0, le.texture = void 0);
  }
  function ue() {
    try {
      s.compressedTexImage2D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function te() {
    try {
      s.compressedTexImage3D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Se() {
    try {
      s.texSubImage2D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function ye() {
    try {
      s.texSubImage3D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ae() {
    try {
      s.compressedTexSubImage2D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ce() {
    try {
      s.compressedTexSubImage3D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ge() {
    try {
      s.texStorage2D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function De() {
    try {
      s.texStorage3D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ve() {
    try {
      s.texImage2D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function ze() {
    try {
      s.texImage3D(...arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ze(le) {
    se.equals(le) === !1 && (s.scissor(le.x, le.y, le.z, le.w), se.copy(le));
  }
  function Le(le) {
    K.equals(le) === !1 && (s.viewport(le.x, le.y, le.z, le.w), K.copy(le));
  }
  function ot(le, ve) {
    let be = c.get(ve);
    be === void 0 && (be = /* @__PURE__ */ new WeakMap(), c.set(ve, be));
    let Xe = be.get(le);
    Xe === void 0 && (Xe = s.getUniformBlockIndex(ve, le.name), be.set(le, Xe));
  }
  function tt(le, ve) {
    const Xe = c.get(ve).get(le);
    l.get(ve) !== Xe && (s.uniformBlockBinding(ve, Xe, le.__bindingPointIndex), l.set(ve, Xe));
  }
  function mt() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), o.setReversed(!1), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), u = {}, Z = null, N = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), f = [], m = null, g = !1, v = null, _ = null, y = null, w = null, x = null, M = null, A = null, E = new rt(0, 0, 0), C = 0, P = !1, T = null, I = null, D = null, U = null, L = null, se.set(0, 0, s.canvas.width, s.canvas.height), K.set(0, 0, s.canvas.width, s.canvas.height), r.reset(), o.reset(), a.reset();
  }
  return {
    buffers: {
      color: r,
      depth: o,
      stencil: a
    },
    enable: ce,
    disable: _e,
    bindFramebuffer: Fe,
    drawBuffers: Ie,
    useProgram: Ee,
    setBlending: $,
    setMaterial: Ue,
    setFlipSided: Me,
    setCullFace: oe,
    setLineWidth: Te,
    setPolygonOffset: Ye,
    setScissorTest: Oe,
    activeTexture: X,
    bindTexture: Y,
    unbindTexture: fe,
    compressedTexImage2D: ue,
    compressedTexImage3D: te,
    texImage2D: Ve,
    texImage3D: ze,
    updateUBOMapping: ot,
    uniformBlockBinding: tt,
    texStorage2D: Ge,
    texStorage3D: De,
    texSubImage2D: Se,
    texSubImage3D: ye,
    compressedTexSubImage2D: Ae,
    compressedTexSubImage3D: Ce,
    scissor: Ze,
    viewport: Le,
    reset: mt
  };
}
function jW(s, e, t, i, n, r, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new Be(), u = /* @__PURE__ */ new WeakMap();
  let h;
  const d = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(X, Y) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(X, Y)
    ) : Gp("canvas");
  }
  function g(X, Y, fe) {
    let ue = 1;
    const te = Oe(X);
    if ((te.width > fe || te.height > fe) && (ue = fe / Math.max(te.width, te.height)), ue < 1)
      if (typeof HTMLImageElement < "u" && X instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && X instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && X instanceof ImageBitmap || typeof VideoFrame < "u" && X instanceof VideoFrame) {
        const Se = Math.floor(ue * te.width), ye = Math.floor(ue * te.height);
        h === void 0 && (h = m(Se, ye));
        const Ae = Y ? m(Se, ye) : h;
        return Ae.width = Se, Ae.height = ye, Ae.getContext("2d").drawImage(X, 0, 0, Se, ye), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + te.width + "x" + te.height + ") to (" + Se + "x" + ye + ")."), Ae;
      } else
        return "data" in X && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + te.width + "x" + te.height + ")."), X;
    return X;
  }
  function v(X) {
    return X.generateMipmaps;
  }
  function _(X) {
    s.generateMipmap(X);
  }
  function y(X) {
    return X.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : X.isWebGL3DRenderTarget ? s.TEXTURE_3D : X.isWebGLArrayRenderTarget || X.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
  }
  function w(X, Y, fe, ue, te = !1) {
    if (X !== null) {
      if (s[X] !== void 0) return s[X];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + X + "'");
    }
    let Se = Y;
    if (Y === s.RED && (fe === s.FLOAT && (Se = s.R32F), fe === s.HALF_FLOAT && (Se = s.R16F), fe === s.UNSIGNED_BYTE && (Se = s.R8)), Y === s.RED_INTEGER && (fe === s.UNSIGNED_BYTE && (Se = s.R8UI), fe === s.UNSIGNED_SHORT && (Se = s.R16UI), fe === s.UNSIGNED_INT && (Se = s.R32UI), fe === s.BYTE && (Se = s.R8I), fe === s.SHORT && (Se = s.R16I), fe === s.INT && (Se = s.R32I)), Y === s.RG && (fe === s.FLOAT && (Se = s.RG32F), fe === s.HALF_FLOAT && (Se = s.RG16F), fe === s.UNSIGNED_BYTE && (Se = s.RG8)), Y === s.RG_INTEGER && (fe === s.UNSIGNED_BYTE && (Se = s.RG8UI), fe === s.UNSIGNED_SHORT && (Se = s.RG16UI), fe === s.UNSIGNED_INT && (Se = s.RG32UI), fe === s.BYTE && (Se = s.RG8I), fe === s.SHORT && (Se = s.RG16I), fe === s.INT && (Se = s.RG32I)), Y === s.RGB_INTEGER && (fe === s.UNSIGNED_BYTE && (Se = s.RGB8UI), fe === s.UNSIGNED_SHORT && (Se = s.RGB16UI), fe === s.UNSIGNED_INT && (Se = s.RGB32UI), fe === s.BYTE && (Se = s.RGB8I), fe === s.SHORT && (Se = s.RGB16I), fe === s.INT && (Se = s.RGB32I)), Y === s.RGBA_INTEGER && (fe === s.UNSIGNED_BYTE && (Se = s.RGBA8UI), fe === s.UNSIGNED_SHORT && (Se = s.RGBA16UI), fe === s.UNSIGNED_INT && (Se = s.RGBA32UI), fe === s.BYTE && (Se = s.RGBA8I), fe === s.SHORT && (Se = s.RGBA16I), fe === s.INT && (Se = s.RGBA32I)), Y === s.RGB && fe === s.UNSIGNED_INT_5_9_9_9_REV && (Se = s.RGB9_E5), Y === s.RGBA) {
      const ye = te ? Bp : vn.getTransfer(ue);
      fe === s.FLOAT && (Se = s.RGBA32F), fe === s.HALF_FLOAT && (Se = s.RGBA16F), fe === s.UNSIGNED_BYTE && (Se = ye === Vn ? s.SRGB8_ALPHA8 : s.RGBA8), fe === s.UNSIGNED_SHORT_4_4_4_4 && (Se = s.RGBA4), fe === s.UNSIGNED_SHORT_5_5_5_1 && (Se = s.RGB5_A1);
    }
    return (Se === s.R16F || Se === s.R32F || Se === s.RG16F || Se === s.RG32F || Se === s.RGBA16F || Se === s.RGBA32F) && e.get("EXT_color_buffer_float"), Se;
  }
  function x(X, Y) {
    let fe;
    return X ? Y === null || Y === hs || Y === mu ? fe = s.DEPTH24_STENCIL8 : Y === Un ? fe = s.DEPTH32F_STENCIL8 : Y === pu && (fe = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : Y === null || Y === hs || Y === mu ? fe = s.DEPTH_COMPONENT24 : Y === Un ? fe = s.DEPTH_COMPONENT32F : Y === pu && (fe = s.DEPTH_COMPONENT16), fe;
  }
  function M(X, Y) {
    return v(X) === !0 || X.isFramebufferTexture && X.minFilter !== Tn && X.minFilter !== Sn ? Math.log2(Math.max(Y.width, Y.height)) + 1 : X.mipmaps !== void 0 && X.mipmaps.length > 0 ? X.mipmaps.length : X.isCompressedTexture && Array.isArray(X.image) ? Y.mipmaps.length : 1;
  }
  function A(X) {
    const Y = X.target;
    Y.removeEventListener("dispose", A), C(Y), Y.isVideoTexture && u.delete(Y);
  }
  function E(X) {
    const Y = X.target;
    Y.removeEventListener("dispose", E), T(Y);
  }
  function C(X) {
    const Y = i.get(X);
    if (Y.__webglInit === void 0) return;
    const fe = X.source, ue = d.get(fe);
    if (ue) {
      const te = ue[Y.__cacheKey];
      te.usedTimes--, te.usedTimes === 0 && P(X), Object.keys(ue).length === 0 && d.delete(fe);
    }
    i.remove(X);
  }
  function P(X) {
    const Y = i.get(X);
    s.deleteTexture(Y.__webglTexture);
    const fe = X.source, ue = d.get(fe);
    delete ue[Y.__cacheKey], o.memory.textures--;
  }
  function T(X) {
    const Y = i.get(X);
    if (X.depthTexture && (X.depthTexture.dispose(), i.remove(X.depthTexture)), X.isWebGLCubeRenderTarget)
      for (let ue = 0; ue < 6; ue++) {
        if (Array.isArray(Y.__webglFramebuffer[ue]))
          for (let te = 0; te < Y.__webglFramebuffer[ue].length; te++) s.deleteFramebuffer(Y.__webglFramebuffer[ue][te]);
        else
          s.deleteFramebuffer(Y.__webglFramebuffer[ue]);
        Y.__webglDepthbuffer && s.deleteRenderbuffer(Y.__webglDepthbuffer[ue]);
      }
    else {
      if (Array.isArray(Y.__webglFramebuffer))
        for (let ue = 0; ue < Y.__webglFramebuffer.length; ue++) s.deleteFramebuffer(Y.__webglFramebuffer[ue]);
      else
        s.deleteFramebuffer(Y.__webglFramebuffer);
      if (Y.__webglDepthbuffer && s.deleteRenderbuffer(Y.__webglDepthbuffer), Y.__webglMultisampledFramebuffer && s.deleteFramebuffer(Y.__webglMultisampledFramebuffer), Y.__webglColorRenderbuffer)
        for (let ue = 0; ue < Y.__webglColorRenderbuffer.length; ue++)
          Y.__webglColorRenderbuffer[ue] && s.deleteRenderbuffer(Y.__webglColorRenderbuffer[ue]);
      Y.__webglDepthRenderbuffer && s.deleteRenderbuffer(Y.__webglDepthRenderbuffer);
    }
    const fe = X.textures;
    for (let ue = 0, te = fe.length; ue < te; ue++) {
      const Se = i.get(fe[ue]);
      Se.__webglTexture && (s.deleteTexture(Se.__webglTexture), o.memory.textures--), i.remove(fe[ue]);
    }
    i.remove(X);
  }
  let I = 0;
  function D() {
    I = 0;
  }
  function U() {
    const X = I;
    return X >= n.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + X + " texture units while this GPU supports only " + n.maxTextures), I += 1, X;
  }
  function L(X) {
    const Y = [];
    return Y.push(X.wrapS), Y.push(X.wrapT), Y.push(X.wrapR || 0), Y.push(X.magFilter), Y.push(X.minFilter), Y.push(X.anisotropy), Y.push(X.internalFormat), Y.push(X.format), Y.push(X.type), Y.push(X.generateMipmaps), Y.push(X.premultiplyAlpha), Y.push(X.flipY), Y.push(X.unpackAlignment), Y.push(X.colorSpace), Y.join();
  }
  function k(X, Y) {
    const fe = i.get(X);
    if (X.isVideoTexture && Te(X), X.isRenderTargetTexture === !1 && X.version > 0 && fe.__version !== X.version) {
      const ue = X.image;
      if (ue === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (ue.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        K(fe, X, Y);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, fe.__webglTexture, s.TEXTURE0 + Y);
  }
  function B(X, Y) {
    const fe = i.get(X);
    if (X.version > 0 && fe.__version !== X.version) {
      K(fe, X, Y);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, fe.__webglTexture, s.TEXTURE0 + Y);
  }
  function j(X, Y) {
    const fe = i.get(X);
    if (X.version > 0 && fe.__version !== X.version) {
      K(fe, X, Y);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, fe.__webglTexture, s.TEXTURE0 + Y);
  }
  function q(X, Y) {
    const fe = i.get(X);
    if (X.version > 0 && fe.__version !== X.version) {
      Q(fe, X, Y);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, fe.__webglTexture, s.TEXTURE0 + Y);
  }
  const Z = {
    [Ns]: s.REPEAT,
    [gr]: s.CLAMP_TO_EDGE,
    [cd]: s.MIRRORED_REPEAT
  }, N = {
    [Tn]: s.NEAREST,
    [m_]: s.NEAREST_MIPMAP_NEAREST,
    [Bc]: s.NEAREST_MIPMAP_LINEAR,
    [Sn]: s.LINEAR,
    [qh]: s.LINEAR_MIPMAP_NEAREST,
    [As]: s.LINEAR_MIPMAP_LINEAR
  }, z = {
    [FD]: s.NEVER,
    [HD]: s.ALWAYS,
    [ND]: s.LESS,
    [Jw]: s.LEQUAL,
    [BD]: s.EQUAL,
    [GD]: s.GEQUAL,
    [zD]: s.GREATER,
    [VD]: s.NOTEQUAL
  };
  function J(X, Y) {
    if (Y.type === Un && e.has("OES_texture_float_linear") === !1 && (Y.magFilter === Sn || Y.magFilter === qh || Y.magFilter === Bc || Y.magFilter === As || Y.minFilter === Sn || Y.minFilter === qh || Y.minFilter === Bc || Y.minFilter === As) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(X, s.TEXTURE_WRAP_S, Z[Y.wrapS]), s.texParameteri(X, s.TEXTURE_WRAP_T, Z[Y.wrapT]), (X === s.TEXTURE_3D || X === s.TEXTURE_2D_ARRAY) && s.texParameteri(X, s.TEXTURE_WRAP_R, Z[Y.wrapR]), s.texParameteri(X, s.TEXTURE_MAG_FILTER, N[Y.magFilter]), s.texParameteri(X, s.TEXTURE_MIN_FILTER, N[Y.minFilter]), Y.compareFunction && (s.texParameteri(X, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(X, s.TEXTURE_COMPARE_FUNC, z[Y.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (Y.magFilter === Tn || Y.minFilter !== Bc && Y.minFilter !== As || Y.type === Un && e.has("OES_texture_float_linear") === !1) return;
      if (Y.anisotropy > 1 || i.get(Y).__currentAnisotropy) {
        const fe = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(X, fe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Y.anisotropy, n.getMaxAnisotropy())), i.get(Y).__currentAnisotropy = Y.anisotropy;
      }
    }
  }
  function se(X, Y) {
    let fe = !1;
    X.__webglInit === void 0 && (X.__webglInit = !0, Y.addEventListener("dispose", A));
    const ue = Y.source;
    let te = d.get(ue);
    te === void 0 && (te = {}, d.set(ue, te));
    const Se = L(Y);
    if (Se !== X.__cacheKey) {
      te[Se] === void 0 && (te[Se] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, fe = !0), te[Se].usedTimes++;
      const ye = te[X.__cacheKey];
      ye !== void 0 && (te[X.__cacheKey].usedTimes--, ye.usedTimes === 0 && P(Y)), X.__cacheKey = Se, X.__webglTexture = te[Se].texture;
    }
    return fe;
  }
  function K(X, Y, fe) {
    let ue = s.TEXTURE_2D;
    (Y.isDataArrayTexture || Y.isCompressedArrayTexture) && (ue = s.TEXTURE_2D_ARRAY), Y.isData3DTexture && (ue = s.TEXTURE_3D);
    const te = se(X, Y), Se = Y.source;
    t.bindTexture(ue, X.__webglTexture, s.TEXTURE0 + fe);
    const ye = i.get(Se);
    if (Se.version !== ye.__version || te === !0) {
      t.activeTexture(s.TEXTURE0 + fe);
      const Ae = vn.getPrimaries(vn.workingColorSpace), Ce = Y.colorSpace === Fo ? null : vn.getPrimaries(Y.colorSpace), Ge = Y.colorSpace === Fo || Ae === Ce ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, Y.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, Y.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ge);
      let De = g(Y.image, !1, n.maxTextureSize);
      De = Ye(Y, De);
      const Ve = r.convert(Y.format, Y.colorSpace), ze = r.convert(Y.type);
      let Ze = w(Y.internalFormat, Ve, ze, Y.colorSpace, Y.isVideoTexture);
      J(ue, Y);
      let Le;
      const ot = Y.mipmaps, tt = Y.isVideoTexture !== !0, mt = ye.__version === void 0 || te === !0, le = Se.dataReady, ve = M(Y, De);
      if (Y.isDepthTexture)
        Ze = x(Y.format === gu, Y.type), mt && (tt ? t.texStorage2D(s.TEXTURE_2D, 1, Ze, De.width, De.height) : t.texImage2D(s.TEXTURE_2D, 0, Ze, De.width, De.height, 0, Ve, ze, null));
      else if (Y.isDataTexture)
        if (ot.length > 0) {
          tt && mt && t.texStorage2D(s.TEXTURE_2D, ve, Ze, ot[0].width, ot[0].height);
          for (let be = 0, Xe = ot.length; be < Xe; be++)
            Le = ot[be], tt ? le && t.texSubImage2D(s.TEXTURE_2D, be, 0, 0, Le.width, Le.height, Ve, ze, Le.data) : t.texImage2D(s.TEXTURE_2D, be, Ze, Le.width, Le.height, 0, Ve, ze, Le.data);
          Y.generateMipmaps = !1;
        } else
          tt ? (mt && t.texStorage2D(s.TEXTURE_2D, ve, Ze, De.width, De.height), le && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, De.width, De.height, Ve, ze, De.data)) : t.texImage2D(s.TEXTURE_2D, 0, Ze, De.width, De.height, 0, Ve, ze, De.data);
      else if (Y.isCompressedTexture)
        if (Y.isCompressedArrayTexture) {
          tt && mt && t.texStorage3D(s.TEXTURE_2D_ARRAY, ve, Ze, ot[0].width, ot[0].height, De.depth);
          for (let be = 0, Xe = ot.length; be < Xe; be++)
            if (Le = ot[be], Y.format !== di)
              if (Ve !== null)
                if (tt) {
                  if (le)
                    if (Y.layerUpdates.size > 0) {
                      const We = E1(Le.width, Le.height, Y.format, Y.type);
                      for (const Ne of Y.layerUpdates) {
                        const ct = Le.data.subarray(
                          Ne * We / Le.data.BYTES_PER_ELEMENT,
                          (Ne + 1) * We / Le.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, be, 0, 0, Ne, Le.width, Le.height, 1, Ve, ct);
                      }
                      Y.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, be, 0, 0, 0, Le.width, Le.height, De.depth, Ve, Le.data);
                } else
                  t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, be, Ze, Le.width, Le.height, De.depth, 0, Le.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              tt ? le && t.texSubImage3D(s.TEXTURE_2D_ARRAY, be, 0, 0, 0, Le.width, Le.height, De.depth, Ve, ze, Le.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, be, Ze, Le.width, Le.height, De.depth, 0, Ve, ze, Le.data);
        } else {
          tt && mt && t.texStorage2D(s.TEXTURE_2D, ve, Ze, ot[0].width, ot[0].height);
          for (let be = 0, Xe = ot.length; be < Xe; be++)
            Le = ot[be], Y.format !== di ? Ve !== null ? tt ? le && t.compressedTexSubImage2D(s.TEXTURE_2D, be, 0, 0, Le.width, Le.height, Ve, Le.data) : t.compressedTexImage2D(s.TEXTURE_2D, be, Ze, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : tt ? le && t.texSubImage2D(s.TEXTURE_2D, be, 0, 0, Le.width, Le.height, Ve, ze, Le.data) : t.texImage2D(s.TEXTURE_2D, be, Ze, Le.width, Le.height, 0, Ve, ze, Le.data);
        }
      else if (Y.isDataArrayTexture)
        if (tt) {
          if (mt && t.texStorage3D(s.TEXTURE_2D_ARRAY, ve, Ze, De.width, De.height, De.depth), le)
            if (Y.layerUpdates.size > 0) {
              const be = E1(De.width, De.height, Y.format, Y.type);
              for (const Xe of Y.layerUpdates) {
                const We = De.data.subarray(
                  Xe * be / De.data.BYTES_PER_ELEMENT,
                  (Xe + 1) * be / De.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, Xe, De.width, De.height, 1, Ve, ze, We);
              }
              Y.clearLayerUpdates();
            } else
              t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, De.width, De.height, De.depth, Ve, ze, De.data);
        } else
          t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Ze, De.width, De.height, De.depth, 0, Ve, ze, De.data);
      else if (Y.isData3DTexture)
        tt ? (mt && t.texStorage3D(s.TEXTURE_3D, ve, Ze, De.width, De.height, De.depth), le && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, De.width, De.height, De.depth, Ve, ze, De.data)) : t.texImage3D(s.TEXTURE_3D, 0, Ze, De.width, De.height, De.depth, 0, Ve, ze, De.data);
      else if (Y.isFramebufferTexture) {
        if (mt)
          if (tt)
            t.texStorage2D(s.TEXTURE_2D, ve, Ze, De.width, De.height);
          else {
            let be = De.width, Xe = De.height;
            for (let We = 0; We < ve; We++)
              t.texImage2D(s.TEXTURE_2D, We, Ze, be, Xe, 0, Ve, ze, null), be >>= 1, Xe >>= 1;
          }
      } else if (ot.length > 0) {
        if (tt && mt) {
          const be = Oe(ot[0]);
          t.texStorage2D(s.TEXTURE_2D, ve, Ze, be.width, be.height);
        }
        for (let be = 0, Xe = ot.length; be < Xe; be++)
          Le = ot[be], tt ? le && t.texSubImage2D(s.TEXTURE_2D, be, 0, 0, Ve, ze, Le) : t.texImage2D(s.TEXTURE_2D, be, Ze, Ve, ze, Le);
        Y.generateMipmaps = !1;
      } else if (tt) {
        if (mt) {
          const be = Oe(De);
          t.texStorage2D(s.TEXTURE_2D, ve, Ze, be.width, be.height);
        }
        le && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Ve, ze, De);
      } else
        t.texImage2D(s.TEXTURE_2D, 0, Ze, Ve, ze, De);
      v(Y) && _(ue), ye.__version = Se.version, Y.onUpdate && Y.onUpdate(Y);
    }
    X.__version = Y.version;
  }
  function Q(X, Y, fe) {
    if (Y.image.length !== 6) return;
    const ue = se(X, Y), te = Y.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, X.__webglTexture, s.TEXTURE0 + fe);
    const Se = i.get(te);
    if (te.version !== Se.__version || ue === !0) {
      t.activeTexture(s.TEXTURE0 + fe);
      const ye = vn.getPrimaries(vn.workingColorSpace), Ae = Y.colorSpace === Fo ? null : vn.getPrimaries(Y.colorSpace), Ce = Y.colorSpace === Fo || ye === Ae ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, Y.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, Y.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ce);
      const Ge = Y.isCompressedTexture || Y.image[0].isCompressedTexture, De = Y.image[0] && Y.image[0].isDataTexture, Ve = [];
      for (let Xe = 0; Xe < 6; Xe++)
        !Ge && !De ? Ve[Xe] = g(Y.image[Xe], !0, n.maxCubemapSize) : Ve[Xe] = De ? Y.image[Xe].image : Y.image[Xe], Ve[Xe] = Ye(Y, Ve[Xe]);
      const ze = Ve[0], Ze = r.convert(Y.format, Y.colorSpace), Le = r.convert(Y.type), ot = w(Y.internalFormat, Ze, Le, Y.colorSpace), tt = Y.isVideoTexture !== !0, mt = Se.__version === void 0 || ue === !0, le = te.dataReady;
      let ve = M(Y, ze);
      J(s.TEXTURE_CUBE_MAP, Y);
      let be;
      if (Ge) {
        tt && mt && t.texStorage2D(s.TEXTURE_CUBE_MAP, ve, ot, ze.width, ze.height);
        for (let Xe = 0; Xe < 6; Xe++) {
          be = Ve[Xe].mipmaps;
          for (let We = 0; We < be.length; We++) {
            const Ne = be[We];
            Y.format !== di ? Ze !== null ? tt ? le && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We, 0, 0, Ne.width, Ne.height, Ze, Ne.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We, ot, Ne.width, Ne.height, 0, Ne.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : tt ? le && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We, 0, 0, Ne.width, Ne.height, Ze, Le, Ne.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We, ot, Ne.width, Ne.height, 0, Ze, Le, Ne.data);
          }
        }
      } else {
        if (be = Y.mipmaps, tt && mt) {
          be.length > 0 && ve++;
          const Xe = Oe(Ve[0]);
          t.texStorage2D(s.TEXTURE_CUBE_MAP, ve, ot, Xe.width, Xe.height);
        }
        for (let Xe = 0; Xe < 6; Xe++)
          if (De) {
            tt ? le && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, 0, 0, 0, Ve[Xe].width, Ve[Xe].height, Ze, Le, Ve[Xe].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, 0, ot, Ve[Xe].width, Ve[Xe].height, 0, Ze, Le, Ve[Xe].data);
            for (let We = 0; We < be.length; We++) {
              const ct = be[We].image[Xe].image;
              tt ? le && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We + 1, 0, 0, ct.width, ct.height, Ze, Le, ct.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We + 1, ot, ct.width, ct.height, 0, Ze, Le, ct.data);
            }
          } else {
            tt ? le && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, 0, 0, 0, Ze, Le, Ve[Xe]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, 0, ot, Ze, Le, Ve[Xe]);
            for (let We = 0; We < be.length; We++) {
              const Ne = be[We];
              tt ? le && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We + 1, 0, 0, Ze, Le, Ne.image[Xe]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xe, We + 1, ot, Ze, Le, Ne.image[Xe]);
            }
          }
      }
      v(Y) && _(s.TEXTURE_CUBE_MAP), Se.__version = te.version, Y.onUpdate && Y.onUpdate(Y);
    }
    X.__version = Y.version;
  }
  function de(X, Y, fe, ue, te, Se) {
    const ye = r.convert(fe.format, fe.colorSpace), Ae = r.convert(fe.type), Ce = w(fe.internalFormat, ye, Ae, fe.colorSpace), Ge = i.get(Y), De = i.get(fe);
    if (De.__renderTarget = Y, !Ge.__hasExternalTextures) {
      const Ve = Math.max(1, Y.width >> Se), ze = Math.max(1, Y.height >> Se);
      te === s.TEXTURE_3D || te === s.TEXTURE_2D_ARRAY ? t.texImage3D(te, Se, Ce, Ve, ze, Y.depth, 0, ye, Ae, null) : t.texImage2D(te, Se, Ce, Ve, ze, 0, ye, Ae, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, X), oe(Y) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, ue, te, De.__webglTexture, 0, Me(Y)) : (te === s.TEXTURE_2D || te >= s.TEXTURE_CUBE_MAP_POSITIVE_X && te <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, ue, te, De.__webglTexture, Se), t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function ce(X, Y, fe) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, X), Y.depthBuffer) {
      const ue = Y.depthTexture, te = ue && ue.isDepthTexture ? ue.type : null, Se = x(Y.stencilBuffer, te), ye = Y.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Ae = Me(Y);
      oe(Y) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Ae, Se, Y.width, Y.height) : fe ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Ae, Se, Y.width, Y.height) : s.renderbufferStorage(s.RENDERBUFFER, Se, Y.width, Y.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, ye, s.RENDERBUFFER, X);
    } else {
      const ue = Y.textures;
      for (let te = 0; te < ue.length; te++) {
        const Se = ue[te], ye = r.convert(Se.format, Se.colorSpace), Ae = r.convert(Se.type), Ce = w(Se.internalFormat, ye, Ae, Se.colorSpace), Ge = Me(Y);
        fe && oe(Y) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Ge, Ce, Y.width, Y.height) : oe(Y) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Ge, Ce, Y.width, Y.height) : s.renderbufferStorage(s.RENDERBUFFER, Ce, Y.width, Y.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function _e(X, Y) {
    if (Y && Y.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(s.FRAMEBUFFER, X), !(Y.depthTexture && Y.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const ue = i.get(Y.depthTexture);
    ue.__renderTarget = Y, (!ue.__webglTexture || Y.depthTexture.image.width !== Y.width || Y.depthTexture.image.height !== Y.height) && (Y.depthTexture.image.width = Y.width, Y.depthTexture.image.height = Y.height, Y.depthTexture.needsUpdate = !0), k(Y.depthTexture, 0);
    const te = ue.__webglTexture, Se = Me(Y);
    if (Y.depthTexture.format === eu)
      oe(Y) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, te, 0, Se) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, te, 0);
    else if (Y.depthTexture.format === gu)
      oe(Y) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, te, 0, Se) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, te, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Fe(X) {
    const Y = i.get(X), fe = X.isWebGLCubeRenderTarget === !0;
    if (Y.__boundDepthTexture !== X.depthTexture) {
      const ue = X.depthTexture;
      if (Y.__depthDisposeCallback && Y.__depthDisposeCallback(), ue) {
        const te = () => {
          delete Y.__boundDepthTexture, delete Y.__depthDisposeCallback, ue.removeEventListener("dispose", te);
        };
        ue.addEventListener("dispose", te), Y.__depthDisposeCallback = te;
      }
      Y.__boundDepthTexture = ue;
    }
    if (X.depthTexture && !Y.__autoAllocateDepthBuffer) {
      if (fe) throw new Error("target.depthTexture not supported in Cube render targets");
      _e(Y.__webglFramebuffer, X);
    } else if (fe) {
      Y.__webglDepthbuffer = [];
      for (let ue = 0; ue < 6; ue++)
        if (t.bindFramebuffer(s.FRAMEBUFFER, Y.__webglFramebuffer[ue]), Y.__webglDepthbuffer[ue] === void 0)
          Y.__webglDepthbuffer[ue] = s.createRenderbuffer(), ce(Y.__webglDepthbuffer[ue], X, !1);
        else {
          const te = X.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Se = Y.__webglDepthbuffer[ue];
          s.bindRenderbuffer(s.RENDERBUFFER, Se), s.framebufferRenderbuffer(s.FRAMEBUFFER, te, s.RENDERBUFFER, Se);
        }
    } else if (t.bindFramebuffer(s.FRAMEBUFFER, Y.__webglFramebuffer), Y.__webglDepthbuffer === void 0)
      Y.__webglDepthbuffer = s.createRenderbuffer(), ce(Y.__webglDepthbuffer, X, !1);
    else {
      const ue = X.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, te = Y.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, te), s.framebufferRenderbuffer(s.FRAMEBUFFER, ue, s.RENDERBUFFER, te);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function Ie(X, Y, fe) {
    const ue = i.get(X);
    Y !== void 0 && de(ue.__webglFramebuffer, X, X.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), fe !== void 0 && Fe(X);
  }
  function Ee(X) {
    const Y = X.texture, fe = i.get(X), ue = i.get(Y);
    X.addEventListener("dispose", E);
    const te = X.textures, Se = X.isWebGLCubeRenderTarget === !0, ye = te.length > 1;
    if (ye || (ue.__webglTexture === void 0 && (ue.__webglTexture = s.createTexture()), ue.__version = Y.version, o.memory.textures++), Se) {
      fe.__webglFramebuffer = [];
      for (let Ae = 0; Ae < 6; Ae++)
        if (Y.mipmaps && Y.mipmaps.length > 0) {
          fe.__webglFramebuffer[Ae] = [];
          for (let Ce = 0; Ce < Y.mipmaps.length; Ce++)
            fe.__webglFramebuffer[Ae][Ce] = s.createFramebuffer();
        } else
          fe.__webglFramebuffer[Ae] = s.createFramebuffer();
    } else {
      if (Y.mipmaps && Y.mipmaps.length > 0) {
        fe.__webglFramebuffer = [];
        for (let Ae = 0; Ae < Y.mipmaps.length; Ae++)
          fe.__webglFramebuffer[Ae] = s.createFramebuffer();
      } else
        fe.__webglFramebuffer = s.createFramebuffer();
      if (ye)
        for (let Ae = 0, Ce = te.length; Ae < Ce; Ae++) {
          const Ge = i.get(te[Ae]);
          Ge.__webglTexture === void 0 && (Ge.__webglTexture = s.createTexture(), o.memory.textures++);
        }
      if (X.samples > 0 && oe(X) === !1) {
        fe.__webglMultisampledFramebuffer = s.createFramebuffer(), fe.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, fe.__webglMultisampledFramebuffer);
        for (let Ae = 0; Ae < te.length; Ae++) {
          const Ce = te[Ae];
          fe.__webglColorRenderbuffer[Ae] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, fe.__webglColorRenderbuffer[Ae]);
          const Ge = r.convert(Ce.format, Ce.colorSpace), De = r.convert(Ce.type), Ve = w(Ce.internalFormat, Ge, De, Ce.colorSpace, X.isXRRenderTarget === !0), ze = Me(X);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, ze, Ve, X.width, X.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, fe.__webglColorRenderbuffer[Ae]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), X.depthBuffer && (fe.__webglDepthRenderbuffer = s.createRenderbuffer(), ce(fe.__webglDepthRenderbuffer, X, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (Se) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, ue.__webglTexture), J(s.TEXTURE_CUBE_MAP, Y);
      for (let Ae = 0; Ae < 6; Ae++)
        if (Y.mipmaps && Y.mipmaps.length > 0)
          for (let Ce = 0; Ce < Y.mipmaps.length; Ce++)
            de(fe.__webglFramebuffer[Ae][Ce], X, Y, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Ae, Ce);
        else
          de(fe.__webglFramebuffer[Ae], X, Y, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Ae, 0);
      v(Y) && _(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (ye) {
      for (let Ae = 0, Ce = te.length; Ae < Ce; Ae++) {
        const Ge = te[Ae], De = i.get(Ge);
        t.bindTexture(s.TEXTURE_2D, De.__webglTexture), J(s.TEXTURE_2D, Ge), de(fe.__webglFramebuffer, X, Ge, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, 0), v(Ge) && _(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Ae = s.TEXTURE_2D;
      if ((X.isWebGL3DRenderTarget || X.isWebGLArrayRenderTarget) && (Ae = X.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), t.bindTexture(Ae, ue.__webglTexture), J(Ae, Y), Y.mipmaps && Y.mipmaps.length > 0)
        for (let Ce = 0; Ce < Y.mipmaps.length; Ce++)
          de(fe.__webglFramebuffer[Ce], X, Y, s.COLOR_ATTACHMENT0, Ae, Ce);
      else
        de(fe.__webglFramebuffer, X, Y, s.COLOR_ATTACHMENT0, Ae, 0);
      v(Y) && _(Ae), t.unbindTexture();
    }
    X.depthBuffer && Fe(X);
  }
  function me(X) {
    const Y = X.textures;
    for (let fe = 0, ue = Y.length; fe < ue; fe++) {
      const te = Y[fe];
      if (v(te)) {
        const Se = y(X), ye = i.get(te).__webglTexture;
        t.bindTexture(Se, ye), _(Se), t.unbindTexture();
      }
    }
  }
  const xe = [], $ = [];
  function Ue(X) {
    if (X.samples > 0) {
      if (oe(X) === !1) {
        const Y = X.textures, fe = X.width, ue = X.height;
        let te = s.COLOR_BUFFER_BIT;
        const Se = X.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, ye = i.get(X), Ae = Y.length > 1;
        if (Ae)
          for (let Ce = 0; Ce < Y.length; Ce++)
            t.bindFramebuffer(s.FRAMEBUFFER, ye.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ce, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, ye.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ce, s.TEXTURE_2D, null, 0);
        t.bindFramebuffer(s.READ_FRAMEBUFFER, ye.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, ye.__webglFramebuffer);
        for (let Ce = 0; Ce < Y.length; Ce++) {
          if (X.resolveDepthBuffer && (X.depthBuffer && (te |= s.DEPTH_BUFFER_BIT), X.stencilBuffer && X.resolveStencilBuffer && (te |= s.STENCIL_BUFFER_BIT)), Ae) {
            s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, ye.__webglColorRenderbuffer[Ce]);
            const Ge = i.get(Y[Ce]).__webglTexture;
            s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Ge, 0);
          }
          s.blitFramebuffer(0, 0, fe, ue, 0, 0, fe, ue, te, s.NEAREST), l === !0 && (xe.length = 0, $.length = 0, xe.push(s.COLOR_ATTACHMENT0 + Ce), X.depthBuffer && X.resolveDepthBuffer === !1 && (xe.push(Se), $.push(Se), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, $)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, xe));
        }
        if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Ae)
          for (let Ce = 0; Ce < Y.length; Ce++) {
            t.bindFramebuffer(s.FRAMEBUFFER, ye.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ce, s.RENDERBUFFER, ye.__webglColorRenderbuffer[Ce]);
            const Ge = i.get(Y[Ce]).__webglTexture;
            t.bindFramebuffer(s.FRAMEBUFFER, ye.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ce, s.TEXTURE_2D, Ge, 0);
          }
        t.bindFramebuffer(s.DRAW_FRAMEBUFFER, ye.__webglMultisampledFramebuffer);
      } else if (X.depthBuffer && X.resolveDepthBuffer === !1 && l) {
        const Y = X.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [Y]);
      }
    }
  }
  function Me(X) {
    return Math.min(n.maxSamples, X.samples);
  }
  function oe(X) {
    const Y = i.get(X);
    return X.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && Y.__useRenderToTexture !== !1;
  }
  function Te(X) {
    const Y = o.render.frame;
    u.get(X) !== Y && (u.set(X, Y), X.update());
  }
  function Ye(X, Y) {
    const fe = X.colorSpace, ue = X.format, te = X.type;
    return X.isCompressedTexture === !0 || X.isVideoTexture === !0 || fe !== Pi && fe !== Fo && (vn.getTransfer(fe) === Vn ? (ue !== di || te !== ro) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", fe)), Y;
  }
  function Oe(X) {
    return typeof HTMLImageElement < "u" && X instanceof HTMLImageElement ? (c.width = X.naturalWidth || X.width, c.height = X.naturalHeight || X.height) : typeof VideoFrame < "u" && X instanceof VideoFrame ? (c.width = X.displayWidth, c.height = X.displayHeight) : (c.width = X.width, c.height = X.height), c;
  }
  this.allocateTextureUnit = U, this.resetTextureUnits = D, this.setTexture2D = k, this.setTexture2DArray = B, this.setTexture3D = j, this.setTextureCube = q, this.rebindTextures = Ie, this.setupRenderTarget = Ee, this.updateRenderTargetMipmap = me, this.updateMultisampleRenderTarget = Ue, this.setupDepthRenderbuffer = Fe, this.setupFrameBufferTexture = de, this.useMultisampledRTT = oe;
}
function VI(s, e) {
  function t(i, n = Fo) {
    let r;
    const o = vn.getTransfer(n);
    if (i === ro) return s.UNSIGNED_BYTE;
    if (i === v_) return s.UNSIGNED_SHORT_4_4_4_4;
    if (i === __) return s.UNSIGNED_SHORT_5_5_5_1;
    if (i === Ww) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (i === Fp) return s.BYTE;
    if (i === g_) return s.SHORT;
    if (i === pu) return s.UNSIGNED_SHORT;
    if (i === Qc) return s.INT;
    if (i === hs) return s.UNSIGNED_INT;
    if (i === Un) return s.FLOAT;
    if (i === vr) return s.HALF_FLOAT;
    if (i === Xw) return s.ALPHA;
    if (i === Yw) return s.RGB;
    if (i === di) return s.RGBA;
    if (i === jw) return s.LUMINANCE;
    if (i === qw) return s.LUMINANCE_ALPHA;
    if (i === eu) return s.DEPTH_COMPONENT;
    if (i === gu) return s.DEPTH_STENCIL;
    if (i === bd) return s.RED;
    if (i === wd) return s.RED_INTEGER;
    if (i === y_) return s.RG;
    if (i === Sd) return s.RG_INTEGER;
    if (i === vu) return s.RGBA_INTEGER;
    if (i === sp || i === op || i === ap || i === lp)
      if (o === Vn)
        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
          if (i === sp) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === op) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === ap) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === lp) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
        if (i === sp) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === op) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === ap) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === lp) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (i === x0 || i === b0 || i === w0 || i === S0)
      if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
        if (i === x0) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === b0) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === w0) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === S0) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (i === M0 || i === E0 || i === T0)
      if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
        if (i === M0 || i === E0) return o === Vn ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (i === T0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (i === A0 || i === C0 || i === P0 || i === R0 || i === D0 || i === I0 || i === L0 || i === U0 || i === k0 || i === O0 || i === F0 || i === N0 || i === B0 || i === z0)
      if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
        if (i === A0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === C0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === P0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === R0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === D0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === I0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === L0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === U0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === k0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === O0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === F0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === N0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === B0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === z0) return o === Vn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (i === cp || i === V0 || i === G0)
      if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
        if (i === cp) return o === Vn ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === V0) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === G0) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (i === Zw || i === H0 || i === W0 || i === X0)
      if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
        if (i === cp) return r.COMPRESSED_RED_RGTC1_EXT;
        if (i === H0) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === W0) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === X0) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return i === mu ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
  }
  return { convert: t };
}
const qW = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, ZW = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class KW {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, i) {
    if (this.texture === null) {
      const n = new ei(), r = e.properties.get(n);
      r.__webglTexture = t.texture, (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = n;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, i = new Mi({
        vertexShader: qW,
        fragmentShader: ZW,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: t.z },
          depthHeight: { value: t.w }
        }
      });
      this.mesh = new it(new $r(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class $W extends Qo {
  constructor(e, t) {
    super();
    const i = this;
    let n = null, r = 1, o = null, a = "local-floor", l = 1, c = null, u = null, h = null, d = null, f = null, m = null;
    const g = new KW(), v = t.getContextAttributes();
    let _ = null, y = null;
    const w = [], x = [], M = new Be();
    let A = null;
    const E = new Fi();
    E.viewport = new Kt();
    const C = new Fi();
    C.viewport = new Kt();
    const P = [E, C], T = new PI();
    let I = null, D = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(K) {
      let Q = w[K];
      return Q === void 0 && (Q = new Fv(), w[K] = Q), Q.getTargetRaySpace();
    }, this.getControllerGrip = function(K) {
      let Q = w[K];
      return Q === void 0 && (Q = new Fv(), w[K] = Q), Q.getGripSpace();
    }, this.getHand = function(K) {
      let Q = w[K];
      return Q === void 0 && (Q = new Fv(), w[K] = Q), Q.getHandSpace();
    };
    function U(K) {
      const Q = x.indexOf(K.inputSource);
      if (Q === -1)
        return;
      const de = w[Q];
      de !== void 0 && (de.update(K.inputSource, K.frame, c || o), de.dispatchEvent({ type: K.type, data: K.inputSource }));
    }
    function L() {
      n.removeEventListener("select", U), n.removeEventListener("selectstart", U), n.removeEventListener("selectend", U), n.removeEventListener("squeeze", U), n.removeEventListener("squeezestart", U), n.removeEventListener("squeezeend", U), n.removeEventListener("end", L), n.removeEventListener("inputsourceschange", k);
      for (let K = 0; K < w.length; K++) {
        const Q = x[K];
        Q !== null && (x[K] = null, w[K].disconnect(Q));
      }
      I = null, D = null, g.reset(), e.setRenderTarget(_), f = null, d = null, h = null, n = null, y = null, se.stop(), i.isPresenting = !1, e.setPixelRatio(A), e.setSize(M.width, M.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(K) {
      r = K, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(K) {
      a = K, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || o;
    }, this.setReferenceSpace = function(K) {
      c = K;
    }, this.getBaseLayer = function() {
      return d !== null ? d : f;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return n;
    }, this.setSession = async function(K) {
      if (n = K, n !== null) {
        if (_ = e.getRenderTarget(), n.addEventListener("select", U), n.addEventListener("selectstart", U), n.addEventListener("selectend", U), n.addEventListener("squeeze", U), n.addEventListener("squeezestart", U), n.addEventListener("squeezeend", U), n.addEventListener("end", L), n.addEventListener("inputsourceschange", k), v.xrCompatible !== !0 && await t.makeXRCompatible(), A = e.getPixelRatio(), e.getSize(M), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
          let de = null, ce = null, _e = null;
          v.depth && (_e = v.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, de = v.stencil ? gu : eu, ce = v.stencil ? mu : hs);
          const Fe = {
            colorFormat: t.RGBA8,
            depthFormat: _e,
            scaleFactor: r
          };
          h = new XRWebGLBinding(n, t), d = h.createProjectionLayer(Fe), n.updateRenderState({ layers: [d] }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), y = new Bs(
            d.textureWidth,
            d.textureHeight,
            {
              format: di,
              type: ro,
              depthTexture: new rS(d.textureWidth, d.textureHeight, ce, void 0, void 0, void 0, void 0, void 0, void 0, de),
              stencilBuffer: v.stencil,
              colorSpace: e.outputColorSpace,
              samples: v.antialias ? 4 : 0,
              resolveDepthBuffer: d.ignoreDepthValues === !1,
              resolveStencilBuffer: d.ignoreDepthValues === !1
            }
          );
        } else {
          const de = {
            antialias: v.antialias,
            alpha: !0,
            depth: v.depth,
            stencil: v.stencil,
            framebufferScaleFactor: r
          };
          f = new XRWebGLLayer(n, t, de), n.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), y = new Bs(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: di,
              type: ro,
              colorSpace: e.outputColorSpace,
              stencilBuffer: v.stencil,
              resolveDepthBuffer: f.ignoreDepthValues === !1,
              resolveStencilBuffer: f.ignoreDepthValues === !1
            }
          );
        }
        y.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await n.requestReferenceSpace(a), se.setContext(n), se.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (n !== null)
        return n.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return g.getDepthTexture();
    };
    function k(K) {
      for (let Q = 0; Q < K.removed.length; Q++) {
        const de = K.removed[Q], ce = x.indexOf(de);
        ce >= 0 && (x[ce] = null, w[ce].disconnect(de));
      }
      for (let Q = 0; Q < K.added.length; Q++) {
        const de = K.added[Q];
        let ce = x.indexOf(de);
        if (ce === -1) {
          for (let Fe = 0; Fe < w.length; Fe++)
            if (Fe >= x.length) {
              x.push(de), ce = Fe;
              break;
            } else if (x[Fe] === null) {
              x[Fe] = de, ce = Fe;
              break;
            }
          if (ce === -1) break;
        }
        const _e = w[ce];
        _e && _e.connect(de);
      }
    }
    const B = new H(), j = new H();
    function q(K, Q, de) {
      B.setFromMatrixPosition(Q.matrixWorld), j.setFromMatrixPosition(de.matrixWorld);
      const ce = B.distanceTo(j), _e = Q.projectionMatrix.elements, Fe = de.projectionMatrix.elements, Ie = _e[14] / (_e[10] - 1), Ee = _e[14] / (_e[10] + 1), me = (_e[9] + 1) / _e[5], xe = (_e[9] - 1) / _e[5], $ = (_e[8] - 1) / _e[0], Ue = (Fe[8] + 1) / Fe[0], Me = Ie * $, oe = Ie * Ue, Te = ce / (-$ + Ue), Ye = Te * -$;
      if (Q.matrixWorld.decompose(K.position, K.quaternion, K.scale), K.translateX(Ye), K.translateZ(Te), K.matrixWorld.compose(K.position, K.quaternion, K.scale), K.matrixWorldInverse.copy(K.matrixWorld).invert(), _e[10] === -1)
        K.projectionMatrix.copy(Q.projectionMatrix), K.projectionMatrixInverse.copy(Q.projectionMatrixInverse);
      else {
        const Oe = Ie + Te, X = Ee + Te, Y = Me - Ye, fe = oe + (ce - Ye), ue = me * Ee / X * Oe, te = xe * Ee / X * Oe;
        K.projectionMatrix.makePerspective(Y, fe, ue, te, Oe, X), K.projectionMatrixInverse.copy(K.projectionMatrix).invert();
      }
    }
    function Z(K, Q) {
      Q === null ? K.matrixWorld.copy(K.matrix) : K.matrixWorld.multiplyMatrices(Q.matrixWorld, K.matrix), K.matrixWorldInverse.copy(K.matrixWorld).invert();
    }
    this.updateCamera = function(K) {
      if (n === null) return;
      let Q = K.near, de = K.far;
      g.texture !== null && (g.depthNear > 0 && (Q = g.depthNear), g.depthFar > 0 && (de = g.depthFar)), T.near = C.near = E.near = Q, T.far = C.far = E.far = de, (I !== T.near || D !== T.far) && (n.updateRenderState({
        depthNear: T.near,
        depthFar: T.far
      }), I = T.near, D = T.far), E.layers.mask = K.layers.mask | 2, C.layers.mask = K.layers.mask | 4, T.layers.mask = E.layers.mask | C.layers.mask;
      const ce = K.parent, _e = T.cameras;
      Z(T, ce);
      for (let Fe = 0; Fe < _e.length; Fe++)
        Z(_e[Fe], ce);
      _e.length === 2 ? q(T, E, C) : T.projectionMatrix.copy(E.projectionMatrix), N(K, T, ce);
    };
    function N(K, Q, de) {
      de === null ? K.matrix.copy(Q.matrixWorld) : (K.matrix.copy(de.matrixWorld), K.matrix.invert(), K.matrix.multiply(Q.matrixWorld)), K.matrix.decompose(K.position, K.quaternion, K.scale), K.updateMatrixWorld(!0), K.projectionMatrix.copy(Q.projectionMatrix), K.projectionMatrixInverse.copy(Q.projectionMatrixInverse), K.isPerspectiveCamera && (K.fov = dd * 2 * Math.atan(1 / K.projectionMatrix.elements[5]), K.zoom = 1);
    }
    this.getCamera = function() {
      return T;
    }, this.getFoveation = function() {
      if (!(d === null && f === null))
        return l;
    }, this.setFoveation = function(K) {
      l = K, d !== null && (d.fixedFoveation = K), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = K);
    }, this.hasDepthSensing = function() {
      return g.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return g.getMesh(T);
    };
    let z = null;
    function J(K, Q) {
      if (u = Q.getViewerPose(c || o), m = Q, u !== null) {
        const de = u.views;
        f !== null && (e.setRenderTargetFramebuffer(y, f.framebuffer), e.setRenderTarget(y));
        let ce = !1;
        de.length !== T.cameras.length && (T.cameras.length = 0, ce = !0);
        for (let Ie = 0; Ie < de.length; Ie++) {
          const Ee = de[Ie];
          let me = null;
          if (f !== null)
            me = f.getViewport(Ee);
          else {
            const $ = h.getViewSubImage(d, Ee);
            me = $.viewport, Ie === 0 && (e.setRenderTargetTextures(
              y,
              $.colorTexture,
              d.ignoreDepthValues ? void 0 : $.depthStencilTexture
            ), e.setRenderTarget(y));
          }
          let xe = P[Ie];
          xe === void 0 && (xe = new Fi(), xe.layers.enable(Ie), xe.viewport = new Kt(), P[Ie] = xe), xe.matrix.fromArray(Ee.transform.matrix), xe.matrix.decompose(xe.position, xe.quaternion, xe.scale), xe.projectionMatrix.fromArray(Ee.projectionMatrix), xe.projectionMatrixInverse.copy(xe.projectionMatrix).invert(), xe.viewport.set(me.x, me.y, me.width, me.height), Ie === 0 && (T.matrix.copy(xe.matrix), T.matrix.decompose(T.position, T.quaternion, T.scale)), ce === !0 && T.cameras.push(xe);
        }
        const _e = n.enabledFeatures;
        if (_e && _e.includes("depth-sensing") && n.depthUsage == "gpu-optimized" && h) {
          const Ie = h.getDepthInformation(de[0]);
          Ie && Ie.isValid && Ie.texture && g.init(e, Ie, n.renderState);
        }
      }
      for (let de = 0; de < w.length; de++) {
        const ce = x[de], _e = w[de];
        ce !== null && _e !== void 0 && _e.update(ce, Q, c || o);
      }
      z && z(K, Q), Q.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: Q }), m = null;
    }
    const se = new OI();
    se.setAnimationLoop(J), this.setAnimationLoop = function(K) {
      z = K;
    }, this.dispose = function() {
    };
  }
}
const fc = /* @__PURE__ */ new fs(), JW = /* @__PURE__ */ new _t();
function QW(s, e) {
  function t(v, _) {
    v.matrixAutoUpdate === !0 && v.updateMatrix(), _.value.copy(v.matrix);
  }
  function i(v, _) {
    _.color.getRGB(v.fogColor.value, qD(s)), _.isFog ? (v.fogNear.value = _.near, v.fogFar.value = _.far) : _.isFogExp2 && (v.fogDensity.value = _.density);
  }
  function n(v, _, y, w, x) {
    _.isMeshBasicMaterial || _.isMeshLambertMaterial ? r(v, _) : _.isMeshToonMaterial ? (r(v, _), h(v, _)) : _.isMeshPhongMaterial ? (r(v, _), u(v, _)) : _.isMeshStandardMaterial ? (r(v, _), d(v, _), _.isMeshPhysicalMaterial && f(v, _, x)) : _.isMeshMatcapMaterial ? (r(v, _), m(v, _)) : _.isMeshDepthMaterial ? r(v, _) : _.isMeshDistanceMaterial ? (r(v, _), g(v, _)) : _.isMeshNormalMaterial ? r(v, _) : _.isLineBasicMaterial ? (o(v, _), _.isLineDashedMaterial && a(v, _)) : _.isPointsMaterial ? l(v, _, y, w) : _.isSpriteMaterial ? c(v, _) : _.isShadowMaterial ? (v.color.value.copy(_.color), v.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = !1);
  }
  function r(v, _) {
    v.opacity.value = _.opacity, _.color && v.diffuse.value.copy(_.color), _.emissive && v.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity), _.map && (v.map.value = _.map, t(_.map, v.mapTransform)), _.alphaMap && (v.alphaMap.value = _.alphaMap, t(_.alphaMap, v.alphaMapTransform)), _.bumpMap && (v.bumpMap.value = _.bumpMap, t(_.bumpMap, v.bumpMapTransform), v.bumpScale.value = _.bumpScale, _.side === Yi && (v.bumpScale.value *= -1)), _.normalMap && (v.normalMap.value = _.normalMap, t(_.normalMap, v.normalMapTransform), v.normalScale.value.copy(_.normalScale), _.side === Yi && v.normalScale.value.negate()), _.displacementMap && (v.displacementMap.value = _.displacementMap, t(_.displacementMap, v.displacementMapTransform), v.displacementScale.value = _.displacementScale, v.displacementBias.value = _.displacementBias), _.emissiveMap && (v.emissiveMap.value = _.emissiveMap, t(_.emissiveMap, v.emissiveMapTransform)), _.specularMap && (v.specularMap.value = _.specularMap, t(_.specularMap, v.specularMapTransform)), _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
    const y = e.get(_), w = y.envMap, x = y.envMapRotation;
    w && (v.envMap.value = w, fc.copy(x), fc.x *= -1, fc.y *= -1, fc.z *= -1, w.isCubeTexture && w.isRenderTargetTexture === !1 && (fc.y *= -1, fc.z *= -1), v.envMapRotation.value.setFromMatrix4(JW.makeRotationFromEuler(fc)), v.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = _.reflectivity, v.ior.value = _.ior, v.refractionRatio.value = _.refractionRatio), _.lightMap && (v.lightMap.value = _.lightMap, v.lightMapIntensity.value = _.lightMapIntensity, t(_.lightMap, v.lightMapTransform)), _.aoMap && (v.aoMap.value = _.aoMap, v.aoMapIntensity.value = _.aoMapIntensity, t(_.aoMap, v.aoMapTransform));
  }
  function o(v, _) {
    v.diffuse.value.copy(_.color), v.opacity.value = _.opacity, _.map && (v.map.value = _.map, t(_.map, v.mapTransform));
  }
  function a(v, _) {
    v.dashSize.value = _.dashSize, v.totalSize.value = _.dashSize + _.gapSize, v.scale.value = _.scale;
  }
  function l(v, _, y, w) {
    v.diffuse.value.copy(_.color), v.opacity.value = _.opacity, v.size.value = _.size * y, v.scale.value = w * 0.5, _.map && (v.map.value = _.map, t(_.map, v.uvTransform)), _.alphaMap && (v.alphaMap.value = _.alphaMap, t(_.alphaMap, v.alphaMapTransform)), _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
  }
  function c(v, _) {
    v.diffuse.value.copy(_.color), v.opacity.value = _.opacity, v.rotation.value = _.rotation, _.map && (v.map.value = _.map, t(_.map, v.mapTransform)), _.alphaMap && (v.alphaMap.value = _.alphaMap, t(_.alphaMap, v.alphaMapTransform)), _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
  }
  function u(v, _) {
    v.specular.value.copy(_.specular), v.shininess.value = Math.max(_.shininess, 1e-4);
  }
  function h(v, _) {
    _.gradientMap && (v.gradientMap.value = _.gradientMap);
  }
  function d(v, _) {
    v.metalness.value = _.metalness, _.metalnessMap && (v.metalnessMap.value = _.metalnessMap, t(_.metalnessMap, v.metalnessMapTransform)), v.roughness.value = _.roughness, _.roughnessMap && (v.roughnessMap.value = _.roughnessMap, t(_.roughnessMap, v.roughnessMapTransform)), _.envMap && (v.envMapIntensity.value = _.envMapIntensity);
  }
  function f(v, _, y) {
    v.ior.value = _.ior, _.sheen > 0 && (v.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen), v.sheenRoughness.value = _.sheenRoughness, _.sheenColorMap && (v.sheenColorMap.value = _.sheenColorMap, t(_.sheenColorMap, v.sheenColorMapTransform)), _.sheenRoughnessMap && (v.sheenRoughnessMap.value = _.sheenRoughnessMap, t(_.sheenRoughnessMap, v.sheenRoughnessMapTransform))), _.clearcoat > 0 && (v.clearcoat.value = _.clearcoat, v.clearcoatRoughness.value = _.clearcoatRoughness, _.clearcoatMap && (v.clearcoatMap.value = _.clearcoatMap, t(_.clearcoatMap, v.clearcoatMapTransform)), _.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap, t(_.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), _.clearcoatNormalMap && (v.clearcoatNormalMap.value = _.clearcoatNormalMap, t(_.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(_.clearcoatNormalScale), _.side === Yi && v.clearcoatNormalScale.value.negate())), _.dispersion > 0 && (v.dispersion.value = _.dispersion), _.iridescence > 0 && (v.iridescence.value = _.iridescence, v.iridescenceIOR.value = _.iridescenceIOR, v.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1], _.iridescenceMap && (v.iridescenceMap.value = _.iridescenceMap, t(_.iridescenceMap, v.iridescenceMapTransform)), _.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = _.iridescenceThicknessMap, t(_.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), _.transmission > 0 && (v.transmission.value = _.transmission, v.transmissionSamplerMap.value = y.texture, v.transmissionSamplerSize.value.set(y.width, y.height), _.transmissionMap && (v.transmissionMap.value = _.transmissionMap, t(_.transmissionMap, v.transmissionMapTransform)), v.thickness.value = _.thickness, _.thicknessMap && (v.thicknessMap.value = _.thicknessMap, t(_.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = _.attenuationDistance, v.attenuationColor.value.copy(_.attenuationColor)), _.anisotropy > 0 && (v.anisotropyVector.value.set(_.anisotropy * Math.cos(_.anisotropyRotation), _.anisotropy * Math.sin(_.anisotropyRotation)), _.anisotropyMap && (v.anisotropyMap.value = _.anisotropyMap, t(_.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = _.specularIntensity, v.specularColor.value.copy(_.specularColor), _.specularColorMap && (v.specularColorMap.value = _.specularColorMap, t(_.specularColorMap, v.specularColorMapTransform)), _.specularIntensityMap && (v.specularIntensityMap.value = _.specularIntensityMap, t(_.specularIntensityMap, v.specularIntensityMapTransform));
  }
  function m(v, _) {
    _.matcap && (v.matcap.value = _.matcap);
  }
  function g(v, _) {
    const y = e.get(_).light;
    v.referencePosition.value.setFromMatrixPosition(y.matrixWorld), v.nearDistance.value = y.shadow.camera.near, v.farDistance.value = y.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: n
  };
}
function e8(s, e, t, i) {
  let n = {}, r = {}, o = [];
  const a = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(y, w) {
    const x = w.program;
    i.uniformBlockBinding(y, x);
  }
  function c(y, w) {
    let x = n[y.id];
    x === void 0 && (m(y), x = u(y), n[y.id] = x, y.addEventListener("dispose", v));
    const M = w.program;
    i.updateUBOMapping(y, M);
    const A = e.render.frame;
    r[y.id] !== A && (d(y), r[y.id] = A);
  }
  function u(y) {
    const w = h();
    y.__bindingPointIndex = w;
    const x = s.createBuffer(), M = y.__size, A = y.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, x), s.bufferData(s.UNIFORM_BUFFER, M, A), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, w, x), x;
  }
  function h() {
    for (let y = 0; y < a; y++)
      if (o.indexOf(y) === -1)
        return o.push(y), y;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function d(y) {
    const w = n[y.id], x = y.uniforms, M = y.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, w);
    for (let A = 0, E = x.length; A < E; A++) {
      const C = Array.isArray(x[A]) ? x[A] : [x[A]];
      for (let P = 0, T = C.length; P < T; P++) {
        const I = C[P];
        if (f(I, A, P, M) === !0) {
          const D = I.__offset, U = Array.isArray(I.value) ? I.value : [I.value];
          let L = 0;
          for (let k = 0; k < U.length; k++) {
            const B = U[k], j = g(B);
            typeof B == "number" || typeof B == "boolean" ? (I.__data[0] = B, s.bufferSubData(s.UNIFORM_BUFFER, D + L, I.__data)) : B.isMatrix3 ? (I.__data[0] = B.elements[0], I.__data[1] = B.elements[1], I.__data[2] = B.elements[2], I.__data[3] = 0, I.__data[4] = B.elements[3], I.__data[5] = B.elements[4], I.__data[6] = B.elements[5], I.__data[7] = 0, I.__data[8] = B.elements[6], I.__data[9] = B.elements[7], I.__data[10] = B.elements[8], I.__data[11] = 0) : (B.toArray(I.__data, L), L += j.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, D, I.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function f(y, w, x, M) {
    const A = y.value, E = w + "_" + x;
    if (M[E] === void 0)
      return typeof A == "number" || typeof A == "boolean" ? M[E] = A : M[E] = A.clone(), !0;
    {
      const C = M[E];
      if (typeof A == "number" || typeof A == "boolean") {
        if (C !== A)
          return M[E] = A, !0;
      } else if (C.equals(A) === !1)
        return C.copy(A), !0;
    }
    return !1;
  }
  function m(y) {
    const w = y.uniforms;
    let x = 0;
    const M = 16;
    for (let E = 0, C = w.length; E < C; E++) {
      const P = Array.isArray(w[E]) ? w[E] : [w[E]];
      for (let T = 0, I = P.length; T < I; T++) {
        const D = P[T], U = Array.isArray(D.value) ? D.value : [D.value];
        for (let L = 0, k = U.length; L < k; L++) {
          const B = U[L], j = g(B), q = x % M, Z = q % j.boundary, N = q + Z;
          x += Z, N !== 0 && M - N < j.storage && (x += M - N), D.__data = new Float32Array(j.storage / Float32Array.BYTES_PER_ELEMENT), D.__offset = x, x += j.storage;
        }
      }
    }
    const A = x % M;
    return A > 0 && (x += M - A), y.__size = x, y.__cache = {}, this;
  }
  function g(y) {
    const w = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof y == "number" || typeof y == "boolean" ? (w.boundary = 4, w.storage = 4) : y.isVector2 ? (w.boundary = 8, w.storage = 8) : y.isVector3 || y.isColor ? (w.boundary = 16, w.storage = 12) : y.isVector4 ? (w.boundary = 16, w.storage = 16) : y.isMatrix3 ? (w.boundary = 48, w.storage = 48) : y.isMatrix4 ? (w.boundary = 64, w.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), w;
  }
  function v(y) {
    const w = y.target;
    w.removeEventListener("dispose", v);
    const x = o.indexOf(w.__bindingPointIndex);
    o.splice(x, 1), s.deleteBuffer(n[w.id]), delete n[w.id], delete r[w.id];
  }
  function _() {
    for (const y in n)
      s.deleteBuffer(n[y]);
    o = [], n = {}, r = {};
  }
  return {
    bind: l,
    update: c,
    dispose: _
  };
}
class CS {
  constructor(e = {}) {
    const {
      canvas: t = XD(),
      context: i = null,
      depth: n = !0,
      stencil: r = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: h = !1,
      reverseDepthBuffer: d = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (i !== null) {
      if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = i.getContextAttributes().alpha;
    } else
      f = o;
    const m = new Uint32Array(4), g = new Int32Array(4);
    let v = null, _ = null;
    const y = [], w = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Oi, this.toneMapping = qo, this.toneMappingExposure = 1;
    const x = this;
    let M = !1, A = 0, E = 0, C = null, P = -1, T = null;
    const I = new Kt(), D = new Kt();
    let U = null;
    const L = new rt(0);
    let k = 0, B = t.width, j = t.height, q = 1, Z = null, N = null;
    const z = new Kt(0, 0, B, j), J = new Kt(0, 0, B, j);
    let se = !1;
    const K = new hm();
    let Q = !1, de = !1;
    this.transmissionResolutionScale = 1;
    const ce = new _t(), _e = new _t(), Fe = new H(), Ie = new Kt(), Ee = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let me = !1;
    function xe() {
      return C === null ? q : 1;
    }
    let $ = i;
    function Ue(F, ie) {
      return t.getContext(F, ie);
    }
    try {
      const F = {
        alpha: !0,
        depth: n,
        stencil: r,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: h
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${yd}`), t.addEventListener("webglcontextlost", Xe, !1), t.addEventListener("webglcontextrestored", We, !1), t.addEventListener("webglcontextcreationerror", Ne, !1), $ === null) {
        const ie = "webgl2";
        if ($ = Ue(ie, F), $ === null)
          throw Ue(ie) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (F) {
      throw console.error("THREE.WebGLRenderer: " + F.message), F;
    }
    let Me, oe, Te, Ye, Oe, X, Y, fe, ue, te, Se, ye, Ae, Ce, Ge, De, Ve, ze, Ze, Le, ot, tt, mt, le;
    function ve() {
      Me = new d6($), Me.init(), tt = new VI($, Me), oe = new s6($, Me, e, tt), Te = new YW($, Me), oe.reverseDepthBuffer && d && Te.buffers.depth.setReversed(!0), Ye = new m6($), Oe = new LW(), X = new jW($, Me, Te, Oe, oe, tt, Ye), Y = new a6(x), fe = new h6(x), ue = new bV($), mt = new i6($, ue), te = new f6($, ue, Ye, mt), Se = new v6($, te, ue, Ye), Ze = new g6($, oe, X), De = new o6(Oe), ye = new IW(x, Y, fe, Me, oe, mt, De), Ae = new QW(x, Oe), Ce = new kW(), Ge = new VW(Me), ze = new n6(x, Y, fe, Te, Se, f, l), Ve = new WW(x, Se, oe), le = new e8($, Ye, oe, Te), Le = new r6($, Me, Ye), ot = new p6($, Me, Ye), Ye.programs = ye.programs, x.capabilities = oe, x.extensions = Me, x.properties = Oe, x.renderLists = Ce, x.shadowMap = Ve, x.state = Te, x.info = Ye;
    }
    ve();
    const be = new $W(x, $);
    this.xr = be, this.getContext = function() {
      return $;
    }, this.getContextAttributes = function() {
      return $.getContextAttributes();
    }, this.forceContextLoss = function() {
      const F = Me.get("WEBGL_lose_context");
      F && F.loseContext();
    }, this.forceContextRestore = function() {
      const F = Me.get("WEBGL_lose_context");
      F && F.restoreContext();
    }, this.getPixelRatio = function() {
      return q;
    }, this.setPixelRatio = function(F) {
      F !== void 0 && (q = F, this.setSize(B, j, !1));
    }, this.getSize = function(F) {
      return F.set(B, j);
    }, this.setSize = function(F, ie, re = !0) {
      if (be.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      B = F, j = ie, t.width = Math.floor(F * q), t.height = Math.floor(ie * q), re === !0 && (t.style.width = F + "px", t.style.height = ie + "px"), this.setViewport(0, 0, F, ie);
    }, this.getDrawingBufferSize = function(F) {
      return F.set(B * q, j * q).floor();
    }, this.setDrawingBufferSize = function(F, ie, re) {
      B = F, j = ie, q = re, t.width = Math.floor(F * re), t.height = Math.floor(ie * re), this.setViewport(0, 0, F, ie);
    }, this.getCurrentViewport = function(F) {
      return F.copy(I);
    }, this.getViewport = function(F) {
      return F.copy(z);
    }, this.setViewport = function(F, ie, re, ne) {
      F.isVector4 ? z.set(F.x, F.y, F.z, F.w) : z.set(F, ie, re, ne), Te.viewport(I.copy(z).multiplyScalar(q).round());
    }, this.getScissor = function(F) {
      return F.copy(J);
    }, this.setScissor = function(F, ie, re, ne) {
      F.isVector4 ? J.set(F.x, F.y, F.z, F.w) : J.set(F, ie, re, ne), Te.scissor(D.copy(J).multiplyScalar(q).round());
    }, this.getScissorTest = function() {
      return se;
    }, this.setScissorTest = function(F) {
      Te.setScissorTest(se = F);
    }, this.setOpaqueSort = function(F) {
      Z = F;
    }, this.setTransparentSort = function(F) {
      N = F;
    }, this.getClearColor = function(F) {
      return F.copy(ze.getClearColor());
    }, this.setClearColor = function() {
      ze.setClearColor(...arguments);
    }, this.getClearAlpha = function() {
      return ze.getClearAlpha();
    }, this.setClearAlpha = function() {
      ze.setClearAlpha(...arguments);
    }, this.clear = function(F = !0, ie = !0, re = !0) {
      let ne = 0;
      if (F) {
        let ae = !1;
        if (C !== null) {
          const we = C.texture.format;
          ae = we === vu || we === Sd || we === wd;
        }
        if (ae) {
          const we = C.texture.type, Pe = we === ro || we === hs || we === pu || we === mu || we === v_ || we === __, Re = ze.getClearColor(), He = ze.getClearAlpha(), qe = Re.r, Ke = Re.g, Je = Re.b;
          Pe ? (m[0] = qe, m[1] = Ke, m[2] = Je, m[3] = He, $.clearBufferuiv($.COLOR, 0, m)) : (g[0] = qe, g[1] = Ke, g[2] = Je, g[3] = He, $.clearBufferiv($.COLOR, 0, g));
        } else
          ne |= $.COLOR_BUFFER_BIT;
      }
      ie && (ne |= $.DEPTH_BUFFER_BIT), re && (ne |= $.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), $.clear(ne);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Xe, !1), t.removeEventListener("webglcontextrestored", We, !1), t.removeEventListener("webglcontextcreationerror", Ne, !1), ze.dispose(), Ce.dispose(), Ge.dispose(), Oe.dispose(), Y.dispose(), fe.dispose(), Se.dispose(), mt.dispose(), le.dispose(), ye.dispose(), be.dispose(), be.removeEventListener("sessionstart", Qe), be.removeEventListener("sessionend", xt), yt.stop();
    };
    function Xe(F) {
      F.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), M = !0;
    }
    function We() {
      console.log("THREE.WebGLRenderer: Context Restored."), M = !1;
      const F = Ye.autoReset, ie = Ve.enabled, re = Ve.autoUpdate, ne = Ve.needsUpdate, ae = Ve.type;
      ve(), Ye.autoReset = F, Ve.enabled = ie, Ve.autoUpdate = re, Ve.needsUpdate = ne, Ve.type = ae;
    }
    function Ne(F) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage);
    }
    function ct(F) {
      const ie = F.target;
      ie.removeEventListener("dispose", ct), gt(ie);
    }
    function gt(F) {
      nt(F), Oe.remove(F);
    }
    function nt(F) {
      const ie = Oe.get(F).programs;
      ie !== void 0 && (ie.forEach(function(re) {
        ye.releaseProgram(re);
      }), F.isShaderMaterial && ye.releaseShaderCache(F));
    }
    this.renderBufferDirect = function(F, ie, re, ne, ae, we) {
      ie === null && (ie = Ee);
      const Pe = ae.isMesh && ae.matrixWorld.determinant() < 0, Re = zi(F, ie, re, ne, ae);
      Te.setMaterial(ne, Pe);
      let He = re.index, qe = 1;
      if (ne.wireframe === !0) {
        if (He = te.getWireframeAttribute(re), He === void 0) return;
        qe = 2;
      }
      const Ke = re.drawRange, Je = re.attributes.position;
      let et = Ke.start * qe, st = (Ke.start + Ke.count) * qe;
      we !== null && (et = Math.max(et, we.start * qe), st = Math.min(st, (we.start + we.count) * qe)), He !== null ? (et = Math.max(et, 0), st = Math.min(st, He.count)) : Je != null && (et = Math.max(et, 0), st = Math.min(st, Je.count));
      const Et = st - et;
      if (Et < 0 || Et === 1 / 0) return;
      mt.setup(ae, ne, Re, re, He);
      let kt, Ot = Le;
      if (He !== null && (kt = ue.get(He), Ot = ot, Ot.setIndex(kt)), ae.isMesh)
        ne.wireframe === !0 ? (Te.setLineWidth(ne.wireframeLinewidth * xe()), Ot.setMode($.LINES)) : Ot.setMode($.TRIANGLES);
      else if (ae.isLine) {
        let bt = ne.linewidth;
        bt === void 0 && (bt = 1), Te.setLineWidth(bt * xe()), ae.isLineSegments ? Ot.setMode($.LINES) : ae.isLineLoop ? Ot.setMode($.LINE_LOOP) : Ot.setMode($.LINE_STRIP);
      } else ae.isPoints ? Ot.setMode($.POINTS) : ae.isSprite && Ot.setMode($.TRIANGLES);
      if (ae.isBatchedMesh)
        if (ae._multiDrawInstances !== null)
          Ac("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Ot.renderMultiDrawInstances(ae._multiDrawStarts, ae._multiDrawCounts, ae._multiDrawCount, ae._multiDrawInstances);
        else if (Me.get("WEBGL_multi_draw"))
          Ot.renderMultiDraw(ae._multiDrawStarts, ae._multiDrawCounts, ae._multiDrawCount);
        else {
          const bt = ae._multiDrawStarts, Yt = ae._multiDrawCounts, St = ae._multiDrawCount, mn = He ? ue.get(He).bytesPerElement : 1, ii = Oe.get(ne).currentProgram.getUniforms();
          for (let hn = 0; hn < St; hn++)
            ii.setValue($, "_gl_DrawID", hn), Ot.render(bt[hn] / mn, Yt[hn]);
        }
      else if (ae.isInstancedMesh)
        Ot.renderInstances(et, Et, ae.count);
      else if (re.isInstancedBufferGeometry) {
        const bt = re._maxInstanceCount !== void 0 ? re._maxInstanceCount : 1 / 0, Yt = Math.min(re.instanceCount, bt);
        Ot.renderInstances(et, Et, Yt);
      } else
        Ot.render(et, Et);
    };
    function je(F, ie, re) {
      F.transparent === !0 && F.side === wi && F.forceSinglePass === !1 ? (F.side = Yi, F.needsUpdate = !0, en(F, ie, re), F.side = Fs, F.needsUpdate = !0, en(F, ie, re), F.side = wi) : en(F, ie, re);
    }
    this.compile = function(F, ie, re = null) {
      re === null && (re = F), _ = Ge.get(re), _.init(ie), w.push(_), re.traverseVisible(function(ae) {
        ae.isLight && ae.layers.test(ie.layers) && (_.pushLight(ae), ae.castShadow && _.pushShadow(ae));
      }), F !== re && F.traverseVisible(function(ae) {
        ae.isLight && ae.layers.test(ie.layers) && (_.pushLight(ae), ae.castShadow && _.pushShadow(ae));
      }), _.setupLights();
      const ne = /* @__PURE__ */ new Set();
      return F.traverse(function(ae) {
        if (!(ae.isMesh || ae.isPoints || ae.isLine || ae.isSprite))
          return;
        const we = ae.material;
        if (we)
          if (Array.isArray(we))
            for (let Pe = 0; Pe < we.length; Pe++) {
              const Re = we[Pe];
              je(Re, re, ae), ne.add(Re);
            }
          else
            je(we, re, ae), ne.add(we);
      }), _ = w.pop(), ne;
    }, this.compileAsync = function(F, ie, re = null) {
      const ne = this.compile(F, ie, re);
      return new Promise((ae) => {
        function we() {
          if (ne.forEach(function(Pe) {
            Oe.get(Pe).currentProgram.isReady() && ne.delete(Pe);
          }), ne.size === 0) {
            ae(F);
            return;
          }
          setTimeout(we, 10);
        }
        Me.get("KHR_parallel_shader_compile") !== null ? we() : setTimeout(we, 10);
      });
    };
    let at = null;
    function ft(F) {
      at && at(F);
    }
    function Qe() {
      yt.stop();
    }
    function xt() {
      yt.start();
    }
    const yt = new OI();
    yt.setAnimationLoop(ft), typeof self < "u" && yt.setContext(self), this.setAnimationLoop = function(F) {
      at = F, be.setAnimationLoop(F), F === null ? yt.stop() : yt.start();
    }, be.addEventListener("sessionstart", Qe), be.addEventListener("sessionend", xt), this.render = function(F, ie) {
      if (ie !== void 0 && ie.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (M === !0) return;
      if (F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), ie.parent === null && ie.matrixWorldAutoUpdate === !0 && ie.updateMatrixWorld(), be.enabled === !0 && be.isPresenting === !0 && (be.cameraAutoUpdate === !0 && be.updateCamera(ie), ie = be.getCamera()), F.isScene === !0 && F.onBeforeRender(x, F, ie, C), _ = Ge.get(F, w.length), _.init(ie), w.push(_), _e.multiplyMatrices(ie.projectionMatrix, ie.matrixWorldInverse), K.setFromProjectionMatrix(_e), de = this.localClippingEnabled, Q = De.init(this.clippingPlanes, de), v = Ce.get(F, y.length), v.init(), y.push(v), be.enabled === !0 && be.isPresenting === !0) {
        const we = x.xr.getDepthSensingMesh();
        we !== null && Mt(we, ie, -1 / 0, x.sortObjects);
      }
      Mt(F, ie, 0, x.sortObjects), v.finish(), x.sortObjects === !0 && v.sort(Z, N), me = be.enabled === !1 || be.isPresenting === !1 || be.hasDepthSensing() === !1, me && ze.addToRenderList(v, F), this.info.render.frame++, Q === !0 && De.beginShadows();
      const re = _.state.shadowsArray;
      Ve.render(re, F, ie), Q === !0 && De.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const ne = v.opaque, ae = v.transmissive;
      if (_.setupLights(), ie.isArrayCamera) {
        const we = ie.cameras;
        if (ae.length > 0)
          for (let Pe = 0, Re = we.length; Pe < Re; Pe++) {
            const He = we[Pe];
            zt(ne, ae, F, He);
          }
        me && ze.render(F);
        for (let Pe = 0, Re = we.length; Pe < Re; Pe++) {
          const He = we[Pe];
          nn(v, F, He, He.viewport);
        }
      } else
        ae.length > 0 && zt(ne, ae, F, ie), me && ze.render(F), nn(v, F, ie);
      C !== null && E === 0 && (X.updateMultisampleRenderTarget(C), X.updateRenderTargetMipmap(C)), F.isScene === !0 && F.onAfterRender(x, F, ie), mt.resetDefaultState(), P = -1, T = null, w.pop(), w.length > 0 ? (_ = w[w.length - 1], Q === !0 && De.setGlobalState(x.clippingPlanes, _.state.camera)) : _ = null, y.pop(), y.length > 0 ? v = y[y.length - 1] : v = null;
    };
    function Mt(F, ie, re, ne) {
      if (F.visible === !1) return;
      if (F.layers.test(ie.layers)) {
        if (F.isGroup)
          re = F.renderOrder;
        else if (F.isLOD)
          F.autoUpdate === !0 && F.update(ie);
        else if (F.isLight)
          _.pushLight(F), F.castShadow && _.pushShadow(F);
        else if (F.isSprite) {
          if (!F.frustumCulled || K.intersectsSprite(F)) {
            ne && Ie.setFromMatrixPosition(F.matrixWorld).applyMatrix4(_e);
            const Pe = Se.update(F), Re = F.material;
            Re.visible && v.push(F, Pe, Re, re, Ie.z, null);
          }
        } else if ((F.isMesh || F.isLine || F.isPoints) && (!F.frustumCulled || K.intersectsObject(F))) {
          const Pe = Se.update(F), Re = F.material;
          if (ne && (F.boundingSphere !== void 0 ? (F.boundingSphere === null && F.computeBoundingSphere(), Ie.copy(F.boundingSphere.center)) : (Pe.boundingSphere === null && Pe.computeBoundingSphere(), Ie.copy(Pe.boundingSphere.center)), Ie.applyMatrix4(F.matrixWorld).applyMatrix4(_e)), Array.isArray(Re)) {
            const He = Pe.groups;
            for (let qe = 0, Ke = He.length; qe < Ke; qe++) {
              const Je = He[qe], et = Re[Je.materialIndex];
              et && et.visible && v.push(F, Pe, et, re, Ie.z, Je);
            }
          } else Re.visible && v.push(F, Pe, Re, re, Ie.z, null);
        }
      }
      const we = F.children;
      for (let Pe = 0, Re = we.length; Pe < Re; Pe++)
        Mt(we[Pe], ie, re, ne);
    }
    function nn(F, ie, re, ne) {
      const ae = F.opaque, we = F.transmissive, Pe = F.transparent;
      _.setupLightsView(re), Q === !0 && De.setGlobalState(x.clippingPlanes, re), ne && Te.viewport(I.copy(ne)), ae.length > 0 && $t(ae, ie, re), we.length > 0 && $t(we, ie, re), Pe.length > 0 && $t(Pe, ie, re), Te.buffers.depth.setTest(!0), Te.buffers.depth.setMask(!0), Te.buffers.color.setMask(!0), Te.setPolygonOffset(!1);
    }
    function zt(F, ie, re, ne) {
      if ((re.isScene === !0 ? re.overrideMaterial : null) !== null)
        return;
      _.state.transmissionRenderTarget[ne.id] === void 0 && (_.state.transmissionRenderTarget[ne.id] = new Bs(1, 1, {
        generateMipmaps: !0,
        type: Me.has("EXT_color_buffer_half_float") || Me.has("EXT_color_buffer_float") ? vr : ro,
        minFilter: As,
        samples: 4,
        stencilBuffer: r,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: vn.workingColorSpace
      }));
      const we = _.state.transmissionRenderTarget[ne.id], Pe = ne.viewport || I;
      we.setSize(Pe.z * x.transmissionResolutionScale, Pe.w * x.transmissionResolutionScale);
      const Re = x.getRenderTarget();
      x.setRenderTarget(we), x.getClearColor(L), k = x.getClearAlpha(), k < 1 && x.setClearColor(16777215, 0.5), x.clear(), me && ze.render(re);
      const He = x.toneMapping;
      x.toneMapping = qo;
      const qe = ne.viewport;
      if (ne.viewport !== void 0 && (ne.viewport = void 0), _.setupLightsView(ne), Q === !0 && De.setGlobalState(x.clippingPlanes, ne), $t(F, re, ne), X.updateMultisampleRenderTarget(we), X.updateRenderTargetMipmap(we), Me.has("WEBGL_multisampled_render_to_texture") === !1) {
        let Ke = !1;
        for (let Je = 0, et = ie.length; Je < et; Je++) {
          const st = ie[Je], Et = st.object, kt = st.geometry, Ot = st.material, bt = st.group;
          if (Ot.side === wi && Et.layers.test(ne.layers)) {
            const Yt = Ot.side;
            Ot.side = Yi, Ot.needsUpdate = !0, qt(Et, re, ne, kt, Ot, bt), Ot.side = Yt, Ot.needsUpdate = !0, Ke = !0;
          }
        }
        Ke === !0 && (X.updateMultisampleRenderTarget(we), X.updateRenderTargetMipmap(we));
      }
      x.setRenderTarget(Re), x.setClearColor(L, k), qe !== void 0 && (ne.viewport = qe), x.toneMapping = He;
    }
    function $t(F, ie, re) {
      const ne = ie.isScene === !0 ? ie.overrideMaterial : null;
      for (let ae = 0, we = F.length; ae < we; ae++) {
        const Pe = F[ae], Re = Pe.object, He = Pe.geometry, qe = ne === null ? Pe.material : ne, Ke = Pe.group;
        Re.layers.test(re.layers) && qt(Re, ie, re, He, qe, Ke);
      }
    }
    function qt(F, ie, re, ne, ae, we) {
      F.onBeforeRender(x, ie, re, ne, ae, we), F.modelViewMatrix.multiplyMatrices(re.matrixWorldInverse, F.matrixWorld), F.normalMatrix.getNormalMatrix(F.modelViewMatrix), ae.onBeforeRender(x, ie, re, ne, F, we), ae.transparent === !0 && ae.side === wi && ae.forceSinglePass === !1 ? (ae.side = Yi, ae.needsUpdate = !0, x.renderBufferDirect(re, ie, ne, ae, F, we), ae.side = Fs, ae.needsUpdate = !0, x.renderBufferDirect(re, ie, ne, ae, F, we), ae.side = wi) : x.renderBufferDirect(re, ie, ne, ae, F, we), F.onAfterRender(x, ie, re, ne, ae, we);
    }
    function en(F, ie, re) {
      ie.isScene !== !0 && (ie = Ee);
      const ne = Oe.get(F), ae = _.state.lights, we = _.state.shadowsArray, Pe = ae.state.version, Re = ye.getParameters(F, ae.state, we, ie, re), He = ye.getProgramCacheKey(Re);
      let qe = ne.programs;
      ne.environment = F.isMeshStandardMaterial ? ie.environment : null, ne.fog = ie.fog, ne.envMap = (F.isMeshStandardMaterial ? fe : Y).get(F.envMap || ne.environment), ne.envMapRotation = ne.environment !== null && F.envMap === null ? ie.environmentRotation : F.envMapRotation, qe === void 0 && (F.addEventListener("dispose", ct), qe = /* @__PURE__ */ new Map(), ne.programs = qe);
      let Ke = qe.get(He);
      if (Ke !== void 0) {
        if (ne.currentProgram === Ke && ne.lightsStateVersion === Pe)
          return on(F, Re), Ke;
      } else
        Re.uniforms = ye.getUniforms(F), F.onBeforeCompile(Re, x), Ke = ye.acquireProgram(Re, He), qe.set(He, Ke), ne.uniforms = Re.uniforms;
      const Je = ne.uniforms;
      return (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (Je.clippingPlanes = De.uniform), on(F, Re), ne.needsLights = An(F), ne.lightsStateVersion = Pe, ne.needsLights && (Je.ambientLightColor.value = ae.state.ambient, Je.lightProbe.value = ae.state.probe, Je.directionalLights.value = ae.state.directional, Je.directionalLightShadows.value = ae.state.directionalShadow, Je.spotLights.value = ae.state.spot, Je.spotLightShadows.value = ae.state.spotShadow, Je.rectAreaLights.value = ae.state.rectArea, Je.ltc_1.value = ae.state.rectAreaLTC1, Je.ltc_2.value = ae.state.rectAreaLTC2, Je.pointLights.value = ae.state.point, Je.pointLightShadows.value = ae.state.pointShadow, Je.hemisphereLights.value = ae.state.hemi, Je.directionalShadowMap.value = ae.state.directionalShadowMap, Je.directionalShadowMatrix.value = ae.state.directionalShadowMatrix, Je.spotShadowMap.value = ae.state.spotShadowMap, Je.spotLightMatrix.value = ae.state.spotLightMatrix, Je.spotLightMap.value = ae.state.spotLightMap, Je.pointShadowMap.value = ae.state.pointShadowMap, Je.pointShadowMatrix.value = ae.state.pointShadowMatrix), ne.currentProgram = Ke, ne.uniformsList = null, Ke;
    }
    function xn(F) {
      if (F.uniformsList === null) {
        const ie = F.currentProgram.getUniforms();
        F.uniformsList = Nv.seqWithValue(ie.seq, F.uniforms);
      }
      return F.uniformsList;
    }
    function on(F, ie) {
      const re = Oe.get(F);
      re.outputColorSpace = ie.outputColorSpace, re.batching = ie.batching, re.batchingColor = ie.batchingColor, re.instancing = ie.instancing, re.instancingColor = ie.instancingColor, re.instancingMorph = ie.instancingMorph, re.skinning = ie.skinning, re.morphTargets = ie.morphTargets, re.morphNormals = ie.morphNormals, re.morphColors = ie.morphColors, re.morphTargetsCount = ie.morphTargetsCount, re.numClippingPlanes = ie.numClippingPlanes, re.numIntersection = ie.numClipIntersection, re.vertexAlphas = ie.vertexAlphas, re.vertexTangents = ie.vertexTangents, re.toneMapping = ie.toneMapping;
    }
    function zi(F, ie, re, ne, ae) {
      ie.isScene !== !0 && (ie = Ee), X.resetTextureUnits();
      const we = ie.fog, Pe = ne.isMeshStandardMaterial ? ie.environment : null, Re = C === null ? x.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : Pi, He = (ne.isMeshStandardMaterial ? fe : Y).get(ne.envMap || Pe), qe = ne.vertexColors === !0 && !!re.attributes.color && re.attributes.color.itemSize === 4, Ke = !!re.attributes.tangent && (!!ne.normalMap || ne.anisotropy > 0), Je = !!re.morphAttributes.position, et = !!re.morphAttributes.normal, st = !!re.morphAttributes.color;
      let Et = qo;
      ne.toneMapped && (C === null || C.isXRRenderTarget === !0) && (Et = x.toneMapping);
      const kt = re.morphAttributes.position || re.morphAttributes.normal || re.morphAttributes.color, Ot = kt !== void 0 ? kt.length : 0, bt = Oe.get(ne), Yt = _.state.lights;
      if (Q === !0 && (de === !0 || F !== T)) {
        const Pn = F === T && ne.id === P;
        De.setState(ne, F, Pn);
      }
      let St = !1;
      ne.version === bt.__version ? (bt.needsLights && bt.lightsStateVersion !== Yt.state.version || bt.outputColorSpace !== Re || ae.isBatchedMesh && bt.batching === !1 || !ae.isBatchedMesh && bt.batching === !0 || ae.isBatchedMesh && bt.batchingColor === !0 && ae.colorTexture === null || ae.isBatchedMesh && bt.batchingColor === !1 && ae.colorTexture !== null || ae.isInstancedMesh && bt.instancing === !1 || !ae.isInstancedMesh && bt.instancing === !0 || ae.isSkinnedMesh && bt.skinning === !1 || !ae.isSkinnedMesh && bt.skinning === !0 || ae.isInstancedMesh && bt.instancingColor === !0 && ae.instanceColor === null || ae.isInstancedMesh && bt.instancingColor === !1 && ae.instanceColor !== null || ae.isInstancedMesh && bt.instancingMorph === !0 && ae.morphTexture === null || ae.isInstancedMesh && bt.instancingMorph === !1 && ae.morphTexture !== null || bt.envMap !== He || ne.fog === !0 && bt.fog !== we || bt.numClippingPlanes !== void 0 && (bt.numClippingPlanes !== De.numPlanes || bt.numIntersection !== De.numIntersection) || bt.vertexAlphas !== qe || bt.vertexTangents !== Ke || bt.morphTargets !== Je || bt.morphNormals !== et || bt.morphColors !== st || bt.toneMapping !== Et || bt.morphTargetsCount !== Ot) && (St = !0) : (St = !0, bt.__version = ne.version);
      let mn = bt.currentProgram;
      St === !0 && (mn = en(ne, ie, ae));
      let ii = !1, hn = !1, jt = !1;
      const Vt = mn.getUniforms(), zn = bt.uniforms;
      if (Te.useProgram(mn.program) && (ii = !0, hn = !0, jt = !0), ne.id !== P && (P = ne.id, hn = !0), ii || T !== F) {
        Te.buffers.depth.getReversed() ? (ce.copy(F.projectionMatrix), i4(ce), r4(ce), Vt.setValue($, "projectionMatrix", ce)) : Vt.setValue($, "projectionMatrix", F.projectionMatrix), Vt.setValue($, "viewMatrix", F.matrixWorldInverse);
        const kn = Vt.map.cameraPosition;
        kn !== void 0 && kn.setValue($, Fe.setFromMatrixPosition(F.matrixWorld)), oe.logarithmicDepthBuffer && Vt.setValue(
          $,
          "logDepthBufFC",
          2 / (Math.log(F.far + 1) / Math.LN2)
        ), (ne.isMeshPhongMaterial || ne.isMeshToonMaterial || ne.isMeshLambertMaterial || ne.isMeshBasicMaterial || ne.isMeshStandardMaterial || ne.isShaderMaterial) && Vt.setValue($, "isOrthographic", F.isOrthographicCamera === !0), T !== F && (T = F, hn = !0, jt = !0);
      }
      if (ae.isSkinnedMesh) {
        Vt.setOptional($, ae, "bindMatrix"), Vt.setOptional($, ae, "bindMatrixInverse");
        const Pn = ae.skeleton;
        Pn && (Pn.boneTexture === null && Pn.computeBoneTexture(), Vt.setValue($, "boneTexture", Pn.boneTexture, X));
      }
      ae.isBatchedMesh && (Vt.setOptional($, ae, "batchingTexture"), Vt.setValue($, "batchingTexture", ae._matricesTexture, X), Vt.setOptional($, ae, "batchingIdTexture"), Vt.setValue($, "batchingIdTexture", ae._indirectTexture, X), Vt.setOptional($, ae, "batchingColorTexture"), ae._colorsTexture !== null && Vt.setValue($, "batchingColorTexture", ae._colorsTexture, X));
      const Jn = re.morphAttributes;
      if ((Jn.position !== void 0 || Jn.normal !== void 0 || Jn.color !== void 0) && Ze.update(ae, re, mn), (hn || bt.receiveShadow !== ae.receiveShadow) && (bt.receiveShadow = ae.receiveShadow, Vt.setValue($, "receiveShadow", ae.receiveShadow)), ne.isMeshGouraudMaterial && ne.envMap !== null && (zn.envMap.value = He, zn.flipEnvMap.value = He.isCubeTexture && He.isRenderTargetTexture === !1 ? -1 : 1), ne.isMeshStandardMaterial && ne.envMap === null && ie.environment !== null && (zn.envMapIntensity.value = ie.environmentIntensity), hn && (Vt.setValue($, "toneMappingExposure", x.toneMappingExposure), bt.needsLights && un(zn, jt), we && ne.fog === !0 && Ae.refreshFogUniforms(zn, we), Ae.refreshMaterialUniforms(zn, ne, q, j, _.state.transmissionRenderTarget[F.id]), Nv.upload($, xn(bt), zn, X)), ne.isShaderMaterial && ne.uniformsNeedUpdate === !0 && (Nv.upload($, xn(bt), zn, X), ne.uniformsNeedUpdate = !1), ne.isSpriteMaterial && Vt.setValue($, "center", ae.center), Vt.setValue($, "modelViewMatrix", ae.modelViewMatrix), Vt.setValue($, "normalMatrix", ae.normalMatrix), Vt.setValue($, "modelMatrix", ae.matrixWorld), ne.isShaderMaterial || ne.isRawShaderMaterial) {
        const Pn = ne.uniformsGroups;
        for (let kn = 0, Ji = Pn.length; kn < Ji; kn++) {
          const Qi = Pn[kn];
          le.update(Qi, mn), le.bind(Qi, mn);
        }
      }
      return mn;
    }
    function un(F, ie) {
      F.ambientLightColor.needsUpdate = ie, F.lightProbe.needsUpdate = ie, F.directionalLights.needsUpdate = ie, F.directionalLightShadows.needsUpdate = ie, F.pointLights.needsUpdate = ie, F.pointLightShadows.needsUpdate = ie, F.spotLights.needsUpdate = ie, F.spotLightShadows.needsUpdate = ie, F.rectAreaLights.needsUpdate = ie, F.hemisphereLights.needsUpdate = ie;
    }
    function An(F) {
      return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return A;
    }, this.getActiveMipmapLevel = function() {
      return E;
    }, this.getRenderTarget = function() {
      return C;
    }, this.setRenderTargetTextures = function(F, ie, re) {
      Oe.get(F.texture).__webglTexture = ie, Oe.get(F.depthTexture).__webglTexture = re;
      const ne = Oe.get(F);
      ne.__hasExternalTextures = !0, ne.__autoAllocateDepthBuffer = re === void 0, ne.__autoAllocateDepthBuffer || Me.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ne.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(F, ie) {
      const re = Oe.get(F);
      re.__webglFramebuffer = ie, re.__useDefaultFramebuffer = ie === void 0;
    };
    const O = $.createFramebuffer();
    this.setRenderTarget = function(F, ie = 0, re = 0) {
      C = F, A = ie, E = re;
      let ne = !0, ae = null, we = !1, Pe = !1;
      if (F) {
        const He = Oe.get(F);
        if (He.__useDefaultFramebuffer !== void 0)
          Te.bindFramebuffer($.FRAMEBUFFER, null), ne = !1;
        else if (He.__webglFramebuffer === void 0)
          X.setupRenderTarget(F);
        else if (He.__hasExternalTextures)
          X.rebindTextures(F, Oe.get(F.texture).__webglTexture, Oe.get(F.depthTexture).__webglTexture);
        else if (F.depthBuffer) {
          const Je = F.depthTexture;
          if (He.__boundDepthTexture !== Je) {
            if (Je !== null && Oe.has(Je) && (F.width !== Je.image.width || F.height !== Je.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            X.setupDepthRenderbuffer(F);
          }
        }
        const qe = F.texture;
        (qe.isData3DTexture || qe.isDataArrayTexture || qe.isCompressedArrayTexture) && (Pe = !0);
        const Ke = Oe.get(F).__webglFramebuffer;
        F.isWebGLCubeRenderTarget ? (Array.isArray(Ke[ie]) ? ae = Ke[ie][re] : ae = Ke[ie], we = !0) : F.samples > 0 && X.useMultisampledRTT(F) === !1 ? ae = Oe.get(F).__webglMultisampledFramebuffer : Array.isArray(Ke) ? ae = Ke[re] : ae = Ke, I.copy(F.viewport), D.copy(F.scissor), U = F.scissorTest;
      } else
        I.copy(z).multiplyScalar(q).floor(), D.copy(J).multiplyScalar(q).floor(), U = se;
      if (re !== 0 && (ae = O), Te.bindFramebuffer($.FRAMEBUFFER, ae) && ne && Te.drawBuffers(F, ae), Te.viewport(I), Te.scissor(D), Te.setScissorTest(U), we) {
        const He = Oe.get(F.texture);
        $.framebufferTexture2D($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, $.TEXTURE_CUBE_MAP_POSITIVE_X + ie, He.__webglTexture, re);
      } else if (Pe) {
        const He = Oe.get(F.texture), qe = ie;
        $.framebufferTextureLayer($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, He.__webglTexture, re, qe);
      } else if (F !== null && re !== 0) {
        const He = Oe.get(F.texture);
        $.framebufferTexture2D($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, $.TEXTURE_2D, He.__webglTexture, re);
      }
      P = -1;
    }, this.readRenderTargetPixels = function(F, ie, re, ne, ae, we, Pe) {
      if (!(F && F.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Re = Oe.get(F).__webglFramebuffer;
      if (F.isWebGLCubeRenderTarget && Pe !== void 0 && (Re = Re[Pe]), Re) {
        Te.bindFramebuffer($.FRAMEBUFFER, Re);
        try {
          const He = F.texture, qe = He.format, Ke = He.type;
          if (!oe.textureFormatReadable(qe)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!oe.textureTypeReadable(Ke)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ie >= 0 && ie <= F.width - ne && re >= 0 && re <= F.height - ae && $.readPixels(ie, re, ne, ae, tt.convert(qe), tt.convert(Ke), we);
        } finally {
          const He = C !== null ? Oe.get(C).__webglFramebuffer : null;
          Te.bindFramebuffer($.FRAMEBUFFER, He);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(F, ie, re, ne, ae, we, Pe) {
      if (!(F && F.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Re = Oe.get(F).__webglFramebuffer;
      if (F.isWebGLCubeRenderTarget && Pe !== void 0 && (Re = Re[Pe]), Re) {
        const He = F.texture, qe = He.format, Ke = He.type;
        if (!oe.textureFormatReadable(qe))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!oe.textureTypeReadable(Ke))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (ie >= 0 && ie <= F.width - ne && re >= 0 && re <= F.height - ae) {
          Te.bindFramebuffer($.FRAMEBUFFER, Re);
          const Je = $.createBuffer();
          $.bindBuffer($.PIXEL_PACK_BUFFER, Je), $.bufferData($.PIXEL_PACK_BUFFER, we.byteLength, $.STREAM_READ), $.readPixels(ie, re, ne, ae, tt.convert(qe), tt.convert(Ke), 0);
          const et = C !== null ? Oe.get(C).__webglFramebuffer : null;
          Te.bindFramebuffer($.FRAMEBUFFER, et);
          const st = $.fenceSync($.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return $.flush(), await n4($, st, 4), $.bindBuffer($.PIXEL_PACK_BUFFER, Je), $.getBufferSubData($.PIXEL_PACK_BUFFER, 0, we), $.deleteBuffer(Je), $.deleteSync(st), we;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(F, ie = null, re = 0) {
      F.isTexture !== !0 && (Ac("WebGLRenderer: copyFramebufferToTexture function signature has changed."), ie = arguments[0] || null, F = arguments[1]);
      const ne = Math.pow(2, -re), ae = Math.floor(F.image.width * ne), we = Math.floor(F.image.height * ne), Pe = ie !== null ? ie.x : 0, Re = ie !== null ? ie.y : 0;
      X.setTexture2D(F, 0), $.copyTexSubImage2D($.TEXTURE_2D, re, 0, 0, Pe, Re, ae, we), Te.unbindTexture();
    };
    const ee = $.createFramebuffer(), he = $.createFramebuffer();
    this.copyTextureToTexture = function(F, ie, re = null, ne = null, ae = 0, we = null) {
      F.isTexture !== !0 && (Ac("WebGLRenderer: copyTextureToTexture function signature has changed."), ne = arguments[0] || null, F = arguments[1], ie = arguments[2], we = arguments[3] || 0, re = null), we === null && (ae !== 0 ? (Ac("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), we = ae, ae = 0) : we = 0);
      let Pe, Re, He, qe, Ke, Je, et, st, Et;
      const kt = F.isCompressedTexture ? F.mipmaps[we] : F.image;
      if (re !== null)
        Pe = re.max.x - re.min.x, Re = re.max.y - re.min.y, He = re.isBox3 ? re.max.z - re.min.z : 1, qe = re.min.x, Ke = re.min.y, Je = re.isBox3 ? re.min.z : 0;
      else {
        const Jn = Math.pow(2, -ae);
        Pe = Math.floor(kt.width * Jn), Re = Math.floor(kt.height * Jn), F.isDataArrayTexture ? He = kt.depth : F.isData3DTexture ? He = Math.floor(kt.depth * Jn) : He = 1, qe = 0, Ke = 0, Je = 0;
      }
      ne !== null ? (et = ne.x, st = ne.y, Et = ne.z) : (et = 0, st = 0, Et = 0);
      const Ot = tt.convert(ie.format), bt = tt.convert(ie.type);
      let Yt;
      ie.isData3DTexture ? (X.setTexture3D(ie, 0), Yt = $.TEXTURE_3D) : ie.isDataArrayTexture || ie.isCompressedArrayTexture ? (X.setTexture2DArray(ie, 0), Yt = $.TEXTURE_2D_ARRAY) : (X.setTexture2D(ie, 0), Yt = $.TEXTURE_2D), $.pixelStorei($.UNPACK_FLIP_Y_WEBGL, ie.flipY), $.pixelStorei($.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ie.premultiplyAlpha), $.pixelStorei($.UNPACK_ALIGNMENT, ie.unpackAlignment);
      const St = $.getParameter($.UNPACK_ROW_LENGTH), mn = $.getParameter($.UNPACK_IMAGE_HEIGHT), ii = $.getParameter($.UNPACK_SKIP_PIXELS), hn = $.getParameter($.UNPACK_SKIP_ROWS), jt = $.getParameter($.UNPACK_SKIP_IMAGES);
      $.pixelStorei($.UNPACK_ROW_LENGTH, kt.width), $.pixelStorei($.UNPACK_IMAGE_HEIGHT, kt.height), $.pixelStorei($.UNPACK_SKIP_PIXELS, qe), $.pixelStorei($.UNPACK_SKIP_ROWS, Ke), $.pixelStorei($.UNPACK_SKIP_IMAGES, Je);
      const Vt = F.isDataArrayTexture || F.isData3DTexture, zn = ie.isDataArrayTexture || ie.isData3DTexture;
      if (F.isDepthTexture) {
        const Jn = Oe.get(F), Pn = Oe.get(ie), kn = Oe.get(Jn.__renderTarget), Ji = Oe.get(Pn.__renderTarget);
        Te.bindFramebuffer($.READ_FRAMEBUFFER, kn.__webglFramebuffer), Te.bindFramebuffer($.DRAW_FRAMEBUFFER, Ji.__webglFramebuffer);
        for (let Qi = 0; Qi < He; Qi++)
          Vt && ($.framebufferTextureLayer($.READ_FRAMEBUFFER, $.COLOR_ATTACHMENT0, Oe.get(F).__webglTexture, ae, Je + Qi), $.framebufferTextureLayer($.DRAW_FRAMEBUFFER, $.COLOR_ATTACHMENT0, Oe.get(ie).__webglTexture, we, Et + Qi)), $.blitFramebuffer(qe, Ke, Pe, Re, et, st, Pe, Re, $.DEPTH_BUFFER_BIT, $.NEAREST);
        Te.bindFramebuffer($.READ_FRAMEBUFFER, null), Te.bindFramebuffer($.DRAW_FRAMEBUFFER, null);
      } else if (ae !== 0 || F.isRenderTargetTexture || Oe.has(F)) {
        const Jn = Oe.get(F), Pn = Oe.get(ie);
        Te.bindFramebuffer($.READ_FRAMEBUFFER, ee), Te.bindFramebuffer($.DRAW_FRAMEBUFFER, he);
        for (let kn = 0; kn < He; kn++)
          Vt ? $.framebufferTextureLayer($.READ_FRAMEBUFFER, $.COLOR_ATTACHMENT0, Jn.__webglTexture, ae, Je + kn) : $.framebufferTexture2D($.READ_FRAMEBUFFER, $.COLOR_ATTACHMENT0, $.TEXTURE_2D, Jn.__webglTexture, ae), zn ? $.framebufferTextureLayer($.DRAW_FRAMEBUFFER, $.COLOR_ATTACHMENT0, Pn.__webglTexture, we, Et + kn) : $.framebufferTexture2D($.DRAW_FRAMEBUFFER, $.COLOR_ATTACHMENT0, $.TEXTURE_2D, Pn.__webglTexture, we), ae !== 0 ? $.blitFramebuffer(qe, Ke, Pe, Re, et, st, Pe, Re, $.COLOR_BUFFER_BIT, $.NEAREST) : zn ? $.copyTexSubImage3D(Yt, we, et, st, Et + kn, qe, Ke, Pe, Re) : $.copyTexSubImage2D(Yt, we, et, st, qe, Ke, Pe, Re);
        Te.bindFramebuffer($.READ_FRAMEBUFFER, null), Te.bindFramebuffer($.DRAW_FRAMEBUFFER, null);
      } else
        zn ? F.isDataTexture || F.isData3DTexture ? $.texSubImage3D(Yt, we, et, st, Et, Pe, Re, He, Ot, bt, kt.data) : ie.isCompressedArrayTexture ? $.compressedTexSubImage3D(Yt, we, et, st, Et, Pe, Re, He, Ot, kt.data) : $.texSubImage3D(Yt, we, et, st, Et, Pe, Re, He, Ot, bt, kt) : F.isDataTexture ? $.texSubImage2D($.TEXTURE_2D, we, et, st, Pe, Re, Ot, bt, kt.data) : F.isCompressedTexture ? $.compressedTexSubImage2D($.TEXTURE_2D, we, et, st, kt.width, kt.height, Ot, kt.data) : $.texSubImage2D($.TEXTURE_2D, we, et, st, Pe, Re, Ot, bt, kt);
      $.pixelStorei($.UNPACK_ROW_LENGTH, St), $.pixelStorei($.UNPACK_IMAGE_HEIGHT, mn), $.pixelStorei($.UNPACK_SKIP_PIXELS, ii), $.pixelStorei($.UNPACK_SKIP_ROWS, hn), $.pixelStorei($.UNPACK_SKIP_IMAGES, jt), we === 0 && ie.generateMipmaps && $.generateMipmap(Yt), Te.unbindTexture();
    }, this.copyTextureToTexture3D = function(F, ie, re = null, ne = null, ae = 0) {
      return F.isTexture !== !0 && (Ac("WebGLRenderer: copyTextureToTexture3D function signature has changed."), re = arguments[0] || null, ne = arguments[1] || null, F = arguments[2], ie = arguments[3], ae = arguments[4] || 0), Ac('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(F, ie, re, ne, ae);
    }, this.initRenderTarget = function(F) {
      Oe.get(F).__webglFramebuffer === void 0 && X.setupRenderTarget(F);
    }, this.initTexture = function(F) {
      F.isCubeTexture ? X.setTextureCube(F, 0) : F.isData3DTexture ? X.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? X.setTexture2DArray(F, 0) : X.setTexture2D(F, 0), Te.unbindTexture();
    }, this.resetState = function() {
      A = 0, E = 0, C = null, Te.reset(), mt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return _o;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorspace = vn._getDrawingBufferColorSpace(e), t.unpackColorSpace = vn._getUnpackColorSpace();
  }
}
const t8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: AD,
  AddEquation: hl,
  AddOperation: SD,
  AdditiveAnimationBlendMode: Kw,
  AdditiveBlending: kp,
  AgXToneMapping: y0,
  AlphaFormat: Xw,
  AlwaysCompare: HD,
  AlwaysDepth: f0,
  AlwaysStencilFunc: j0,
  AmbientLight: wI,
  AnimationAction: LI,
  AnimationClip: pd,
  AnimationLoader: T5,
  AnimationMixer: q5,
  AnimationObjectGroup: Y5,
  AnimationUtils: w5,
  ArcCurve: JD,
  ArrayCamera: PI,
  ArrowHelper: pV,
  AttachedBindMode: _1,
  Audio: wS,
  AudioAnalyser: O5,
  AudioContext: xS,
  AudioListener: RI,
  AudioLoader: CI,
  AxesHelper: mV,
  BackSide: Yi,
  BasicDepthPacking: kD,
  BasicShadowMap: cz,
  BatchedMesh: KD,
  Bone: R_,
  BooleanKeyframeTrack: Du,
  Box2: tV,
  Box3: yn,
  Box3Helper: dV,
  BoxGeometry: pi,
  BoxHelper: hV,
  BufferAttribute: Nt,
  BufferGeometry: Gt,
  BufferGeometryLoader: TI,
  ByteType: Fp,
  Cache: Ea,
  Camera: M_,
  CameraHelper: uV,
  CanvasTexture: U_,
  CapsuleGeometry: O_,
  CatmullRomCurve3: QD,
  CineonToneMapping: TD,
  CircleGeometry: F_,
  ClampToEdgeWrapping: gr,
  Clock: bS,
  Color: rt,
  ColorKeyframeTrack: pS,
  ColorManagement: vn,
  CompressedArrayTexture: X4,
  CompressedCubeTexture: Y4,
  CompressedTexture: L_,
  CompressedTextureLoader: A5,
  ConeGeometry: N_,
  ConstantAlphaFactor: xD,
  ConstantColorFactor: _D,
  Controls: $_,
  CubeCamera: E_,
  CubeReflectionMapping: Ia,
  CubeRefractionMapping: Il,
  CubeTexture: Ed,
  CubeTextureLoader: xI,
  CubeUVReflectionMapping: xd,
  CubicBezierCurve: oS,
  CubicBezierCurve3: eI,
  CubicInterpolant: vI,
  CullFaceBack: m1,
  CullFaceFront: iD,
  CullFaceFrontBack: lz,
  CullFaceNone: nD,
  Curve: Mo,
  CurvePath: nI,
  CustomBlending: rD,
  CustomToneMapping: CD,
  CylinderGeometry: Di,
  Cylindrical: eV,
  Data3DTexture: w_,
  DataArrayTexture: om,
  DataTexture: yr,
  DataTextureLoader: gS,
  DataUtils: Gc,
  DecrementStencilOp: yz,
  DecrementWrapStencilOp: bz,
  DefaultLoadingManager: Lu,
  DepthFormat: eu,
  DepthStencilFormat: gu,
  DepthTexture: rS,
  DetachedBindMode: RD,
  DirectionalLight: q_,
  DirectionalLightHelper: cV,
  DiscreteInterpolant: _I,
  DodecahedronGeometry: B_,
  DoubleSide: wi,
  DstAlphaFactor: fD,
  DstColorFactor: mD,
  DynamicCopyUsage: kz,
  DynamicDrawUsage: Zh,
  DynamicReadUsage: Iz,
  EdgesGeometry: iI,
  EllipseCurve: k_,
  EqualCompare: BD,
  EqualDepth: m0,
  EqualStencilFunc: Ez,
  EquirectangularReflectionMapping: ld,
  EquirectangularRefractionMapping: Op,
  Euler: fs,
  EventDispatcher: Qo,
  ExtrudeGeometry: Ad,
  FileLoader: ps,
  Float16BufferAttribute: E4,
  Float32BufferAttribute: Tt,
  FloatType: Un,
  Fog: C_,
  FogExp2: A_,
  FramebufferTexture: W4,
  FrontSide: Fs,
  Frustum: hm,
  GLBufferAttribute: Q5,
  GLSL1: Fz,
  GLSL3: y1,
  GreaterCompare: zD,
  GreaterDepth: v0,
  GreaterEqualCompare: GD,
  GreaterEqualDepth: g0,
  GreaterEqualStencilFunc: Pz,
  GreaterStencilFunc: Az,
  GridHelper: aV,
  Group: Zn,
  HalfFloatType: vr,
  HemisphereLight: bI,
  HemisphereLightHelper: oV,
  IcosahedronGeometry: V_,
  ImageBitmapLoader: AI,
  ImageLoader: jp,
  ImageUtils: YD,
  IncrementStencilOp: _z,
  IncrementWrapStencilOp: xz,
  InstancedBufferAttribute: Jo,
  InstancedBufferGeometry: pm,
  InstancedInterleavedBuffer: $0,
  InstancedMesh: Td,
  Int16BufferAttribute: S4,
  Int32BufferAttribute: M4,
  Int8BufferAttribute: x4,
  IntType: Qc,
  InterleavedBuffer: lm,
  InterleavedBufferAttribute: ss,
  Interpolant: Pd,
  InterpolateDiscrete: ud,
  InterpolateLinear: hd,
  InterpolateSmooth: kv,
  InvertStencilOp: wz,
  KeepStencilOp: Tc,
  KeyframeTrack: Eo,
  LOD: nS,
  LatheGeometry: dm,
  Layers: S_,
  LessCompare: ND,
  LessDepth: p0,
  LessEqualCompare: Jw,
  LessEqualDepth: fu,
  LessEqualStencilFunc: Tz,
  LessStencilFunc: Mz,
  Light: zl,
  LightProbe: EI,
  Line: Ui,
  Line3: xo,
  LineBasicMaterial: Bi,
  LineCurve: aS,
  LineCurve3: tI,
  LineDashedMaterial: pI,
  LineLoop: iS,
  LineSegments: so,
  LinearFilter: Sn,
  LinearInterpolant: fS,
  LinearMipMapLinearFilter: fz,
  LinearMipMapNearestFilter: dz,
  LinearMipmapLinearFilter: As,
  LinearMipmapNearestFilter: qh,
  LinearSRGBColorSpace: Pi,
  LinearToneMapping: MD,
  LinearTransfer: Bp,
  Loader: br,
  LoaderUtils: Tl,
  LoadingManager: mS,
  LoopOnce: DD,
  LoopPingPong: LD,
  LoopRepeat: ID,
  LuminanceAlphaFormat: qw,
  LuminanceFormat: jw,
  MOUSE: Is,
  Material: ji,
  MaterialLoader: Z_,
  MathUtils: Kr,
  Matrix2: TS,
  Matrix3: Jt,
  Matrix4: _t,
  MaxEquation: lD,
  Mesh: it,
  MeshBasicMaterial: qn,
  MeshDepthMaterial: Ru,
  MeshDistanceMaterial: Cd,
  MeshLambertMaterial: dI,
  MeshMatcapMaterial: fI,
  MeshNormalMaterial: hI,
  MeshPhongMaterial: cI,
  MeshPhysicalMaterial: oo,
  MeshStandardMaterial: fm,
  MeshToonMaterial: uI,
  MinEquation: aD,
  MirroredRepeatWrapping: cd,
  MixOperation: wD,
  MultiplyBlending: v1,
  MultiplyOperation: sm,
  NearestFilter: Tn,
  NearestMipMapLinearFilter: hz,
  NearestMipMapNearestFilter: uz,
  NearestMipmapLinearFilter: Bc,
  NearestMipmapNearestFilter: m_,
  NeutralToneMapping: PD,
  NeverCompare: FD,
  NeverDepth: d0,
  NeverStencilFunc: Sz,
  NoBlending: Aa,
  NoColorSpace: Fo,
  NoToneMapping: qo,
  NormalAnimationBlendMode: x_,
  NormalBlending: Jc,
  NotEqualCompare: VD,
  NotEqualDepth: _0,
  NotEqualStencilFunc: Cz,
  NumberKeyframeTrack: yu,
  Object3D: tn,
  ObjectLoader: D5,
  ObjectSpaceNormalMap: OD,
  OctahedronGeometry: Ma,
  OneFactor: uD,
  OneMinusConstantAlphaFactor: bD,
  OneMinusConstantColorFactor: yD,
  OneMinusDstAlphaFactor: pD,
  OneMinusDstColorFactor: gD,
  OneMinusSrcAlphaFactor: h0,
  OneMinusSrcColorFactor: dD,
  OrthographicCamera: Ua,
  PCFShadowMap: Hw,
  PCFSoftShadowMap: rp,
  PMREMGenerator: T1,
  Path: Hp,
  PerspectiveCamera: Fi,
  Plane: $s,
  PlaneGeometry: $r,
  PlaneHelper: fV,
  PointLight: yS,
  PointLightHelper: rV,
  Points: I_,
  PointsMaterial: D_,
  PolarGridHelper: lV,
  PolyhedronGeometry: Nl,
  PositionalAudio: DI,
  PropertyBinding: Mn,
  PropertyMixer: II,
  QuadraticBezierCurve: lS,
  QuadraticBezierCurve3: cS,
  Quaternion: En,
  QuaternionKeyframeTrack: xu,
  QuaternionLinearInterpolant: yI,
  RED_GREEN_RGTC2_Format: W0,
  RED_RGTC1_Format: Zw,
  REVISION: yd,
  RGBADepthPacking: Md,
  RGBAFormat: di,
  RGBAIntegerFormat: vu,
  RGBA_ASTC_10x10_Format: N0,
  RGBA_ASTC_10x5_Format: k0,
  RGBA_ASTC_10x6_Format: O0,
  RGBA_ASTC_10x8_Format: F0,
  RGBA_ASTC_12x10_Format: B0,
  RGBA_ASTC_12x12_Format: z0,
  RGBA_ASTC_4x4_Format: A0,
  RGBA_ASTC_5x4_Format: C0,
  RGBA_ASTC_5x5_Format: P0,
  RGBA_ASTC_6x5_Format: R0,
  RGBA_ASTC_6x6_Format: D0,
  RGBA_ASTC_8x5_Format: I0,
  RGBA_ASTC_8x6_Format: L0,
  RGBA_ASTC_8x8_Format: U0,
  RGBA_BPTC_Format: cp,
  RGBA_ETC2_EAC_Format: T0,
  RGBA_PVRTC_2BPPV1_Format: S0,
  RGBA_PVRTC_4BPPV1_Format: w0,
  RGBA_S3TC_DXT1_Format: op,
  RGBA_S3TC_DXT3_Format: ap,
  RGBA_S3TC_DXT5_Format: lp,
  RGBDepthPacking: mz,
  RGBFormat: Yw,
  RGBIntegerFormat: pz,
  RGB_BPTC_SIGNED_Format: V0,
  RGB_BPTC_UNSIGNED_Format: G0,
  RGB_ETC1_Format: M0,
  RGB_ETC2_Format: E0,
  RGB_PVRTC_2BPPV1_Format: b0,
  RGB_PVRTC_4BPPV1_Format: x0,
  RGB_S3TC_DXT1_Format: sp,
  RGDepthPacking: gz,
  RGFormat: y_,
  RGIntegerFormat: Sd,
  RawShaderMaterial: lI,
  Ray: Ol,
  Raycaster: K_,
  RectAreaLight: SI,
  RedFormat: bd,
  RedIntegerFormat: wd,
  ReinhardToneMapping: ED,
  RenderTarget: b_,
  RenderTarget3D: Z5,
  RenderTargetArray: K5,
  RepeatWrapping: Ns,
  ReplaceStencilOp: Ov,
  ReverseSubtractEquation: oD,
  RingGeometry: G_,
  SIGNED_RED_GREEN_RGTC2_Format: X0,
  SIGNED_RED_RGTC1_Format: H0,
  SRGBColorSpace: Oi,
  SRGBTransfer: Vn,
  Scene: am,
  ShaderChunk: Ft,
  ShaderLib: Dr,
  ShaderMaterial: Mi,
  ShadowMaterial: aI,
  Shape: El,
  ShapeGeometry: H_,
  ShapePath: kI,
  ShapeUtils: Zo,
  ShortType: g_,
  Skeleton: um,
  SkeletonHelper: iV,
  SkinnedMesh: P_,
  Source: yl,
  Sphere: fi,
  SphereGeometry: Bl,
  Spherical: md,
  SphericalHarmonics3: MI,
  SplineCurve: uS,
  SpotLight: _S,
  SpotLightHelper: nV,
  Sprite: cm,
  SpriteMaterial: Pu,
  SrcAlphaFactor: u0,
  SrcAlphaSaturateFactor: vD,
  SrcColorFactor: hD,
  StaticCopyUsage: Uz,
  StaticDrawUsage: zp,
  StaticReadUsage: Dz,
  StereoCamera: L5,
  StreamCopyUsage: Oz,
  StreamDrawUsage: Rz,
  StreamReadUsage: Lz,
  StringKeyframeTrack: Iu,
  SubtractEquation: sD,
  SubtractiveBlending: g1,
  TOUCH: Nc,
  TangentSpaceNormalMap: kl,
  TetrahedronGeometry: W_,
  Texture: ei,
  TextureLoader: j_,
  TextureUtils: xV,
  TimestampQuery: Nz,
  TorusGeometry: wa,
  TorusKnotGeometry: X_,
  Triangle: Xi,
  TriangleFanDrawMode: Y0,
  TriangleStripDrawMode: $w,
  TrianglesDrawMode: UD,
  TubeGeometry: Y_,
  UVMapping: p_,
  Uint16BufferAttribute: eS,
  Uint32BufferAttribute: tS,
  Uint8BufferAttribute: b4,
  Uint8ClampedBufferAttribute: w4,
  Uniform: ES,
  UniformsGroup: J5,
  UniformsLib: vt,
  UniformsUtils: Fl,
  UnsignedByteType: ro,
  UnsignedInt248Type: mu,
  UnsignedInt5999Type: Ww,
  UnsignedIntType: hs,
  UnsignedShort4444Type: v_,
  UnsignedShort5551Type: __,
  UnsignedShortType: pu,
  VSMShadowMap: Lo,
  Vector2: Be,
  Vector3: H,
  Vector4: Kt,
  VectorKeyframeTrack: bu,
  VideoFrameTexture: H4,
  VideoTexture: $D,
  WebGL3DRenderTarget: c4,
  WebGLArrayRenderTarget: l4,
  WebGLCoordinateSystem: _o,
  WebGLCubeRenderTarget: T_,
  WebGLRenderTarget: Bs,
  WebGLRenderer: CS,
  WebGLUtils: VI,
  WebGPUCoordinateSystem: Vp,
  WebXRController: Fv,
  WireframeGeometry: hS,
  WrapAroundEnding: Np,
  ZeroCurvatureEnding: zc,
  ZeroFactor: cD,
  ZeroSlopeEnding: Vc,
  ZeroStencilOp: vz,
  createCanvasElement: XD
}, Symbol.toStringTag, { value: "Module" })), NA = (s, e) => {
  if (s === e)
    return !0;
  if (!s || !e)
    return !1;
  const t = s.length;
  if (e.length !== t)
    return !1;
  for (let i = 0; i < t; i++)
    if (s[i] !== e[i])
      return !1;
  return !0;
}, GI = () => {
  const s = [], i = { items: s, remember: (n, r) => {
    for (let a = 0; a < s.length; a++) {
      const l = s[a];
      if (NA(r, l.keys) && l.promise)
        return l.promise;
    }
    const o = {
      promise: n(),
      keys: r
    };
    return s.push(o), o.promise;
  }, clear: (n) => {
    for (let r = 0; r < s.length; r++) {
      const o = s[r];
      if (NA(n, o.keys)) {
        s.splice(r, 1);
        return;
      }
    }
  } };
  return xr("threlte-cache", i), i;
}, PS = () => {
  const s = sr("threlte-cache");
  if (!s)
    throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");
  return s;
}, BA = Symbol(), n8 = (s) => typeof (s == null ? void 0 : s.subscribe) == "function", HI = (s, e, t) => {
  const i = s().map((o) => n8(o) ? rm(o) : BA), n = /* @__PURE__ */ wt(() => s().map((o, a) => i[a] === BA ? o : i[a].current)), r = () => {
    pe(n);
    let o;
    return io(() => {
      o = e(pe(n));
    }), o;
  };
  t ? $e(r) : Ht(r);
}, i8 = (s, e) => HI(s, e, !1), r8 = (s, e) => HI(s, e, !0), zs = Object.assign(i8, { pre: r8 }), bn = (s, e) => (s == null ? void 0 : s[`is${e}`]) === !0, nu = (s) => {
  const e = Gn(void 0), t = Gn(void 0);
  return s.then((i) => {
    e.set(i);
  }).catch((i) => {
    console.error("Error in asyncWritable:", i.message), t.set(i);
  }), Object.assign(Object.assign(s, e), { error: t, promise: s });
}, s8 = typeof window < "u", o8 = yd.replace("dev", ""), zA = Number.parseInt(o8), ui = (s, e) => {
  const t = Cl(s, (r) => r);
  let i;
  const n = t.subscribe(async (r) => {
    i && i();
    const o = await e(r);
    o && (i = o);
  });
  Ki(() => {
    n(), i && i();
  });
}, Xn = (s) => {
  const e = Gn(s), t = {
    set: (i) => {
      t.current = i, e.set(i);
    },
    subscribe: e.subscribe,
    update: (i) => {
      const n = i(t.current);
      t.current = n, e.set(n);
    },
    current: s
  };
  return t;
}, a8 = (s) => ({
  subscribe: s.subscribe,
  get current() {
    return s.current;
  }
}), WI = (s, e) => {
  if (e.includes(".")) {
    const t = e.split("."), i = t.pop();
    for (let n = 0; n < t.length; n += 1)
      s = s[t[n]];
    return {
      target: s,
      key: i
    };
  } else
    return {
      target: s,
      key: e
    };
}, XI = (s) => {
  const { dom: e, canvas: t } = s, i = Xn({ width: e.offsetWidth, height: e.offsetHeight });
  So(() => {
    const r = new ResizeObserver(() => {
      const { offsetWidth: o, offsetHeight: a } = e;
      (i.current.width !== o || i.current.height !== a) && i.set({ width: o, height: a });
    });
    return r.observe(e), () => {
      r.disconnect();
    };
  });
  const n = {
    dom: e,
    canvas: t,
    size: a8(i)
  };
  return xr("threlte-dom-context", n), n;
}, RS = () => {
  const s = sr("threlte-dom-context");
  if (!s)
    throw new Error("useDOM can only be used in a child component to <Canvas>.");
  return s;
};
function l8(s) {
  return { all: s = s || /* @__PURE__ */ new Map(), on: function(e, t) {
    var i = s.get(e);
    i ? i.push(t) : s.set(e, [t]);
  }, off: function(e, t) {
    var i = s.get(e);
    i && (t ? i.splice(i.indexOf(t) >>> 0, 1) : s.set(e, []));
  }, emit: function(e, t) {
    var i = s.get(e);
    i && i.slice().map(function(n) {
      n(t);
    }), (i = s.get("*")) && i.slice().map(function(n) {
      n(e, t);
    });
  } };
}
class ll {
  constructor() {
    ht(this, "allVertices", {});
    /** Nodes that are fully unlinked */
    ht(this, "isolatedVertices", {});
    ht(this, "connectedVertices", {});
    ht(this, "sortedConnectedValues", []);
    ht(this, "needsSort", !1);
    ht(this, "emitter", l8());
    ht(this, "emit", this.emitter.emit.bind(this.emitter));
    ht(this, "on", this.emitter.on.bind(this.emitter));
    ht(this, "off", this.emitter.off.bind(this.emitter));
    ht(this, "getKey", (e) => typeof e == "object" ? e.key : e);
  }
  get sortedVertices() {
    return this.mapNodes((e) => e);
  }
  moveToIsolated(e) {
    const t = this.connectedVertices[e];
    t && (this.isolatedVertices[e] = t, delete this.connectedVertices[e]);
  }
  moveToConnected(e) {
    const t = this.isolatedVertices[e];
    t && (this.connectedVertices[e] = t, delete this.isolatedVertices[e]);
  }
  add(e, t, i) {
    if (this.allVertices[e] && this.allVertices[e].value !== void 0)
      throw new Error(`A node with the key ${e.toString()} already exists`);
    let n = this.allVertices[e];
    n ? n.value === void 0 && (n.value = t) : (n = {
      value: t,
      previous: /* @__PURE__ */ new Set(),
      next: /* @__PURE__ */ new Set()
    }, this.allVertices[e] = n);
    const r = n.next.size > 0 || n.previous.size > 0;
    if (!(i != null && i.after) && !(i != null && i.before) && !r) {
      this.isolatedVertices[e] = n, this.emit("node:added", {
        key: e,
        type: "isolated",
        value: t
      });
      return;
    } else
      this.connectedVertices[e] = n;
    if (i != null && i.after) {
      const o = Array.isArray(i.after) ? i.after : [i.after];
      o.forEach((a) => {
        n.previous.add(this.getKey(a));
      }), o.forEach((a) => {
        const l = this.getKey(a), c = this.allVertices[l];
        c ? (c.next.add(e), this.moveToConnected(l)) : (this.allVertices[l] = {
          value: void 0,
          // uninitialized
          previous: /* @__PURE__ */ new Set(),
          next: /* @__PURE__ */ new Set([e])
        }, this.connectedVertices[l] = this.allVertices[l]);
      });
    }
    if (i != null && i.before) {
      const o = Array.isArray(i.before) ? i.before : [i.before];
      o.forEach((a) => {
        n.next.add(this.getKey(a));
      }), o.forEach((a) => {
        const l = this.getKey(a), c = this.allVertices[l];
        c ? (c.previous.add(e), this.moveToConnected(l)) : (this.allVertices[l] = {
          value: void 0,
          // uninitialized
          previous: /* @__PURE__ */ new Set([e]),
          next: /* @__PURE__ */ new Set()
        }, this.connectedVertices[l] = this.allVertices[l]);
      });
    }
    this.emit("node:added", {
      key: e,
      type: "connected",
      value: t
    }), this.needsSort = !0;
  }
  remove(e) {
    const t = this.getKey(e);
    if (this.isolatedVertices[t]) {
      delete this.isolatedVertices[t], delete this.allVertices[t], this.emit("node:removed", {
        key: t,
        type: "isolated"
      });
      return;
    }
    const n = this.connectedVertices[t];
    n && (n.next.forEach((r) => {
      const o = this.connectedVertices[r];
      o && (o.previous.delete(t), o.previous.size === 0 && o.next.size === 0 && this.moveToIsolated(r));
    }), n.previous.forEach((r) => {
      const o = this.connectedVertices[r];
      o && (o.next.delete(t), o.previous.size === 0 && o.next.size === 0 && this.moveToIsolated(r));
    }), delete this.connectedVertices[t], delete this.allVertices[t], this.emit("node:removed", {
      key: t,
      type: "connected"
    }), this.needsSort = !0);
  }
  mapNodes(e) {
    this.needsSort && this.sort();
    const t = [];
    return this.forEachNode((i, n) => {
      t.push(e(i, n));
    }), t;
  }
  forEachNode(e) {
    this.needsSort && this.sort();
    let t = 0;
    for (; t < this.sortedConnectedValues.length; t++)
      e(this.sortedConnectedValues[t], t);
    Reflect.ownKeys(this.isolatedVertices).forEach((i) => {
      const n = this.isolatedVertices[i];
      n.value !== void 0 && e(n.value, t++);
    });
  }
  getValueByKey(e) {
    var t;
    return (t = this.allVertices[e]) == null ? void 0 : t.value;
  }
  getKeyByValue(e) {
    return Reflect.ownKeys(this.connectedVertices).find((t) => this.connectedVertices[t].value === e) ?? Reflect.ownKeys(this.isolatedVertices).find((t) => this.isolatedVertices[t].value === e);
  }
  sort() {
    var o;
    const e = /* @__PURE__ */ new Map(), t = [], i = [], n = Reflect.ownKeys(this.connectedVertices).filter((a) => this.connectedVertices[a].value !== void 0);
    for (n.forEach((a) => {
      e.set(a, 0);
    }), n.forEach((a) => {
      this.connectedVertices[a].next.forEach((c) => {
        this.connectedVertices[c] && e.set(c, (e.get(c) || 0) + 1);
      });
    }), e.forEach((a, l) => {
      a === 0 && t.push(l);
    }); t.length > 0; ) {
      const a = t.shift();
      i.push(a);
      const l = n.find((c) => c === a);
      l && ((o = this.connectedVertices[l]) == null || o.next.forEach((c) => {
        const u = (e.get(c) || 0) - 1;
        e.set(c, u), u === 0 && t.push(c);
      }));
    }
    if (i.length !== n.length)
      throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");
    const r = (a) => a !== void 0;
    this.sortedConnectedValues = i.map((a) => this.connectedVertices[a].value).filter(r), this.needsSort = !1;
  }
  clear() {
    this.allVertices = {}, this.isolatedVertices = {}, this.connectedVertices = {}, this.sortedConnectedValues = [], this.needsSort = !1;
  }
  static isKey(e) {
    return typeof e == "string" || typeof e == "symbol";
  }
  static isValue(e) {
    return typeof e == "object" && "key" in e;
  }
}
class c8 {
  constructor(e, t, i) {
    ht(this, "key");
    ht(this, "stage");
    ht(this, "callback");
    ht(this, "runTask", !0);
    this.stage = e, this.key = t, this.callback = i;
  }
  stop() {
    this.runTask = !1;
  }
  start() {
    this.runTask = !0;
  }
  run(e) {
    this.runTask && this.callback(e);
  }
}
class u8 extends ll {
  constructor(t, i, n) {
    super();
    ht(this, "key");
    ht(this, "scheduler");
    ht(this, "runTask", !0);
    ht(this, "callback", (t, i) => i());
    ht(this, "removeTask", this.remove.bind(this));
    this.scheduler = t, this.key = i, this.start = this.start.bind(this), this.stop = this.stop.bind(this), n && (this.callback = n.bind(this));
  }
  stop() {
    this.runTask = !1;
  }
  start() {
    this.runTask = !0;
  }
  get tasks() {
    return this.sortedVertices;
  }
  createTask(t, i, n) {
    const r = new c8(this, t, i);
    return this.add(t, r, n), r;
  }
  getTask(t) {
    return this.getValueByKey(t);
  }
  run(t) {
    this.runTask && this.callback(t, (i) => {
      this.forEachNode((n) => {
        n.run(i ?? t);
      });
    });
  }
  runWithTiming(t) {
    if (!this.runTask)
      return {};
    const i = {};
    return this.callback(t, (n) => {
      this.forEachNode((r) => {
        const o = performance.now();
        r.run(n ?? t);
        const a = performance.now() - o;
        i[r.key] = a;
      });
    }), i;
  }
  getSchedule() {
    return this.mapNodes((t) => t.key.toString());
  }
}
class h8 extends ll {
  constructor(t) {
    super();
    ht(this, "lastTime", performance.now());
    ht(this, "clampDeltaTo", 0.1);
    ht(this, "removeStage", this.remove.bind(this));
    t != null && t.clampDeltaTo && (this.clampDeltaTo = t.clampDeltaTo), this.run = this.run.bind(this);
  }
  get stages() {
    return this.sortedVertices;
  }
  createStage(t, i) {
    const n = new u8(this, t, i == null ? void 0 : i.callback);
    return this.add(t, n, {
      after: i == null ? void 0 : i.after,
      before: i == null ? void 0 : i.before
    }), n;
  }
  getStage(t) {
    return this.getValueByKey(t);
  }
  /**
   * Runs all the stages in the scheduler.
   *
   * @param time The time in milliseconds since the start of the program.
   */
  run(t) {
    const i = t - this.lastTime;
    this.forEachNode((n) => {
      n.run(Math.min(i / 1e3, this.clampDeltaTo));
    }), this.lastTime = t;
  }
  runWithTiming(t) {
    const i = t - this.lastTime, n = {}, r = performance.now();
    return this.forEachNode((o) => {
      const a = performance.now(), l = o.runWithTiming(Math.min(i / 1e3, this.clampDeltaTo)), c = performance.now() - a;
      n[o.key.toString()] = {
        duration: c,
        tasks: l
      };
    }), {
      total: performance.now() - r,
      stages: n
    };
  }
  getSchedule(t = {
    tasks: !0
  }) {
    return {
      stages: this.mapNodes((i) => {
        if (i === void 0)
          throw new Error("Stage not found");
        return {
          key: i.key.toString(),
          tasks: t.tasks ? i.getSchedule() : void 0
        };
      })
    };
  }
  dispose() {
    this.clear();
  }
}
const d8 = (s) => {
  const e = new h8(), t = e.createStage(Symbol("threlte-main-stage")), i = {
    scheduler: e,
    frameInvalidated: !0,
    autoInvalidations: /* @__PURE__ */ new Set(),
    shouldAdvance: !1,
    advance: () => {
      i.shouldAdvance = !0;
    },
    autoRender: Xn(s.autoRender ?? !0),
    renderMode: Xn(s.renderMode ?? "on-demand"),
    invalidate() {
      i.frameInvalidated = !0;
    },
    mainStage: t,
    shouldRender: () => i.renderMode.current === "always" || i.renderMode.current === "on-demand" && (i.frameInvalidated || i.autoInvalidations.size > 0) || i.renderMode.current === "manual" && i.shouldAdvance,
    renderStage: e.createStage(Symbol("threlte-render-stage"), {
      after: t,
      callback(n, r) {
        i.shouldRender() && r();
      }
    }),
    resetFrameInvalidation() {
      i.frameInvalidated = !1, i.shouldAdvance = !1;
    }
  };
  return Ht(() => {
    i.autoRender.set(s.autoRender ?? !0);
  }), Ht(() => {
    i.renderMode.set(s.renderMode ?? "on-demand");
  }), Ki(() => {
    i.scheduler.dispose();
  }), xr("threlte-scheduler-context", i), i;
}, Q_ = () => {
  const s = sr("threlte-scheduler-context");
  if (!s)
    throw new Error("useScheduler can only be used in a child component to <Canvas>.");
  return s;
}, DS = () => {
  const { size: s } = RS(), { invalidate: e } = Q_(), t = new Fi(75, 0, 0.1, 1e3);
  t.position.z = 5, t.lookAt(0, 0, 0);
  const i = Xn(t);
  ui(s, (r) => {
    if (i.current === t) {
      const o = i.current;
      o.aspect = r.width / r.height, o.updateProjectionMatrix(), e();
    }
  });
  const n = { camera: i };
  return xr("threlte-camera-context", n), n;
}, YI = () => {
  const s = sr("threlte-camera-context");
  if (!s)
    throw new Error("useCamera can only be used in a child component to <Canvas>.");
  return s;
}, f8 = () => {
  const s = {
    removeObjectFromDisposal: (e) => {
      s.disposableObjects.delete(e);
    },
    disposableObjectMounted: (e) => {
      const t = s.disposableObjects.get(e);
      t ? s.disposableObjects.set(e, t + 1) : s.disposableObjects.set(e, 1);
    },
    disposableObjectUnmounted: (e) => {
      const t = s.disposableObjects.get(e);
      t && t > 0 && (s.disposableObjects.set(e, t - 1), t - 1 <= 0 && (s.shouldDispose = !0));
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: !1,
    dispose: async (e = !1) => {
      await aw(), !(!s.shouldDispose && !e) && (s.disposableObjects.forEach((t, i) => {
        var n;
        (t === 0 || e) && ((n = i == null ? void 0 : i.dispose) == null || n.call(i), s.disposableObjects.delete(i));
      }), s.shouldDispose = !1);
    }
  };
  return Ki(() => {
    s.dispose(!0);
  }), xr("threlte-disposal-context", s), s;
}, jI = () => {
  const s = sr("threlte-disposal-context");
  if (!s)
    throw new Error("useDisposal can only be used in a child component to <Canvas>.");
  return s;
}, qI = Symbol("threlte-parent-context"), IS = (s) => {
  const e = Xn(s);
  return xr(qI, e), e;
}, To = () => sr(qI), J0 = Symbol("threlte-parent-object3d-context"), p8 = (s) => {
  const e = tm(s);
  return xr(J0, e), e;
}, ZI = (s) => {
  const e = sr(J0), t = Gn(s), i = Cl([t, e], ([n, r]) => n ?? r);
  return xr(J0, i), t;
}, KI = () => sr(J0);
function ti(s, e, t) {
  if (!s8)
    return {
      task: void 0,
      start: () => {
      },
      stop: () => {
      },
      started: tm(!1)
    };
  let i, n, r;
  ll.isKey(s) ? (i = s, n = e, r = t) : (i = Symbol("useTask"), n = s, r = e);
  const o = Q_();
  let a = o.mainStage;
  if (r) {
    if (r.stage)
      if (ll.isValue(r.stage))
        a = r.stage;
      else {
        const d = o.scheduler.getStage(r.stage);
        if (!d)
          throw new Error(`No stage found with key ${r.stage.toString()}`);
        a = d;
      }
    else if (r.after)
      if (Array.isArray(r.after))
        for (let d = 0; d < r.after.length; d++) {
          const f = r.after[d];
          if (ll.isValue(f)) {
            a = f.stage;
            break;
          }
        }
      else ll.isValue(r.after) && (a = r.after.stage);
    else if (r.before)
      if (Array.isArray(r.before))
        for (let d = 0; d < r.before.length; d++) {
          const f = r.before[d];
          if (ll.isValue(f)) {
            a = f.stage;
            break;
          }
        }
      else ll.isValue(r.before) && (a = r.before.stage);
  }
  const l = Gn(!1), c = a.createTask(i, n, r), u = () => {
    l.set(!0), ((r == null ? void 0 : r.autoInvalidate) ?? !0) && o.autoInvalidations.add(n), c.start();
  }, h = () => {
    l.set(!1), ((r == null ? void 0 : r.autoInvalidate) ?? !0) && o.autoInvalidations.delete(n), c.stop();
  };
  return (r == null ? void 0 : r.autoStart) ?? !0 ? u() : h(), Ki(() => {
    h(), a.removeTask(i);
  }), {
    task: c,
    start: u,
    stop: h,
    started: {
      subscribe: l.subscribe
    }
  };
}
const ey = (s) => {
  const e = { scene: new am() };
  return xr("threlte-scene-context", e), e;
}, $I = () => {
  const s = sr("threlte-scene-context");
  if (!s)
    throw new Error("useScene can only be used in a child component to <Canvas>.");
  return s;
}, m8 = (s) => {
  const { dispose: e } = jI(), { camera: t } = YI(), { scene: i } = $I(), {
    invalidate: n,
    renderStage: r,
    autoRender: o,
    scheduler: a,
    resetFrameInvalidation: l
  } = Q_(), { size: c, canvas: u } = RS(), h = s.createRenderer ? s.createRenderer(u) : new CS({
    canvas: u,
    powerPreference: "high-performance",
    antialias: !0,
    alpha: !0
  }), d = r.createTask(Symbol("threlte-auto-render-task"), () => {
    h.render(i, t.current);
  }), f = {
    renderer: h,
    colorManagementEnabled: Xn(s.colorManagementEnabled ?? !0),
    colorSpace: Xn(s.colorSpace ?? "srgb"),
    dpr: Xn(s.dpr ?? window.devicePixelRatio),
    shadows: Xn(s.shadows ?? rp),
    toneMapping: Xn(s.toneMapping ?? y0),
    autoRenderTask: d
  };
  xr("threlte-renderer-context", f), ui([f.colorManagementEnabled], ([v]) => {
    vn.enabled = v;
  }), ui([f.colorSpace], ([v]) => {
    "outputColorSpace" in h && (h.outputColorSpace = v);
  }), ui([f.dpr], ([v]) => {
    "setPixelRatio" in h && h.setPixelRatio(v);
  });
  const { start: m, stop: g } = ti(
    () => {
      var v;
      !("xr" in h) || (v = h.xr) != null && v.isPresenting || (h.setSize(c.current.width, c.current.height), n(), g());
    },
    {
      before: d,
      autoStart: !1,
      autoInvalidate: !1
    }
  );
  return ui([c], () => {
    m();
  }), ui([f.shadows], ([v]) => {
    "shadowMap" in h && (h.shadowMap.enabled = !!v, v && v !== !0 ? h.shadowMap.type = v : v === !0 && (h.shadowMap.type = rp));
  }), ui([f.toneMapping], ([v]) => {
    "toneMapping" in h && (h.toneMapping = v);
  }), ui([o], ([v]) => (v ? f.autoRenderTask.start() : f.autoRenderTask.stop(), () => {
    f.autoRenderTask.stop();
  })), "setAnimationLoop" in f.renderer && f.renderer.setAnimationLoop((_) => {
    e(), a.run(_), l();
  }), Ki(() => {
    if ("dispose" in f.renderer) {
      const v = f.renderer.dispose;
      v();
    }
  }), Ht(() => {
    f.colorManagementEnabled.set(s.colorManagementEnabled ?? !0);
  }), Ht(() => {
    f.colorSpace.set(s.colorSpace ?? "srgb");
  }), Ht(() => {
    f.toneMapping.set(s.toneMapping ?? y0);
  }), Ht(() => {
    f.shadows.set(s.shadows ?? rp);
  }), Ht(() => {
    f.dpr.set(s.dpr ?? window.devicePixelRatio);
  }), f;
}, g8 = () => {
  const s = sr("threlte-renderer-context");
  if (!s)
    throw new Error("useRenderer can only be used in a child component to <Canvas>.");
  return s;
}, JI = () => {
  const s = Xn({});
  return xr("threlte-user-context", s), s;
}, v8 = () => {
  const s = sr("threlte-user-context");
  if (!s)
    throw new Error("useUserContext can only be used in a child component to <Canvas>.");
  return s;
}, _8 = (s) => {
  const { scene: e } = ey();
  return {
    scene: e,
    ...XI(s),
    ...GI(),
    ...IS(e),
    ...p8(e),
    ...f8(),
    ...d8(s),
    ...DS(),
    ...m8(s),
    ...JI()
  };
};
function LS(s, e) {
  if (new.target) return Rt({ component: LS, ...s });
  Ct(e, !0);
  let t = G(e, "children", 7);
  _8(/* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children"
  ]));
  var n = At(), r = dt(n);
  return Wt(r, t), ut(s, n), Pt({
    get children() {
      return t();
    },
    set children(o) {
      t(o), V();
    },
    $set: Lt,
    $on: (o, a) => It(e, o, a)
  });
}
Ut(LS, { children: {} }, [], [], !0);
var y8 = /* @__PURE__ */ ni('<div class="svelte-1osucwe"><canvas class="svelte-1osucwe"><!></canvas></div>');
const x8 = {
  hash: "svelte-1osucwe",
  code: "div.svelte-1osucwe {position:relative;width:100%;height:100%;}canvas.svelte-1osucwe {display:block;position:relative;width:100%;height:100%;}"
};
function US(s, e) {
  if (new.target) return Rt({ component: US, ...s });
  Ct(e, !0), hP(s, x8);
  let t = G(e, "children", 7), i = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children"
  ]), n = Us(void 0), r = Us(void 0);
  var o = y8(), a = Ic(o), l = Ic(a);
  {
    var c = (u) => {
      LS(u, sn(
        {
          get dom() {
            return pe(r);
          },
          get canvas() {
            return pe(n);
          }
        },
        () => i,
        {
          children: (h, d) => {
            var f = At(), m = dt(f);
            Wt(m, () => t() ?? Bt), ut(h, f);
          },
          $$slots: { default: !0 }
        }
      ));
    };
    Ai(l, (u) => {
      pe(n) && pe(r) && u(c);
    });
  }
  return Dc(a), Vh(a, (u) => In(n, u), () => pe(n)), Dc(o), Vh(o, (u) => In(r, u), () => pe(r)), ut(s, o), Pt({
    get children() {
      return t();
    },
    set children(u) {
      t(u), V();
    },
    $set: Lt,
    $on: (u, h) => It(e, u, h)
  });
}
Ut(US, { children: {} }, [], [], !0);
const cn = () => {
  const s = Q_(), e = g8(), t = YI(), i = $I(), n = RS();
  return {
    advance: s.advance,
    autoRender: s.autoRender,
    autoRenderTask: e.autoRenderTask,
    camera: t.camera,
    colorManagementEnabled: e.colorManagementEnabled,
    colorSpace: e.colorSpace,
    dpr: e.dpr,
    invalidate: s.invalidate,
    mainStage: s.mainStage,
    renderer: e.renderer,
    renderMode: s.renderMode,
    renderStage: s.renderStage,
    scheduler: s.scheduler,
    shadows: e.shadows,
    shouldRender: s.shouldRender,
    dom: n.dom,
    canvas: n.canvas,
    size: n.size,
    toneMapping: e.toneMapping,
    get scene() {
      return i.scene;
    },
    set scene(o) {
      i.scene = o;
    }
  };
}, b8 = (s) => typeof s == "object" && s !== null, w8 = () => {
  const { invalidate: s } = cn();
  let e;
  const t = Gn(), i = To(), n = KI(), r = IS(), o = ZI();
  ui([t, r, i, n], ([c, u, h, d]) => {
    if (e == null || e(), e = void 0, !u) {
      s();
      return;
    }
    if (c !== void 0) {
      if (c) {
        if (typeof c == "function")
          e = c({ ref: u, parent: h, parentObject3D: d });
        else if (bn(c, "Object3D") && bn(u, "Object3D"))
          e = () => c == null ? void 0 : c.remove(u), c == null || c.add(u);
        else if (typeof c == "string") {
          const { target: f, key: m } = WI(h, c), g = f[m];
          e = () => f[m] = g, f[m] = u;
        }
      }
    } else
      bn(u, "Object3D") ? (e = () => d == null ? void 0 : d.remove(u), d == null || d.add(u)) : b8(h) && (bn(u, "Material") ? h.material = u : bn(u, "BufferGeometry") && (h.geometry = u));
    s();
  });
  const a = (c) => {
    t.set(c);
  }, l = (c) => {
    r.set(c), bn(c, "Object3D") && o.set(c);
  };
  return Ki(() => {
    e == null || e(), s();
  }), {
    updateRef: l,
    updateAttach: a
  };
}, S8 = (s) => bn(s, "PerspectiveCamera") || bn(s, "OrthographicCamera"), M8 = () => {
  const { invalidate: s, size: e, camera: t } = cn(), i = Gn(), n = Gn(!0), r = Gn(!1);
  return ui([i, r], ([c, u]) => {
    !c || !u || (t.set(c), s());
  }), ui([i, n, e], ([c, u, h]) => {
    !c || u || (bn(c, "OrthographicCamera") ? (c.left = h.width / -2, c.right = h.width / 2, c.top = h.height / 2, c.bottom = h.height / -2, c.updateProjectionMatrix(), c.updateMatrixWorld(), s()) : bn(c, "PerspectiveCamera") && (c.aspect = h.width / h.height, c.updateProjectionMatrix(), c.updateMatrixWorld(), s()));
  }), {
    updateRef: (c) => {
      S8(c) && i.set(c);
    },
    updateManual: (c) => {
      n.set(c);
    },
    updateMakeDefault: (c) => {
      r.set(c);
    }
  };
}, E8 = (s) => {
  let e, t, i = !1;
  const n = () => {
    e == null || e(), e = s == null ? void 0 : s(t);
  }, r = (o) => {
    t = o, i && n();
  };
  return So(() => {
    n(), i = !0;
  }), Ki(() => e == null ? void 0 : e()), {
    updateRef: r
  };
}, VA = Symbol("threlte-disposable-object-context"), T8 = (s) => typeof (s == null ? void 0 : s.dispose) == "function" && !bn(s, "Scene"), A8 = (s) => {
  let e;
  const t = Gn(void 0), i = Gn(s), { disposableObjectMounted: n, disposableObjectUnmounted: r, removeObjectFromDisposal: o } = jI(), a = sr(VA), l = Cl([i, a ?? Gn(!0)], ([h, d]) => h ?? d ?? !0);
  return xr(VA, l), ui([t, l], ([h, d]) => {
    h === e ? d ? e && n(e) : e && o(e) : d && (e && r(e), h && n(h)), e = h;
  }), Ki(() => {
    if (!Kv(l))
      return;
    const h = Kv(t);
    h && r(h);
  }), {
    updateRef: (h) => {
      T8(h) && t.set(h);
    },
    updateDispose: (h) => {
      i.set(h);
    }
  };
}, C8 = (s) => s !== null && typeof s == "object" && "addEventListener" in s && "removeEventListener" in s, P8 = (s = {}) => {
  const e = (n) => {
    var r;
    n != null && n.type && ((r = s[`on${n.type}`]) == null || r.call(s, n));
  }, t = (n, r) => {
    const o = [];
    for (const a of Object.keys(r))
      a.startsWith("on") && (n.addEventListener(a.slice(2), e), o.push(a));
    return () => {
      for (let a = 0; a < o.length; a++)
        n.removeEventListener(o[a], e);
    };
  };
  return {
    updateRef: (n) => {
      if (C8(n))
        return t(n, s);
    }
  };
};
let C1;
const R8 = (s) => {
  C1 = s;
}, GA = () => {
  const s = C1;
  return C1 = void 0, s;
}, D8 = (s) => {
  const t = sr("threlte-plugin-context");
  if (!t)
    return;
  const i = [], n = Object.values(t);
  if (n.length) {
    const r = s();
    for (let o = 0; o < n.length; o++) {
      const a = n[o], l = a(r);
      l && l.pluginProps && i.push(...l.pluginProps);
    }
  }
  return {
    pluginsProps: i
  };
}, I8 = /* @__PURE__ */ new Set(["$$scope", "$$slots", "type", "args", "attach", "instance"]), L8 = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
]), U8 = (s) => typeof s == "string" || typeof s == "number" || typeof s == "boolean" || typeof s > "u" || s === null, HA = (s, e, t) => {
  var i, n, r;
  return !Array.isArray(t) && typeof t == "number" && typeof ((i = s[e]) == null ? void 0 : i.setScalar) == "function" && // colors do have a setScalar function, but we don't want to use it, because
  // the hex notation (i.e. 0xff0000) is very popular and matches the number
  // type. So we exclude colors here.
  !((n = s[e]) != null && n.isColor) ? (o, a, l) => {
    o[a].setScalar(l);
  } : typeof ((r = s[e]) == null ? void 0 : r.set) == "function" ? Array.isArray(t) ? (o, a, l) => {
    o[a].set(...l);
  } : (o, a, l) => {
    o[a].set(l);
  } : (o, a, l) => {
    o[a] = l;
  };
}, k8 = () => {
  const { invalidate: s } = cn(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), i = (r, o, a, l) => {
    if (U8(a)) {
      const h = e.get(o);
      if (h && h.instance === r && h.value === a)
        return;
      e.set(o, {
        instance: r,
        value: a
      });
    }
    const { key: c, target: u } = WI(r, o);
    if (a != null) {
      const h = t.get(o);
      if (h)
        h(u, c, a);
      else {
        const d = HA(u, c, a);
        t.set(o, d), d(u, c, a);
      }
    } else
      HA(u, c, a)(u, c, a);
    l.manualCamera || L8.has(c) && (u.isPerspectiveCamera || u.isOrthographicCamera) && u.updateProjectionMatrix();
  };
  return {
    updateProp: (r, o, a, l) => {
      var c;
      !I8.has(o) && !((c = l.pluginsProps) != null && c.includes(o)) && i(r, o, a, l), s();
    }
  };
}, O8 = /^\s*class\s+/, F8 = (s) => typeof s != "function" ? !1 : O8.test(s.toString()), N8 = (s) => Array.isArray(s), B8 = (s, e) => F8(s) ? N8(e) ? new s(...e) : new s() : s;
function fp(s, e) {
  if (new.target) return Rt({ component: fp, ...s });
  Ct(e, !0);
  let t = G(e, "is", 23, GA), i = G(e, "args", 7), n = G(e, "attach", 7), r = G(e, "manual", 7, !1), o = G(e, "makeDefault", 7, !1), a = G(e, "dispose", 7), l = G(e, "ref", 15), c = G(e, "oncreate", 7), u = G(e, "children", 7), h = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "is",
    "args",
    "attach",
    "manual",
    "makeDefault",
    "dispose",
    "ref",
    "oncreate",
    "children"
  ]), d = /* @__PURE__ */ wt(() => B8(t(), i()));
  const f = E8(c());
  $e(() => {
    l() !== pe(d) && (l(pe(d)), f.updateRef(pe(d)));
  });
  const m = D8(() => ({
    get ref() {
      return pe(d);
    },
    get args() {
      return i();
    },
    get attach() {
      return n();
    },
    get manual() {
      return r();
    },
    get makeDefault() {
      return o();
    },
    get dispose() {
      return a();
    },
    get props() {
      return h;
    }
  })), { updateProp: g } = k8();
  Object.keys(h).forEach((A) => {
    $e(() => {
      g(pe(d), A, h[A], {
        manualCamera: r(),
        pluginsProps: m == null ? void 0 : m.pluginsProps
      });
    });
  });
  const v = w8();
  $e(() => v.updateAttach(n())), $e(() => v.updateRef(pe(d)));
  const _ = M8();
  $e(() => _.updateRef(pe(d))), $e(() => _.updateManual(r())), $e(() => _.updateMakeDefault(o()));
  const y = A8(a());
  $e(() => y.updateRef(pe(d))), $e(() => y.updateDispose(a()));
  const w = P8(h);
  $e(() => w.updateRef(pe(d)));
  var x = At(), M = dt(x);
  return Wt(M, () => u() ?? Bt, () => ({ ref: pe(d) })), ut(s, x), Pt({
    get is() {
      return t();
    },
    set is(A = GA()) {
      t(A), V();
    },
    get args() {
      return i();
    },
    set args(A) {
      i(A), V();
    },
    get attach() {
      return n();
    },
    set attach(A) {
      n(A), V();
    },
    get manual() {
      return r();
    },
    set manual(A = !1) {
      r(A), V();
    },
    get makeDefault() {
      return o();
    },
    set makeDefault(A = !1) {
      o(A), V();
    },
    get dispose() {
      return a();
    },
    set dispose(A) {
      a(A), V();
    },
    get ref() {
      return l();
    },
    set ref(A) {
      l(A), V();
    },
    get oncreate() {
      return c();
    },
    set oncreate(A) {
      c(A), V();
    },
    get children() {
      return u();
    },
    set children(A) {
      u(A), V();
    },
    $set: Lt,
    $on: (A, E) => It(e, A, E)
  });
}
Ut(
  fp,
  {
    is: {},
    args: {},
    attach: {},
    manual: {},
    makeDefault: {},
    dispose: {},
    ref: {},
    oncreate: {},
    children: {}
  },
  [],
  [],
  !0
);
const z8 = {}, pt = new Proxy(function() {
}, {
  apply(s, e, t) {
    return fp(...t);
  },
  get(s, e) {
    if (typeof e != "string")
      return fp;
    const t = z8[e] || t8[e];
    if (t === void 0)
      throw new Error(`No Three.js module found for ${e}. Did you forget to extend the catalogue?`);
    return R8(t), fp;
  }
});
function kS(s, e) {
  const t = "threlte-plugin-context";
  e && xr(t, {
    ...sr(t),
    [s]: e
  });
}
function wu(s, e) {
  const { scheduler: t } = cn();
  return t.getStage(s) ?? t.createStage(s, e);
}
function OS(s, e, t) {
  const i = v8();
  if (!i)
    throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");
  return s ? s && !e ? Cl(i, (n) => n[s]) : (i.update((n) => {
    if (s in n)
      return n;
    const r = typeof e == "function" ? e() : e;
    return n[s] = r, n;
  }), i.current[s]) : {
    subscribe: i.subscribe
  };
}
function mm(s, e) {
  const { remember: t, clear: i } = PS();
  let n;
  const r = () => {
    var c;
    const l = new s(...(e == null ? void 0 : e.args) ?? []);
    return (c = e == null ? void 0 : e.extend) == null || c.call(e, l), l;
  };
  return {
    load: (l, c) => {
      const u = async (h) => {
        var d;
        if (n || (n = r()), "loadAsync" in n) {
          const f = await n.loadAsync(h, c == null ? void 0 : c.onProgress);
          return ((d = c == null ? void 0 : c.transform) == null ? void 0 : d.call(c, f)) ?? f;
        } else
          return new Promise((f, m) => {
            n.load(h, (g) => {
              var v;
              return f(((v = c == null ? void 0 : c.transform) == null ? void 0 : v.call(c, g)) ?? g);
            }, (g) => {
              var v;
              return (v = c == null ? void 0 : c.onProgress) == null ? void 0 : v.call(c, g);
            }, m);
          });
      };
      if (Array.isArray(l)) {
        const h = l.map((f) => t(() => u(f), [s, f]));
        return nu(Promise.all(h));
      } else if (typeof l == "string") {
        const h = t(() => u(l), [s, l]);
        return nu(h);
      } else {
        const h = Object.values(l).map((f) => t(() => u(f), [s, f]));
        return nu(Promise.all(h).then((f) => Object.fromEntries(Object.entries(l).map(([m], g) => [m, f[g]]))));
      }
    },
    clear: (l) => {
      Array.isArray(l) ? l.forEach((c) => {
        i([s, c]);
      }) : typeof l == "string" ? i([s, l]) : Object.entries(l).forEach(([c, u]) => {
        i([s, c, u]);
      });
    },
    loader: n
  };
}
function WA(s, e) {
  if (e === UD)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
  if (e === Y0 || e === $w) {
    let t = s.getIndex();
    if (t === null) {
      const o = [], a = s.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++)
          o.push(l);
        s.setIndex(o), t = s.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
    }
    const i = t.count - 2, n = [];
    if (e === Y0)
      for (let o = 1; o <= i; o++)
        n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
    else
      for (let o = 0; o < i; o++)
        o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = s.clone();
    return r.setIndex(n), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
}
function FS(s, e = Math.PI / 3) {
  const t = Math.cos(e), i = (1 + 1e-10) * 100, n = [new H(), new H(), new H()], r = new H(), o = new H(), a = new H(), l = new H();
  function c(g) {
    const v = ~~(g.x * i), _ = ~~(g.y * i), y = ~~(g.z * i);
    return `${v},${_},${y}`;
  }
  const u = s.index ? s.toNonIndexed() : s, h = u.attributes.position, d = {};
  for (let g = 0, v = h.count / 3; g < v; g++) {
    const _ = 3 * g, y = n[0].fromBufferAttribute(h, _ + 0), w = n[1].fromBufferAttribute(h, _ + 1), x = n[2].fromBufferAttribute(h, _ + 2);
    r.subVectors(x, w), o.subVectors(y, w);
    const M = new H().crossVectors(r, o).normalize();
    for (let A = 0; A < 3; A++) {
      const E = n[A], C = c(E);
      C in d || (d[C] = []), d[C].push(M);
    }
  }
  const f = new Float32Array(h.count * 3), m = new Nt(f, 3, !1);
  for (let g = 0, v = h.count / 3; g < v; g++) {
    const _ = 3 * g, y = n[0].fromBufferAttribute(h, _ + 0), w = n[1].fromBufferAttribute(h, _ + 1), x = n[2].fromBufferAttribute(h, _ + 2);
    r.subVectors(x, w), o.subVectors(y, w), a.crossVectors(r, o).normalize();
    for (let M = 0; M < 3; M++) {
      const A = n[M], E = c(A), C = d[E];
      l.set(0, 0, 0);
      for (let P = 0, T = C.length; P < T; P++) {
        const I = C[P];
        a.dot(I) > t && l.add(I);
      }
      l.normalize(), m.setXYZ(_ + M, l.x, l.y, l.z);
    }
  }
  return u.setAttribute("normal", m), u;
}
class V8 extends br {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new Y8(t);
    }), this.register(function(t) {
      return new j8(t);
    }), this.register(function(t) {
      return new n7(t);
    }), this.register(function(t) {
      return new i7(t);
    }), this.register(function(t) {
      return new r7(t);
    }), this.register(function(t) {
      return new Z8(t);
    }), this.register(function(t) {
      return new K8(t);
    }), this.register(function(t) {
      return new $8(t);
    }), this.register(function(t) {
      return new J8(t);
    }), this.register(function(t) {
      return new X8(t);
    }), this.register(function(t) {
      return new Q8(t);
    }), this.register(function(t) {
      return new q8(t);
    }), this.register(function(t) {
      return new t7(t);
    }), this.register(function(t) {
      return new e7(t);
    }), this.register(function(t) {
      return new H8(t);
    }), this.register(function(t) {
      return new s7(t);
    }), this.register(function(t) {
      return new o7(t);
    });
  }
  load(e, t, i, n) {
    const r = this;
    let o;
    if (this.resourcePath !== "")
      o = this.resourcePath;
    else if (this.path !== "") {
      const c = Tl.extractUrlBase(e);
      o = Tl.resolveURL(c, this.path);
    } else
      o = Tl.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function(c) {
      n ? n(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
    }, l = new ps(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        r.parse(c, o, function(u) {
          t(u), r.manager.itemEnd(e);
        }, a);
      } catch (u) {
        a(u);
      }
    }, i, a);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, i, n) {
    let r;
    const o = {}, a = {}, l = new TextDecoder();
    if (typeof e == "string")
      r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === QI) {
        try {
          o[_n.KHR_BINARY_GLTF] = new a7(e);
        } catch (h) {
          n && n(h);
          return;
        }
        r = JSON.parse(o[_n.KHR_BINARY_GLTF].content);
      } else
        r = JSON.parse(l.decode(e));
    else
      r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new x7(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](c);
      h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[h.name] = h, o[h.name] = !0;
    }
    if (r.extensionsUsed)
      for (let u = 0; u < r.extensionsUsed.length; ++u) {
        const h = r.extensionsUsed[u], d = r.extensionsRequired || [];
        switch (h) {
          case _n.KHR_MATERIALS_UNLIT:
            o[h] = new W8();
            break;
          case _n.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new l7(r, this.dracoLoader);
            break;
          case _n.KHR_TEXTURE_TRANSFORM:
            o[h] = new c7();
            break;
          case _n.KHR_MESH_QUANTIZATION:
            o[h] = new u7();
            break;
          default:
            d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    c.setExtensions(o), c.setPlugins(a), c.parse(i, n);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function(n, r) {
      i.parse(e, t, n, r);
    });
  }
}
function G8() {
  let s = {};
  return {
    get: function(e) {
      return s[e];
    },
    add: function(e, t) {
      s[e] = t;
    },
    remove: function(e) {
      delete s[e];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const _n = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class H8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, i = "light:" + e;
    let n = t.cache.get(i);
    if (n) return n;
    const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let c;
    const u = new rt(16777215);
    l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], Pi);
    const h = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new q_(u), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new yS(u), c.distance = h;
        break;
      case "spot":
        c = new _S(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), ga(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), n = Promise.resolve(c), t.cache.add(i, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, i = this.parser, r = i.json.nodes[e], a = (r.extensions && r.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return i._getNodeRef(t.cache, a, l);
    });
  }
}
class W8 {
  constructor() {
    this.name = _n.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return qn;
  }
  extendParams(e, t, i) {
    const n = [];
    e.color = new rt(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const o = r.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Pi), e.opacity = o[3];
      }
      r.baseColorTexture !== void 0 && n.push(i.assignTexture(e, "map", r.baseColorTexture, Oi));
    }
    return Promise.all(n);
  }
}
class X8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class Y8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (r.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Be(a, a);
    }
    return Promise.all(r);
  }
}
class j8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name];
    return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
  }
}
class q8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(r);
  }
}
class Z8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new rt(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], Pi);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && r.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Oi)), o.sheenRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r);
  }
}
class K8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && r.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r);
  }
}
class $8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && r.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const a = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new rt().setRGB(a[0], a[1], a[2], Pi), Promise.all(r);
  }
}
class J8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class Q8 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && r.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new rt().setRGB(a[0], a[1], a[2], Pi), o.specularColorTexture !== void 0 && r.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, Oi)), Promise.all(r);
  }
}
class e7 {
  constructor(e) {
    this.parser = e, this.name = _n.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], o = n.extensions[this.name];
    return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && r.push(i.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(r);
  }
}
class t7 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && r.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(r);
  }
}
class n7 {
  constructor(e) {
    this.parser = e, this.name = _n.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, i = t.json, n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const r = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, o);
  }
}
class i7 {
  constructor(e) {
    this.parser = e, this.name = _n.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, n = i.json, r = n.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const o = r.extensions[t], a = n.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return i.loadTextureImage(e, o.source, l);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class r7 {
  constructor(e) {
    this.parser = e, this.name = _n.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, n = i.json, r = n.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const o = r.extensions[t], a = n.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return i.loadTextureImage(e, o.source, l);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class s7 {
  constructor(e) {
    this.name = _n.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const n = i.extensions[this.name], r = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(a) {
        const l = n.byteOffset || 0, c = n.byteLength || 0, u = n.count, h = n.byteStride, d = new Uint8Array(a, l, c);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, n.mode, n.filter).then(function(f) {
          return f.buffer;
        }) : o.ready.then(function() {
          const f = new ArrayBuffer(u * h);
          return o.decodeGltfBuffer(new Uint8Array(f), u, h, d, n.mode, n.filter), f;
        });
      });
    } else
      return null;
  }
}
class o7 {
  constructor(e) {
    this.name = _n.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const n = t.meshes[i.mesh];
    for (const c of n.primitives)
      if (c.mode !== Ys.TRIANGLES && c.mode !== Ys.TRIANGLE_STRIP && c.mode !== Ys.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const o = i.extensions[this.name].attributes, a = [], l = {};
    for (const c in o)
      a.push(this.parser.getDependency("accessor", o[c]).then((u) => (l[c] = u, l[c])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
      const u = c.pop(), h = u.isGroup ? u.children : [u], d = c[0].count, f = [];
      for (const m of h) {
        const g = new _t(), v = new H(), _ = new En(), y = new H(1, 1, 1), w = new Td(m.geometry, m.material, d);
        for (let x = 0; x < d; x++)
          l.TRANSLATION && v.fromBufferAttribute(l.TRANSLATION, x), l.ROTATION && _.fromBufferAttribute(l.ROTATION, x), l.SCALE && y.fromBufferAttribute(l.SCALE, x), w.setMatrixAt(x, g.compose(v, _, y));
        for (const x in l)
          if (x === "_COLOR_0") {
            const M = l[x];
            w.instanceColor = new Jo(M.array, M.itemSize, M.normalized);
          } else x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && m.geometry.setAttribute(x, l[x]);
        tn.prototype.copy.call(w, m), this.parser.assignFinalMaterial(w), f.push(w);
      }
      return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
    }));
  }
}
const QI = "glTF", pf = 12, XA = { JSON: 1313821514, BIN: 5130562 };
class a7 {
  constructor(e) {
    this.name = _n.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, pf), i = new TextDecoder();
    if (this.header = {
      magic: i.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== QI)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - pf, r = new DataView(e, pf);
    let o = 0;
    for (; o < n; ) {
      const a = r.getUint32(o, !0);
      o += 4;
      const l = r.getUint32(o, !0);
      if (o += 4, l === XA.JSON) {
        const c = new Uint8Array(e, pf + o, a);
        this.content = i.decode(c);
      } else if (l === XA.BIN) {
        const c = pf + o;
        this.body = e.slice(c, c + a);
      }
      o += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class l7 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = _n.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json, n = this.dracoLoader, r = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
    for (const u in o) {
      const h = P1[u] || u.toLowerCase();
      a[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = P1[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = i.accessors[e.attributes[u]], f = $h[d.componentType];
        c[h] = f.name, l[h] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(u) {
      return new Promise(function(h, d) {
        n.decodeDracoFile(u, function(f) {
          for (const m in f.attributes) {
            const g = f.attributes[m], v = l[m];
            v !== void 0 && (g.normalized = v);
          }
          h(f);
        }, a, c, Pi, d);
      });
    });
  }
}
class c7 {
  constructor() {
    this.name = _n.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class u7 {
  constructor() {
    this.name = _n.KHR_MESH_QUANTIZATION;
  }
}
class eL extends Pd {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = i[r + o];
    return t;
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, u = n - t, h = (i - t) / u, d = h * h, f = d * h, m = e * c, g = m - c, v = -2 * f + 3 * d, _ = f - d, y = 1 - v, w = _ - d + h;
    for (let x = 0; x !== a; x++) {
      const M = o[g + x + a], A = o[g + x + l] * u, E = o[m + x + a], C = o[m + x] * u;
      r[x] = y * M + w * A + v * E + _ * C;
    }
    return r;
  }
}
const h7 = new En();
class d7 extends eL {
  interpolate_(e, t, i, n) {
    const r = super.interpolate_(e, t, i, n);
    return h7.fromArray(r).normalize().toArray(r), r;
  }
}
const Ys = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, $h = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, YA = {
  9728: Tn,
  9729: Sn,
  9984: m_,
  9985: qh,
  9986: Bc,
  9987: As
}, jA = {
  33071: gr,
  33648: cd,
  10497: Ns
}, Gx = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, P1 = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, tl = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, f7 = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: hd,
  STEP: ud
}, Hx = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function p7(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new fm({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Fs
  })), s.DefaultMaterial;
}
function pc(s, e, t) {
  for (const i in t.extensions)
    s[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
}
function ga(s, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function m7(s, e, t) {
  let i = !1, n = !1, r = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (h.POSITION !== void 0 && (i = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (r = !0), i && n && r) break;
  }
  if (!i && !n && !r) return Promise.resolve(s);
  const o = [], a = [], l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (i) {
      const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : s.attributes.position;
      o.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : s.attributes.normal;
      a.push(d);
    }
    if (r) {
      const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : s.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(a),
    Promise.all(l)
  ]).then(function(c) {
    const u = c[0], h = c[1], d = c[2];
    return i && (s.morphAttributes.position = u), n && (s.morphAttributes.normal = h), r && (s.morphAttributes.color = d), s.morphTargetsRelative = !0, s;
  });
}
function g7(s, e) {
  if (s.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, i = e.weights.length; t < i; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let i = 0, n = t.length; i < n; i++)
        s.morphTargetDictionary[t[i]] = i;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function v7(s) {
  let e;
  const t = s.extensions && s.extensions[_n.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Wx(t.attributes) : e = s.indices + ":" + Wx(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let i = 0, n = s.targets.length; i < n; i++)
      e += ":" + Wx(s.targets[i]);
  return e;
}
function Wx(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let i = 0, n = t.length; i < n; i++)
    e += t[i] + ":" + s[t[i]] + ";";
  return e;
}
function R1(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function _7(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : s.search(/\.ktx2($|\?)/i) > 0 || s.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
}
const y7 = new _t();
class x7 {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new G8(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let i = !1, n = -1, r = !1, o = -1;
    if (typeof navigator < "u") {
      const a = navigator.userAgent;
      i = /^((?!chrome|android).)*safari/i.test(a) === !0;
      const l = a.match(/Version\/(\d+)/);
      n = i && l ? parseInt(l[1], 10) : -1, r = a.indexOf("Firefox") > -1, o = r ? a.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    typeof createImageBitmap > "u" || i && n < 17 || r && o < 98 ? this.textureLoader = new j_(this.options.manager) : this.textureLoader = new AI(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ps(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this, n = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(this._invokeAll(function(o) {
      return o.beforeRoot && o.beforeRoot();
    })).then(function() {
      return Promise.all([
        i.getDependencies("scene"),
        i.getDependencies("animation"),
        i.getDependencies("camera")
      ]);
    }).then(function(o) {
      const a = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: i,
        userData: {}
      };
      return pc(r, a, n), ga(a, n), Promise.all(i._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(a);
      })).then(function() {
        for (const l of a.scenes)
          l.updateMatrixWorld();
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
    for (let n = 0, r = t.length; n < r; n++) {
      const o = t[n].joints;
      for (let a = 0, l = o.length; a < l; a++)
        e[o[a]].isBone = !0;
    }
    for (let n = 0, r = e.length; n < r; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   *
   * @param {Object} cache
   * @param {Object3D} index
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /**
   * Returns a reference to a shared resource, cloning it if necessary.
   *
   * @param {Object} cache
   * @param {number} index
   * @param {Object} object
   * @return {Object}
   */
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const n = i.clone(), r = (o, a) => {
      const l = this.associations.get(o);
      l != null && this.associations.set(a, l);
      for (const [c, u] of o.children.entries())
        r(u, a.children[c]);
    };
    return r(i, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const r = e(t[n]);
      r && i.push(r);
    }
    return i;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const i = e + ":" + t;
    let n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(r, o) {
        return i.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[_n.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(r, o) {
      i.load(Tl.resolveURL(t.uri, n.path), r, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(i) {
      const n = t.byteLength || 0, r = t.byteOffset || 0;
      return i.slice(r, r + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, i = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = Gx[n.type], a = $h[n.componentType], l = n.normalized === !0, c = new a(n.count * o);
      return Promise.resolve(new Nt(c, o, l));
    }
    const r = [];
    return n.bufferView !== void 0 ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), n.sparse !== void 0 && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then(function(o) {
      const a = o[0], l = Gx[n.type], c = $h[n.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, m = n.normalized === !0;
      let g, v;
      if (f && f !== h) {
        const _ = Math.floor(d / f), y = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + _ + ":" + n.count;
        let w = t.cache.get(y);
        w || (g = new c(a, _ * f, n.count * f / u), w = new lm(g, f / u), t.cache.add(y, w)), v = new ss(w, l, d % f / u, m);
      } else
        a === null ? g = new c(n.count * l) : g = new c(a, d, n.count * l), v = new Nt(g, l, m);
      if (n.sparse !== void 0) {
        const _ = Gx.SCALAR, y = $h[n.sparse.indices.componentType], w = n.sparse.indices.byteOffset || 0, x = n.sparse.values.byteOffset || 0, M = new y(o[1], w, n.sparse.count * _), A = new c(o[2], x, n.sparse.count * l);
        a !== null && (v = new Nt(v.array.slice(), v.itemSize, v.normalized)), v.normalized = !1;
        for (let E = 0, C = M.length; E < C; E++) {
          const P = M[E];
          if (v.setX(P, A[E * l]), l >= 2 && v.setY(P, A[E * l + 1]), l >= 3 && v.setZ(P, A[E * l + 2]), l >= 4 && v.setW(P, A[E * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        v.normalized = m;
      }
      return v;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, i = this.options, r = t.textures[e].source, o = t.images[r];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, r, a);
  }
  loadTextureImage(e, t, i) {
    const n = this, r = this.json, o = r.textures[e], a = r.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, i).then(function(u) {
      u.flipY = !1, u.name = o.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
      const d = (r.samplers || {})[o.sampler] || {};
      return u.magFilter = YA[d.magFilter] || Sn, u.minFilter = YA[d.minFilter] || As, u.wrapS = jA[d.wrapS] || Ns, u.wrapT = jA[d.wrapT] || Ns, u.generateMipmaps = !u.isCompressedTexture && u.minFilter !== Tn && u.minFilter !== Sn, n.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const i = this, n = this.json, r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], a = self.URL || self.webkitURL;
    let l = o.uri || "", c = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function(h) {
        c = !0;
        const d = new Blob([h], { type: o.mimeType });
        return l = a.createObjectURL(d), l;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(l).then(function(h) {
      return new Promise(function(d, f) {
        let m = d;
        t.isImageBitmapLoader === !0 && (m = function(g) {
          const v = new ei(g);
          v.needsUpdate = !0, d(v);
        }), t.load(Tl.resolveURL(h, r.path), m, void 0, f);
      });
    }).then(function(h) {
      return c === !0 && a.revokeObjectURL(l), ga(h, o), h.userData.mimeType = o.mimeType || _7(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   *
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @param {string} colorSpace
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, i, n) {
    const r = this;
    return this.getDependency("texture", i.index).then(function(o) {
      if (!o) return null;
      if (i.texCoord !== void 0 && i.texCoord > 0 && (o = o.clone(), o.channel = i.texCoord), r.extensions[_n.KHR_TEXTURE_TRANSFORM]) {
        const a = i.extensions !== void 0 ? i.extensions[_n.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const l = r.associations.get(o);
          o = r.extensions[_n.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), r.associations.set(o, l);
        }
      }
      return n !== void 0 && (o.colorSpace = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const n = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l || (l = new D_(), ji.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(a, l)), i = l;
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l || (l = new Bi(), ji.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, this.cache.add(a, l)), i = l;
    }
    if (n || r || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      n && (a += "derivative-tangents:"), r && (a += "vertex-colors:"), o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l || (l = i.clone(), r && (l.vertexColors = !0), o && (l.flatShading = !0), n && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(i))), i = l;
    }
    e.material = i;
  }
  getMaterialType() {
    return fm;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, i = this.json, n = this.extensions, r = i.materials[e];
    let o;
    const a = {}, l = r.extensions || {}, c = [];
    if (l[_n.KHR_MATERIALS_UNLIT]) {
      const h = n[_n.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), c.push(h.extendParams(a, r, t));
    } else {
      const h = r.pbrMetallicRoughness || {};
      if (a.color = new rt(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        a.color.setRGB(d[0], d[1], d[2], Pi), a.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, Oi)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, a);
      })));
    }
    r.doubleSided === !0 && (a.side = wi);
    const u = r.alphaMode || Hx.OPAQUE;
    if (u === Hx.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === Hx.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && o !== qn && (c.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new Be(1, 1), r.normalTexture.scale !== void 0)) {
      const h = r.normalTexture.scale;
      a.normalScale.set(h, h);
    }
    if (r.occlusionTexture !== void 0 && o !== qn && (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && o !== qn) {
      const h = r.emissiveFactor;
      a.emissive = new rt().setRGB(h[0], h[1], h[2], Pi);
    }
    return r.emissiveTexture !== void 0 && o !== qn && c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, Oi)), Promise.all(c).then(function() {
      const h = new o(a);
      return r.name && (h.name = r.name), ga(h, r), t.associations.set(h, { materials: e }), r.extensions && pc(n, h, r), h;
    });
  }
  /**
   * When Object3D instances are targeted by animation, they need unique names.
   *
   * @param {string} originalName
   * @return {string}
   */
  createUniqueName(e) {
    const t = Mn.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, i = this.extensions, n = this.primitiveCache;
    function r(a) {
      return i[_n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return qA(l, a, t);
      });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], u = v7(c), h = n[u];
      if (h)
        o.push(h.promise);
      else {
        let d;
        c.extensions && c.extensions[_n.KHR_DRACO_MESH_COMPRESSION] ? d = r(c) : d = qA(new Gt(), c, t), n[u] = { primitive: c, promise: d }, o.push(d);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, i = this.json, n = this.extensions, r = i.meshes[e], o = r.primitives, a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const u = o[l].material === void 0 ? p7(this.cache) : this.getDependency("material", o[l].material);
      a.push(u);
    }
    return a.push(t.loadGeometries(o)), Promise.all(a).then(function(l) {
      const c = l.slice(0, l.length - 1), u = l[l.length - 1], h = [];
      for (let f = 0, m = u.length; f < m; f++) {
        const g = u[f], v = o[f];
        let _;
        const y = c[f];
        if (v.mode === Ys.TRIANGLES || v.mode === Ys.TRIANGLE_STRIP || v.mode === Ys.TRIANGLE_FAN || v.mode === void 0)
          _ = r.isSkinnedMesh === !0 ? new P_(g, y) : new it(g, y), _.isSkinnedMesh === !0 && _.normalizeSkinWeights(), v.mode === Ys.TRIANGLE_STRIP ? _.geometry = WA(_.geometry, $w) : v.mode === Ys.TRIANGLE_FAN && (_.geometry = WA(_.geometry, Y0));
        else if (v.mode === Ys.LINES)
          _ = new so(g, y);
        else if (v.mode === Ys.LINE_STRIP)
          _ = new Ui(g, y);
        else if (v.mode === Ys.LINE_LOOP)
          _ = new iS(g, y);
        else if (v.mode === Ys.POINTS)
          _ = new I_(g, y);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
        Object.keys(_.geometry.morphAttributes).length > 0 && g7(_, r), _.name = t.createUniqueName(r.name || "mesh_" + e), ga(_, r), v.extensions && pc(n, _, v), t.assignFinalMaterial(_), h.push(_);
      }
      for (let f = 0, m = h.length; f < m; f++)
        t.associations.set(h[f], {
          meshes: e,
          primitives: f
        });
      if (h.length === 1)
        return r.extensions && pc(n, h[0], r), h[0];
      const d = new Zn();
      r.extensions && pc(n, d, r), t.associations.set(d, { meshes: e });
      for (let f = 0, m = h.length; f < m; f++)
        d.add(h[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e], n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return i.type === "perspective" ? t = new Fi(Kr.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (t = new Ua(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (t.name = this.createUniqueName(i.name)), ga(t, i), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], i = [];
    for (let n = 0, r = t.joints.length; n < r; n++)
      i.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
      const r = n.pop(), o = n, a = [], l = [];
      for (let c = 0, u = o.length; c < u; c++) {
        const h = o[c];
        if (h) {
          a.push(h);
          const d = new _t();
          r !== null && d.fromArray(r.array, c * 16), l.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new um(a, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, i = this, n = t.animations[e], r = n.name ? n.name : "animation_" + e, o = [], a = [], l = [], c = [], u = [];
    for (let h = 0, d = n.channels.length; h < d; h++) {
      const f = n.channels[h], m = n.samplers[f.sampler], g = f.target, v = g.node, _ = n.parameters !== void 0 ? n.parameters[m.input] : m.input, y = n.parameters !== void 0 ? n.parameters[m.output] : m.output;
      g.node !== void 0 && (o.push(this.getDependency("node", v)), a.push(this.getDependency("accessor", _)), l.push(this.getDependency("accessor", y)), c.push(m), u.push(g));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(u)
    ]).then(function(h) {
      const d = h[0], f = h[1], m = h[2], g = h[3], v = h[4], _ = [];
      for (let y = 0, w = d.length; y < w; y++) {
        const x = d[y], M = f[y], A = m[y], E = g[y], C = v[y];
        if (x === void 0) continue;
        x.updateMatrix && x.updateMatrix();
        const P = i._createAnimationTracks(x, M, A, E, C);
        if (P)
          for (let T = 0; T < P.length; T++)
            _.push(P[T]);
      }
      return new pd(r, void 0, _);
    });
  }
  createNodeMesh(e) {
    const t = this.json, i = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(r) {
      const o = i._getNodeRef(i.meshCache, n.mesh, r);
      return n.weights !== void 0 && o.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, c = n.weights.length; l < c; l++)
            a.morphTargetInfluences[l] = n.weights[l];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, i = this, n = t.nodes[e], r = i._loadNodeShallow(e), o = [], a = n.children || [];
    for (let c = 0, u = a.length; c < u; c++)
      o.push(i.getDependency("node", a[c]));
    const l = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
    return Promise.all([
      r,
      Promise.all(o),
      l
    ]).then(function(c) {
      const u = c[0], h = c[1], d = c[2];
      d !== null && u.traverse(function(f) {
        f.isSkinnedMesh && f.bind(d, y7);
      });
      for (let f = 0, m = h.length; f < m; f++)
        u.add(h[f]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, i = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], o = r.name ? n.createUniqueName(r.name) : "", a = [], l = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && a.push(l), r.camera !== void 0 && a.push(n.getDependency("camera", r.camera).then(function(c) {
      return n._getNodeRef(n.cameraCache, r.camera, c);
    })), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[e] = Promise.all(a).then(function(c) {
      let u;
      if (r.isBone === !0 ? u = new R_() : c.length > 1 ? u = new Zn() : c.length === 1 ? u = c[0] : u = new tn(), u !== c[0])
        for (let h = 0, d = c.length; h < d; h++)
          u.add(c[h]);
      if (r.name && (u.userData.name = r.name, u.name = o), ga(u, r), r.extensions && pc(i, u, r), r.matrix !== void 0) {
        const h = new _t();
        h.fromArray(r.matrix), u.applyMatrix4(h);
      } else
        r.translation !== void 0 && u.position.fromArray(r.translation), r.rotation !== void 0 && u.quaternion.fromArray(r.rotation), r.scale !== void 0 && u.scale.fromArray(r.scale);
      return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, i = this.json.scenes[e], n = this, r = new Zn();
    i.name && (r.name = n.createUniqueName(i.name)), ga(r, i), i.extensions && pc(t, r, i);
    const o = i.nodes || [], a = [];
    for (let l = 0, c = o.length; l < c; l++)
      a.push(n.getDependency("node", o[l]));
    return Promise.all(a).then(function(l) {
      for (let u = 0, h = l.length; u < h; u++)
        r.add(l[u]);
      const c = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, f] of n.associations)
          (d instanceof ji || d instanceof ei) && h.set(d, f);
        return u.traverse((d) => {
          const f = n.associations.get(d);
          f != null && h.set(d, f);
        }), h;
      };
      return n.associations = c(r), r;
    });
  }
  _createAnimationTracks(e, t, i, n, r) {
    const o = [], a = e.name ? e.name : e.uuid, l = [];
    tl[r.path] === tl.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
    }) : l.push(a);
    let c;
    switch (tl[r.path]) {
      case tl.weights:
        c = yu;
        break;
      case tl.rotation:
        c = xu;
        break;
      case tl.position:
      case tl.scale:
        c = bu;
        break;
      default:
        switch (i.itemSize) {
          case 1:
            c = yu;
            break;
          case 2:
          case 3:
          default:
            c = bu;
            break;
        }
        break;
    }
    const u = n.interpolation !== void 0 ? f7[n.interpolation] : hd, h = this._getArrayFromAccessor(i);
    for (let d = 0, f = l.length; d < f; d++) {
      const m = new c(
        l[d] + "." + tl[r.path],
        t.array,
        h,
        u
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), o.push(m);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const i = R1(t.constructor), n = new Float32Array(t.length);
      for (let r = 0, o = t.length; r < o; r++)
        n[r] = t[r] * i;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(i) {
      const n = this instanceof xu ? d7 : eL;
      return new n(this.times, this.values, this.getValueSize() / 3, i);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function b7(s, e, t) {
  const i = e.attributes, n = new yn();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION], l = a.min, c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (n.set(
        new H(l[0], l[1], l[2]),
        new H(c[0], c[1], c[2])
      ), a.normalized) {
        const u = R1($h[a.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const a = new H(), l = new H();
    for (let c = 0, u = r.length; c < u; c++) {
      const h = r[c];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION], f = d.min, m = d.max;
        if (f !== void 0 && m !== void 0) {
          if (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))), d.normalized) {
            const g = R1($h[d.componentType]);
            l.multiplyScalar(g);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(a);
  }
  s.boundingBox = n;
  const o = new fi();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, s.boundingSphere = o;
}
function qA(s, e, t) {
  const i = e.attributes, n = [];
  function r(o, a) {
    return t.getDependency("accessor", o).then(function(l) {
      s.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = P1[o] || o.toLowerCase();
    a in s.attributes || n.push(r(i[o], a));
  }
  if (e.indices !== void 0 && !s.index) {
    const o = t.getDependency("accessor", e.indices).then(function(a) {
      s.setIndex(a);
    });
    n.push(o);
  }
  return vn.workingColorSpace !== Pi && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${vn.workingColorSpace}" not supported.`), ga(s, e), b7(s, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? m7(s, e.targets, t) : s;
  });
}
const w7 = (s) => {
  const e = { nodes: {}, materials: {} };
  return s && s.traverse((t) => {
    t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material);
  }), e;
};
function S7(s, e) {
  const t = typeof s == "string" ? e : s, i = mm(V8, {
    extend(o) {
      t != null && t.dracoLoader && o.setDRACOLoader(t.dracoLoader), t != null && t.meshoptDecoder && o.setMeshoptDecoder(t.meshoptDecoder), t != null && t.ktx2Loader && o.setKTX2Loader(t.ktx2Loader);
    }
  }), n = (o) => i.load(o, {
    transform(a) {
      return {
        ...a,
        ...w7(a.scene)
      };
    }
  }), r = typeof s == "string" ? s : void 0;
  return r ? n(r) : {
    load: n
  };
}
const mc = (s) => ({
  subscribe: s.subscribe,
  get current() {
    return s.current;
  }
});
let pp = 0;
const NS = Xn(!1), ty = Xn(!1), BS = Xn(void 0), zS = Xn(0), VS = Xn(0), tL = Xn([]), GS = Xn(0), { onStart: Xx, onLoad: Yx, onError: jx } = Lu;
Lu.onStart = (s, e, t) => {
  Xx == null || Xx(s, e, t), ty.set(!0), BS.set(s), zS.set(e), VS.set(t);
  const i = (e - pp) / (t - pp);
  GS.set(i), i === 1 && NS.set(!0);
};
Lu.onLoad = () => {
  Yx == null || Yx(), ty.set(!1);
};
Lu.onError = (s) => {
  jx == null || jx(s), tL.update((e) => [...e, s]);
};
Lu.onProgress = (s, e, t) => {
  e === t && (pp = t), ty.set(!0), BS.set(s), zS.set(e), VS.set(t);
  const i = (e - pp) / (t - pp) || 1;
  GS.set(i), i === 1 && NS.set(!0);
};
mc(ty), mc(BS), mc(zS), mc(VS), mc(tL), mc(GS), mc(NS);
const nL = (s, e) => {
  const t = mm(j_, e), { renderer: i } = cn();
  return t.load(s, {
    ...e,
    transform: (n) => {
      var r;
      return n.colorSpace = i.outputColorSpace, n.needsUpdate = !0, ((r = e == null ? void 0 : e.transform) == null ? void 0 : r.call(e, n)) ?? n;
    }
  });
};
new H();
new H();
new H();
new fi();
new _t();
new Ol();
new H();
const iL = Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER"), M7 = (s) => {
  const e = Xn(/* @__PURE__ */ new Set()), t = Xn(/* @__PURE__ */ new Map()), i = Gn(!1), n = () => {
    e.current.size === 0 && t.current.size === 0 && i.set(!0);
  }, r = Gn((s == null ? void 0 : s.final) ?? !1), o = (f) => {
    e.update((m) => (m.add(f), m));
  }, a = (f) => {
    e.update((m) => (m.delete(f), m));
  }, l = (f, m) => {
    t.update((g) => (g.set(f, m), g));
  }, c = (f) => {
    t.update((m) => (m.delete(f), m));
  }, u = Cl([e, t, r, i], ([f, m, g, v]) => g && v ? !1 : m.size > 0 ? !0 : f.size > 0), h = {
    suspend(f) {
      o(f), f.catch((m) => {
        l(f, m);
      }).finally(() => {
        a(f), n();
      });
    },
    onComponentDestroy(f) {
      a(f), c(f), n();
    },
    suspended: u
  }, d = Cl(t, (f) => Array.from(f.values()));
  return xr(iL, h), {
    promises: e,
    suspended: u,
    errors: d,
    setFinal: (f) => r.set(f ?? !1)
  };
}, Vl = () => {
  const s = sr(iL), e = /* @__PURE__ */ new Set(), t = (n) => (s && (s.suspend(n), e.add(n)), n), i = {
    suspended: Cl((s == null ? void 0 : s.suspended) ?? tm(!1), (n) => n)
  };
  return Ki(() => {
    if (s) {
      for (const n of e)
        s.onComponentDestroy(n);
      e.clear();
    }
  }), Object.assign(t, i);
};
var E7 = /* @__PURE__ */ ni("<!> <!>", 1);
function rL(s, e) {
  if (new.target) return Rt({
    component: rL,
    ...s
  });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(D, "$parent", t);
  let r = G(e, "textureUrl", 7), o = G(e, "dataUrl", 7, ""), a = G(e, "animation", 7, ""), l = G(e, "loop", 7, !0), c = G(e, "autoplay", 7, !0), u = G(e, "fps", 7, 10), h = G(e, "filter", 7, "nearest"), d = G(e, "alphaTest", 7, 0.1), f = G(e, "delay", 7, 0), m = G(e, "transparent", 7, !0), g = G(e, "flipX", 7, !1), v = G(e, "startFrame", 7, 0), _ = G(e, "endFrame", 7, void 0), y = G(e, "rows", 7, 1), w = G(e, "columns", 7, void 0), x = G(e, "totalFrames", 7, 0), M = G(e, "is", 15), A = G(e, "ref", 15), E = G(e, "onload", 7), C = G(e, "onstart", 7), P = G(e, "onend", 7), T = G(e, "onloop", 7), I = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "textureUrl",
    "dataUrl",
    "animation",
    "loop",
    "autoplay",
    "fps",
    "filter",
    "alphaTest",
    "delay",
    "transparent",
    "flipX",
    "startFrame",
    "endFrame",
    "rows",
    "columns",
    "totalFrames",
    "is",
    "ref",
    "onload",
    "onstart",
    "onend",
    "onloop"
  ]);
  const D = To(), U = ["forward", "reverse"], L = (te) => {
    const Se = U.includes(te);
    return Se || console.warn(`frame tag direction: "${te}" is not supported.${o() != "" ? `
source dataURL: ${o()}` : `
texture URL: ${r()}`}`), Se;
  };
  let k = 0, B = v(), j = 0, q = g() ? -1 : 1, Z = 0, N = 0, z = Us(void 0), J, se = [], K = "forward", Q, de = { w: 0, h: 0 }, ce = 0, _e = Us(!1);
  $e(() => {
    In(_e, pr(n() !== void 0 && bn(n(), "Mesh")));
  }), $e(() => {
    ce = 1e3 / u();
  }), M(M() ?? (pe(_e) ? new qn() : new Pu()));
  const Fe = Vl(), Ie = Fe(nL(r(), {
    transform: (te) => (te.matrixAutoUpdate = !1, te.generateMipmaps = !1, te.premultiplyAlpha = !1, te.wrapS = te.wrapT = Ns, te.magFilter = te.minFilter = h() === "nearest" ? Tn : Sn, te)
  })), Ee = Fe(o() ? mm(ps).load(o(), {
    transform: (te) => {
      if (typeof te == "string")
        try {
          return JSON.parse(te);
        } catch {
          return;
        }
    }
  }) : nu(new Promise((te) => {
    const Se = Ie.subscribe((ye) => {
      ye && (Se(), te(me(ye)));
    });
  }))), me = (te) => {
    const { width: Se, height: ye } = te.image, Ae = w() ?? x();
    j = x();
    const Ce = Se / Ae, Ge = ye / y(), De = {
      frames: {},
      meta: {
        app: "",
        image: "",
        format: "",
        frameTags: [],
        version: "1.0",
        size: { w: Se, h: ye },
        scale: 1
      }
    };
    for (let Ve = 0; Ve < j; Ve += 1) {
      const ze = Math.floor(Ve / Ae), Le = Ve % Ae * Ce, ot = ze * Ge;
      De.frames[`${Ve}`] = {
        frame: { x: Le, y: ot, w: Ce, h: Ge },
        spriteSourceSize: { x: 0, y: 0, w: Ce, h: Ge },
        sourceSize: { w: Ce, h: Ge }
      };
    }
    return De;
  }, xe = (te) => {
    var Ve, ze;
    const Se = de.w / Z, ye = de.h / N, Ae = 1 / Se, Ce = 1 / ye, Ge = q > 0 ? Ae * (te.x / Z) : Ae * (te.x / N) - pe(z).repeat.x, De = Math.abs(1 - Ce) - Ce * (te.y / N);
    (Ve = pe(z)) == null || Ve.offset.set(Ge, De), (ze = pe(z)) == null || ze.updateMatrix();
  }, $ = (te) => {
    var Se;
    J && (Q = J == null ? void 0 : J.meta.frameTags.find((ye) => ye.name === te), K = "forward", Q != null && Q.direction && (K = L(Q == null ? void 0 : Q.direction) ? Q.direction : "forward"), B = K === "forward" ? (Q == null ? void 0 : Q.from) ?? 0 : (Q == null ? void 0 : Q.to) ?? j - 1, xe(J.frames[se[B]].frame), (Se = C()) == null || Se());
  };
  let Ue = !1;
  const Me = async () => {
    Ue = !0, await Promise.all([Ie, Ee]), Ue && (k = performance.now() - f(), Te());
  }, oe = () => {
    Ue = !1, Ye();
  }, { start: Te, stop: Ye } = ti(
    () => {
      var ze, Ze;
      if (!J) return;
      const te = performance.now(), Se = te - k, ye = se[B], { frame: Ae, duration: Ce } = J.frames[ye], Ge = Ce ?? ce;
      if (Se <= Ge) return;
      k = te - Se % Ge;
      const De = K === "forward" ? (Q == null ? void 0 : Q.from) ?? v() ?? 0 : (Q == null ? void 0 : Q.to) ?? _() ?? j - 1, Ve = K === "forward" ? (Q == null ? void 0 : Q.to) ?? _() ?? j - 1 : (Q == null ? void 0 : Q.from) ?? v() ?? 0;
      switch (xe(Ae), K) {
        case "forward":
          B += 1;
          break;
        case "reverse":
          B -= 1;
          break;
      }
      (K === "forward" && B > Ve || K === "reverse" && B < Ve) && (B = De, l() ? (ze = T()) == null || ze() : (oe(), (Ze = P()) == null || Ze()));
    },
    { autoStart: !1 }
  );
  ui([Ie, Ee], ([te, Se]) => {
    var Ae;
    if (te === void 0 || Se === void 0) return;
    In(z, pr(te.clone())), J = Se, se = Object.keys(J.frames), j = se.length, de = J.meta.size;
    const { sourceSize: ye } = Object.values(J.frames)[0];
    Z = ye.w, N = ye.h, pe(z).repeat.set(1 * q / (de.w / Z), 1 / (de.h / N)), $(a()), (Ae = E()) == null || Ae(), c() && Me();
  }), $e(() => {
    $(a()), c() && Me();
  });
  var Oe = At(), X = dt(Oe);
  {
    var Y = (te) => {
      var Se = E7(), ye = dt(Se);
      pt(ye, sn(
        {
          get is() {
            return M();
          },
          get map() {
            return pe(z);
          },
          toneMapped: !1,
          side: wi,
          shadowSide: wi,
          get transparent() {
            return m();
          },
          get alphaTest() {
            return d();
          }
        },
        () => I,
        {
          get ref() {
            return A();
          },
          set ref(Ce) {
            A(Ce);
          }
        }
      ));
      var Ae = Wn(ye, 2);
      Rs(Ae, () => pt.MeshDepthMaterial, (Ce, Ge) => {
        Ge(Ce, {
          attach: "customDepthMaterial",
          depthPacking: Md,
          get map() {
            return pe(z);
          },
          get alphaTest() {
            return d();
          }
        });
      }), ut(te, Se);
    }, fe = (te) => {
      var Se = At(), ye = dt(Se);
      {
        var Ae = (Ce) => {
          pt(Ce, sn(
            {
              get is() {
                return M();
              },
              get map() {
                return pe(z);
              },
              toneMapped: !1,
              get transparent() {
                return m();
              },
              get alphaTest() {
                return d();
              }
            },
            () => I,
            {
              get ref() {
                return A();
              },
              set ref(Ge) {
                A(Ge);
              }
            }
          ));
        };
        Ai(
          ye,
          (Ce) => {
            pe(z) && Ce(Ae);
          },
          !0
        );
      }
      ut(te, Se);
    };
    Ai(X, (te) => {
      pe(z) && pe(_e) ? te(Y) : te(fe, !1);
    });
  }
  ut(s, Oe);
  var ue = Pt({
    play: Me,
    pause: oe,
    get textureUrl() {
      return r();
    },
    set textureUrl(te) {
      r(te), V();
    },
    get dataUrl() {
      return o();
    },
    set dataUrl(te = "") {
      o(te), V();
    },
    get animation() {
      return a();
    },
    set animation(te = "") {
      a(te), V();
    },
    get loop() {
      return l();
    },
    set loop(te = !0) {
      l(te), V();
    },
    get autoplay() {
      return c();
    },
    set autoplay(te = !0) {
      c(te), V();
    },
    get fps() {
      return u();
    },
    set fps(te = 10) {
      u(te), V();
    },
    get filter() {
      return h();
    },
    set filter(te = "nearest") {
      h(te), V();
    },
    get alphaTest() {
      return d();
    },
    set alphaTest(te = 0.1) {
      d(te), V();
    },
    get delay() {
      return f();
    },
    set delay(te = 0) {
      f(te), V();
    },
    get transparent() {
      return m();
    },
    set transparent(te = !0) {
      m(te), V();
    },
    get flipX() {
      return g();
    },
    set flipX(te = !1) {
      g(te), V();
    },
    get startFrame() {
      return v();
    },
    set startFrame(te = 0) {
      v(te), V();
    },
    get endFrame() {
      return _();
    },
    set endFrame(te = void 0) {
      _(te), V();
    },
    get rows() {
      return y();
    },
    set rows(te = 1) {
      y(te), V();
    },
    get columns() {
      return w();
    },
    set columns(te = void 0) {
      w(te), V();
    },
    get totalFrames() {
      return x();
    },
    set totalFrames(te = 0) {
      x(te), V();
    },
    get is() {
      return M();
    },
    set is(te) {
      M(te), V();
    },
    get ref() {
      return A();
    },
    set ref(te) {
      A(te), V();
    },
    get onload() {
      return E();
    },
    set onload(te) {
      E(te), V();
    },
    get onstart() {
      return C();
    },
    set onstart(te) {
      C(te), V();
    },
    get onend() {
      return P();
    },
    set onend(te) {
      P(te), V();
    },
    get onloop() {
      return T();
    },
    set onloop(te) {
      T(te), V();
    },
    $set: Lt,
    $on: (te, Se) => It(e, te, Se)
  });
  return i(), ue;
}
Ut(
  rL,
  {
    textureUrl: {},
    dataUrl: {},
    animation: {},
    loop: {},
    autoplay: {},
    fps: {},
    filter: {},
    alphaTest: {},
    delay: {},
    transparent: {},
    flipX: {},
    startFrame: {},
    endFrame: {},
    rows: {},
    columns: {},
    totalFrames: {},
    is: {},
    ref: {},
    onload: {},
    onstart: {},
    onend: {},
    onloop: {}
  },
  [],
  ["play", "pause"],
  !0
);
var T7 = /* @__PURE__ */ ni("<!> <!> <!>", 1);
function sL(s, e) {
  if (new.target) return Rt({ component: sL, ...s });
  Ct(e, !0);
  let t = G(e, "thresholdAngle", 7, 1), i = G(e, "color", 7, "#ffffff"), n = G(e, "ref", 15), r = G(e, "children", 7), o = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "thresholdAngle",
    "color",
    "ref",
    "children"
  ]);
  const a = rm(To()), l = /* @__PURE__ */ wt(() => {
    if (!bn(a.current, "Mesh"))
      throw new Error("Edges: component must be a child of a Mesh");
    return a.current.geometry;
  });
  return n(new so()), pt(s, sn(
    {
      get is() {
        return n();
      }
    },
    () => o,
    {
      children: (c, u) => {
        var h = T7(), d = dt(h);
        const f = /* @__PURE__ */ wt(() => [pe(l), t()]);
        Rs(d, () => pt.EdgesGeometry, (v, _) => {
          _(v, {
            get args() {
              return pe(f);
            }
          });
        });
        var m = Wn(d, 2);
        Rs(m, () => pt.LineBasicMaterial, (v, _) => {
          _(v, {
            get color() {
              return i();
            }
          });
        });
        var g = Wn(m, 2);
        Wt(g, () => r() ?? Bt, () => ({ ref: n() })), ut(c, h);
      },
      $$slots: { default: !0 }
    }
  )), Pt({
    get thresholdAngle() {
      return t();
    },
    set thresholdAngle(c = 1) {
      t(c), V();
    },
    get color() {
      return i();
    },
    set color(c = "#ffffff") {
      i(c), V();
    },
    get ref() {
      return n();
    },
    set ref(c) {
      n(c), V();
    },
    get children() {
      return r();
    },
    set children(c) {
      r(c), V();
    },
    $set: Lt,
    $on: (c, u) => It(e, c, u)
  });
}
Ut(
  sL,
  {
    thresholdAngle: {},
    color: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
const Su = new H(), ny = new H(), A7 = new H(), C7 = new Be(), ZA = (s, e, t) => {
  const i = Su.setFromMatrixPosition(s.matrixWorld);
  i.project(e);
  const n = t.width / 2, r = t.height / 2;
  return [i.x * n + n, -(i.y * r) + r];
}, P7 = (s, e) => {
  const t = Su.setFromMatrixPosition(s.matrixWorld), i = ny.setFromMatrixPosition(e.matrixWorld), n = t.sub(i), r = e.getWorldDirection(A7);
  return n.angleTo(r) > Math.PI / 2;
}, R7 = (s, e, t, i) => {
  const n = Su.setFromMatrixPosition(s.matrixWorld), r = ny.copy(Su);
  r.project(e), t.setFromCamera(C7.set(r.x, r.y), e);
  const o = t.intersectObjects(i, !0);
  if (o.length) {
    const a = o[0].distance;
    return n.distanceTo(t.ray.origin) < a;
  }
  return !0;
}, D7 = (s, e) => {
  if (bn(e, "OrthographicCamera"))
    return e.zoom;
  if (bn(e, "PerspectiveCamera")) {
    const t = Su.setFromMatrixPosition(s.matrixWorld), i = ny.setFromMatrixPosition(e.matrixWorld), n = e.fov * Math.PI / 180, r = t.distanceTo(i);
    return 1 / (2 * Math.tan(n / 2) * r);
  } else
    return 1;
}, I7 = (s, e, t) => {
  const i = Su.setFromMatrixPosition(s.matrixWorld), n = ny.setFromMatrixPosition(e.matrixWorld), r = i.distanceTo(n), o = (t[1] - t[0]) / (e.far - e.near), a = t[1] - o * e.far;
  return Math.round(o * r + a);
}, tr = (s) => Math.abs(s) < 1e-10 ? 0 : s, oL = (s, e, t = "") => {
  const { elements: i } = s;
  return `${t}matrix3d(
    ${tr(e[0] * i[0])},${tr(e[1] * i[1])},${tr(e[2] * i[2])},${tr(e[3] * i[3])},
    ${tr(e[4] * i[4])},${tr(e[5] * i[5])},${tr(e[6] * i[6])},${tr(e[7] * i[7])},
    ${tr(e[8] * i[8])},${tr(e[9] * i[9])},${tr(e[10] * i[10])},${tr(e[11] * i[11])},
    ${tr(e[12] * i[12])},${tr(e[13] * i[13])},${tr(e[14] * i[14])},${tr(e[15] * i[15])}
  )`;
}, L7 = /* @__PURE__ */ ((s) => (e) => oL(e, s))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), U7 = /* @__PURE__ */ ((s) => (e, t) => oL(e, s(t), "translate(-50%,-50%)"))((s) => [
  1 / s,
  1 / s,
  1 / s,
  1,
  -1 / s,
  -1 / s,
  -1 / s,
  -1,
  1 / s,
  1 / s,
  1 / s,
  1,
  1,
  1,
  1,
  1
]), k7 = (s, e, t) => {
  if (bn(s, "OrthographicCamera"))
    return 1;
  if (bn(s, "PerspectiveCamera")) {
    const { width: i, height: n } = t, r = s.getWorldPosition(Su).distanceTo(e), o = s.fov * Math.PI / 180, l = 2 * Math.tan(o / 2) * r * (i / n);
    return i / l;
  }
  throw new Error("getViewportFactor needs a Perspective or Orthographic Camera");
}, O7 = `
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    #include <logdepthbuf_vertex>
}`, KA = `
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
}`, F7 = `
#include <common>
#include <logdepthbuf_pars_vertex>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;
  
  // This is somewhat arbitrary, but it seems to work well
  // Need to figure out how to derive this dynamically if it even matters
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale = vec2(
    length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) ),
    length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) )
  );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
  #include <logdepthbuf_vertex>
}`;
let Vg = !1, Q0 = 0, $A = "", JA = "", QA = "";
const e2 = (s, e) => {
  Q0 === 1 && !Vg ? ($A = s.style.zIndex, JA = s.style.position, QA = s.style.pointerEvents, s.style.zIndex = `${Math.floor(e / 2)}`, s.style.position = "absolute", s.style.pointerEvents = "none", Vg = !0) : Q0 === 0 && Vg && (s.style.zIndex = $A, s.style.position = JA, s.style.pointerEvents = QA, Vg = !1);
};
var N7 = /* @__PURE__ */ ni("<!> <!>", 1), B7 = /* @__PURE__ */ ni("<div><div><div><!></div></div></div>"), z7 = /* @__PURE__ */ ni("<div><!></div>"), V7 = /* @__PURE__ */ ni("<!> <!>", 1);
function aL(s, e) {
  if (new.target) return Rt({ component: aL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(k, "$size", t), r = () => Bn(U, "$camera", t);
  let o = G(e, "autoRender", 7, !0), a = G(e, "eps", 7, 1e-3), l = G(e, "center", 7, !1), c = G(e, "fullscreen", 7, !1), u = G(e, "portal", 7), h = G(e, "distanceFactor", 7), d = G(e, "sprite", 7, !1), f = G(e, "transform", 7, !1), m = G(e, "occlude", 7, !1), g = G(e, "castShadow", 7), v = G(e, "receiveShadow", 7), _ = G(e, "material", 7), y = G(e, "geometry", 7), w = G(e, "zIndexRange", 23, () => [16777271, 0]), x = G(e, "calculatePosition", 7, ZA), M = G(e, "as", 7, "div"), A = G(e, "wrapperClass", 7), E = G(e, "pointerEvents", 7, "auto"), C = G(e, "ref", 15), P = G(e, "visible", 15), T = G(e, "style", 7), I = G(e, "children", 7), D = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "autoRender",
    "eps",
    "center",
    "fullscreen",
    "portal",
    "distanceFactor",
    "sprite",
    "transform",
    "occlude",
    "castShadow",
    "receiveShadow",
    "material",
    "geometry",
    "zIndexRange",
    "calculatePosition",
    "as",
    "wrapperClass",
    "pointerEvents",
    "ref",
    "visible",
    "style",
    "children"
  ]);
  P(!0);
  const { camera: U, scene: L, size: k, dom: B, canvas: j } = cn(), q = new Zn();
  let Z = document.createElement(M()), N = 0, z = [0, 0], J = Us(void 0), se = Us(void 0), K = !1;
  const Q = new it(), de = new K_();
  let ce = /* @__PURE__ */ wt(() => m() && m() !== "blending" || Array.isArray(m()) && m().length > 0), _e = new _t(), Fe = /* @__PURE__ */ wt(() => n().width), Ie = /* @__PURE__ */ wt(() => n().height), Ee = /* @__PURE__ */ wt(() => pe(Fe) / 2), me = /* @__PURE__ */ wt(() => pe(Ie) / 2), xe = /* @__PURE__ */ wt(() => r().projectionMatrix.elements[5] * pe(me)), $ = /* @__PURE__ */ wt(() => k7(r(), new H(), n()));
  $e(() => {
    A() && (Z.className = A());
  }), $e(() => (m() === "blending" && (Q0 += 1, e2(j, w()[0])), () => {
    Q0 -= 1, e2(j, w()[0]);
  }));
  const Ue = () => {
    U.current.updateMatrixWorld(), q.updateWorldMatrix(!0, !1);
    const ue = f() ? z : x()(q, U.current, n());
    if (f() || Math.abs(N - U.current.zoom) > a() || Math.abs(z[0] - ue[0]) > a() || Math.abs(z[1] - ue[1]) > a()) {
      const te = P7(q, U.current);
      let Se = !1;
      pe(ce) && (Array.isArray(m()) ? Se = m() : m() !== "blending" && (Se = [L]));
      const ye = P();
      if (Se) {
        const Ge = R7(q, U.current, de, Se);
        P(Ge && !te);
      } else
        P(!te);
      ye !== P() && (e.onvisibilitychange ? e.onvisibilitychange(P()) : Z.style.display = P() ? "block" : "none");
      const Ae = Math.floor(w()[0] / 2), Ce = m() ? pe(ce) ? [
        w()[0],
        //
        Ae
      ] : [Ae - 1, 0] : w();
      if (Z.style.zIndex = `${I7(q, U.current, Ce)}`, f() && pe(J) && pe(se)) {
        const {
          isOrthographicCamera: Ge,
          top: De,
          left: Ve,
          bottom: ze,
          right: Ze
        } = U.current, Le = L7(U.current.matrixWorldInverse), ot = Ge ? `scale(${pe(xe)})translate(${tr(-(Ze + Ve) / 2)}px,${tr((De + ze) / 2)}px)` : `translateZ(${pe(xe)}px)`;
        d() ? (_e.copy(U.current.matrixWorldInverse).transpose().copyPosition(_e).scale(q.scale), _e.elements[3] = _e.elements[7] = _e.elements[11] = 0, _e.elements[15] = 1) : _e.copy(q.matrixWorld), Z.style.width = `${pe(Fe)}px`, Z.style.height = `${pe(Ie)}px`, Z.style.perspective = Ge ? "" : `${pe(xe)}px`, pe(J).style.transform = `${ot}${Le}translate(${pe(Ee)}px,${pe(me)}px)`, pe(se).style.transform = U7(_e, 1 / ((h() || 10) / 400));
      } else {
        const Ge = h() === void 0 ? 1 : D7(q, U.current) * h();
        Z.style.transform = `translate3d(${ue[0]}px,${ue[1]}px,0) scale(${Ge})`;
      }
      z = ue, N = U.current.zoom;
    }
    if (!pe(ce) && !K)
      if (f() && pe(J)) {
        const te = pe(J).children[0];
        if (te != null && te.clientWidth && (te != null && te.clientHeight)) {
          const { isOrthographicCamera: Se } = U.current;
          if (Se || y()) {
            const { scale: ye } = D;
            ye && (Array.isArray(ye) ? Q.scale.set(1 / ye[0], 1 / ye[1], 1 / ye[2]) : Q.scale.setScalar(1 / ye));
          } else {
            const ye = (h() ?? 10) / 400, Ae = te.clientWidth * ye, Ce = te.clientHeight * ye;
            Q.scale.set(Ae, Ce, 1);
          }
          K = !0;
        }
      } else {
        const te = Z.children[0];
        if (te != null && te.clientWidth && (te != null && te.clientHeight)) {
          const Se = 1 / pe($), ye = te.clientWidth * Se, Ae = te.clientHeight * Se;
          Q.scale.set(ye, Ae, 1), K = !0;
        }
        Q.lookAt(U.current.position);
      }
  }, { start: Me, stop: oe } = ti(Ue, { autoStart: !1 });
  Ht(() => {
    if (o())
      return Me(), () => {
        oe();
      };
  });
  let Te = /* @__PURE__ */ wt(() => (L.updateMatrixWorld(), x()(q, r(), n())));
  const Ye = (ue) => {
    const te = u() ?? B;
    if (!te) {
      console.warn("<HTML>: target is undefined.");
      return;
    }
    return te.append(ue), { destroy: () => ue.remove() };
  };
  var Oe = V7(), X = dt(Oe);
  pt(X, sn({ is: q }, () => D, {
    get ref() {
      return C();
    },
    set ref(ue) {
      C(ue);
    },
    children: (ue, te) => {
      var Se = At(), ye = dt(Se);
      {
        var Ae = (Ce) => {
          pt(Ce, {
            is: Q,
            get castShadow() {
              return g();
            },
            get receiveShadow() {
              return v();
            },
            children: (Ge, De) => {
              var Ve = N7(), ze = dt(Ve);
              {
                var Ze = (le) => {
                  pt(le, {
                    get is() {
                      return y();
                    }
                  });
                }, Le = (le) => {
                  var ve = At(), be = dt(ve);
                  Rs(be, () => pt.PlaneGeometry, (Xe, We) => {
                    We(Xe, {});
                  }), ut(le, ve);
                };
                Ai(ze, (le) => {
                  y() ? le(Ze) : le(Le, !1);
                });
              }
              var ot = Wn(ze, 2);
              {
                var tt = (le) => {
                  pt(le, {
                    get is() {
                      return _();
                    }
                  });
                }, mt = (le) => {
                  var ve = At(), be = dt(ve);
                  {
                    var Xe = (Ne) => {
                      var ct = At(), gt = dt(ct);
                      Rs(gt, () => pt.ShaderMaterial, (nt, je) => {
                        je(nt, {
                          side: wi,
                          vertexShader: F7,
                          fragmentShader: KA
                        });
                      }), ut(Ne, ct);
                    }, We = (Ne) => {
                      var ct = At(), gt = dt(ct);
                      Rs(gt, () => pt.ShaderMaterial, (nt, je) => {
                        je(nt, {
                          side: wi,
                          vertexShader: O7,
                          fragmentShader: KA
                        });
                      }), ut(Ne, ct);
                    };
                    Ai(
                      be,
                      (Ne) => {
                        f() ? Ne(We, !1) : Ne(Xe);
                      },
                      !0
                    );
                  }
                  ut(le, ve);
                };
                Ai(ot, (le) => {
                  _() ? le(tt) : le(mt, !1);
                });
              }
              ut(Ge, Ve);
            },
            $$slots: { default: !0 }
          });
        };
        Ai(ye, (Ce) => {
          m() && !pe(ce) && Ce(Ae);
        });
      }
      ut(ue, Se);
    },
    $$slots: { default: !0 }
  }));
  var Y = Wn(X, 2);
  SF(Y, M, !1, (ue, te) => {
    MF(ue, (Ge) => Ye == null ? void 0 : Ye(Ge)), Vh(ue, (Ge) => Z = Ge, () => Z), yi(ue, "position", "absolute"), yi(ue, "top", "0"), yi(ue, "left", "0"), By(() => {
      yi(ue, "pointer-events", f() ? "none" : void 0), yi(ue, "overflow", f() ? "hidden" : void 0), yi(ue, "transform", f() ? void 0 : `translate3d(${pe(Te)[0]}px,${pe(Te)[1]}px,0)`), yi(ue, "transform-origin", f() ? void 0 : "0 0");
    });
    var Se = At(), ye = dt(Se);
    {
      var Ae = (Ge) => {
        var De = B7();
        yi(De, "position", "absolute"), yi(De, "top", "0"), yi(De, "left", "0"), yi(De, "transform-style", "preserve-3d"), yi(De, "pointer-events", "none");
        var Ve = Ic(De);
        yi(Ve, "position", "absolute");
        var ze = Ic(Ve), Ze = Ic(ze);
        Wt(Ze, () => I() ?? Bt, () => ({ render: Ue, startRendering: Me, stopRendering: oe })), Dc(ze), Dc(Ve), Vh(Ve, (Le) => In(se, Le), () => pe(se)), Dc(De), Vh(De, (Le) => In(J, Le), () => pe(J)), By(() => {
          yi(De, "width", `${pe(Fe)}px`), yi(De, "height", `${pe(Ie)}px`), yi(Ve, "pointer-events", E()), gE(ze, fE(e.class)), pE(ze, "style", e.style);
        }), ut(Ge, De);
      }, Ce = (Ge) => {
        var De = z7(), Ve = Ic(De);
        Wt(Ve, () => I() ?? Bt, () => ({ render: Ue, startRendering: Me, stopRendering: oe })), Dc(De), By(() => {
          pE(De, "style", e.style), gE(De, fE(e.class)), yi(De, "position", "absolute"), yi(De, "transform", l() ? "translate3d(-50%,-50%,0)" : "none"), yi(De, "top", c() ? `${-pe(Ie) / 2}px` : void 0), yi(De, "left", c() ? `${-pe(Fe) / 2}px` : void 0), yi(De, "width", c() ? `${pe(Fe)}px` : void 0), yi(De, "height", c() ? `${pe(Ie)}px` : void 0);
        }), ut(Ge, De);
      };
      Ai(ye, (Ge) => {
        f() ? Ge(Ae) : Ge(Ce, !1);
      });
    }
    ut(te, Se);
  }), ut(s, Oe);
  var fe = Pt({
    render: Ue,
    startRendering: Me,
    stopRendering: oe,
    get autoRender() {
      return o();
    },
    set autoRender(ue = !0) {
      o(ue), V();
    },
    get eps() {
      return a();
    },
    set eps(ue = 1e-3) {
      a(ue), V();
    },
    get center() {
      return l();
    },
    set center(ue = !1) {
      l(ue), V();
    },
    get fullscreen() {
      return c();
    },
    set fullscreen(ue = !1) {
      c(ue), V();
    },
    get portal() {
      return u();
    },
    set portal(ue) {
      u(ue), V();
    },
    get distanceFactor() {
      return h();
    },
    set distanceFactor(ue) {
      h(ue), V();
    },
    get sprite() {
      return d();
    },
    set sprite(ue = !1) {
      d(ue), V();
    },
    get transform() {
      return f();
    },
    set transform(ue = !1) {
      f(ue), V();
    },
    get occlude() {
      return m();
    },
    set occlude(ue = !1) {
      m(ue), V();
    },
    get castShadow() {
      return g();
    },
    set castShadow(ue) {
      g(ue), V();
    },
    get receiveShadow() {
      return v();
    },
    set receiveShadow(ue) {
      v(ue), V();
    },
    get material() {
      return _();
    },
    set material(ue) {
      _(ue), V();
    },
    get geometry() {
      return y();
    },
    set geometry(ue) {
      y(ue), V();
    },
    get zIndexRange() {
      return w();
    },
    set zIndexRange(ue = [16777271, 0]) {
      w(ue), V();
    },
    get calculatePosition() {
      return x();
    },
    set calculatePosition(ue = ZA) {
      x(ue), V();
    },
    get as() {
      return M();
    },
    set as(ue = "div") {
      M(ue), V();
    },
    get wrapperClass() {
      return A();
    },
    set wrapperClass(ue) {
      A(ue), V();
    },
    get pointerEvents() {
      return E();
    },
    set pointerEvents(ue = "auto") {
      E(ue), V();
    },
    get ref() {
      return C();
    },
    set ref(ue) {
      C(ue), V();
    },
    get visible() {
      return P();
    },
    set visible(ue) {
      P(ue), V();
    },
    get style() {
      return T();
    },
    set style(ue) {
      T(ue), V();
    },
    get children() {
      return I();
    },
    set children(ue) {
      I(ue), V();
    },
    $set: Lt,
    $on: (ue, te) => It(e, ue, te)
  });
  return i(), fe;
}
Ut(
  aL,
  {
    autoRender: {},
    eps: {},
    center: {},
    fullscreen: {},
    portal: {},
    distanceFactor: {},
    sprite: {},
    transform: {},
    occlude: {},
    castShadow: {},
    receiveShadow: {},
    material: {},
    geometry: {},
    zIndexRange: {},
    calculatePosition: {},
    as: {},
    wrapperClass: {},
    pointerEvents: {},
    ref: {},
    visible: {},
    style: {},
    children: {}
  },
  [],
  ["render", "startRendering", "stopRendering"],
  !0
);
function lL(s, e) {
  if (new.target) return Rt({ component: lL, ...s });
  Ct(e, !0);
  const { scene: t } = ey(), { camera: i } = DS(), { renderStage: n, renderer: r, toneMapping: o } = cn();
  let a = G(e, "autoRender", 7, !0), l = G(e, "toneMapping", 7), c = G(e, "stage", 7, n), u = G(e, "ref", 15), h = G(e, "children", 7);
  const d = Symbol("threlte-hud-render-stage");
  return $e(() => {
    if (a())
      return c().createTask(d, () => {
        const { autoClear: f } = r;
        r.autoClear = !1, r.toneMapping = l() ?? o.current, r.clearDepth(), r.render(t, i.current), r.autoClear = f, r.toneMapping = o.current;
      }), () => c().removeTask(d);
  }), pt(s, {
    is: t,
    attach: !1,
    get ref() {
      return u();
    },
    set ref(f) {
      u(f);
    },
    children: (f, m) => {
      var g = At(), v = dt(g);
      Wt(v, () => h() ?? Bt, () => ({ ref: t })), ut(f, g);
    },
    $$slots: { default: !0 }
  }), Pt({
    get autoRender() {
      return a();
    },
    set autoRender(f = !0) {
      a(f), V();
    },
    get toneMapping() {
      return l();
    },
    set toneMapping(f) {
      l(f), V();
    },
    get stage() {
      return c();
    },
    set stage(f = n) {
      c(f), V();
    },
    get ref() {
      return u();
    },
    set ref(f) {
      u(f), V();
    },
    get children() {
      return h();
    },
    set children(f) {
      h(f), V();
    },
    $set: Lt,
    $on: (f, m) => It(e, f, m)
  });
}
Ut(
  lL,
  {
    autoRender: {},
    toneMapping: {},
    stage: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
function cL(s, e) {
  if (new.target) return Rt({ component: cL, ...s });
  Ct(e, !0);
  let t = G(e, "speed", 7, 1), i = G(e, "floatIntensity", 7, 1), n = G(e, "floatingRange", 23, () => [-0.1, 0.1]), r = G(e, "rotationSpeed", 7, 0), o = G(e, "rotationIntensity", 7, 0), a = G(e, "seed", 23, () => 1e4 * Math.random()), l = G(e, "ref", 15), c = G(e, "children", 7), u = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "speed",
    "floatIntensity",
    "floatingRange",
    "rotationSpeed",
    "rotationIntensity",
    "seed",
    "ref",
    "children"
  ]);
  const h = new Zn(), d = new Zn();
  let f = a();
  const m = Kr.mapLinear;
  let g = /* @__PURE__ */ wt(() => Array.isArray(t()) ? t() : [t(), t(), t()]), v = /* @__PURE__ */ wt(() => Array.isArray(i()) ? i() : [
    i(),
    i(),
    i()
  ]), _ = /* @__PURE__ */ wt(() => n().length === 3 ? n() : [[0, 0], n(), [0, 0]]), y = /* @__PURE__ */ wt(() => Array.isArray(r()) ? r() : [
    r(),
    r(),
    r()
  ]), w = /* @__PURE__ */ wt(() => Array.isArray(o()) ? o() : [
    o(),
    o(),
    o()
  ]);
  return ti((x) => {
    f += x, d.position.x = m(Math.sin(f / 4 * pe(g)[0]) / 10, -0.1, 0.1, ...pe(_)[0]) * pe(v)[0], d.position.y = m(Math.sin(f / 4 * pe(g)[1]) / 10, -0.1, 0.1, ...pe(_)[1]) * pe(v)[1], d.position.z = m(Math.sin(f / 4 * pe(g)[2]) / 10, -0.1, 0.1, ...pe(_)[2]) * pe(v)[2], d.rotation.x = Math.cos(f / 4 * pe(y)[0]) / 8 * pe(w)[0], d.rotation.y = Math.sin(f / 4 * pe(y)[1]) / 8 * pe(w)[1], d.rotation.z = Math.sin(f / 4 * pe(y)[2]) / 20 * pe(w)[2], d.updateMatrix();
  }), pt(s, sn({ is: h }, () => u, {
    children: (x, M) => {
      pt(x, {
        is: d,
        matrixAutoUpdate: !1,
        get ref() {
          return l();
        },
        set ref(A) {
          l(A);
        },
        children: (A, E) => {
          var C = At(), P = dt(C);
          Wt(P, () => c() ?? Bt, () => ({ ref: d })), ut(A, C);
        },
        $$slots: { default: !0 }
      });
    },
    $$slots: { default: !0 }
  })), Pt({
    get speed() {
      return t();
    },
    set speed(x = 1) {
      t(x), V();
    },
    get floatIntensity() {
      return i();
    },
    set floatIntensity(x = 1) {
      i(x), V();
    },
    get floatingRange() {
      return n();
    },
    set floatingRange(x = [-0.1, 0.1]) {
      n(x), V();
    },
    get rotationSpeed() {
      return r();
    },
    set rotationSpeed(x = 0) {
      r(x), V();
    },
    get rotationIntensity() {
      return o();
    },
    set rotationIntensity(x = 0) {
      o(x), V();
    },
    get seed() {
      return a();
    },
    set seed(x = 1e4 * Math.random()) {
      a(x), V();
    },
    get ref() {
      return l();
    },
    set ref(x) {
      l(x), V();
    },
    get children() {
      return c();
    },
    set children(x) {
      c(x), V();
    },
    $set: Lt,
    $on: (x, M) => It(e, x, M)
  });
}
Ut(
  cL,
  {
    speed: {},
    floatIntensity: {},
    floatingRange: {},
    rotationSpeed: {},
    rotationIntensity: {},
    seed: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
function uL(s, e) {
  if (new.target) return Rt({ component: uL, ...s });
  Ct(e, !0);
  let t = G(e, "url", 7), i = G(e, "dracoLoader", 7), n = G(e, "meshoptDecoder", 7), r = G(e, "ktx2Loader", 7), o = G(e, "gltf", 15), a = G(e, "scene", 15), l = G(e, "animations", 15), c = G(e, "asset", 15), u = G(e, "cameras", 15), h = G(e, "scenes", 15), d = G(e, "userData", 15), f = G(e, "parser", 15), m = G(e, "materials", 15), g = G(e, "nodes", 15), v = G(e, "onload", 7), _ = G(e, "onunload", 7), y = G(e, "onerror", 7), w = G(e, "children", 7), x = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "url",
    "dracoLoader",
    "meshoptDecoder",
    "ktx2Loader",
    "gltf",
    "scene",
    "animations",
    "asset",
    "cameras",
    "scenes",
    "userData",
    "parser",
    "materials",
    "nodes",
    "onload",
    "onunload",
    "onerror",
    "children"
  ]);
  const M = S7({
    dracoLoader: i(),
    meshoptDecoder: n(),
    ktx2Loader: r()
  }), A = (U) => {
    var L, k;
    o() && ((L = _()) == null || L()), o(U), a(U.scene), l(U.animations), c(U.asset), u(U.cameras), h(U.scenes), d(U.userData), f(U.parser), m(U.materials), g(U.nodes), (k = v()) == null || k(o());
  }, E = (U) => {
    var L;
    o(void 0), a(void 0), l(void 0), c(void 0), u(void 0), h(void 0), d(void 0), f(void 0), g(void 0), m(void 0), (L = y()) == null || L(U);
  }, C = Vl(), P = async (U) => {
    try {
      const L = await C(M.load(U));
      A(L);
    } catch (L) {
      E(L);
    }
  };
  $e(() => {
    P(t());
  });
  var T = At(), I = dt(T);
  {
    var D = (U) => {
      pt(U, sn(
        {
          get is() {
            return a();
          }
        },
        () => x,
        {
          children: (L, k) => {
            var B = At(), j = dt(B);
            Wt(j, () => w() ?? Bt, () => ({ ref: a() })), ut(L, B);
          },
          $$slots: { default: !0 }
        }
      ));
    };
    Ai(I, (U) => {
      a() && U(D);
    });
  }
  return ut(s, T), Pt({
    get url() {
      return t();
    },
    set url(U) {
      t(U), V();
    },
    get dracoLoader() {
      return i();
    },
    set dracoLoader(U) {
      i(U), V();
    },
    get meshoptDecoder() {
      return n();
    },
    set meshoptDecoder(U) {
      n(U), V();
    },
    get ktx2Loader() {
      return r();
    },
    set ktx2Loader(U) {
      r(U), V();
    },
    get gltf() {
      return o();
    },
    set gltf(U) {
      o(U), V();
    },
    get scene() {
      return a();
    },
    set scene(U) {
      a(U), V();
    },
    get animations() {
      return l();
    },
    set animations(U) {
      l(U), V();
    },
    get asset() {
      return c();
    },
    set asset(U) {
      c(U), V();
    },
    get cameras() {
      return u();
    },
    set cameras(U) {
      u(U), V();
    },
    get scenes() {
      return h();
    },
    set scenes(U) {
      h(U), V();
    },
    get userData() {
      return d();
    },
    set userData(U) {
      d(U), V();
    },
    get parser() {
      return f();
    },
    set parser(U) {
      f(U), V();
    },
    get materials() {
      return m();
    },
    set materials(U) {
      m(U), V();
    },
    get nodes() {
      return g();
    },
    set nodes(U) {
      g(U), V();
    },
    get onload() {
      return v();
    },
    set onload(U) {
      v(U), V();
    },
    get onunload() {
      return _();
    },
    set onunload(U) {
      _(U), V();
    },
    get onerror() {
      return y();
    },
    set onerror(U) {
      y(U), V();
    },
    get children() {
      return w();
    },
    set children(U) {
      w(U), V();
    },
    $set: Lt,
    $on: (U, L) => It(e, U, L)
  });
}
Ut(
  uL,
  {
    url: {},
    dracoLoader: {},
    meshoptDecoder: {},
    ktx2Loader: {},
    gltf: {},
    scene: {},
    animations: {},
    asset: {},
    cameras: {},
    scenes: {},
    userData: {},
    parser: {},
    materials: {},
    nodes: {},
    onload: {},
    onunload: {},
    onerror: {},
    children: {}
  },
  [],
  [],
  !0
);
var G7 = Object.defineProperty, H7 = (s, e, t) => e in s ? G7(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, On = (s, e, t) => H7(s, typeof e != "symbol" ? e + "" : e, t);
const hL = (s, e) => {
  const [t, i] = e.split("-");
  return Object.assign(s.style, {
    left: i === "left" ? "0" : i === "center" ? "50%" : "",
    right: i === "right" ? "0" : "",
    top: t === "top" ? "0" : t === "bottom" ? "" : "50%",
    bottom: t === "bottom" ? "0" : "",
    transform: `${i === "center" ? "translateX(-50%)" : ""} ${t === "center" ? "translateY(-50%)" : ""}`
  }), e;
}, W7 = ({
  placement: s,
  size: e,
  offset: t,
  id: i,
  className: n
}) => {
  const r = document.createElement("div"), { top: o, left: a, right: l, bottom: c } = t;
  return Object.assign(r.style, {
    id: i,
    position: "absolute",
    zIndex: "1000",
    height: `${e}px`,
    width: `${e}px`,
    margin: `${o}px ${l}px ${c}px ${a}px`,
    borderRadius: "100%"
  }), hL(r, s), i && (r.id = i), n && (r.className = n), r;
}, X7 = (s) => {
  const e = typeof s == "string" ? document.querySelector(s) : s;
  if (!e) throw Error("Invalid DOM element");
  return e;
};
function D1(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
const Y7 = [
  ["x", 0, 3],
  ["y", 1, 4],
  ["z", 2, 5]
], t2 = /* @__PURE__ */ new H();
function n2({ isSphere: s }, e, t) {
  s && (t2.set(0, 0, 1).applyQuaternion(t.quaternion), Y7.forEach(([i, n, r]) => {
    const o = t2[i];
    let a = e[n], l = a.userData.opacity;
    a.material.opacity = D1(o >= 0 ? l : l / 2, 0, 1), a = e[r], l = a.userData.opacity, a.material.opacity = D1(o >= 0 ? l / 2 : l, 0, 1);
  }));
}
const j7 = (s, e, t = 10) => Math.abs(s.clientX - e.x) < t && Math.abs(s.clientY - e.y) < t, i2 = /* @__PURE__ */ new K_(), r2 = /* @__PURE__ */ new Be(), s2 = (s, e, t, i) => {
  r2.set(
    (s.clientX - e.left) / e.width * 2 - 1,
    -((s.clientY - e.top) / e.height) * 2 + 1
  ), i2.setFromCamera(r2, t);
  const n = i2.intersectObjects(
    i,
    !1
  ), r = n.length ? n[0] : null;
  return !r || !r.object.visible ? null : r;
}, qx = 1e-6, q7 = 2 * Math.PI, dL = ["x", "y", "z"], qp = [...dL, "nx", "ny", "nz"], Z7 = [
  "right",
  "top",
  "front",
  "left",
  "bottom",
  "back"
], fL = 1.3, o2 = (s, e = !0) => {
  const { material: t, userData: i } = s, { color: n, opacity: r } = e ? i.hover : i;
  t.color.set(n), t.opacity = r;
}, gc = (s) => JSON.parse(JSON.stringify(s)), K7 = (s) => {
  const e = s.type || "sphere", t = e === "sphere", i = s.resolution || t ? 64 : 128, { container: n } = s;
  s.container = void 0, s = JSON.parse(JSON.stringify(s)), s.container = n, Z7.forEach((l, c) => {
    s[l] && (s[qp[c]] = s[l]);
  });
  const r = {
    enabled: !0,
    color: 16777215,
    opacity: 1,
    scale: 0.7,
    labelColor: 2236962,
    line: !1,
    border: {
      size: 0,
      color: 14540253
    },
    hover: {
      color: t ? 16777215 : 9688043,
      labelColor: 2236962,
      opacity: 1,
      scale: 0.7,
      border: {
        size: 0,
        color: 14540253
      }
    }
  }, o = {
    line: !1,
    scale: t ? 0.45 : 0.7,
    hover: {
      scale: t ? 0.5 : 0.7
    }
  }, a = {
    type: e,
    container: document.body,
    size: 128,
    placement: "top-right",
    resolution: i,
    lineWidth: 20,
    radius: t ? 1 : 0.2,
    smoothness: 18,
    animated: !0,
    speed: 1,
    background: {
      enabled: !0,
      color: t ? 16777215 : 14739180,
      opacity: t ? 0 : 1,
      hover: {
        color: t ? 16777215 : 14739180,
        opacity: t ? 0.2 : 1
      }
    },
    font: {
      family: "sans-serif",
      weight: 900
    },
    offset: {
      top: 10,
      left: 10,
      bottom: 10,
      right: 10
    },
    corners: {
      enabled: !t,
      color: t ? 15915362 : 16777215,
      opacity: 1,
      scale: t ? 0.15 : 0.2,
      radius: 1,
      smoothness: 18,
      hover: {
        color: t ? 16777215 : 9688043,
        opacity: 1,
        scale: t ? 0.2 : 0.225
      }
    },
    edges: {
      enabled: !t,
      color: t ? 15915362 : 16777215,
      opacity: t ? 1 : 0,
      radius: t ? 1 : 0.125,
      smoothness: 18,
      scale: t ? 0.15 : 1,
      hover: {
        color: t ? 16777215 : 9688043,
        opacity: 1,
        scale: t ? 0.2 : 1
      }
    },
    x: {
      ...gc(r),
      ...t ? {
        label: "X",
        color: 16725587,
        line: !0
      } : {
        label: "Right"
      }
    },
    y: {
      ...gc(r),
      ...t ? {
        label: "Y",
        color: 9100032,
        line: !0
      } : {
        label: "Top"
      }
    },
    z: {
      ...gc(r),
      ...t ? {
        label: "Z",
        color: 2920447,
        line: !0
      } : {
        label: "Front"
      }
    },
    nx: {
      ...gc(o),
      label: t ? "" : "Left"
    },
    ny: {
      ...gc(o),
      label: t ? "" : "Bottom"
    },
    nz: {
      ...gc(o),
      label: t ? "" : "Back"
    }
  };
  return I1(s, a), dL.forEach(
    (l) => I1(
      s[`n${l}`],
      gc(s[l])
    )
  ), { ...s, isSphere: t };
};
function I1(s, ...e) {
  if (s instanceof HTMLElement || typeof s != "object" || s === null)
    return s;
  for (const t of e)
    for (const i in t)
      i !== "container" && i in t && (s[i] === void 0 ? s[i] = t[i] : typeof t[i] == "object" && !Array.isArray(t[i]) && (s[i] = I1(
        s[i] || {},
        t[i]
      )));
  return s;
}
const $7 = (s, e = 2) => {
  const t = new rt(), i = e * 2, { isSphere: n, resolution: r, radius: o, font: a, corners: l, edges: c } = s, u = qp.map((E) => ({ ...s[E], radius: o }));
  n && l.enabled && u.push(l), n && c.enabled && u.push(c);
  const h = document.createElement("canvas"), d = h.getContext("2d");
  h.width = r * 2 + i * 2, h.height = r * u.length + i * u.length;
  const [f, m] = M(u, r, a);
  u.forEach(
    ({
      radius: E,
      label: C,
      color: P,
      labelColor: T,
      border: I,
      hover: {
        color: D,
        labelColor: U,
        border: L
      }
    }, k) => {
      const B = r * k + k * i + e;
      x(
        e,
        B,
        e,
        r,
        E,
        C,
        I,
        P,
        T
      ), x(
        r + e * 3,
        B,
        e,
        r,
        E,
        C,
        L ?? I,
        D ?? P,
        U ?? T
      );
    }
  );
  const g = u.length, v = e / (r * 2), _ = e / (r * 6), y = 1 / g, w = new U_(h);
  return w.repeat.set(0.5 - 2 * v, y - 2 * _), w.offset.set(v, 1 - _), Object.assign(w, {
    colorSpace: Oi,
    wrapS: Ns,
    wrapT: Ns,
    userData: {
      offsetX: v,
      offsetY: _,
      cellHeight: y
    }
  }), w;
  function x(E, C, P, T, I, D, U, L, k) {
    if (I = I * (T / 2), L != null && L !== "" && (B(), d.fillStyle = t.set(L).getStyle(), d.fill()), U && U.size) {
      const j = U.size * T / 2;
      E += j, C += j, T -= U.size * T, I = Math.max(0, I - j), B(), d.strokeStyle = t.set(U.color).getStyle(), d.lineWidth = U.size * T, d.stroke();
    }
    D && A(
      d,
      E + T / 2,
      C + (T + P) / 2,
      D,
      t.set(k).getStyle()
    );
    function B() {
      d.beginPath(), d.moveTo(E + I, C), d.lineTo(E + T - I, C), d.arcTo(E + T, C, E + T, C + I, I), d.lineTo(E + T, C + T - I), d.arcTo(E + T, C + T, E + T - I, C + T, I), d.lineTo(E + I, C + T), d.arcTo(E, C + T, E, C + T - I, I), d.lineTo(E, C + I), d.arcTo(E, C, E + I, C, I), d.closePath();
    }
  }
  function M(E, C, P) {
    const T = [...E].sort((N, z) => {
      var J, se;
      return (((J = N.label) == null ? void 0 : J.length) || 0) - (((se = z.label) == null ? void 0 : se.length) || 0);
    }).pop().label, { family: I, weight: D } = P, U = n ? Math.sqrt(Math.pow(C * 0.7, 2) / 2) : C;
    let L = U, k = 0, B = 0;
    do {
      d.font = `${D} ${L}px ${I}`;
      const N = d.measureText(T);
      k = N.width, B = N.fontBoundingBoxDescent, L--;
    } while (k > U && L > 0);
    const j = U / B, q = Math.min(U / k, j), Z = Math.floor(L * q);
    return [`${D} ${Z}px ${I}`, j];
  }
  function A(E, C, P, T, I) {
    E.font = f, E.textAlign = "center", E.textBaseline = "middle", E.fillStyle = I, E.fillText(T, C, P + (n ? m : 0));
  }
}, J7 = (s, e) => s.offset.x = (e ? 0.5 : 0) + s.userData.offsetX, HS = (s, e) => {
  const {
    offset: t,
    userData: { offsetY: i, cellHeight: n }
  } = s;
  t.y = 1 - (e + 1) * n + i;
};
function WS(s, e, t = 2, i = 2) {
  const n = t / 2 - s, r = i / 2 - s, o = s / t, a = (t - s) / t, l = s / i, c = (i - s) / i, u = [n, r, 0, -n, r, 0, -n, -r, 0, n, -r, 0], h = [a, c, o, c, o, l, a, l], d = [
    3 * (e + 1) + 3,
    3 * (e + 1) + 4,
    e + 4,
    e + 5,
    2 * (e + 1) + 4,
    2,
    1,
    2 * (e + 1) + 3,
    3,
    4 * (e + 1) + 3,
    4,
    0
  ], f = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(
    (A) => d[A]
  );
  let m, g, v, _, y, w, x, M;
  for (let A = 0; A < 4; A++) {
    _ = A < 1 || A > 2 ? n : -n, y = A < 2 ? r : -r, w = A < 1 || A > 2 ? a : o, x = A < 2 ? c : l;
    for (let E = 0; E <= e; E++)
      m = Math.PI / 2 * (A + E / e), g = Math.cos(m), v = Math.sin(m), u.push(_ + s * g, y + s * v, 0), h.push(w + o * g, x + l * v), E < e && (M = (e + 1) * A + E + 4, f.push(A, M, M + 1));
  }
  return new Gt().setIndex(new Nt(new Uint32Array(f), 1)).setAttribute(
    "position",
    new Nt(new Float32Array(u), 3)
  ).setAttribute("uv", new Nt(new Float32Array(h), 2));
}
const Q7 = (s, e) => {
  const t = new H(), { isSphere: i, radius: n, smoothness: r } = s, o = WS(n, r);
  return qp.map((a, l) => {
    const c = l < 3, u = qp[l], h = l ? e.clone() : e;
    HS(h, l);
    const { enabled: d, scale: f, opacity: m, hover: g } = s[u], v = {
      map: h,
      opacity: m,
      transparent: !0
    }, _ = i ? new cm(new Pu(v)) : new it(o, new qn(v)), y = c ? u : u[1];
    return _.position[y] = (c ? 1 : -1) * (i ? fL : 1), i || _.lookAt(t.copy(_.position).multiplyScalar(1.7)), _.scale.setScalar(f), _.renderOrder = 1, _.visible = d, _.userData = {
      scale: f,
      opacity: m,
      hover: g
    }, _;
  });
}, eX = (s, e) => {
  const { isSphere: t, corners: i } = s;
  if (!i.enabled) return [];
  const { color: n, opacity: r, scale: o, radius: a, smoothness: l, hover: c } = i, u = t ? null : WS(a, l), h = {
    transparent: !0,
    opacity: r
  }, d = [
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1
  ].map((m) => m * 0.85), f = new H();
  return Array(d.length / 3).fill(0).map((m, g) => {
    if (t) {
      const y = e.clone();
      HS(y, 6), h.map = y;
    } else
      h.color = n;
    const v = t ? new cm(new Pu(h)) : new it(u, new qn(h)), _ = g * 3;
    return v.position.set(d[_], d[_ + 1], d[_ + 2]), t && v.position.normalize().multiplyScalar(1.7), v.scale.setScalar(o), v.lookAt(f.copy(v.position).multiplyScalar(2)), v.renderOrder = 1, v.userData = {
      color: n,
      opacity: r,
      scale: o,
      hover: c
    }, v;
  });
}, tX = (s, e, t) => {
  const { isSphere: i, edges: n } = s;
  if (!n.enabled) return [];
  const { color: r, opacity: o, scale: a, hover: l, radius: c, smoothness: u } = n, h = i ? null : WS(c, u, 1.2, 0.25), d = {
    transparent: !0,
    opacity: o
  }, f = [
    0,
    1,
    1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    1,
    0,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    0,
    -1,
    -1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    -1,
    1,
    0,
    -1,
    -1,
    0
  ].map((v) => v * 0.925), m = new H(), g = new H(0, 1, 0);
  return Array(f.length / 3).fill(0).map((v, _) => {
    if (i) {
      const x = e.clone();
      HS(x, t), d.map = x;
    } else
      d.color = r;
    const y = i ? new cm(new Pu(d)) : new it(h, new qn(d)), w = _ * 3;
    return y.position.set(f[w], f[w + 1], f[w + 2]), i && y.position.normalize().multiplyScalar(1.7), y.scale.setScalar(a), y.up.copy(g), y.lookAt(m.copy(y.position).multiplyScalar(2)), !i && !y.position.y && (y.rotation.z = Math.PI / 2), y.renderOrder = 1, y.userData = {
      color: r,
      opacity: o,
      scale: a,
      hover: l
    }, y;
  });
};
function nX(s, e = !1) {
  const t = s[0].index !== null, i = new Set(Object.keys(s[0].attributes)), n = new Set(Object.keys(s[0].morphAttributes)), r = {}, o = {}, a = s[0].morphTargetsRelative, l = new Gt();
  let c = 0;
  for (let u = 0; u < s.length; ++u) {
    const h = s[u];
    let d = 0;
    if (t !== (h.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const f in h.attributes) {
      if (!i.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
      r[f] === void 0 && (r[f] = []), r[f].push(h.attributes[f]), d++;
    }
    if (d !== i.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". Make sure all geometries have the same number of attributes."), null;
    if (a !== h.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const f in h.morphAttributes) {
      if (!n.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ".  .morphAttributes must be consistent throughout all geometries."), null;
      o[f] === void 0 && (o[f] = []), o[f].push(h.morphAttributes[f]);
    }
    if (e) {
      let f;
      if (t)
        f = h.index.count;
      else if (h.attributes.position !== void 0)
        f = h.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + u + ". The geometry must have either an index or a position attribute"), null;
      l.addGroup(c, f, u), c += f;
    }
  }
  if (t) {
    let u = 0;
    const h = [];
    for (let d = 0; d < s.length; ++d) {
      const f = s[d].index;
      for (let m = 0; m < f.count; ++m)
        h.push(f.getX(m) + u);
      u += s[d].attributes.position.count;
    }
    l.setIndex(h);
  }
  for (const u in r) {
    const h = a2(r[u]);
    if (!h)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + u + " attribute."), null;
    l.setAttribute(u, h);
  }
  for (const u in o) {
    const h = o[u][0].length;
    if (h === 0) break;
    l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[u] = [];
    for (let d = 0; d < h; ++d) {
      const f = [];
      for (let g = 0; g < o[u].length; ++g)
        f.push(o[u][g][d]);
      const m = a2(f);
      if (!m)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + u + " morphAttribute."), null;
      l.morphAttributes[u].push(m);
    }
  }
  return l;
}
function a2(s) {
  let e, t, i, n = -1, r = 0;
  for (let c = 0; c < s.length; ++c) {
    const u = s[c];
    if (e === void 0 && (e = u.array.constructor), e !== u.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = u.itemSize), t !== u.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (i === void 0 && (i = u.normalized), i !== u.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (n === -1 && (n = u.gpuType), n !== u.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    r += u.count * t;
  }
  const o = new e(r), a = new Nt(o, t, i);
  let l = 0;
  for (let c = 0; c < s.length; ++c) {
    const u = s[c];
    if (u.isInterleavedBufferAttribute) {
      const h = l / t;
      for (let d = 0, f = u.count; d < f; d++)
        for (let m = 0; m < t; m++) {
          const g = u.getComponent(d, m);
          a.setComponent(d + h, m, g);
        }
    } else
      o.set(u.array, l);
    l += u.count * t;
  }
  return n !== void 0 && (a.gpuType = n), a;
}
const iX = (s, e) => {
  const {
    isSphere: t,
    background: { enabled: i, color: n, opacity: r, hover: o }
  } = e;
  let a;
  const l = new qn({
    color: n,
    side: Yi,
    opacity: r,
    transparent: !0,
    depthWrite: !1
  });
  if (!i) return null;
  if (t)
    a = new it(
      new Bl(1.8, 64, 64),
      l
    );
  else {
    let c;
    s.forEach((u) => {
      const h = u.scale.x;
      u.scale.setScalar(0.9), u.updateMatrix();
      const d = u.geometry.clone();
      d.applyMatrix4(u.matrix), c = c ? nX([c, d]) : d, u.scale.setScalar(h);
    }), a = new it(c, l);
  }
  return a.userData = {
    color: n,
    opacity: r,
    hover: o
  }, a;
}, l2 = new yn(), Gg = new H();
class pL extends pm {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], i = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(i), this.setAttribute("position", new Tt(e, 3)), this.setAttribute("uv", new Tt(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, i = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new $0(t, 6, 1);
    return this.setAttribute("instanceStart", new ss(i, 3, 0)), this.setAttribute("instanceEnd", new ss(i, 3, 3)), this.instanceCount = this.attributes.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new $0(t, 6, 1);
    return this.setAttribute("instanceColorStart", new ss(i, 3, 0)), this.setAttribute("instanceColorEnd", new ss(i, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new hS(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new yn());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), l2.setFromBufferAttribute(t), this.boundingBox.union(l2));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const i = this.boundingSphere.center;
      this.boundingBox.getCenter(i);
      let n = 0;
      for (let r = 0, o = e.count; r < o; r++)
        Gg.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(Gg)), Gg.fromBufferAttribute(t, r), n = Math.max(n, i.distanceToSquared(Gg));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
vt.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Be(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
Dr.line = {
  uniforms: Fl.merge([
    vt.common,
    vt.fog,
    vt.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
let XS = class extends Mi {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: Fl.clone(Dr.line.uniforms),
      vertexShader: Dr.line.vertexShader,
      fragmentShader: Dr.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
};
const Zx = new Kt(), c2 = new H(), u2 = new H(), lr = new Kt(), cr = new Kt(), Po = new Kt(), Kx = new H(), $x = new _t(), fr = new xo(), h2 = new H(), Hg = new yn(), Wg = new fi(), Ro = new Kt();
let No, iu;
function d2(s, e, t) {
  return Ro.set(0, 0, -e, 1).applyMatrix4(s.projectionMatrix), Ro.multiplyScalar(1 / Ro.w), Ro.x = iu / t.width, Ro.y = iu / t.height, Ro.applyMatrix4(s.projectionMatrixInverse), Ro.multiplyScalar(1 / Ro.w), Math.abs(Math.max(Ro.x, Ro.y));
}
function rX(s, e) {
  const t = s.matrixWorld, i = s.geometry, n = i.attributes.instanceStart, r = i.attributes.instanceEnd, o = Math.min(i.instanceCount, n.count);
  for (let a = 0, l = o; a < l; a++) {
    fr.start.fromBufferAttribute(n, a), fr.end.fromBufferAttribute(r, a), fr.applyMatrix4(t);
    const c = new H(), u = new H();
    No.distanceSqToSegment(fr.start, fr.end, u, c), u.distanceTo(c) < iu * 0.5 && e.push({
      point: u,
      pointOnLine: c,
      distance: No.origin.distanceTo(u),
      object: s,
      face: null,
      faceIndex: a,
      uv: null,
      uv1: null
    });
  }
}
function sX(s, e, t) {
  const i = e.projectionMatrix, n = s.material.resolution, r = s.matrixWorld, o = s.geometry, a = o.attributes.instanceStart, l = o.attributes.instanceEnd, c = Math.min(o.instanceCount, a.count), u = -e.near;
  No.at(1, Po), Po.w = 1, Po.applyMatrix4(e.matrixWorldInverse), Po.applyMatrix4(i), Po.multiplyScalar(1 / Po.w), Po.x *= n.x / 2, Po.y *= n.y / 2, Po.z = 0, Kx.copy(Po), $x.multiplyMatrices(e.matrixWorldInverse, r);
  for (let h = 0, d = c; h < d; h++) {
    if (lr.fromBufferAttribute(a, h), cr.fromBufferAttribute(l, h), lr.w = 1, cr.w = 1, lr.applyMatrix4($x), cr.applyMatrix4($x), lr.z > u && cr.z > u)
      continue;
    if (lr.z > u) {
      const _ = lr.z - cr.z, y = (lr.z - u) / _;
      lr.lerp(cr, y);
    } else if (cr.z > u) {
      const _ = cr.z - lr.z, y = (cr.z - u) / _;
      cr.lerp(lr, y);
    }
    lr.applyMatrix4(i), cr.applyMatrix4(i), lr.multiplyScalar(1 / lr.w), cr.multiplyScalar(1 / cr.w), lr.x *= n.x / 2, lr.y *= n.y / 2, cr.x *= n.x / 2, cr.y *= n.y / 2, fr.start.copy(lr), fr.start.z = 0, fr.end.copy(cr), fr.end.z = 0;
    const f = fr.closestPointToPointParameter(Kx, !0);
    fr.at(f, h2);
    const m = Kr.lerp(lr.z, cr.z, f), g = m >= -1 && m <= 1, v = Kx.distanceTo(h2) < iu * 0.5;
    if (g && v) {
      fr.start.fromBufferAttribute(a, h), fr.end.fromBufferAttribute(l, h), fr.start.applyMatrix4(r), fr.end.applyMatrix4(r);
      const _ = new H(), y = new H();
      No.distanceSqToSegment(fr.start, fr.end, y, _), t.push({
        point: y,
        pointOnLine: _,
        distance: No.origin.distanceTo(y),
        object: s,
        face: null,
        faceIndex: h,
        uv: null,
        uv1: null
      });
    }
  }
}
let oX = class extends it {
  constructor(e = new pL(), t = new XS({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, i = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let o = 0, a = 0, l = t.count; o < l; o++, a += 2)
      c2.fromBufferAttribute(t, o), u2.fromBufferAttribute(i, o), n[a] = a === 0 ? 0 : n[a - 1], n[a + 1] = n[a] + c2.distanceTo(u2);
    const r = new $0(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new ss(r, 1, 0)), e.setAttribute("instanceDistanceEnd", new ss(r, 1, 1)), this;
  }
  raycast(e, t) {
    const i = this.material.worldUnits, n = e.camera;
    n === null && !i && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const r = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    No = e.ray;
    const o = this.matrixWorld, a = this.geometry, l = this.material;
    iu = l.linewidth + r, a.boundingSphere === null && a.computeBoundingSphere(), Wg.copy(a.boundingSphere).applyMatrix4(o);
    let c;
    if (i)
      c = iu * 0.5;
    else {
      const h = Math.max(n.near, Wg.distanceToPoint(No.origin));
      c = d2(n, h, l.resolution);
    }
    if (Wg.radius += c, No.intersectsSphere(Wg) === !1)
      return;
    a.boundingBox === null && a.computeBoundingBox(), Hg.copy(a.boundingBox).applyMatrix4(o);
    let u;
    if (i)
      u = iu * 0.5;
    else {
      const h = Math.max(n.near, Hg.distanceToPoint(No.origin));
      u = d2(n, h, l.resolution);
    }
    Hg.expandByScalar(u), No.intersectsBox(Hg) !== !1 && (i ? rX(this, t) : sX(this, n, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(Zx), this.material.uniforms.resolution.value.set(Zx.z, Zx.w));
  }
}, mL = class extends pL {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      i[2 * n] = e[n], i[2 * n + 1] = e[n + 1], i[2 * n + 2] = e[n + 2], i[2 * n + 3] = e[n + 3], i[2 * n + 4] = e[n + 4], i[2 * n + 5] = e[n + 5];
    return super.setPositions(i), this;
  }
  setColors(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      i[2 * n] = e[n], i[2 * n + 1] = e[n + 1], i[2 * n + 2] = e[n + 2], i[2 * n + 3] = e[n + 3], i[2 * n + 4] = e[n + 4], i[2 * n + 5] = e[n + 5];
    return super.setColors(i), this;
  }
  setFromPoints(e) {
    const t = e.length - 1, i = new Float32Array(6 * t);
    for (let n = 0; n < t; n++)
      i[6 * n] = e[n].x, i[6 * n + 1] = e[n].y, i[6 * n + 2] = e[n].z || 0, i[6 * n + 3] = e[n + 1].x, i[6 * n + 4] = e[n + 1].y, i[6 * n + 5] = e[n + 1].z || 0;
    return super.setPositions(i), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
};
class aX extends oX {
  constructor(e = new mL(), t = new XS({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
const lX = (s) => {
  const e = new rt(), t = [], i = [], { isSphere: n } = s;
  if (qp.forEach((a, l) => {
    const { enabled: c, line: u, scale: h, color: d } = s[a];
    if (!c || !u) return;
    const f = l < 3 ? 1 : -1, m = (n ? fL - h / 2 : 0.975) * f;
    t.push(
      a.includes("x") ? m : 0,
      a.includes("y") ? m : 0,
      a.includes("z") ? m : 0,
      0,
      0,
      0
    );
    const g = e.set(d).toArray();
    i.push(...g, ...g);
  }), !t.length) return null;
  const r = new mL().setPositions(t).setColors(i), o = new XS({
    linewidth: s.lineWidth,
    vertexColors: !0,
    resolution: new Be(window.innerWidth, window.innerHeight)
  });
  return new aX(r, o).computeLineDistances();
}, cX = (s) => {
  const { corners: e, edges: t } = s, i = [], n = $7(s), r = Q7(s, n);
  i.push(...r), e.enabled && i.push(...eX(s, n)), t.enabled && i.push(...tX(s, n, e.enabled ? 7 : 6));
  const o = iX(r, s), a = lX(s);
  return [i, o, a];
}, mf = (s, e = !0) => {
  const { material: t, userData: i } = s, { opacity: n, color: r, scale: o } = e ? i.hover : i;
  s.scale.setScalar(o), t.opacity = n, t.map ? J7(t.map, e) : t.color.set(r);
}, fh = /* @__PURE__ */ new _t(), uX = /* @__PURE__ */ new md(), hX = /* @__PURE__ */ new Be(), vc = /* @__PURE__ */ new H(), f2 = /* @__PURE__ */ new Kt();
class p2 extends tn {
  /**
   * Creates a new ViewportGizmo instance.
   *
   * @param camera - The camera to be controlled by this gizmo
   * @param renderer - The WebGL renderer used to render the scene
   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.
   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string
   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'
   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128
   * @param options.placement - Position of the gizmo in the viewport
   *    Options include:
   *    - `"top-left"`
   *    - `"top-center"`
   *    - `"top-right"`
   *    - `"center-left"`
   *    - `"center-center"`
   *    - `"center-right"`
   *    - `"bottom-left"`
   *    - `"bottom-center"`
   *    - `"bottom-right"`
   * @param options.offset - Offset of the gizmo from container edges in pixels
   * @param options.offset.left - Offset from the left edge
   * @param options.offset.top - Offset from the top edge
   * @param options.offset.right - Offset from the right edge
   * @param options.offset.bottom - Offset from the bottom edge
   * @param options.animated - Whether view changes should be animated. Defaults to true
   * @param options.speed - Animation speed multiplier. Defaults to 1
   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube
   * @param options.lineWidth - Width of the axes lines in pixels
   * @param options.id - HTML `id` attribute for the gizmo container
   * @param options.className - HTML `class` attribute for the gizmo container
   * @param options.font - Font configuration for axis labels
   * @param options.font.family - Font family for axis labels
   * @param options.font.weight - Font weight for axis labels
   * @param options.background - Configuration for the background sphere/cube
   * @param options.background.enabled - Whether to display the background
   * @param options.background.color - Color of the background in normal state
   * @param options.background.opacity - Opacity of the background in normal state
   * @param options.background.hover.color - Color of the background when hovered
   * @param options.background.hover.opacity - Opacity of the background when hovered
   * @param options.corners - Configuration for corner indicators
   * @param options.corners.enabled - Whether to display corner indicators
   * @param options.corners.color - Base color of corner indicators
   * @param options.corners.opacity - Opacity of corner indicators
   * @param options.corners.scale - Scale multiplier for corner indicators
   * @param options.corners.radius - Radius of corner indicators
   * @param options.corners.smoothness - Smoothness of corner indicators
   * @param options.corners.hover.color - Color of corner indicators when hovered
   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered
   * @param options.corners.hover.scale - Scale of corner indicators when hovered
   * @param options.edges - Configuration for edge indicators
   * @param options.edges.enabled - Whether to display edge indicators
   * @param options.edges.color - Base color of edge indicators
   * @param options.edges.opacity - Opacity of edge indicators
   * @param options.edges.scale - Scale multiplier for edge indicators
   * @param options.edges.radius - Radius of edge indicators
   * @param options.edges.smoothness - Smoothness of edge indicators
   * @param options.edges.hover.color - Color of edge indicators when hovered
   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered
   * @param options.edges.hover.scale - Scale of edge indicators when hovered
   * @param options.x - Configuration for positive X axis/face
   * @param options.y - Configuration for positive Y axis/face
   * @param options.z - Configuration for positive Z axis/face
   * @param options.nx - Configuration for negative X axis/face
   * @param options.ny - Configuration for negative Y axis/face
   * @param options.nz - Configuration for negative Z axis/face
   *
   * @remarks Axis-specific configuration can also use alias names for cube mode:
   * - `right` (same as `x`)
   * - `left` (same as `nx`)
   * - `top` (same as `y`)
   * - `bottom` (same as `ny`)
   * - `front` (same as `z`)
   * - `back` (same as `nz`)
   *
   * For each axis/face configuration, the following options are available:
   * @param options.AXIS.enabled - Whether to draw the axis
   * @param options.AXIS.label - Custom text label for the axis
   * @param options.AXIS.opacity - Axis opacity
   * @param options.AXIS.scale - Scale multiplier for indicator size
   * @param options.AXIS.line - Whether to draw the axis line
   * @param options.AXIS.color - Axis indicator background color
   * @param options.AXIS.labelColor - Axis label color
   * @param options.AXIS.border.size - Border size around the axis indicator
   * @param options.AXIS.border.color - Border color around the axis indicator
   * @param options.AXIS.hover.color - Fill color on hover
   * @param options.AXIS.hover.labelColor - Label text color on hover
   * @param options.AXIS.hover.opacity - Opacity when hovered
   * @param options.AXIS.hover.scale - Indicator scale when hovered
   * @param options.AXIS.hover.border.size - Hover border size
   * @param options.AXIS.hover.border.color - Hover border color
   */
  constructor(e, t, i = {}) {
    super(), On(this, "enabled", !0), On(this, "camera"), On(this, "renderer"), On(this, "options"), On(this, "target", new H()), On(this, "animated", !0), On(this, "speed", 1), On(this, "animating", !1), On(this, "_options"), On(this, "_intersections"), On(this, "_background", null), On(this, "_viewport", [0, 0, 0, 0]), On(this, "_originalViewport", [0, 0, 0, 0]), On(this, "_originalScissor", [0, 0, 0, 0]), On(this, "_scene"), On(this, "_camera"), On(this, "_container"), On(this, "_domElement"), On(this, "_domRect"), On(this, "_dragging", !1), On(this, "_distance", 0), On(this, "_clock", new bS()), On(this, "_targetQuaternion", new En()), On(this, "_quaternionStart", new En()), On(this, "_quaternionEnd", new En()), On(this, "_pointerStart", new Be()), On(this, "_focus", null), On(this, "_placement"), On(this, "_controls"), On(this, "_controlsListeners"), this.camera = e, this.renderer = t, this._scene = new am().add(this), this.set(i);
  }
  /** Gets the current placement of the gizmo relative to its container. */
  get placement() {
    return this._placement;
  }
  /**
   * Sets and update the placement of the gizmo relative to its container.
   *
   * @param placement - The new placement position
   */
  set placement(e) {
    this._placement = hL(this._domElement, e), this.domUpdate();
  }
  /**
   * Regenerates the gizmo with the new options.
   *
   * @remarks
   * - Not recommended for use in real-time rendering or animation loops
   * - Provides a way to completely rebuild the gizmo with new options
   * - Can be computationally expensive, so use sparingly
   */
  set(e = {}) {
    this.dispose(), this.options = e, this._options = K7(e), this._camera = this._options.isSphere ? new Ua(-1.8, 1.8, 1.8, -1.8, 5, 10) : new Fi(26, 1, 5, 10), this._camera.position.set(0, 0, 7);
    const [t, i, n] = cX(this._options);
    i && this.add(i), n && this.add(n), this.add(...t), this._background = i, this._intersections = t;
    const { container: r, animated: o, speed: a } = this._options;
    return this.animated = o, this.speed = a, this._container = r ? X7(r) : document.body, this._domElement = W7(this._options), this._domElement.onpointerdown = (l) => this._onPointerDown(l), this._domElement.onpointermove = (l) => this._onPointerMove(l), this._domElement.onpointerleave = () => this._onPointerLeave(), this._container.appendChild(this._domElement), this._controls && this.attachControls(this._controls), this.update(), this;
  }
  /**
   * Renders the gizmo to the screen.
   * This method handles viewport and scissor management to ensure the gizmo
   * renders correctly without affecting the main scene rendering.
   *
   * @returns The gizmo instance for method chaining
   */
  render() {
    this.animating && this._animate();
    const { renderer: e, _viewport: t } = this, i = e.getScissorTest(), n = e.autoClear;
    return e.autoClear = !1, e.setViewport(...t), i && e.setScissor(...t), e.clear(!1, !0, !1), e.render(this._scene, this._camera), e.setViewport(...this._originalViewport), i && e.setScissor(...this._originalScissor), e.autoClear = n, this;
  }
  /**
   * Updates the gizmo's DOM-related properties based on its current position
   * and size in the document.
   *
   * @returns The gizmo instance for method chaining
   */
  domUpdate() {
    this._domRect = this._domElement.getBoundingClientRect();
    const e = this.renderer, t = this._domRect, i = e.domElement.getBoundingClientRect();
    return this._viewport.splice(
      0,
      4,
      t.left - i.left,
      e.domElement.clientHeight - (t.top - i.top + t.height),
      t.width,
      t.height
    ), e.getViewport(f2).toArray(this._originalViewport), e.getScissorTest() && e.getScissor(f2).toArray(this._originalScissor), this;
  }
  /**
   * Updates the gizmo's orientation to match the current camera orientation.
   *
   * @returns The gizmo instance for method chaining
   */
  cameraUpdate() {
    return this._updateOrientation(), this;
  }
  /**
   * Performs a complete update of the gizmo, including both DOM and camera-related updates.
   *
   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.
   *
   * @returns The gizmo instance for method chaining
   */
  update(e = !0) {
    return e && this._controls && this._controls.update(), this.domUpdate().cameraUpdate();
  }
  /**
   * Connects OrbitControls with the gizmo, handling interaction states and updates.
   * Automatically detaches any previously attached controls.
   *
   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}
   */
  attachControls(e) {
    return this.detachControls(), this.target = e.target, this._controlsListeners = {
      start: () => e.enabled = !1,
      end: () => e.enabled = !0,
      change: () => this.update(!1)
    }, this.addEventListener("start", this._controlsListeners.start), this.addEventListener("end", this._controlsListeners.end), e.addEventListener("change", this._controlsListeners.change), this._controls = e, this;
  }
  /** Removes all control event listeners and references. Safe to call multiple times. */
  detachControls() {
    if (!(!this._controlsListeners || !this._controls))
      return this.target = new H().copy(this._controls.target), this.removeEventListener("start", this._controlsListeners.start), this.removeEventListener("end", this._controlsListeners.end), this._controls.removeEventListener(
        "change",
        this._controlsListeners.change
      ), this._controlsListeners = void 0, this._controls = void 0, this;
  }
  /** Cleans up all resources including geometries, materials, textures, and event listeners. */
  dispose() {
    var e;
    this.detachControls(), this.children.forEach((t) => {
      var i, n, r, o;
      this.remove(t);
      const a = t;
      (i = a.material) == null || i.dispose(), (r = (n = a.material) == null ? void 0 : n.map) == null || r.dispose(), (o = a.geometry) == null || o.dispose();
    }), (e = this._domElement) == null || e.remove();
  }
  /**
   * Updates the gizmo's orientation either based on the camera or internal state.
   *
   * @private
   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)
   */
  _updateOrientation(e = !0) {
    e && (this.quaternion.copy(this.camera.quaternion).invert(), this.updateMatrixWorld()), n2(this._options, this._intersections, this.camera);
  }
  /**
   * Handles the animation of camera position and orientation changes.
   *
   * @private
   */
  _animate() {
    const { position: e, quaternion: t } = this.camera;
    if (e.set(0, 0, 1), !this.animated) {
      e.applyQuaternion(this._quaternionEnd).multiplyScalar(this._distance).add(this.target), t.copy(this._targetQuaternion), this._updateOrientation(), this.animating = !1, this.dispatchEvent({ type: "change" }), this.dispatchEvent({ type: "end" });
      return;
    }
    this._controls && (this._controls.enabled = !1);
    const i = this._clock.getDelta() * q7 * this.speed;
    this._quaternionStart.rotateTowards(this._quaternionEnd, i), e.applyQuaternion(this._quaternionStart).multiplyScalar(this._distance).add(this.target), t.rotateTowards(this._targetQuaternion, i), this._updateOrientation(), requestAnimationFrame(() => this.dispatchEvent({ type: "change" })), this._quaternionStart.angleTo(this._quaternionEnd) < qx && (this._controls && (this._controls.enabled = !0), this.animating = !1, this.dispatchEvent({ type: "end" }));
  }
  /**
   * Sets the camera orientation to look at the target from a specific axis.
   *
   * @private
   * @param position - The axis point position
   */
  _setOrientation(e) {
    const t = this.camera, i = this.target;
    vc.copy(e).multiplyScalar(this._distance), fh.setPosition(vc).lookAt(vc, this.position, this.up), this._targetQuaternion.setFromRotationMatrix(fh), vc.add(i), fh.lookAt(vc, i, this.up), this._quaternionEnd.setFromRotationMatrix(fh), fh.setPosition(t.position).lookAt(t.position, i, this.up), this._quaternionStart.setFromRotationMatrix(fh), this.animating = !0, this._clock.start(), this.dispatchEvent({ type: "start" });
  }
  /**
   * Handles the pointer down event for starting drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerDown(e) {
    if (!this.enabled) return;
    const t = (a) => {
      if (!this._dragging) {
        if (j7(a, this._pointerStart)) return;
        this._dragging = !0;
      }
      const l = hX.set(a.clientX, a.clientY).sub(this._pointerStart).multiplyScalar(1 / this._domRect.width * Math.PI), c = uX.setFromVector3(
        vc.subVectors(this.camera.position, this.target)
      );
      c.theta = r - l.x, c.phi = D1(
        o - l.y,
        qx,
        Math.PI - qx
      ), this.camera.position.setFromSpherical(c).add(this.target), this.camera.lookAt(this.target), this.quaternion.copy(this.camera.quaternion).invert(), this._updateOrientation(!1), this.dispatchEvent({ type: "change" });
    }, i = () => {
      if (document.removeEventListener("pointermove", t, !1), document.removeEventListener("pointerup", i, !1), !this._dragging) return this._handleClick(e);
      this._focus && (mf(this._focus, !1), this._focus = null), this._dragging = !1, this.dispatchEvent({ type: "end" });
    };
    if (this.animating) return;
    e.preventDefault(), this._pointerStart.set(e.clientX, e.clientY);
    const n = new md().setFromVector3(
      vc.subVectors(this.camera.position, this.target)
    ), r = n.theta, o = n.phi;
    this._distance = n.radius, document.addEventListener("pointermove", t, !1), document.addEventListener("pointerup", i, !1), this.dispatchEvent({ type: "start" });
  }
  /**
   * Handles pointer move events for hover effects and drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerMove(e) {
    !this.enabled || this._dragging || (this._background && o2(this._background, !0), this._handleHover(e));
  }
  /**
   * Handles pointer leave events to reset hover states.
   *
   * @private
   */
  _onPointerLeave() {
    !this.enabled || this._dragging || (this._background && o2(this._background, !1), this._focus && mf(this._focus, !1), this._domElement.style.cursor = "");
  }
  /**
   * Handles click events for axis selection.
   *
   * @private
   * @param e - The pointer event
   */
  _handleClick(e) {
    const t = s2(
      e,
      this._domRect,
      this._camera,
      this._intersections
    );
    this._focus && (mf(this._focus, !1), this._focus = null), t && (this._setOrientation(t.object.position), this.dispatchEvent({ type: "change" }));
  }
  /**
   * Handles hover effects for interactive elements.
   *
   * @private
   * @param e - The pointer event
   */
  _handleHover(e) {
    const t = s2(
      e,
      this._domRect,
      this._camera,
      this._intersections
    ), i = (t == null ? void 0 : t.object) || null;
    this._focus !== i && (this._domElement.style.cursor = i ? "pointer" : "", this._focus && mf(this._focus, !1), (this._focus = i) ? mf(i, !0) : n2(this._options, this._intersections, this.camera));
  }
}
const m2 = { type: "change" }, YS = { type: "start" }, gL = { type: "end" }, Xg = new Ol(), g2 = new $s(), dX = Math.cos(70 * Kr.DEG2RAD), Gi = new H(), ts = 2 * Math.PI, Hn = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, Jx = 1e-6;
let vL = class extends $_ {
  constructor(e, t = null) {
    super(e, t), this.state = Hn.NONE, this.enabled = !0, this.target = new H(), this.cursor = new H(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: Is.ROTATE, MIDDLE: Is.DOLLY, RIGHT: Is.PAN }, this.touches = { ONE: Nc.ROTATE, TWO: Nc.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new H(), this._lastQuaternion = new En(), this._lastTargetPosition = new H(), this._quat = new En().setFromUnitVectors(e.up, new H(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new md(), this._sphericalDelta = new md(), this._scale = 1, this._panOffset = new H(), this._rotateStart = new Be(), this._rotateEnd = new Be(), this._rotateDelta = new Be(), this._panStart = new Be(), this._panEnd = new Be(), this._panDelta = new Be(), this._dollyStart = new Be(), this._dollyEnd = new Be(), this._dollyDelta = new Be(), this._dollyDirection = new H(), this._mouse = new Be(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = pX.bind(this), this._onPointerDown = fX.bind(this), this._onPointerUp = mX.bind(this), this._onContextMenu = wX.bind(this), this._onMouseWheel = _X.bind(this), this._onKeyDown = yX.bind(this), this._onTouchStart = xX.bind(this), this._onTouchMove = bX.bind(this), this._onMouseDown = gX.bind(this), this._onMouseMove = vX.bind(this), this._interceptControlDown = SX.bind(this), this._interceptControlUp = MX.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(m2), this.update(), this.state = Hn.NONE;
  }
  update(e = null) {
    const t = this.object.position;
    Gi.copy(t).sub(this.target), Gi.applyQuaternion(this._quat), this._spherical.setFromVector3(Gi), this.autoRotate && this.state === Hn.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let i = this.minAzimuthAngle, n = this.maxAzimuthAngle;
    isFinite(i) && isFinite(n) && (i < -Math.PI ? i += ts : i > Math.PI && (i -= ts), n < -Math.PI ? n += ts : n > Math.PI && (n -= ts), i <= n ? this._spherical.theta = Math.max(i, Math.min(n, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (i + n) / 2 ? Math.max(i, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let r = !1;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), r = o != this._spherical.radius;
    }
    if (Gi.setFromSpherical(this._spherical), Gi.applyQuaternion(this._quatInverse), t.copy(this.target).add(Gi), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const a = Gi.length();
        o = this._clampDistance(a * this._scale);
        const l = a - o;
        this.object.position.addScaledVector(this._dollyDirection, l), this.object.updateMatrixWorld(), r = !!l;
      } else if (this.object.isOrthographicCamera) {
        const a = new H(this._mouse.x, this._mouse.y, 0);
        a.unproject(this.object);
        const l = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), r = l !== this.object.zoom;
        const c = new H(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(a), this.object.updateMatrixWorld(), o = Gi.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (Xg.origin.copy(this.object.position), Xg.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(Xg.direction)) < dX ? this.object.lookAt(this.target) : (g2.setFromNormalAndCoplanarPoint(this.object.up, this.target), Xg.intersectPlane(g2, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), r = !0);
    }
    return this._scale = 1, this._performCursorZoom = !1, r || this._lastPosition.distanceToSquared(this.object.position) > Jx || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Jx || this._lastTargetPosition.distanceToSquared(this.target) > Jx ? (this.dispatchEvent(m2), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : !1;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? ts / 60 * this.autoRotateSpeed * e : ts / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const t = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * t);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, t) {
    Gi.setFromMatrixColumn(t, 0), Gi.multiplyScalar(-e), this._panOffset.add(Gi);
  }
  _panUp(e, t) {
    this.screenSpacePanning === !0 ? Gi.setFromMatrixColumn(t, 1) : (Gi.setFromMatrixColumn(t, 0), Gi.crossVectors(this.object.up, Gi)), Gi.multiplyScalar(e), this._panOffset.add(Gi);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, t) {
    const i = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const n = this.object.position;
      Gi.copy(n).sub(this.target);
      let r = Gi.length();
      r *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * r / i.clientHeight, this.object.matrix), this._panUp(2 * t * r / i.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, t) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const i = this.domElement.getBoundingClientRect(), n = e - i.left, r = t - i.top, o = i.width, a = i.height;
    this._mouse.x = n / o * 2 - 1, this._mouse.y = -(r / a) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(ts * this._rotateDelta.x / t.clientHeight), this._rotateUp(ts * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let t = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(ts * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), t = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-ts * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), t = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(ts * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), t = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-ts * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), t = !0;
        break;
    }
    t && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._rotateStart.set(i, n);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panStart.set(i, n);
    }
  }
  _handleTouchStartDolly(e) {
    const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
    this._dollyStart.set(0, r);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), r = 0.5 * (e.pageY + i.y);
      this._rotateEnd.set(n, r);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(ts * this._rotateDelta.x / t.clientHeight), this._rotateUp(ts * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panEnd.set(i, n);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
    this._dollyEnd.set(0, r), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + t.x) * 0.5, a = (e.pageY + t.y) * 0.5;
    this._updateZoomParameters(o, a);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new Be(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t];
  }
  //
  _customWheelEvent(e) {
    const t = e.deltaMode, i = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (t) {
      case 1:
        i.deltaY *= 16;
        break;
      case 2:
        i.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
  }
};
function fX(s) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(s) && (this._addPointer(s), s.pointerType === "touch" ? this._onTouchStart(s) : this._onMouseDown(s)));
}
function pX(s) {
  this.enabled !== !1 && (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s));
}
function mX(s) {
  switch (this._removePointer(s), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(gL), this.state = Hn.NONE;
      break;
    case 1:
      const e = this._pointers[0], t = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: t.x, pageY: t.y });
      break;
  }
}
function gX(s) {
  let e;
  switch (s.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case Is.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(s), this.state = Hn.DOLLY;
      break;
    case Is.ROTATE:
      if (s.ctrlKey || s.metaKey || s.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(s), this.state = Hn.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(s), this.state = Hn.ROTATE;
      }
      break;
    case Is.PAN:
      if (s.ctrlKey || s.metaKey || s.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(s), this.state = Hn.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(s), this.state = Hn.PAN;
      }
      break;
    default:
      this.state = Hn.NONE;
  }
  this.state !== Hn.NONE && this.dispatchEvent(YS);
}
function vX(s) {
  switch (this.state) {
    case Hn.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(s);
      break;
    case Hn.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(s);
      break;
    case Hn.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(s);
      break;
  }
}
function _X(s) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== Hn.NONE || (s.preventDefault(), this.dispatchEvent(YS), this._handleMouseWheel(this._customWheelEvent(s)), this.dispatchEvent(gL));
}
function yX(s) {
  this.enabled !== !1 && this._handleKeyDown(s);
}
function xX(s) {
  switch (this._trackPointer(s), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case Nc.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(s), this.state = Hn.TOUCH_ROTATE;
          break;
        case Nc.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(s), this.state = Hn.TOUCH_PAN;
          break;
        default:
          this.state = Hn.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case Nc.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(s), this.state = Hn.TOUCH_DOLLY_PAN;
          break;
        case Nc.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(s), this.state = Hn.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = Hn.NONE;
      }
      break;
    default:
      this.state = Hn.NONE;
  }
  this.state !== Hn.NONE && this.dispatchEvent(YS);
}
function bX(s) {
  switch (this._trackPointer(s), this.state) {
    case Hn.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(s), this.update();
      break;
    case Hn.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(s), this.update();
      break;
    case Hn.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(s), this.update();
      break;
    case Hn.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(s), this.update();
      break;
    default:
      this.state = Hn.NONE;
  }
}
function wX(s) {
  this.enabled !== !1 && s.preventDefault();
}
function SX(s) {
  s.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function MX(s) {
  s.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
const Qx = { type: "change" }, jS = { type: "start" }, qS = { type: "end" }, v2 = 1e-6, Dn = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 }, Yg = new Be(), nl = new Be(), EX = new H(), jg = new H(), eb = new H(), ph = new En(), _2 = new H(), qg = new H(), tb = new H(), Zg = new H();
let _L = class extends $_ {
  constructor(e, t = null) {
    super(e, t), this.enabled = !0, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ], this.mouseButtons = { LEFT: Is.ROTATE, MIDDLE: Is.DOLLY, RIGHT: Is.PAN }, this.state = Dn.NONE, this.keyState = Dn.NONE, this.target = new H(), this._lastPosition = new H(), this._lastZoom = 1, this._touchZoomDistanceStart = 0, this._touchZoomDistanceEnd = 0, this._lastAngle = 0, this._eye = new H(), this._movePrev = new Be(), this._moveCurr = new Be(), this._lastAxis = new H(), this._zoomStart = new Be(), this._zoomEnd = new Be(), this._panStart = new Be(), this._panEnd = new Be(), this._pointers = [], this._pointerPositions = {}, this._onPointerMove = AX.bind(this), this._onPointerDown = TX.bind(this), this._onPointerUp = CX.bind(this), this._onPointerCancel = PX.bind(this), this._onContextMenu = OX.bind(this), this._onMouseWheel = kX.bind(this), this._onKeyDown = DX.bind(this), this._onKeyUp = RX.bind(this), this._onTouchStart = FX.bind(this), this._onTouchMove = NX.bind(this), this._onTouchEnd = BX.bind(this), this._onMouseDown = IX.bind(this), this._onMouseMove = LX.bind(this), this._onMouseUp = UX.bind(this), this._target0 = this.target.clone(), this._position0 = this.object.position.clone(), this._up0 = this.object.up.clone(), this._zoom0 = this.object.zoom, t !== null && (this.connect(), this.handleResize()), this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const e = this.domElement.getBoundingClientRect(), t = this.domElement.ownerDocument.documentElement;
    this.screen.left = e.left + window.pageXOffset - t.clientLeft, this.screen.top = e.top + window.pageYOffset - t.clientTop, this.screen.width = e.width, this.screen.height = e.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target), this.noRotate || this._rotateCamera(), this.noZoom || this._zoomCamera(), this.noPan || this._panCamera(), this.object.position.addVectors(this.target, this._eye), this.object.isPerspectiveCamera ? (this._checkDistances(), this.object.lookAt(this.target), this._lastPosition.distanceToSquared(this.object.position) > v2 && (this.dispatchEvent(Qx), this._lastPosition.copy(this.object.position))) : this.object.isOrthographicCamera ? (this.object.lookAt(this.target), (this._lastPosition.distanceToSquared(this.object.position) > v2 || this._lastZoom !== this.object.zoom) && (this.dispatchEvent(Qx), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type.");
  }
  reset() {
    this.state = Dn.NONE, this.keyState = Dn.NONE, this.target.copy(this._target0), this.object.position.copy(this._position0), this.object.up.copy(this._up0), this.object.zoom = this._zoom0, this.object.updateProjectionMatrix(), this._eye.subVectors(this.object.position, this.target), this.object.lookAt(this.target), this.dispatchEvent(Qx), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    if (nl.copy(this._panEnd).sub(this._panStart), nl.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const e = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth, t = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        nl.x *= e, nl.y *= t;
      }
      nl.multiplyScalar(this._eye.length() * this.panSpeed), jg.copy(this._eye).cross(this.object.up).setLength(nl.x), jg.add(EX.copy(this.object.up).setLength(nl.y)), this.object.position.add(jg), this.target.add(jg), this.staticMoving ? this._panStart.copy(this._panEnd) : this._panStart.add(nl.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
    }
  }
  _rotateCamera() {
    Zg.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let e = Zg.length();
    e ? (this._eye.copy(this.object.position).sub(this.target), _2.copy(this._eye).normalize(), qg.copy(this.object.up).normalize(), tb.crossVectors(qg, _2).normalize(), qg.setLength(this._moveCurr.y - this._movePrev.y), tb.setLength(this._moveCurr.x - this._movePrev.x), Zg.copy(qg.add(tb)), eb.crossVectors(Zg, this._eye).normalize(), e *= this.rotateSpeed, ph.setFromAxisAngle(eb, e), this._eye.applyQuaternion(ph), this.object.up.applyQuaternion(ph), this._lastAxis.copy(eb), this._lastAngle = e) : !this.staticMoving && this._lastAngle && (this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor), this._eye.copy(this.object.position).sub(this.target), ph.setFromAxisAngle(this._lastAxis, this._lastAngle), this._eye.applyQuaternion(ph), this.object.up.applyQuaternion(ph)), this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let e;
    this.state === Dn.TOUCH_ZOOM_PAN ? (e = this._touchZoomDistanceStart / this._touchZoomDistanceEnd, this._touchZoomDistanceStart = this._touchZoomDistanceEnd, this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Kr.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (e = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed, e !== 1 && e > 0 && (this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Kr.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), this.staticMoving ? this._zoomStart.copy(this._zoomEnd) : this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor);
  }
  _getMouseOnScreen(e, t) {
    return Yg.set(
      (e - this.screen.left) / this.screen.width,
      (t - this.screen.top) / this.screen.height
    ), Yg;
  }
  _getMouseOnCircle(e, t) {
    return Yg.set(
      (e - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - t)) / this.screen.width
      // screen.width intentional
    ), Yg;
  }
  _addPointer(e) {
    this._pointers.push(e);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t].pointerId == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new Be(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t.pointerId];
  }
  _checkDistances() {
    (!this.noZoom || !this.noPan) && (this._eye.lengthSq() > this.maxDistance * this.maxDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance)), this._zoomStart.copy(this._zoomEnd)), this._eye.lengthSq() < this.minDistance * this.minDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance)), this._zoomStart.copy(this._zoomEnd)));
  }
};
function TX(s) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), this._addPointer(s), s.pointerType === "touch" ? this._onTouchStart(s) : this._onMouseDown(s));
}
function AX(s) {
  this.enabled !== !1 && (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s));
}
function CX(s) {
  this.enabled !== !1 && (s.pointerType === "touch" ? this._onTouchEnd(s) : this._onMouseUp(), this._removePointer(s), this._pointers.length === 0 && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp)));
}
function PX(s) {
  this._removePointer(s);
}
function RX() {
  this.enabled !== !1 && (this.keyState = Dn.NONE, window.addEventListener("keydown", this._onKeyDown));
}
function DX(s) {
  this.enabled !== !1 && (window.removeEventListener("keydown", this._onKeyDown), this.keyState === Dn.NONE && (s.code === this.keys[Dn.ROTATE] && !this.noRotate ? this.keyState = Dn.ROTATE : s.code === this.keys[Dn.ZOOM] && !this.noZoom ? this.keyState = Dn.ZOOM : s.code === this.keys[Dn.PAN] && !this.noPan && (this.keyState = Dn.PAN)));
}
function IX(s) {
  let e;
  switch (s.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case Is.DOLLY:
      this.state = Dn.ZOOM;
      break;
    case Is.ROTATE:
      this.state = Dn.ROTATE;
      break;
    case Is.PAN:
      this.state = Dn.PAN;
      break;
    default:
      this.state = Dn.NONE;
  }
  const t = this.keyState !== Dn.NONE ? this.keyState : this.state;
  t === Dn.ROTATE && !this.noRotate ? (this._moveCurr.copy(this._getMouseOnCircle(s.pageX, s.pageY)), this._movePrev.copy(this._moveCurr)) : t === Dn.ZOOM && !this.noZoom ? (this._zoomStart.copy(this._getMouseOnScreen(s.pageX, s.pageY)), this._zoomEnd.copy(this._zoomStart)) : t === Dn.PAN && !this.noPan && (this._panStart.copy(this._getMouseOnScreen(s.pageX, s.pageY)), this._panEnd.copy(this._panStart)), this.dispatchEvent(jS);
}
function LX(s) {
  const e = this.keyState !== Dn.NONE ? this.keyState : this.state;
  e === Dn.ROTATE && !this.noRotate ? (this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(s.pageX, s.pageY))) : e === Dn.ZOOM && !this.noZoom ? this._zoomEnd.copy(this._getMouseOnScreen(s.pageX, s.pageY)) : e === Dn.PAN && !this.noPan && this._panEnd.copy(this._getMouseOnScreen(s.pageX, s.pageY));
}
function UX() {
  this.state = Dn.NONE, this.dispatchEvent(qS);
}
function kX(s) {
  if (this.enabled !== !1 && this.noZoom !== !0) {
    switch (s.preventDefault(), s.deltaMode) {
      case 2:
        this._zoomStart.y -= s.deltaY * 0.025;
        break;
      case 1:
        this._zoomStart.y -= s.deltaY * 0.01;
        break;
      default:
        this._zoomStart.y -= s.deltaY * 25e-5;
        break;
    }
    this.dispatchEvent(jS), this.dispatchEvent(qS);
  }
}
function OX(s) {
  this.enabled !== !1 && s.preventDefault();
}
function FX(s) {
  switch (this._trackPointer(s), this._pointers.length) {
    case 1:
      this.state = Dn.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY)), this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = Dn.TOUCH_ZOOM_PAN;
      const e = this._pointers[0].pageX - this._pointers[1].pageX, t = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(e * e + t * t);
      const i = (this._pointers[0].pageX + this._pointers[1].pageX) / 2, n = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(i, n)), this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(jS);
}
function NX(s) {
  switch (this._trackPointer(s), this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(s.pageX, s.pageY));
      break;
    default:
      const e = this._getSecondPointerPosition(s), t = s.pageX - e.x, i = s.pageY - e.y;
      this._touchZoomDistanceEnd = Math.sqrt(t * t + i * i);
      const n = (s.pageX + e.x) / 2, r = (s.pageY + e.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(n, r));
      break;
  }
}
function BX(s) {
  switch (this._pointers.length) {
    case 0:
      this.state = Dn.NONE;
      break;
    case 1:
      this.state = Dn.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(s.pageX, s.pageY)), this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = Dn.TOUCH_ZOOM_PAN;
      for (let e = 0; e < this._pointers.length; e++)
        if (this._pointers[e].pointerId !== s.pointerId) {
          const t = this._pointerPositions[this._pointers[e].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(t.x, t.y)), this._movePrev.copy(this._moveCurr);
          break;
        }
      break;
  }
  this.dispatchEvent(qS);
}
function yL(s, e) {
  var P;
  if (new.target) return Rt({ component: yL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(m, "$parent", t), r = () => Bn(g, "$camera", t), o = () => Bn(x, "$size", t);
  let a = G(e, "controls", 7), l = G(e, "renderTask", 7), c = G(e, "ref", 15), u = G(e, "onstart", 7), h = G(e, "onchange", 7), d = G(e, "onend", 7), f = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "controls",
    "renderTask",
    "ref",
    "onstart",
    "onchange",
    "onend"
  ]);
  const m = To(), {
    camera: g,
    renderer: v,
    dom: _,
    autoRenderTask: y,
    shouldRender: w,
    size: x,
    invalidate: M
  } = cn();
  c(new p2(g.current, v));
  const A = new Kt(), E = /* @__PURE__ */ wt(() => a() ?? n());
  ti(
    ((P = l()) == null ? void 0 : P.key) ?? Symbol("threlte-extras-gizmo-render"),
    () => {
      if (w()) {
        const T = v.toneMapping;
        v.getViewport(A), v.toneMapping = qo, c().render(), v.setViewport(A), v.toneMapping = T;
      }
    },
    {
      autoInvalidate: !1,
      ...l() ?? { after: y }
    }
  ), $e(() => {
    c(c().camera = r(), !0);
  }), Ht(() => {
    if (pe(E))
      if (pe(E) instanceof vL || pe(E) instanceof _L) {
        c(c().target = pe(E).target, !0);
        const T = () => {
          c().update(!1);
        };
        return pe(E).addEventListener("change", T), () => pe(E).removeEventListener("change", T);
      } else {
        const T = () => {
          "getTarget" in pe(E) && typeof pe(E).getTarget == "function" && (pe(E).getTarget(c().target), c().update());
        }, I = () => {
          pe(E).setPosition(...g.current.position.toArray());
        };
        return c().addEventListener("change", I), pe(E).addEventListener("update", T), () => {
          c().removeEventListener("change", I), pe(E).removeEventListener("update", T);
        };
      }
  }), Ht(() => {
    const T = (I) => {
      var D;
      pe(E).enabled = !1, (D = u()) == null || D(I);
    };
    return c().addEventListener("start", T), () => c().removeEventListener("start", T);
  }), Ht(() => {
    const T = (I) => {
      var D;
      M(), (D = h()) == null || D(I);
    };
    return c().addEventListener("change", T), () => c().removeEventListener("change", T);
  }), Ht(() => {
    const T = (I) => {
      var D;
      pe(E).enabled = !0, (D = d()) == null || D(I);
    };
    return c().addEventListener("end", T), () => c().removeEventListener("end", T);
  }), $e(() => {
    _ && (c().dispose(), c(new p2(g.current, v, {
      container: _,
      placement: "bottom-left",
      size: 86,
      ...f
    })), M());
  }), Ht(() => {
    o(), c().update(), M();
  }), Ht(() => () => c().dispose());
  var C = Pt({
    get controls() {
      return a();
    },
    set controls(T) {
      a(T), V();
    },
    get renderTask() {
      return l();
    },
    set renderTask(T) {
      l(T), V();
    },
    get ref() {
      return c();
    },
    set ref(T) {
      c(T), V();
    },
    get onstart() {
      return u();
    },
    set onstart(T) {
      u(T), V();
    },
    get onchange() {
      return h();
    },
    set onchange(T) {
      h(T), V();
    },
    get onend() {
      return d();
    },
    set onend(T) {
      d(T), V();
    },
    $set: Lt,
    $on: (T, I) => It(e, T, I)
  });
  return i(), C;
}
Ut(
  yL,
  {
    controls: {},
    renderTask: {},
    ref: {},
    onstart: {},
    onchange: {},
    onend: {}
  },
  [],
  [],
  !0
);
const zX = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, VX = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
var GX = /* @__PURE__ */ ni("<!> <!> <!>", 1);
function xL(s, e) {
  if (new.target) return Rt({ component: xL, ...s });
  Ct(e, !0);
  let t = G(e, "opacity", 7, 1), i = G(e, "width", 7, 1), n = G(e, "height", 7, 1), r = G(e, "blur", 7, 1), o = G(e, "far", 7, 10), a = G(e, "smooth", 7, !0), l = G(e, "resolution", 7, 512), c = G(e, "frames", 7, 1 / 0), u = G(e, "scale", 7, 10), h = G(e, "color", 7, "#000000"), d = G(e, "depthWrite", 7, !1), f = G(e, "ref", 15), m = G(e, "children", 7), g = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "opacity",
    "width",
    "height",
    "blur",
    "far",
    "smooth",
    "resolution",
    "frames",
    "scale",
    "color",
    "depthWrite",
    "ref",
    "children"
  ]);
  const { scene: v, renderer: _ } = cn(), y = new Zn(), w = /* @__PURE__ */ wt(() => i() * (Array.isArray(u()) ? u()[0] : u() || 1)), x = /* @__PURE__ */ wt(() => n() * (Array.isArray(u()) ? u()[1] : u() || 1)), M = /* @__PURE__ */ wt(() => {
    const N = new Bs(l(), l());
    return N.texture.generateMipmaps = !1, N.texture.colorSpace = _.outputColorSpace, N;
  }), A = /* @__PURE__ */ wt(() => {
    const N = new Bs(l(), l());
    return N.texture.generateMipmaps = !1, N;
  }), E = /* @__PURE__ */ wt(() => new $r(pe(w), pe(x)).rotateX(Math.PI / 2)), C = /* @__PURE__ */ wt(() => new it(pe(E))), P = /* @__PURE__ */ wt(() => {
    const N = new Ru({ depthTest: !1, depthWrite: !1 });
    return N.onBeforeCompile = (z) => {
      z.uniforms = {
        ...z.uniforms,
        uColor: {
          value: new rt(h()).convertSRGBToLinear()
        }
      }, z.fragmentShader = `uniform vec3 uColor;
${z.fragmentShader}`, z.fragmentShader = z.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );"), z.fragmentShader = z.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
    }, N;
  }), T = new Mi({ ...zX, depthTest: !1 }), I = new Mi({ ...VX, depthTest: !1 }), D = /* @__PURE__ */ wt(() => new Ua(-pe(w) / 2, pe(w) / 2, pe(x) / 2, -pe(x) / 2, 0, o()));
  $e(() => pe(D).updateProjectionMatrix());
  const U = /* @__PURE__ */ wt(() => new qn({
    map: pe(M).texture,
    transparent: !0,
    opacity: t(),
    depthWrite: d()
  })), L = (N) => {
    pe(C).visible = !0, pe(C).material = T, T.uniforms.tDiffuse.value = pe(M).texture, T.uniforms.h.value = N * 1 / 256, _.setRenderTarget(pe(A)), _.render(pe(C), pe(D)), pe(C).material = I, I.uniforms.tDiffuse.value = pe(A).texture, I.uniforms.v.value = N * 1 / 256, _.setRenderTarget(pe(M)), _.render(pe(C), pe(D)), pe(C).visible = !1;
  }, k = () => {
    const N = v.background;
    v.background = null;
    const z = v.overrideMaterial;
    v.overrideMaterial = pe(P);
    const J = _.getClearAlpha();
    _.setClearAlpha(0), _.setRenderTarget(pe(M)), _.render(v, pe(D)), v.overrideMaterial = z, L(r()), a() && L(r() * 0.4), _.setRenderTarget(null), v.background = N, _.setClearAlpha(J);
  }, B = () => {
    k();
  }, j = ti(
    () => {
      k();
    },
    { autoStart: !1 }
  );
  let q = 0;
  const Z = ti(
    () => {
      k(), q += 1, q >= c() && Z.stop();
    },
    { autoStart: !1 }
  );
  return $e(() => {
    c() === Number.POSITIVE_INFINITY ? j.start() : q < c() && Z.start();
  }), Ki(() => {
    pe(M).dispose(), pe(A).dispose(), pe(E).dispose(), pe(P).dispose(), T.dispose(), I.dispose(), pe(U).dispose();
  }), pt(s, sn({ is: y }, () => g, {
    get ref() {
      return f();
    },
    set ref(N) {
      f(N);
    },
    children: (N, z) => {
      var J = At(), se = dt(J);
      Rs(se, () => pt.Group, (K, Q) => {
        Q(K, {
          "rotation.x": Math.PI / 2,
          children: (de, ce) => {
            var _e = GX(), Fe = dt(_e);
            Rs(Fe, () => pt.Mesh, (me, xe) => {
              xe(me, {
                "scale.y": -1,
                "rotation.x": -Math.PI / 2,
                get material() {
                  return pe(U);
                },
                get geometry() {
                  return pe(E);
                }
              });
            });
            var Ie = Wn(Fe, 2);
            pt(Ie, {
              get is() {
                return pe(D);
              },
              manual: !0
            });
            var Ee = Wn(Ie, 2);
            Wt(Ee, () => m() ?? Bt, () => ({ ref: y })), ut(de, _e);
          },
          $$slots: { default: !0 }
        });
      }), ut(N, J);
    },
    $$slots: { default: !0 }
  })), Pt({
    refresh: B,
    get opacity() {
      return t();
    },
    set opacity(N = 1) {
      t(N), V();
    },
    get width() {
      return i();
    },
    set width(N = 1) {
      i(N), V();
    },
    get height() {
      return n();
    },
    set height(N = 1) {
      n(N), V();
    },
    get blur() {
      return r();
    },
    set blur(N = 1) {
      r(N), V();
    },
    get far() {
      return o();
    },
    set far(N = 10) {
      o(N), V();
    },
    get smooth() {
      return a();
    },
    set smooth(N = !0) {
      a(N), V();
    },
    get resolution() {
      return l();
    },
    set resolution(N = 512) {
      l(N), V();
    },
    get frames() {
      return c();
    },
    set frames(N = 1 / 0) {
      c(N), V();
    },
    get scale() {
      return u();
    },
    set scale(N = 10) {
      u(N), V();
    },
    get color() {
      return h();
    },
    set color(N = "#000000") {
      h(N), V();
    },
    get depthWrite() {
      return d();
    },
    set depthWrite(N = !1) {
      d(N), V();
    },
    get ref() {
      return f();
    },
    set ref(N) {
      f(N), V();
    },
    get children() {
      return m();
    },
    set children(N) {
      m(N), V();
    },
    $set: Lt,
    $on: (N, z) => It(e, N, z)
  });
}
Ut(
  xL,
  {
    opacity: {},
    width: {},
    height: {},
    blur: {},
    far: {},
    smooth: {},
    resolution: {},
    frames: {},
    scale: {},
    color: {},
    depthWrite: {},
    ref: {},
    children: {}
  },
  [],
  ["refresh"],
  !0
);
class bL extends gS {
  constructor(e) {
    super(e), this.type = vr;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const o = function(C, P) {
      switch (C) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (P || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (P || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (P || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (P || ""));
      }
    }, u = `
`, h = function(C, P, T) {
      P = P || 1024;
      let D = C.pos, U = -1, L = 0, k = "", B = String.fromCharCode.apply(null, new Uint16Array(C.subarray(D, D + 128)));
      for (; 0 > (U = B.indexOf(u)) && L < P && D < C.byteLength; )
        k += B, L += B.length, D += 128, B += String.fromCharCode.apply(null, new Uint16Array(C.subarray(D, D + 128)));
      return -1 < U ? (C.pos += L + U + 1, k + B.slice(0, U)) : !1;
    }, d = function(C) {
      const P = /^#\?(\S+)/, T = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, I = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, D = /^\s*FORMAT=(\S+)\s*$/, U = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, L = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let k, B;
      for ((C.pos >= C.byteLength || !(k = h(C))) && o(1, "no header found"), (B = k.match(P)) || o(3, "bad initial token"), L.valid |= 1, L.programtype = B[1], L.string += k + `
`; k = h(C), k !== !1; ) {
        if (L.string += k + `
`, k.charAt(0) === "#") {
          L.comments += k + `
`;
          continue;
        }
        if ((B = k.match(T)) && (L.gamma = parseFloat(B[1])), (B = k.match(I)) && (L.exposure = parseFloat(B[1])), (B = k.match(D)) && (L.valid |= 2, L.format = B[1]), (B = k.match(U)) && (L.valid |= 4, L.height = parseInt(B[1], 10), L.width = parseInt(B[2], 10)), L.valid & 2 && L.valid & 4) break;
      }
      return L.valid & 2 || o(3, "missing format specifier"), L.valid & 4 || o(3, "missing image size specifier"), L;
    }, f = function(C, P, T) {
      const I = P;
      if (
        // run length encoding is not allowed so read flat
        I < 8 || I > 32767 || // this file is not run length encoded
        C[0] !== 2 || C[1] !== 2 || C[2] & 128
      )
        return new Uint8Array(C);
      I !== (C[2] << 8 | C[3]) && o(3, "wrong scanline width");
      const D = new Uint8Array(4 * P * T);
      D.length || o(4, "unable to allocate buffer space");
      let U = 0, L = 0;
      const k = 4 * I, B = new Uint8Array(4), j = new Uint8Array(k);
      let q = T;
      for (; q > 0 && L < C.byteLength; ) {
        L + 4 > C.byteLength && o(1), B[0] = C[L++], B[1] = C[L++], B[2] = C[L++], B[3] = C[L++], (B[0] != 2 || B[1] != 2 || (B[2] << 8 | B[3]) != I) && o(3, "bad rgbe scanline format");
        let Z = 0, N;
        for (; Z < k && L < C.byteLength; ) {
          N = C[L++];
          const J = N > 128;
          if (J && (N -= 128), (N === 0 || Z + N > k) && o(3, "bad scanline data"), J) {
            const se = C[L++];
            for (let K = 0; K < N; K++)
              j[Z++] = se;
          } else
            j.set(C.subarray(L, L + N), Z), Z += N, L += N;
        }
        const z = I;
        for (let J = 0; J < z; J++) {
          let se = 0;
          D[U] = j[J + se], se += I, D[U + 1] = j[J + se], se += I, D[U + 2] = j[J + se], se += I, D[U + 3] = j[J + se], U += 4;
        }
        q--;
      }
      return D;
    }, m = function(C, P, T, I) {
      const D = C[P + 3], U = Math.pow(2, D - 128) / 255;
      T[I + 0] = C[P + 0] * U, T[I + 1] = C[P + 1] * U, T[I + 2] = C[P + 2] * U, T[I + 3] = 1;
    }, g = function(C, P, T, I) {
      const D = C[P + 3], U = Math.pow(2, D - 128) / 255;
      T[I + 0] = Gc.toHalfFloat(Math.min(C[P + 0] * U, 65504)), T[I + 1] = Gc.toHalfFloat(Math.min(C[P + 1] * U, 65504)), T[I + 2] = Gc.toHalfFloat(Math.min(C[P + 2] * U, 65504)), T[I + 3] = Gc.toHalfFloat(1);
    }, v = new Uint8Array(e);
    v.pos = 0;
    const _ = d(v), y = _.width, w = _.height, x = f(v.subarray(v.pos), y, w);
    let M, A, E;
    switch (this.type) {
      case Un:
        E = x.length / 4;
        const C = new Float32Array(E * 4);
        for (let T = 0; T < E; T++)
          m(x, T * 4, C, T * 4);
        M = C, A = Un;
        break;
      case vr:
        E = x.length / 4;
        const P = new Uint16Array(E * 4);
        for (let T = 0; T < E; T++)
          g(x, T * 4, P, T * 4);
        M = P, A = vr;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: y,
      height: w,
      data: M,
      header: _.string,
      gamma: _.gamma,
      exposure: _.exposure,
      type: A
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, i, n) {
    function r(o, a) {
      switch (o.type) {
        case Un:
        case vr:
          o.colorSpace = Pi, o.minFilter = Sn, o.magFilter = Sn, o.generateMipmaps = !1, o.flipY = !0;
          break;
      }
      t && t(o, a);
    }
    return super.load(e, r, i, n);
  }
}
class HX extends br {
  constructor(e) {
    super(e), this.hdrLoader = new bL(), this.type = vr;
  }
  load(e, t, i, n) {
    const r = new Ed();
    switch (r.type = this.type, r.type) {
      case Un:
        r.colorSpace = Pi, r.minFilter = Sn, r.magFilter = Sn, r.generateMipmaps = !1;
        break;
      case vr:
        r.colorSpace = Pi, r.minFilter = Sn, r.magFilter = Sn, r.generateMipmaps = !1;
        break;
    }
    const o = this;
    let a = 0;
    function l(c, u, h, d) {
      new ps(o.manager).setPath(o.path).setResponseType("arraybuffer").setWithCredentials(o.withCredentials).load(e[c], function(f) {
        a++;
        const m = o.hdrLoader.parse(f);
        if (m) {
          if (m.data !== void 0) {
            const g = new yr(m.data, m.width, m.height);
            g.type = r.type, g.colorSpace = r.colorSpace, g.format = r.format, g.minFilter = r.minFilter, g.magFilter = r.magFilter, g.generateMipmaps = r.generateMipmaps, r.images[c] = g;
          }
          a === 6 && (r.needsUpdate = !0, u && u(r));
        }
      }, h, d);
    }
    for (let c = 0; c < e.length; c++)
      l(c, t, i, n);
    return r;
  }
  setDataType(e) {
    return this.type = e, this.hdrLoader.setDataType(e), this;
  }
}
const ZS = (s) => {
  const { invalidate: e } = cn();
  zs(() => [s.scene], ([n]) => {
    const r = n.background, o = n.environment;
    return () => {
      n.background = r, n.environment = o;
    };
  });
  let t = Us(void 0), i = Us(void 0);
  zs(() => [s.scene], ([n]) => {
    In(t, pr(n.background)), In(i, pr(n.environment));
  }), Ht(() => {
    if (s.isBackground && s.texture !== void 0)
      return s.scene.background = s.texture, e(), () => {
        pe(t) !== void 0 && (s.scene.background = pe(t), e());
      };
  }), Ht(() => {
    if (s.texture !== void 0)
      return s.scene.environment = s.texture, e(), () => {
        pe(i) !== void 0 && (s.scene.environment = pe(i), e());
      };
  });
}, il = {};
function wL(s, e) {
  if (new.target) return Rt({ component: wL, ...s });
  Ct(e, !0);
  const t = cn();
  let i = G(e, "isBackground", 7, !1), n = G(e, "scene", 23, () => t.scene), r = G(e, "texture", 15), o = G(e, "urls", 7);
  const a = PS(), l = Vl();
  ZS({
    get scene() {
      return n();
    },
    get isBackground() {
      return i();
    },
    get texture() {
      return r();
    }
  });
  const c = /* @__PURE__ */ wt(() => {
    var d;
    return (d = o()) == null ? void 0 : d[0];
  }), u = /* @__PURE__ */ wt(() => {
    var d;
    return ((d = pe(c)) == null ? void 0 : d.endsWith("hdr")) ?? !1;
  }), h = /* @__PURE__ */ wt(() => {
    if (o() !== void 0)
      return pe(u) ? (il.hdr ?? (il.hdr = new HX()), il.hdr) : (il.tex ?? (il.tex = new xI()), il.tex);
  });
  return Ht(() => {
    if (o() !== void 0 && pe(h) !== void 0) {
      const d = l(a.remember(
        () => pe(h).loadAsync(o()),
        o()
      ));
      return d.then((f) => {
        r(f);
      }), () => {
        d.then((f) => {
          f.dispose();
        });
      };
    }
  }), Pt({
    get isBackground() {
      return i();
    },
    set isBackground(d = !1) {
      i(d), V();
    },
    get scene() {
      return n();
    },
    set scene(d = t.scene) {
      n(d), V();
    },
    get texture() {
      return r();
    },
    set texture(d) {
      r(d), V();
    },
    get urls() {
      return o();
    },
    set urls(d) {
      o(d), V();
    },
    $set: Lt,
    $on: (d, f) => It(e, d, f)
  });
}
Ut(
  wL,
  {
    isBackground: {},
    scene: {},
    texture: {},
    urls: {}
  },
  [],
  [],
  !0
);
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/
var Js = Uint8Array, Oh = Uint16Array, WX = Int32Array, SL = new Js([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), ML = new Js([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), XX = new Js([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), EL = function(s, e) {
  for (var t = new Oh(31), i = 0; i < 31; ++i)
    t[i] = e += 1 << s[i - 1];
  for (var n = new WX(t[30]), i = 1; i < 30; ++i)
    for (var r = t[i]; r < t[i + 1]; ++r)
      n[r] = r - t[i] << 5 | i;
  return { b: t, r: n };
}, TL = EL(SL, 2), AL = TL.b, YX = TL.r;
AL[28] = 258, YX[258] = 28;
var jX = EL(ML, 0), qX = jX.b, L1 = new Oh(32768);
for (var si = 0; si < 32768; ++si) {
  var rl = (si & 43690) >> 1 | (si & 21845) << 1;
  rl = (rl & 52428) >> 2 | (rl & 13107) << 2, rl = (rl & 61680) >> 4 | (rl & 3855) << 4, L1[si] = ((rl & 65280) >> 8 | (rl & 255) << 8) >> 1;
}
var mp = function(s, e, t) {
  for (var i = s.length, n = 0, r = new Oh(e); n < i; ++n)
    s[n] && ++r[s[n] - 1];
  var o = new Oh(e);
  for (n = 1; n < e; ++n)
    o[n] = o[n - 1] + r[n - 1] << 1;
  var a;
  if (t) {
    a = new Oh(1 << e);
    var l = 15 - e;
    for (n = 0; n < i; ++n)
      if (s[n])
        for (var c = n << 4 | s[n], u = e - s[n], h = o[s[n] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
          a[L1[h] >> l] = c;
  } else
    for (a = new Oh(i), n = 0; n < i; ++n)
      s[n] && (a[n] = L1[o[s[n] - 1]++] >> 15 - s[n]);
  return a;
}, gm = new Js(288);
for (var si = 0; si < 144; ++si)
  gm[si] = 8;
for (var si = 144; si < 256; ++si)
  gm[si] = 9;
for (var si = 256; si < 280; ++si)
  gm[si] = 7;
for (var si = 280; si < 288; ++si)
  gm[si] = 8;
var CL = new Js(32);
for (var si = 0; si < 32; ++si)
  CL[si] = 5;
var ZX = /* @__PURE__ */ mp(gm, 9, 1), KX = /* @__PURE__ */ mp(CL, 5, 1), nb = function(s) {
  for (var e = s[0], t = 1; t < s.length; ++t)
    s[t] > e && (e = s[t]);
  return e;
}, ho = function(s, e, t) {
  var i = e / 8 | 0;
  return (s[i] | s[i + 1] << 8) >> (e & 7) & t;
}, ib = function(s, e) {
  var t = e / 8 | 0;
  return (s[t] | s[t + 1] << 8 | s[t + 2] << 16) >> (e & 7);
}, $X = function(s) {
  return (s + 7) / 8 | 0;
}, JX = function(s, e, t) {
  return (t == null || t > s.length) && (t = s.length), new Js(s.subarray(e, t));
}, QX = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], mo = function(s, e, t) {
  var i = new Error(e || QX[s]);
  if (i.code = s, Error.captureStackTrace && Error.captureStackTrace(i, mo), !t)
    throw i;
  return i;
}, e9 = function(s, e, t, i) {
  var n = s.length, r = 0;
  if (!n || e.f && !e.l)
    return t || new Js(0);
  var o = !t, a = o || e.i != 2, l = e.i;
  o && (t = new Js(n * 3));
  var c = function(Ee) {
    var me = t.length;
    if (Ee > me) {
      var xe = new Js(Math.max(me * 2, Ee));
      xe.set(t), t = xe;
    }
  }, u = e.f || 0, h = e.p || 0, d = e.b || 0, f = e.l, m = e.d, g = e.m, v = e.n, _ = n * 8;
  do {
    if (!f) {
      u = ho(s, h, 1);
      var y = ho(s, h + 1, 3);
      if (h += 3, y)
        if (y == 1)
          f = ZX, m = KX, g = 9, v = 5;
        else if (y == 2) {
          var A = ho(s, h, 31) + 257, E = ho(s, h + 10, 15) + 4, C = A + ho(s, h + 5, 31) + 1;
          h += 14;
          for (var P = new Js(C), T = new Js(19), I = 0; I < E; ++I)
            T[XX[I]] = ho(s, h + I * 3, 7);
          h += E * 3;
          for (var D = nb(T), U = (1 << D) - 1, L = mp(T, D, 1), I = 0; I < C; ) {
            var k = L[ho(s, h, U)];
            h += k & 15;
            var w = k >> 4;
            if (w < 16)
              P[I++] = w;
            else {
              var B = 0, j = 0;
              for (w == 16 ? (j = 3 + ho(s, h, 3), h += 2, B = P[I - 1]) : w == 17 ? (j = 3 + ho(s, h, 7), h += 3) : w == 18 && (j = 11 + ho(s, h, 127), h += 7); j--; )
                P[I++] = B;
            }
          }
          var q = P.subarray(0, A), Z = P.subarray(A);
          g = nb(q), v = nb(Z), f = mp(q, g, 1), m = mp(Z, v, 1);
        } else
          mo(1);
      else {
        var w = $X(h) + 4, x = s[w - 4] | s[w - 3] << 8, M = w + x;
        if (M > n) {
          l && mo(0);
          break;
        }
        a && c(d + x), t.set(s.subarray(w, M), d), e.b = d += x, e.p = h = M * 8, e.f = u;
        continue;
      }
      if (h > _) {
        l && mo(0);
        break;
      }
    }
    a && c(d + 131072);
    for (var N = (1 << g) - 1, z = (1 << v) - 1, J = h; ; J = h) {
      var B = f[ib(s, h) & N], se = B >> 4;
      if (h += B & 15, h > _) {
        l && mo(0);
        break;
      }
      if (B || mo(2), se < 256)
        t[d++] = se;
      else if (se == 256) {
        J = h, f = null;
        break;
      } else {
        var K = se - 254;
        if (se > 264) {
          var I = se - 257, Q = SL[I];
          K = ho(s, h, (1 << Q) - 1) + AL[I], h += Q;
        }
        var de = m[ib(s, h) & z], ce = de >> 4;
        de || mo(3), h += de & 15;
        var Z = qX[ce];
        if (ce > 3) {
          var Q = ML[ce];
          Z += ib(s, h) & (1 << Q) - 1, h += Q;
        }
        if (h > _) {
          l && mo(0);
          break;
        }
        a && c(d + 131072);
        var _e = d + K;
        if (d < Z) {
          var Fe = r - Z, Ie = Math.min(Z, _e);
          for (Fe + d < 0 && mo(3); d < Ie; ++d)
            t[d] = i[Fe + d];
        }
        for (; d < _e; ++d)
          t[d] = t[d - Z];
      }
    }
    e.l = f, e.p = J, e.b = d, e.f = u, f && (u = 1, e.m = g, e.d = m, e.n = v);
  } while (!u);
  return d != t.length && o ? JX(t, 0, d) : t.subarray(0, d);
}, t9 = /* @__PURE__ */ new Js(0), n9 = function(s, e) {
  return ((s[0] & 15) != 8 || s[0] >> 4 > 7 || (s[0] << 8 | s[1]) % 31) && mo(6, "invalid zlib data"), (s[1] >> 5 & 1) == 1 && mo(6, "invalid zlib data: " + (s[1] & 32 ? "need" : "unexpected") + " dictionary"), (s[1] >> 3 & 4) + 2;
};
function Kg(s, e) {
  return e9(s.subarray(n9(s), -4), { i: 2 }, e, e);
}
var i9 = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), r9 = 0;
try {
  i9.decode(t9, { stream: !0 }), r9 = 1;
} catch {
}
class s9 extends gS {
  constructor(e) {
    super(e), this.type = vr;
  }
  parse(e) {
    const P = Math.pow(2.7182818, 2.2);
    function T(O, ee) {
      let he = 0;
      for (let ie = 0; ie < 65536; ++ie)
        (ie == 0 || O[ie >> 3] & 1 << (ie & 7)) && (ee[he++] = ie);
      const F = he - 1;
      for (; he < 65536; ) ee[he++] = 0;
      return F;
    }
    function I(O) {
      for (let ee = 0; ee < 16384; ee++)
        O[ee] = {}, O[ee].len = 0, O[ee].lit = 0, O[ee].p = null;
    }
    const D = { l: 0, c: 0, lc: 0 };
    function U(O, ee, he, F, ie) {
      for (; he < O; )
        ee = ee << 8 | Le(F, ie), he += 8;
      he -= O, D.l = ee >> he & (1 << O) - 1, D.c = ee, D.lc = he;
    }
    const L = new Array(59);
    function k(O) {
      for (let he = 0; he <= 58; ++he) L[he] = 0;
      for (let he = 0; he < 65537; ++he) L[O[he]] += 1;
      let ee = 0;
      for (let he = 58; he > 0; --he) {
        const F = ee + L[he] >> 1;
        L[he] = ee, ee = F;
      }
      for (let he = 0; he < 65537; ++he) {
        const F = O[he];
        F > 0 && (O[he] = F | L[F]++ << 6);
      }
    }
    function B(O, ee, he, F, ie, re) {
      const ne = ee;
      let ae = 0, we = 0;
      for (; F <= ie; F++) {
        if (ne.value - ee.value > he) return !1;
        U(6, ae, we, O, ne);
        const Pe = D.l;
        if (ae = D.c, we = D.lc, re[F] = Pe, Pe == 63) {
          if (ne.value - ee.value > he)
            throw new Error("Something wrong with hufUnpackEncTable");
          U(8, ae, we, O, ne);
          let Re = D.l + 6;
          if (ae = D.c, we = D.lc, F + Re > ie + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; Re--; ) re[F++] = 0;
          F--;
        } else if (Pe >= 59) {
          let Re = Pe - 59 + 2;
          if (F + Re > ie + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; Re--; ) re[F++] = 0;
          F--;
        }
      }
      k(re);
    }
    function j(O) {
      return O & 63;
    }
    function q(O) {
      return O >> 6;
    }
    function Z(O, ee, he, F) {
      for (; ee <= he; ee++) {
        const ie = q(O[ee]), re = j(O[ee]);
        if (ie >> re)
          throw new Error("Invalid table entry");
        if (re > 14) {
          const ne = F[ie >> re - 14];
          if (ne.len)
            throw new Error("Invalid table entry");
          if (ne.lit++, ne.p) {
            const ae = ne.p;
            ne.p = new Array(ne.lit);
            for (let we = 0; we < ne.lit - 1; ++we)
              ne.p[we] = ae[we];
          } else
            ne.p = new Array(1);
          ne.p[ne.lit - 1] = ee;
        } else if (re) {
          let ne = 0;
          for (let ae = 1 << 14 - re; ae > 0; ae--) {
            const we = F[(ie << 14 - re) + ne];
            if (we.len || we.p)
              throw new Error("Invalid table entry");
            we.len = re, we.lit = ee, ne++;
          }
        }
      }
      return !0;
    }
    const N = { c: 0, lc: 0 };
    function z(O, ee, he, F) {
      O = O << 8 | Le(he, F), ee += 8, N.c = O, N.lc = ee;
    }
    const J = { c: 0, lc: 0 };
    function se(O, ee, he, F, ie, re, ne, ae, we) {
      if (O == ee) {
        F < 8 && (z(he, F, ie, re), he = N.c, F = N.lc), F -= 8;
        let Pe = he >> F;
        if (Pe = new Uint8Array([Pe])[0], ae.value + Pe > we)
          return !1;
        const Re = ne[ae.value - 1];
        for (; Pe-- > 0; )
          ne[ae.value++] = Re;
      } else if (ae.value < we)
        ne[ae.value++] = O;
      else
        return !1;
      J.c = he, J.lc = F;
    }
    function K(O) {
      return O & 65535;
    }
    function Q(O) {
      const ee = K(O);
      return ee > 32767 ? ee - 65536 : ee;
    }
    const de = { a: 0, b: 0 };
    function ce(O, ee) {
      const he = Q(O), ie = Q(ee), re = he + (ie & 1) + (ie >> 1), ne = re, ae = re - ie;
      de.a = ne, de.b = ae;
    }
    function _e(O, ee) {
      const he = K(O), F = K(ee), ie = he - (F >> 1) & 65535, re = F + ie - 32768 & 65535;
      de.a = re, de.b = ie;
    }
    function Fe(O, ee, he, F, ie, re, ne) {
      const ae = ne < 16384, we = he > ie ? ie : he;
      let Pe = 1, Re, He;
      for (; Pe <= we; ) Pe <<= 1;
      for (Pe >>= 1, Re = Pe, Pe >>= 1; Pe >= 1; ) {
        He = 0;
        const qe = He + re * (ie - Re), Ke = re * Pe, Je = re * Re, et = F * Pe, st = F * Re;
        let Et, kt, Ot, bt;
        for (; He <= qe; He += Je) {
          let Yt = He;
          const St = He + F * (he - Re);
          for (; Yt <= St; Yt += st) {
            const mn = Yt + et, ii = Yt + Ke, hn = ii + et;
            ae ? (ce(O[Yt + ee], O[ii + ee]), Et = de.a, Ot = de.b, ce(O[mn + ee], O[hn + ee]), kt = de.a, bt = de.b, ce(Et, kt), O[Yt + ee] = de.a, O[mn + ee] = de.b, ce(Ot, bt), O[ii + ee] = de.a, O[hn + ee] = de.b) : (_e(O[Yt + ee], O[ii + ee]), Et = de.a, Ot = de.b, _e(O[mn + ee], O[hn + ee]), kt = de.a, bt = de.b, _e(Et, kt), O[Yt + ee] = de.a, O[mn + ee] = de.b, _e(Ot, bt), O[ii + ee] = de.a, O[hn + ee] = de.b);
          }
          if (he & Pe) {
            const mn = Yt + Ke;
            ae ? ce(O[Yt + ee], O[mn + ee]) : _e(O[Yt + ee], O[mn + ee]), Et = de.a, O[mn + ee] = de.b, O[Yt + ee] = Et;
          }
        }
        if (ie & Pe) {
          let Yt = He;
          const St = He + F * (he - Re);
          for (; Yt <= St; Yt += st) {
            const mn = Yt + et;
            ae ? ce(O[Yt + ee], O[mn + ee]) : _e(O[Yt + ee], O[mn + ee]), Et = de.a, O[mn + ee] = de.b, O[Yt + ee] = Et;
          }
        }
        Re = Pe, Pe >>= 1;
      }
      return He;
    }
    function Ie(O, ee, he, F, ie, re, ne, ae, we) {
      let Pe = 0, Re = 0;
      const He = ne, qe = Math.trunc(F.value + (ie + 7) / 8);
      for (; F.value < qe; )
        for (z(Pe, Re, he, F), Pe = N.c, Re = N.lc; Re >= 14; ) {
          const Je = Pe >> Re - 14 & 16383, et = ee[Je];
          if (et.len)
            Re -= et.len, se(et.lit, re, Pe, Re, he, F, ae, we, He), Pe = J.c, Re = J.lc;
          else {
            if (!et.p)
              throw new Error("hufDecode issues");
            let st;
            for (st = 0; st < et.lit; st++) {
              const Et = j(O[et.p[st]]);
              for (; Re < Et && F.value < qe; )
                z(Pe, Re, he, F), Pe = N.c, Re = N.lc;
              if (Re >= Et && q(O[et.p[st]]) == (Pe >> Re - Et & (1 << Et) - 1)) {
                Re -= Et, se(et.p[st], re, Pe, Re, he, F, ae, we, He), Pe = J.c, Re = J.lc;
                break;
              }
            }
            if (st == et.lit)
              throw new Error("hufDecode issues");
          }
        }
      const Ke = 8 - ie & 7;
      for (Pe >>= Ke, Re -= Ke; Re > 0; ) {
        const Je = ee[Pe << 14 - Re & 16383];
        if (Je.len)
          Re -= Je.len, se(Je.lit, re, Pe, Re, he, F, ae, we, He), Pe = J.c, Re = J.lc;
        else
          throw new Error("hufDecode issues");
      }
      return !0;
    }
    function Ee(O, ee, he, F, ie, re) {
      const ne = { value: 0 }, ae = he.value, we = Ze(ee, he), Pe = Ze(ee, he);
      he.value += 4;
      const Re = Ze(ee, he);
      if (he.value += 4, we < 0 || we >= 65537 || Pe < 0 || Pe >= 65537)
        throw new Error("Something wrong with HUF_ENCSIZE");
      const He = new Array(65537), qe = new Array(16384);
      I(qe);
      const Ke = F - (he.value - ae);
      if (B(O, he, Ke, we, Pe, He), Re > 8 * (F - (he.value - ae)))
        throw new Error("Something wrong with hufUncompress");
      Z(He, we, Pe, qe), Ie(He, qe, O, he, Re, Pe, re, ie, ne);
    }
    function me(O, ee, he) {
      for (let F = 0; F < he; ++F)
        ee[F] = O[ee[F]];
    }
    function xe(O) {
      for (let ee = 1; ee < O.length; ee++) {
        const he = O[ee - 1] + O[ee] - 128;
        O[ee] = he;
      }
    }
    function $(O, ee) {
      let he = 0, F = Math.floor((O.length + 1) / 2), ie = 0;
      const re = O.length - 1;
      for (; !(ie > re || (ee[ie++] = O[he++], ie > re)); )
        ee[ie++] = O[F++];
    }
    function Ue(O) {
      let ee = O.byteLength;
      const he = new Array();
      let F = 0;
      const ie = new DataView(O);
      for (; ee > 0; ) {
        const re = ie.getInt8(F++);
        if (re < 0) {
          const ne = -re;
          ee -= ne + 1;
          for (let ae = 0; ae < ne; ae++)
            he.push(ie.getUint8(F++));
        } else {
          const ne = re;
          ee -= 2;
          const ae = ie.getUint8(F++);
          for (let we = 0; we < ne + 1; we++)
            he.push(ae);
        }
      }
      return he;
    }
    function Me(O, ee, he, F, ie, re) {
      let ne = new DataView(re.buffer);
      const ae = he[O.idx[0]].width, we = he[O.idx[0]].height, Pe = 3, Re = Math.floor(ae / 8), He = Math.ceil(ae / 8), qe = Math.ceil(we / 8), Ke = ae - (He - 1) * 8, Je = we - (qe - 1) * 8, et = { value: 0 }, st = new Array(Pe), Et = new Array(Pe), kt = new Array(Pe), Ot = new Array(Pe), bt = new Array(Pe);
      for (let St = 0; St < Pe; ++St)
        bt[St] = ee[O.idx[St]], st[St] = St < 1 ? 0 : st[St - 1] + He * qe, Et[St] = new Float32Array(64), kt[St] = new Uint16Array(64), Ot[St] = new Uint16Array(He * 64);
      for (let St = 0; St < qe; ++St) {
        let mn = 8;
        St == qe - 1 && (mn = Je);
        let ii = 8;
        for (let jt = 0; jt < He; ++jt) {
          jt == He - 1 && (ii = Ke);
          for (let Vt = 0; Vt < Pe; ++Vt)
            kt[Vt].fill(0), kt[Vt][0] = ie[st[Vt]++], oe(et, F, kt[Vt]), Te(kt[Vt], Et[Vt]), Ye(Et[Vt]);
          Oe(Et);
          for (let Vt = 0; Vt < Pe; ++Vt)
            X(Et[Vt], Ot[Vt], jt * 64);
        }
        let hn = 0;
        for (let jt = 0; jt < Pe; ++jt) {
          const Vt = he[O.idx[jt]].type;
          for (let zn = 8 * St; zn < 8 * St + mn; ++zn) {
            hn = bt[jt][zn];
            for (let Jn = 0; Jn < Re; ++Jn) {
              const Pn = Jn * 64 + (zn & 7) * 8;
              ne.setUint16(hn + 0 * 2 * Vt, Ot[jt][Pn + 0], !0), ne.setUint16(hn + 1 * 2 * Vt, Ot[jt][Pn + 1], !0), ne.setUint16(hn + 2 * 2 * Vt, Ot[jt][Pn + 2], !0), ne.setUint16(hn + 3 * 2 * Vt, Ot[jt][Pn + 3], !0), ne.setUint16(hn + 4 * 2 * Vt, Ot[jt][Pn + 4], !0), ne.setUint16(hn + 5 * 2 * Vt, Ot[jt][Pn + 5], !0), ne.setUint16(hn + 6 * 2 * Vt, Ot[jt][Pn + 6], !0), ne.setUint16(hn + 7 * 2 * Vt, Ot[jt][Pn + 7], !0), hn += 8 * 2 * Vt;
            }
          }
          if (Re != He)
            for (let zn = 8 * St; zn < 8 * St + mn; ++zn) {
              const Jn = bt[jt][zn] + 8 * Re * 2 * Vt, Pn = Re * 64 + (zn & 7) * 8;
              for (let kn = 0; kn < ii; ++kn)
                ne.setUint16(Jn + kn * 2 * Vt, Ot[jt][Pn + kn], !0);
            }
        }
      }
      const Yt = new Uint16Array(ae);
      ne = new DataView(re.buffer);
      for (let St = 0; St < Pe; ++St) {
        he[O.idx[St]].decoded = !0;
        const mn = he[O.idx[St]].type;
        if (he[St].type == 2)
          for (let ii = 0; ii < we; ++ii) {
            const hn = bt[St][ii];
            for (let jt = 0; jt < ae; ++jt)
              Yt[jt] = ne.getUint16(hn + jt * 2 * mn, !0);
            for (let jt = 0; jt < ae; ++jt)
              ne.setFloat32(hn + jt * 2 * mn, ve(Yt[jt]), !0);
          }
      }
    }
    function oe(O, ee, he) {
      let F, ie = 1;
      for (; ie < 64; )
        F = ee[O.value], F == 65280 ? ie = 64 : F >> 8 == 255 ? ie += F & 255 : (he[ie] = F, ie++), O.value++;
    }
    function Te(O, ee) {
      ee[0] = ve(O[0]), ee[1] = ve(O[1]), ee[2] = ve(O[5]), ee[3] = ve(O[6]), ee[4] = ve(O[14]), ee[5] = ve(O[15]), ee[6] = ve(O[27]), ee[7] = ve(O[28]), ee[8] = ve(O[2]), ee[9] = ve(O[4]), ee[10] = ve(O[7]), ee[11] = ve(O[13]), ee[12] = ve(O[16]), ee[13] = ve(O[26]), ee[14] = ve(O[29]), ee[15] = ve(O[42]), ee[16] = ve(O[3]), ee[17] = ve(O[8]), ee[18] = ve(O[12]), ee[19] = ve(O[17]), ee[20] = ve(O[25]), ee[21] = ve(O[30]), ee[22] = ve(O[41]), ee[23] = ve(O[43]), ee[24] = ve(O[9]), ee[25] = ve(O[11]), ee[26] = ve(O[18]), ee[27] = ve(O[24]), ee[28] = ve(O[31]), ee[29] = ve(O[40]), ee[30] = ve(O[44]), ee[31] = ve(O[53]), ee[32] = ve(O[10]), ee[33] = ve(O[19]), ee[34] = ve(O[23]), ee[35] = ve(O[32]), ee[36] = ve(O[39]), ee[37] = ve(O[45]), ee[38] = ve(O[52]), ee[39] = ve(O[54]), ee[40] = ve(O[20]), ee[41] = ve(O[22]), ee[42] = ve(O[33]), ee[43] = ve(O[38]), ee[44] = ve(O[46]), ee[45] = ve(O[51]), ee[46] = ve(O[55]), ee[47] = ve(O[60]), ee[48] = ve(O[21]), ee[49] = ve(O[34]), ee[50] = ve(O[37]), ee[51] = ve(O[47]), ee[52] = ve(O[50]), ee[53] = ve(O[56]), ee[54] = ve(O[59]), ee[55] = ve(O[61]), ee[56] = ve(O[35]), ee[57] = ve(O[36]), ee[58] = ve(O[48]), ee[59] = ve(O[49]), ee[60] = ve(O[57]), ee[61] = ve(O[58]), ee[62] = ve(O[62]), ee[63] = ve(O[63]);
    }
    function Ye(O) {
      const ee = 0.5 * Math.cos(0.7853975), he = 0.5 * Math.cos(3.14159 / 16), F = 0.5 * Math.cos(3.14159 / 8), ie = 0.5 * Math.cos(3 * 3.14159 / 16), re = 0.5 * Math.cos(5 * 3.14159 / 16), ne = 0.5 * Math.cos(3 * 3.14159 / 8), ae = 0.5 * Math.cos(7 * 3.14159 / 16), we = new Array(4), Pe = new Array(4), Re = new Array(4), He = new Array(4);
      for (let qe = 0; qe < 8; ++qe) {
        const Ke = qe * 8;
        we[0] = F * O[Ke + 2], we[1] = ne * O[Ke + 2], we[2] = F * O[Ke + 6], we[3] = ne * O[Ke + 6], Pe[0] = he * O[Ke + 1] + ie * O[Ke + 3] + re * O[Ke + 5] + ae * O[Ke + 7], Pe[1] = ie * O[Ke + 1] - ae * O[Ke + 3] - he * O[Ke + 5] - re * O[Ke + 7], Pe[2] = re * O[Ke + 1] - he * O[Ke + 3] + ae * O[Ke + 5] + ie * O[Ke + 7], Pe[3] = ae * O[Ke + 1] - re * O[Ke + 3] + ie * O[Ke + 5] - he * O[Ke + 7], Re[0] = ee * (O[Ke + 0] + O[Ke + 4]), Re[3] = ee * (O[Ke + 0] - O[Ke + 4]), Re[1] = we[0] + we[3], Re[2] = we[1] - we[2], He[0] = Re[0] + Re[1], He[1] = Re[3] + Re[2], He[2] = Re[3] - Re[2], He[3] = Re[0] - Re[1], O[Ke + 0] = He[0] + Pe[0], O[Ke + 1] = He[1] + Pe[1], O[Ke + 2] = He[2] + Pe[2], O[Ke + 3] = He[3] + Pe[3], O[Ke + 4] = He[3] - Pe[3], O[Ke + 5] = He[2] - Pe[2], O[Ke + 6] = He[1] - Pe[1], O[Ke + 7] = He[0] - Pe[0];
      }
      for (let qe = 0; qe < 8; ++qe)
        we[0] = F * O[16 + qe], we[1] = ne * O[16 + qe], we[2] = F * O[48 + qe], we[3] = ne * O[48 + qe], Pe[0] = he * O[8 + qe] + ie * O[24 + qe] + re * O[40 + qe] + ae * O[56 + qe], Pe[1] = ie * O[8 + qe] - ae * O[24 + qe] - he * O[40 + qe] - re * O[56 + qe], Pe[2] = re * O[8 + qe] - he * O[24 + qe] + ae * O[40 + qe] + ie * O[56 + qe], Pe[3] = ae * O[8 + qe] - re * O[24 + qe] + ie * O[40 + qe] - he * O[56 + qe], Re[0] = ee * (O[qe] + O[32 + qe]), Re[3] = ee * (O[qe] - O[32 + qe]), Re[1] = we[0] + we[3], Re[2] = we[1] - we[2], He[0] = Re[0] + Re[1], He[1] = Re[3] + Re[2], He[2] = Re[3] - Re[2], He[3] = Re[0] - Re[1], O[0 + qe] = He[0] + Pe[0], O[8 + qe] = He[1] + Pe[1], O[16 + qe] = He[2] + Pe[2], O[24 + qe] = He[3] + Pe[3], O[32 + qe] = He[3] - Pe[3], O[40 + qe] = He[2] - Pe[2], O[48 + qe] = He[1] - Pe[1], O[56 + qe] = He[0] - Pe[0];
    }
    function Oe(O) {
      for (let ee = 0; ee < 64; ++ee) {
        const he = O[0][ee], F = O[1][ee], ie = O[2][ee];
        O[0][ee] = he + 1.5747 * ie, O[1][ee] = he - 0.1873 * F - 0.4682 * ie, O[2][ee] = he + 1.8556 * F;
      }
    }
    function X(O, ee, he) {
      for (let F = 0; F < 64; ++F)
        ee[he + F] = Gc.toHalfFloat(Y(O[F]));
    }
    function Y(O) {
      return O <= 1 ? Math.sign(O) * Math.pow(Math.abs(O), 2.2) : Math.sign(O) * Math.pow(P, Math.abs(O) - 1);
    }
    function fe(O) {
      return new DataView(O.array.buffer, O.offset.value, O.size);
    }
    function ue(O) {
      const ee = O.viewer.buffer.slice(O.offset.value, O.offset.value + O.size), he = new Uint8Array(Ue(ee)), F = new Uint8Array(he.length);
      return xe(he), $(he, F), new DataView(F.buffer);
    }
    function te(O) {
      const ee = O.array.slice(O.offset.value, O.offset.value + O.size), he = Kg(ee), F = new Uint8Array(he.length);
      return xe(he), $(he, F), new DataView(F.buffer);
    }
    function Se(O) {
      const ee = O.viewer, he = { value: O.offset.value }, F = new Uint16Array(O.columns * O.lines * (O.inputChannels.length * O.type)), ie = new Uint8Array(8192);
      let re = 0;
      const ne = new Array(O.inputChannels.length);
      for (let Je = 0, et = O.inputChannels.length; Je < et; Je++)
        ne[Je] = {}, ne[Je].start = re, ne[Je].end = ne[Je].start, ne[Je].nx = O.columns, ne[Je].ny = O.lines, ne[Je].size = O.type, re += ne[Je].nx * ne[Je].ny * ne[Je].size;
      const ae = be(ee, he), we = be(ee, he);
      if (we >= 8192)
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      if (ae <= we)
        for (let Je = 0; Je < we - ae + 1; Je++)
          ie[Je + ae] = ot(ee, he);
      const Pe = new Uint16Array(65536), Re = T(ie, Pe), He = Ze(ee, he);
      Ee(O.array, ee, he, He, F, re);
      for (let Je = 0; Je < O.inputChannels.length; ++Je) {
        const et = ne[Je];
        for (let st = 0; st < ne[Je].size; ++st)
          Fe(
            F,
            et.start + st,
            et.nx,
            et.size,
            et.ny,
            et.nx * et.size,
            Re
          );
      }
      me(Pe, F, re);
      let qe = 0;
      const Ke = new Uint8Array(F.buffer.byteLength);
      for (let Je = 0; Je < O.lines; Je++)
        for (let et = 0; et < O.inputChannels.length; et++) {
          const st = ne[et], Et = st.nx * st.size, kt = new Uint8Array(F.buffer, st.end * 2, Et * 2);
          Ke.set(kt, qe), qe += Et * 2, st.end += Et;
        }
      return new DataView(Ke.buffer);
    }
    function ye(O) {
      const ee = O.array.slice(O.offset.value, O.offset.value + O.size), he = Kg(ee), F = O.inputChannels.length * O.lines * O.columns * O.totalBytes, ie = new ArrayBuffer(F), re = new DataView(ie);
      let ne = 0, ae = 0;
      const we = new Array(4);
      for (let Pe = 0; Pe < O.lines; Pe++)
        for (let Re = 0; Re < O.inputChannels.length; Re++) {
          let He = 0;
          switch (O.inputChannels[Re].pixelType) {
            case 1:
              we[0] = ne, we[1] = we[0] + O.columns, ne = we[1] + O.columns;
              for (let Ke = 0; Ke < O.columns; ++Ke) {
                const Je = he[we[0]++] << 8 | he[we[1]++];
                He += Je, re.setUint16(ae, He, !0), ae += 2;
              }
              break;
            case 2:
              we[0] = ne, we[1] = we[0] + O.columns, we[2] = we[1] + O.columns, ne = we[2] + O.columns;
              for (let Ke = 0; Ke < O.columns; ++Ke) {
                const Je = he[we[0]++] << 24 | he[we[1]++] << 16 | he[we[2]++] << 8;
                He += Je, re.setUint32(ae, He, !0), ae += 4;
              }
              break;
          }
        }
      return re;
    }
    function Ae(O) {
      const ee = O.viewer, he = { value: O.offset.value }, F = new Uint8Array(O.columns * O.lines * (O.inputChannels.length * O.type * 2)), ie = {
        version: tt(ee, he),
        unknownUncompressedSize: tt(ee, he),
        unknownCompressedSize: tt(ee, he),
        acCompressedSize: tt(ee, he),
        dcCompressedSize: tt(ee, he),
        rleCompressedSize: tt(ee, he),
        rleUncompressedSize: tt(ee, he),
        rleRawSize: tt(ee, he),
        totalAcUncompressedCount: tt(ee, he),
        totalDcUncompressedCount: tt(ee, he),
        acCompression: tt(ee, he)
      };
      if (ie.version < 2)
        throw new Error("EXRLoader.parse: " + un.compression + " version " + ie.version + " is unsupported");
      const re = new Array();
      let ne = be(ee, he) - 2;
      for (; ne > 0; ) {
        const et = Ce(ee.buffer, he), st = ot(ee, he), Et = st >> 2 & 3, kt = (st >> 4) - 1, Ot = new Int8Array([kt])[0], bt = ot(ee, he);
        re.push({
          name: et,
          index: Ot,
          type: bt,
          compression: Et
        }), ne -= et.length + 3;
      }
      const ae = un.channels, we = new Array(O.inputChannels.length);
      for (let et = 0; et < O.inputChannels.length; ++et) {
        const st = we[et] = {}, Et = ae[et];
        st.name = Et.name, st.compression = 0, st.decoded = !1, st.type = Et.pixelType, st.pLinear = Et.pLinear, st.width = O.columns, st.height = O.lines;
      }
      const Pe = {
        idx: new Array(3)
      };
      for (let et = 0; et < O.inputChannels.length; ++et) {
        const st = we[et];
        for (let Et = 0; Et < re.length; ++Et) {
          const kt = re[Et];
          st.name == kt.name && (st.compression = kt.compression, kt.index >= 0 && (Pe.idx[kt.index] = et), st.offset = et);
        }
      }
      let Re, He, qe;
      if (ie.acCompressedSize > 0)
        switch (ie.acCompression) {
          case 0:
            Re = new Uint16Array(ie.totalAcUncompressedCount), Ee(O.array, ee, he, ie.acCompressedSize, Re, ie.totalAcUncompressedCount);
            break;
          case 1:
            const et = O.array.slice(he.value, he.value + ie.totalAcUncompressedCount), st = Kg(et);
            Re = new Uint16Array(st.buffer), he.value += ie.totalAcUncompressedCount;
            break;
        }
      if (ie.dcCompressedSize > 0) {
        const et = {
          array: O.array,
          offset: he,
          size: ie.dcCompressedSize
        };
        He = new Uint16Array(te(et).buffer), he.value += ie.dcCompressedSize;
      }
      if (ie.rleRawSize > 0) {
        const et = O.array.slice(he.value, he.value + ie.rleCompressedSize), st = Kg(et);
        qe = Ue(st.buffer), he.value += ie.rleCompressedSize;
      }
      let Ke = 0;
      const Je = new Array(we.length);
      for (let et = 0; et < Je.length; ++et)
        Je[et] = new Array();
      for (let et = 0; et < O.lines; ++et)
        for (let st = 0; st < we.length; ++st)
          Je[st].push(Ke), Ke += we[st].width * O.type * 2;
      Me(Pe, Je, we, Re, He, F);
      for (let et = 0; et < we.length; ++et) {
        const st = we[et];
        if (!st.decoded)
          switch (st.compression) {
            case 2:
              let Et = 0, kt = 0;
              for (let Ot = 0; Ot < O.lines; ++Ot) {
                let bt = Je[et][Et];
                for (let Yt = 0; Yt < st.width; ++Yt) {
                  for (let St = 0; St < 2 * st.type; ++St)
                    F[bt++] = qe[kt + St * st.width * st.height];
                  kt++;
                }
                Et++;
              }
              break;
            case 1:
            // skip
            default:
              throw new Error("EXRLoader.parse: unsupported channel compression");
          }
      }
      return new DataView(F.buffer);
    }
    function Ce(O, ee) {
      const he = new Uint8Array(O);
      let F = 0;
      for (; he[ee.value + F] != 0; )
        F += 1;
      const ie = new TextDecoder().decode(
        he.slice(ee.value, ee.value + F)
      );
      return ee.value = ee.value + F + 1, ie;
    }
    function Ge(O, ee, he) {
      const F = new TextDecoder().decode(
        new Uint8Array(O).slice(ee.value, ee.value + he)
      );
      return ee.value = ee.value + he, F;
    }
    function De(O, ee) {
      const he = ze(O, ee), F = Ze(O, ee);
      return [he, F];
    }
    function Ve(O, ee) {
      const he = Ze(O, ee), F = Ze(O, ee);
      return [he, F];
    }
    function ze(O, ee) {
      const he = O.getInt32(ee.value, !0);
      return ee.value = ee.value + 4, he;
    }
    function Ze(O, ee) {
      const he = O.getUint32(ee.value, !0);
      return ee.value = ee.value + 4, he;
    }
    function Le(O, ee) {
      const he = O[ee.value];
      return ee.value = ee.value + 1, he;
    }
    function ot(O, ee) {
      const he = O.getUint8(ee.value);
      return ee.value = ee.value + 1, he;
    }
    const tt = function(O, ee) {
      let he;
      return "getBigInt64" in DataView.prototype ? he = Number(O.getBigInt64(ee.value, !0)) : he = O.getUint32(ee.value + 4, !0) + Number(O.getUint32(ee.value, !0) << 32), ee.value += 8, he;
    };
    function mt(O, ee) {
      const he = O.getFloat32(ee.value, !0);
      return ee.value += 4, he;
    }
    function le(O, ee) {
      return Gc.toHalfFloat(mt(O, ee));
    }
    function ve(O) {
      const ee = (O & 31744) >> 10, he = O & 1023;
      return (O >> 15 ? -1 : 1) * (ee ? ee === 31 ? he ? NaN : 1 / 0 : Math.pow(2, ee - 15) * (1 + he / 1024) : 6103515625e-14 * (he / 1024));
    }
    function be(O, ee) {
      const he = O.getUint16(ee.value, !0);
      return ee.value += 2, he;
    }
    function Xe(O, ee) {
      return ve(be(O, ee));
    }
    function We(O, ee, he, F) {
      const ie = he.value, re = [];
      for (; he.value < ie + F - 1; ) {
        const ne = Ce(ee, he), ae = ze(O, he), we = ot(O, he);
        he.value += 3;
        const Pe = ze(O, he), Re = ze(O, he);
        re.push({
          name: ne,
          pixelType: ae,
          pLinear: we,
          xSampling: Pe,
          ySampling: Re
        });
      }
      return he.value += 1, re;
    }
    function Ne(O, ee) {
      const he = mt(O, ee), F = mt(O, ee), ie = mt(O, ee), re = mt(O, ee), ne = mt(O, ee), ae = mt(O, ee), we = mt(O, ee), Pe = mt(O, ee);
      return { redX: he, redY: F, greenX: ie, greenY: re, blueX: ne, blueY: ae, whiteX: we, whiteY: Pe };
    }
    function ct(O, ee) {
      const he = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], F = ot(O, ee);
      return he[F];
    }
    function gt(O, ee) {
      const he = ze(O, ee), F = ze(O, ee), ie = ze(O, ee), re = ze(O, ee);
      return { xMin: he, yMin: F, xMax: ie, yMax: re };
    }
    function nt(O, ee) {
      const he = [
        "INCREASING_Y",
        "DECREASING_Y",
        "RANDOM_Y"
      ], F = ot(O, ee);
      return he[F];
    }
    function je(O, ee) {
      const he = [
        "ENVMAP_LATLONG",
        "ENVMAP_CUBE"
      ], F = ot(O, ee);
      return he[F];
    }
    function at(O, ee) {
      const he = [
        "ONE_LEVEL",
        "MIPMAP_LEVELS",
        "RIPMAP_LEVELS"
      ], F = [
        "ROUND_DOWN",
        "ROUND_UP"
      ], ie = Ze(O, ee), re = Ze(O, ee), ne = ot(O, ee);
      return {
        xSize: ie,
        ySize: re,
        levelMode: he[ne & 15],
        roundingMode: F[ne >> 4]
      };
    }
    function ft(O, ee) {
      const he = mt(O, ee), F = mt(O, ee);
      return [he, F];
    }
    function Qe(O, ee) {
      const he = mt(O, ee), F = mt(O, ee), ie = mt(O, ee);
      return [he, F, ie];
    }
    function xt(O, ee, he, F, ie) {
      if (F === "string" || F === "stringvector" || F === "iccProfile")
        return Ge(ee, he, ie);
      if (F === "chlist")
        return We(O, ee, he, ie);
      if (F === "chromaticities")
        return Ne(O, he);
      if (F === "compression")
        return ct(O, he);
      if (F === "box2i")
        return gt(O, he);
      if (F === "envmap")
        return je(O, he);
      if (F === "tiledesc")
        return at(O, he);
      if (F === "lineOrder")
        return nt(O, he);
      if (F === "float")
        return mt(O, he);
      if (F === "v2f")
        return ft(O, he);
      if (F === "v3f")
        return Qe(O, he);
      if (F === "int")
        return ze(O, he);
      if (F === "rational")
        return De(O, he);
      if (F === "timecode")
        return Ve(O, he);
      if (F === "preview")
        return he.value += ie, "skipped";
      he.value += ie;
    }
    function yt(O, ee) {
      const he = Math.log2(O);
      return ee == "ROUND_DOWN" ? Math.floor(he) : Math.ceil(he);
    }
    function Mt(O, ee, he) {
      let F = 0;
      switch (O.levelMode) {
        case "ONE_LEVEL":
          F = 1;
          break;
        case "MIPMAP_LEVELS":
          F = yt(Math.max(ee, he), O.roundingMode) + 1;
          break;
        case "RIPMAP_LEVELS":
          throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.");
      }
      return F;
    }
    function nn(O, ee, he, F) {
      const ie = new Array(O);
      for (let re = 0; re < O; re++) {
        const ne = 1 << re;
        let ae = ee / ne | 0;
        F == "ROUND_UP" && ae * ne < ee && (ae += 1);
        const we = Math.max(ae, 1);
        ie[re] = (we + he - 1) / he | 0;
      }
      return ie;
    }
    function zt() {
      const O = this, ee = O.offset, he = { value: 0 };
      for (let F = 0; F < O.tileCount; F++) {
        const ie = ze(O.viewer, ee), re = ze(O.viewer, ee);
        ee.value += 8, O.size = Ze(O.viewer, ee);
        const ne = ie * O.blockWidth, ae = re * O.blockHeight;
        O.columns = ne + O.blockWidth > O.width ? O.width - ne : O.blockWidth, O.lines = ae + O.blockHeight > O.height ? O.height - ae : O.blockHeight;
        const we = O.columns * O.totalBytes, Re = O.size < O.lines * we ? O.uncompress(O) : fe(O);
        ee.value += O.size;
        for (let He = 0; He < O.lines; He++) {
          const qe = He * O.columns * O.totalBytes;
          for (let Ke = 0; Ke < O.inputChannels.length; Ke++) {
            const Je = un.channels[Ke].name, et = O.channelByteOffsets[Je] * O.columns, st = O.decodeChannels[Je];
            if (st === void 0) continue;
            he.value = qe + et;
            const Et = (O.height - (1 + ae + He)) * O.outLineWidth;
            for (let kt = 0; kt < O.columns; kt++) {
              const Ot = Et + (kt + ne) * O.outputChannels + st;
              O.byteArray[Ot] = O.getter(Re, he);
            }
          }
        }
      }
    }
    function $t() {
      const O = this, ee = O.offset, he = { value: 0 };
      for (let F = 0; F < O.height / O.blockHeight; F++) {
        const ie = ze(O.viewer, ee) - un.dataWindow.yMin;
        O.size = Ze(O.viewer, ee), O.lines = ie + O.blockHeight > O.height ? O.height - ie : O.blockHeight;
        const re = O.columns * O.totalBytes, ae = O.size < O.lines * re ? O.uncompress(O) : fe(O);
        ee.value += O.size;
        for (let we = 0; we < O.blockHeight; we++) {
          const Pe = F * O.blockHeight, Re = we + O.scanOrder(Pe);
          if (Re >= O.height) continue;
          const He = we * re, qe = (O.height - 1 - Re) * O.outLineWidth;
          for (let Ke = 0; Ke < O.inputChannels.length; Ke++) {
            const Je = un.channels[Ke].name, et = O.channelByteOffsets[Je] * O.columns, st = O.decodeChannels[Je];
            if (st !== void 0) {
              he.value = He + et;
              for (let Et = 0; Et < O.columns; Et++) {
                const kt = qe + Et * O.outputChannels + st;
                O.byteArray[kt] = O.getter(ae, he);
              }
            }
          }
        }
      }
    }
    function qt(O, ee, he) {
      const F = {};
      if (O.getUint32(0, !0) != 20000630)
        throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
      F.version = O.getUint8(4);
      const ie = O.getUint8(5);
      F.spec = {
        singleTile: !!(ie & 2),
        longName: !!(ie & 4),
        deepFormat: !!(ie & 8),
        multiPart: !!(ie & 16)
      }, he.value = 8;
      let re = !0;
      for (; re; ) {
        const ne = Ce(ee, he);
        if (ne == 0)
          re = !1;
        else {
          const ae = Ce(ee, he), we = Ze(O, he), Pe = xt(O, ee, he, ae, we);
          Pe === void 0 ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${ae}'.`) : F[ne] = Pe;
        }
      }
      if (ie & -7)
        throw console.error("THREE.EXRHeader:", F), new Error("THREE.EXRLoader: Provided file is currently unsupported.");
      return F;
    }
    function en(O, ee, he, F, ie) {
      const re = {
        size: 0,
        viewer: ee,
        array: he,
        offset: F,
        width: O.dataWindow.xMax - O.dataWindow.xMin + 1,
        height: O.dataWindow.yMax - O.dataWindow.yMin + 1,
        inputChannels: O.channels,
        channelByteOffsets: {},
        scanOrder: null,
        totalBytes: null,
        columns: null,
        lines: null,
        type: null,
        uncompress: null,
        getter: null,
        format: null,
        colorSpace: Pi
      };
      switch (O.compression) {
        case "NO_COMPRESSION":
          re.blockHeight = 1, re.uncompress = fe;
          break;
        case "RLE_COMPRESSION":
          re.blockHeight = 1, re.uncompress = ue;
          break;
        case "ZIPS_COMPRESSION":
          re.blockHeight = 1, re.uncompress = te;
          break;
        case "ZIP_COMPRESSION":
          re.blockHeight = 16, re.uncompress = te;
          break;
        case "PIZ_COMPRESSION":
          re.blockHeight = 32, re.uncompress = Se;
          break;
        case "PXR24_COMPRESSION":
          re.blockHeight = 16, re.uncompress = ye;
          break;
        case "DWAA_COMPRESSION":
          re.blockHeight = 32, re.uncompress = Ae;
          break;
        case "DWAB_COMPRESSION":
          re.blockHeight = 256, re.uncompress = Ae;
          break;
        default:
          throw new Error("EXRLoader.parse: " + O.compression + " is unsupported");
      }
      const ne = {};
      for (const Re of O.channels)
        switch (Re.name) {
          case "Y":
          case "R":
          case "G":
          case "B":
          case "A":
            ne[Re.name] = !0, re.type = Re.pixelType;
        }
      let ae = !1;
      if (ne.R && ne.G && ne.B)
        ae = !ne.A, re.outputChannels = 4, re.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };
      else if (ne.Y)
        re.outputChannels = 1, re.decodeChannels = { Y: 0 };
      else
        throw new Error("EXRLoader.parse: file contains unsupported data channels.");
      if (re.type == 1)
        switch (ie) {
          case Un:
            re.getter = Xe;
            break;
          case vr:
            re.getter = be;
            break;
        }
      else if (re.type == 2)
        switch (ie) {
          case Un:
            re.getter = mt;
            break;
          case vr:
            re.getter = le;
        }
      else
        throw new Error("EXRLoader.parse: unsupported pixelType " + re.type + " for " + O.compression + ".");
      re.columns = re.width;
      const we = re.width * re.height * re.outputChannels;
      switch (ie) {
        case Un:
          re.byteArray = new Float32Array(we), ae && re.byteArray.fill(1, 0, we);
          break;
        case vr:
          re.byteArray = new Uint16Array(we), ae && re.byteArray.fill(15360, 0, we);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", ie);
          break;
      }
      let Pe = 0;
      for (const Re of O.channels)
        re.decodeChannels[Re.name] !== void 0 && (re.channelByteOffsets[Re.name] = Pe), Pe += Re.pixelType * 2;
      if (re.totalBytes = Pe, re.outLineWidth = re.width * re.outputChannels, O.lineOrder === "INCREASING_Y" ? re.scanOrder = (Re) => Re : re.scanOrder = (Re) => re.height - 1 - Re, re.outputChannels == 4 ? (re.format = di, re.colorSpace = Pi) : (re.format = bd, re.colorSpace = Fo), O.spec.singleTile) {
        re.blockHeight = O.tiles.ySize, re.blockWidth = O.tiles.xSize;
        const Re = Mt(O.tiles, re.width, re.height), He = nn(Re, re.width, O.tiles.xSize, O.tiles.roundingMode), qe = nn(Re, re.height, O.tiles.ySize, O.tiles.roundingMode);
        re.tileCount = He[0] * qe[0];
        for (let Ke = 0; Ke < Re; Ke++)
          for (let Je = 0; Je < qe[Ke]; Je++)
            for (let et = 0; et < He[Ke]; et++)
              tt(ee, F);
        re.decode = zt.bind(re);
      } else {
        re.blockWidth = re.width;
        const Re = Math.ceil(re.height / re.blockHeight);
        for (let He = 0; He < Re; He++)
          tt(ee, F);
        re.decode = $t.bind(re);
      }
      return re;
    }
    const xn = { value: 0 }, on = new DataView(e), zi = new Uint8Array(e), un = qt(on, e, xn), An = en(un, on, zi, xn, this.type);
    return An.decode(), {
      header: un,
      width: An.width,
      height: An.height,
      data: An.byteArray,
      format: An.format,
      colorSpace: An.colorSpace,
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, i, n) {
    function r(o, a) {
      o.colorSpace = a.colorSpace, o.minFilter = Sn, o.magFilter = Sn, o.generateMipmaps = !1, o.flipY = !1, t && t(o, a);
    }
    return super.load(e, r, i, n);
  }
}
class o9 extends it {
  constructor(e, t, i, n = 128) {
    if (t <= 0 || i <= 0 || n <= 0)
      throw new Error("GroundedSkybox height, radius, and resolution must be positive.");
    const r = new Bl(i, 2 * n, n);
    r.scale(1, 1, -1);
    const o = r.getAttribute("position"), a = new H();
    for (let l = 0; l < o.count; ++l)
      if (a.fromBufferAttribute(o, l), a.y < 0) {
        const c = -t * 3 / 2, u = a.y < c ? -t / a.y : 1 - a.y * a.y / (3 * c * c);
        a.multiplyScalar(u), a.toArray(o.array, 3 * l);
      }
    o.needsUpdate = !0, super(r, new qn({ map: e, depthWrite: !1 }));
  }
}
const Ws = {};
function PL(s, e) {
  if (new.target) return Rt({ component: PL, ...s });
  Ct(e, !0);
  const t = cn();
  let i = G(e, "skybox", 15), n = G(e, "texture", 15), r = G(e, "ground", 7, !1), o = G(e, "isBackground", 7, !1), a = G(e, "scene", 23, () => t.scene), l = G(e, "url", 7);
  const c = Vl(), u = PS();
  ZS({
    get scene() {
      return a();
    },
    get isBackground() {
      return o();
    },
    get texture() {
      return n();
    }
  });
  const h = /* @__PURE__ */ wt(() => {
    var _;
    return ((_ = l()) == null ? void 0 : _.endsWith("exr")) ?? !1;
  }), d = /* @__PURE__ */ wt(() => {
    var _;
    return ((_ = l()) == null ? void 0 : _.endsWith("hdr")) ?? !1;
  }), f = /* @__PURE__ */ wt(() => {
    if (l() !== void 0)
      return pe(h) ? (Ws.exr ?? (Ws.exr = new s9()), Ws.exr) : pe(d) ? (Ws.hdr ?? (Ws.hdr = new bL()), Ws.hdr) : (Ws.tex ?? (Ws.tex = new j_()), Ws.tex);
  });
  Ht(() => {
    if (l() !== void 0 && pe(f) !== void 0) {
      const _ = c(u.remember(
        () => pe(f).loadAsync(l()),
        [l()]
      ));
      return _.then((y) => {
        y.mapping = ld, n(y);
      }), () => {
        _.then((y) => {
          y.dispose();
        });
      };
    }
  });
  var m = At(), g = dt(m);
  {
    var v = (_) => {
      var y = At();
      const w = /* @__PURE__ */ wt(() => r() === !0 ? {} : r());
      var x = dt(y);
      {
        var M = (A) => {
          const E = /* @__PURE__ */ wt(() => [
            n(),
            pe(w).height ?? 1,
            pe(w).radius ?? 1,
            pe(w).resolution ?? 128
          ]);
          pt(A, {
            is: o9,
            oncreate: () => () => {
              i(void 0);
            },
            get args() {
              return pe(E);
            },
            get ref() {
              return i();
            },
            set ref(C) {
              i(C);
            }
          });
        };
        Ai(x, (A) => {
          n() && A(M);
        });
      }
      ut(_, y);
    };
    Ai(g, (_) => {
      r() && _(v);
    });
  }
  return ut(s, m), Pt({
    get skybox() {
      return i();
    },
    set skybox(_) {
      i(_), V();
    },
    get texture() {
      return n();
    },
    set texture(_) {
      n(_), V();
    },
    get ground() {
      return r();
    },
    set ground(_ = !1) {
      r(_), V();
    },
    get isBackground() {
      return o();
    },
    set isBackground(_ = !1) {
      o(_), V();
    },
    get scene() {
      return a();
    },
    set scene(_ = t.scene) {
      a(_), V();
    },
    get url() {
      return l();
    },
    set url(_) {
      l(_), V();
    },
    $set: Lt,
    $on: (_, y) => It(e, _, y)
  });
}
Ut(
  PL,
  {
    skybox: {},
    texture: {},
    ground: {},
    isBackground: {},
    scene: {},
    url: {}
  },
  [],
  [],
  !0
);
const a9 = 1, rb = 1e3, l9 = 256, RL = (s = () => rb, e = () => rb, t = () => l9) => {
  const i = new T_(t()), n = new E_(a9, rb, i);
  return Ht(() => {
    const r = t();
    i.setSize(r, r);
  }), Ht(() => {
    const r = s();
    for (const o of n.children)
      bn(o, "PerspectiveCamera") && (o.near = r, o.updateProjectionMatrix());
  }), Ht(() => {
    const r = e();
    for (const o of n.children)
      bn(o, "PerspectiveCamera") && (o.far = r, o.updateProjectionMatrix());
  }), Ht(() => () => {
    i.dispose();
  }), { camera: n, renderTarget: i };
};
var c9 = /* @__PURE__ */ ni("<!> <!>", 1);
function DL(s, e) {
  if (new.target) return Rt({ component: DL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(E, "$started", t), r = cn();
  let o = G(e, "far", 7, 1e3), a = G(e, "frames", 7, 1 / 0), l = G(e, "isBackground", 7), c = G(e, "near", 7, 0.1), u = G(e, "onupdatestart", 7), h = G(e, "onupdatestop", 7), d = G(e, "resolution", 7, 256), f = G(e, "scene", 23, () => r.scene), m = G(e, "visible", 7), g = G(e, "children", 7);
  const { scene: v } = ey(), { camera: _, renderTarget: y } = RL(() => c(), () => o(), () => d());
  ZS({
    texture: y.texture,
    get scene() {
      return f();
    },
    get isBackground() {
      return l();
    }
  });
  const w = () => {
    _.update(r.renderer, v);
  };
  let x = 0;
  const { start: M, stop: A, started: E } = ti(
    () => {
      var I;
      x < a() ? (w(), x += 1) : (A(), (I = h()) == null || I());
    },
    { autoStart: !1 }
  ), C = () => {
    var I, D;
    n() && (A(), (I = h()) == null || I()), x = 0, M(), (D = u()) == null || D();
  };
  zs(
    () => [
      o(),
      c(),
      a(),
      d()
    ],
    C
  );
  const P = /* @__PURE__ */ wt(() => m() ? void 0 : !1);
  pt(s, {
    is: v,
    get attach() {
      return pe(P);
    },
    children: (I, D) => {
      var U = c9(), L = dt(U);
      pt(L, { is: _ });
      var k = Wn(L, 2);
      Wt(k, () => g() ?? Bt, () => ({ camera: _, renderTarget: y, restart: C, update: w })), ut(I, U);
    },
    $$slots: { default: !0 }
  });
  var T = Pt({
    camera: _,
    renderTarget: y,
    update: w,
    restart: C,
    get far() {
      return o();
    },
    set far(I = 1e3) {
      o(I), V();
    },
    get frames() {
      return a();
    },
    set frames(I = 1 / 0) {
      a(I), V();
    },
    get isBackground() {
      return l();
    },
    set isBackground(I) {
      l(I), V();
    },
    get near() {
      return c();
    },
    set near(I = 0.1) {
      c(I), V();
    },
    get onupdatestart() {
      return u();
    },
    set onupdatestart(I) {
      u(I), V();
    },
    get onupdatestop() {
      return h();
    },
    set onupdatestop(I) {
      h(I), V();
    },
    get resolution() {
      return d();
    },
    set resolution(I = 256) {
      d(I), V();
    },
    get scene() {
      return f();
    },
    set scene(I = r.scene) {
      f(I), V();
    },
    get visible() {
      return m();
    },
    set visible(I) {
      m(I), V();
    },
    get children() {
      return g();
    },
    set children(I) {
      g(I), V();
    },
    $set: Lt,
    $on: (I, D) => It(e, I, D)
  });
  return i(), T;
}
Ut(
  DL,
  {
    far: {},
    frames: {},
    isBackground: {},
    near: {},
    onupdatestart: {},
    onupdatestop: {},
    resolution: {},
    scene: {},
    visible: {},
    children: {}
  },
  [],
  [
    "camera",
    "renderTarget",
    "update",
    "restart"
  ],
  !0
);
const iy = Number.parseInt(yd.replace("dev", "")), u9 = (
  /* glsl */
  `
varying vec2 vUv;
varying vec2 vPos;
void main () {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
  vUv = uv;
  vPos = position.xy;
}
`
), h9 = (
  /* glsl */
  `
// Majority from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
varying vec2 vUv;
varying vec2 vPos;
uniform vec2 scale;
uniform vec2 imageBounds;
uniform float resolution;
uniform vec3 color;
uniform sampler2D map;
uniform sampler2D colorProccessingTexture;
uniform float radius;
uniform float zoom;
uniform float alphaThreshold;
uniform float alphaSmoothing;
uniform float brightness;
uniform float contrast;
uniform float monochromeStrength;
uniform vec3 monochromeColor;
uniform float negative;
uniform vec3 hsl;
uniform float grayscale;
uniform float opacity;
uniform int colorProcessingEnabled;
uniform int colorProcessingTextureOverride;

#define PI 3.14159265;

vec2 aspect(vec2 size) {
  return size / min(size.x, size.y);
}

// from https://iquilezles.org/articles/distfunctions
float udRoundBox(vec2 p, vec2 b, float r) {
  return length(max(abs(p) - b + r, 0.0)) - r;
}

float hueToRgb(float p, float q, float t) {
  if (t < 0.0f)
    t += 1.0f;
  if (t > 1.0f)
    t -= 1.0f;
  if (t < 1.0f / 6.0f)
    return p + (q - p) * 6.0f * t;
  if (t < 1.0f / 2.0f)
    return q;
  if (t < 2.0f / 3.0f)
    return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
  return p;
}

vec3 rgbToHsl(vec3 color) {
  float max = max(max(color.r, color.g), color.b);
  float min = min(min(color.r, color.g), color.b);
  float h, s, l = (max + min) / 2.0f;

  if (max == min) {
    h = s = 0.0f;
  } else {
    float d = max - min;
    s = l > 0.5f ? d / (2.0f - max - min) : d / (max + min);
    if (max == color.r) {
      h = (color.g - color.b) / d + (color.g < color.b ? 6.0f : 0.0f);
    } else if (max == color.g) {
      h = (color.b - color.r) / d + 2.0f;
    } else if (max == color.b) {
      h = (color.r - color.g) / d + 4.0f;
    }
    h /= 6.0f;
  }

  return vec3(h, s, l);
}

vec3 hslToRgb(vec3 hsl) {
  float h = hsl.x;
  float s = hsl.y;
  float l = hsl.z;

  float r, g, b;

  if (s == 0.0f) {
    r = g = b = l;
  } else {
    float q = l < 0.5f ? l * (1.0f + s) : l + s - l * s;
    float p = 2.0f * l - q;
    r = hueToRgb(p, q, h + 1.0f / 3.0f);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1.0f / 3.0f);
  }

  return vec3(r, g, b);
}

vec3 monochrome(float x, vec3 col) {
  return col * exp(4.0 * x - 1.0);
}

void processColors (inout vec4 colors) {
	vec4 strength = vec4(1.0);

	if (colorProcessingTextureOverride == 1) {
		strength = texture2D(colorProccessingTexture, vUv);

		float smoothedAlpha = smoothstep(1.0 - alphaThreshold - alphaSmoothing, 1.0 - alphaThreshold, strength.a + 0.0001);
		colors.a *= smoothedAlpha;

		if (gl_FragColor.a == 0.0) {
			discard;
			return;
		}
	}

	// BRIGHTNESS
	colors.rgb = max(colors.rgb + brightness, 0.0);

	// CONTRAST
  colors.rgb = max(((colors.rgb - 0.5) * max(contrast + 1.0, 0.0)) + 0.5, 0.0);

	// HSL
	vec3 hslColor = rgbToHsl(colors.rgb);
	hslColor.x = mod(hslColor.x + hsl.x * strength.r ,1.0);
	hslColor.y *= (1.0 + hsl.y * strength.g);
	hslColor.z += hsl.z * strength.b;
	colors.rgb = max(hslToRgb(hslColor), vec3(0.0));

	// MONOCHROME
	colors.rgb = mix(colors.rgb, monochrome(hslColor.z, monochromeColor), monochromeStrength);
}

void main() {
  vec2 s = aspect(scale);
  vec2 i = aspect(imageBounds);
  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = vUv * s / new + offset;
  vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

  vec2 res = vec2(scale * resolution);
  vec2 halfRes = 0.5 * res;
  float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);
  vec3 a = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), smoothstep(0.0, 1.0, b));

	gl_FragColor = texture2D(map, zUv) * vec4(color, opacity * a);

	if (colorProcessingEnabled == 1) {
	  processColors(gl_FragColor);
	}

	if (gl_FragColor.a == 0.0) {
	  discard;
	}

  #include <tonemapping_fragment>
  #include <${iy >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
	gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0) - gl_FragColor.rgb, negative);
}
`
);
function gp(s, e) {
  if (new.target) return Rt({ component: gp, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(B, "$textureStore", t), r = () => Bn(j, "$size", t), o = () => Bn(q, "$parent", t);
  let a = G(e, "color", 7, "white"), l = G(e, "zoom", 7, 1), c = G(e, "radius", 7, 0), u = G(e, "alphaThreshold", 7, 0), h = G(e, "alphaSmoothing", 7, 0.1), d = G(e, "brightness", 7, 0), f = G(e, "contrast", 7, 0), m = G(e, "hue", 7, 0), g = G(e, "saturation", 7, 0), v = G(e, "lightness", 7, 0), _ = G(e, "negative", 7, !1), y = G(e, "opacity", 7, 1), w = G(e, "toneMapped", 7, !0), x = G(e, "transparent", 7, !1), M = G(e, "texture", 7), A = G(e, "monochromeColor", 7), E = G(e, "monochromeStrength", 7), C = G(e, "colorProcessingTexture", 7), P = G(e, "side", 7), T = G(e, "url", 7), I = G(e, "ref", 15), D = G(e, "children", 7), U = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "color",
    "zoom",
    "radius",
    "alphaThreshold",
    "alphaSmoothing",
    "brightness",
    "contrast",
    "hue",
    "saturation",
    "lightness",
    "negative",
    "opacity",
    "toneMapped",
    "transparent",
    "texture",
    "monochromeColor",
    "monochromeStrength",
    "colorProcessingTexture",
    "side",
    "url",
    "ref",
    "children"
  ]);
  const L = new Mi(), k = Vl();
  let B = nu(Promise.resolve(void 0));
  $e(() => {
    B = k(T() ? nL(T()) : nu(Promise.resolve(M())));
  });
  let { size: j } = cn();
  const q = To(), Z = {
    color: { value: new rt(a()) },
    scale: { value: new Be() },
    imageBounds: { value: new Be(1, 1) },
    resolution: { value: 1024 },
    map: { value: null },
    zoom: { value: l() },
    radius: { value: c() },
    alphaThreshold: { value: u() },
    alphaSmoothing: { value: h() },
    brightness: { value: d() },
    contrast: { value: f() },
    monochromeColor: { value: new rt(A()) },
    monochromeStrength: { value: E() ?? 0 },
    negative: { value: _() ? 1 : 0 },
    opacity: { value: y() },
    hsl: { value: new H(0, 0, 0) },
    colorProccessingTexture: { value: null },
    colorProcessingTextureOverride: { value: 0 },
    colorProcessingEnabled: { value: 1 }
  };
  $e(() => {
    Z.color.value.set(a());
  }), $e(() => {
    var z, J;
    Z.imageBounds.value.set(((z = n()) == null ? void 0 : z.image.width) ?? 0, ((J = n()) == null ? void 0 : J.image.height) ?? 0);
  }), $e(() => {
    Z.resolution.value = Math.max(r().width, r().height);
  }), $e(() => {
    Z.zoom.value = l();
  }), $e(() => {
    Z.radius.value = c();
  }), $e(() => {
    Z.opacity.value = y();
  }), $e(() => {
    Z.alphaThreshold.value = u();
  }), $e(() => {
    Z.alphaSmoothing.value = h();
  }), $e(() => {
    Z.brightness.value = d();
  }), $e(() => {
    Z.contrast.value = f();
  }), $e(() => {
    Z.hsl.value.x = m();
  }), $e(() => {
    Z.hsl.value.z = v();
  }), $e(() => {
    Z.negative.value = _() ? 1 : 0;
  }), $e(() => {
    Z.map.value = n() ?? null;
  }), $e(() => {
    Z.colorProccessingTexture.value = C() ?? null;
  }), $e(() => {
    Z.colorProcessingTextureOverride.value = C() ? 1 : 0;
  }), $e(() => {
    A() !== void 0 ? (Z.monochromeColor.value.set(A()), Z.monochromeStrength.value = E() ?? 1) : Z.monochromeStrength.value = 0;
  }), $e(() => {
    let z = 0;
    const J = (A() ? 1 : 0) * (E() === void 0 ? 1 : E());
    for (const se of [
      d(),
      f(),
      m(),
      g(),
      v(),
      J,
      C() ? 1 : 0
    ])
      if (se !== 0) {
        z = 1;
        break;
      }
    Z.colorProcessingEnabled.value = z;
  }), ti(() => {
    const z = o();
    if (!bn(z, "Mesh")) return;
    Z.scale.value.set(z.scale.x, z.scale.y);
    const J = z.geometry;
    if (J !== void 0 && "parameters" in J) {
      const { width: se, height: K } = J.parameters;
      Z.scale.value.set(Z.scale.value.x * se, Z.scale.value.y * K);
    }
  }), pt(s, sn(
    {
      is: L,
      uniforms: Z,
      get toneMapped() {
        return w();
      },
      get transparent() {
        return x();
      },
      get side() {
        return P();
      },
      vertexShader: u9,
      fragmentShader: h9
    },
    () => U,
    {
      get ref() {
        return I();
      },
      set ref(z) {
        I(z);
      },
      children: (z, J) => {
        var se = At(), K = dt(se);
        Wt(K, () => D() ?? Bt, () => ({ ref: L })), ut(z, se);
      },
      $$slots: { default: !0 }
    }
  ));
  var N = Pt({
    get color() {
      return a();
    },
    set color(z = "white") {
      a(z), V();
    },
    get zoom() {
      return l();
    },
    set zoom(z = 1) {
      l(z), V();
    },
    get radius() {
      return c();
    },
    set radius(z = 0) {
      c(z), V();
    },
    get alphaThreshold() {
      return u();
    },
    set alphaThreshold(z = 0) {
      u(z), V();
    },
    get alphaSmoothing() {
      return h();
    },
    set alphaSmoothing(z = 0.1) {
      h(z), V();
    },
    get brightness() {
      return d();
    },
    set brightness(z = 0) {
      d(z), V();
    },
    get contrast() {
      return f();
    },
    set contrast(z = 0) {
      f(z), V();
    },
    get hue() {
      return m();
    },
    set hue(z = 0) {
      m(z), V();
    },
    get saturation() {
      return g();
    },
    set saturation(z = 0) {
      g(z), V();
    },
    get lightness() {
      return v();
    },
    set lightness(z = 0) {
      v(z), V();
    },
    get negative() {
      return _();
    },
    set negative(z = !1) {
      _(z), V();
    },
    get opacity() {
      return y();
    },
    set opacity(z = 1) {
      y(z), V();
    },
    get toneMapped() {
      return w();
    },
    set toneMapped(z = !0) {
      w(z), V();
    },
    get transparent() {
      return x();
    },
    set transparent(z = !1) {
      x(z), V();
    },
    get texture() {
      return M();
    },
    set texture(z) {
      M(z), V();
    },
    get monochromeColor() {
      return A();
    },
    set monochromeColor(z) {
      A(z), V();
    },
    get monochromeStrength() {
      return E();
    },
    set monochromeStrength(z) {
      E(z), V();
    },
    get colorProcessingTexture() {
      return C();
    },
    set colorProcessingTexture(z) {
      C(z), V();
    },
    get side() {
      return P();
    },
    set side(z) {
      P(z), V();
    },
    get url() {
      return T();
    },
    set url(z) {
      T(z), V();
    },
    get ref() {
      return I();
    },
    set ref(z) {
      I(z), V();
    },
    get children() {
      return D();
    },
    set children(z) {
      D(z), V();
    },
    $set: Lt,
    $on: (z, J) => It(e, z, J)
  });
  return i(), N;
}
Ut(
  gp,
  {
    color: {},
    zoom: {},
    radius: {},
    alphaThreshold: {},
    alphaSmoothing: {},
    brightness: {},
    contrast: {},
    hue: {},
    saturation: {},
    lightness: {},
    negative: {},
    opacity: {},
    toneMapped: {},
    transparent: {},
    texture: {},
    monochromeColor: {},
    monochromeStrength: {},
    colorProcessingTexture: {},
    side: {},
    url: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
const d9 = (
  /*glsl*/
  `
  varying vec3 localPosition;
  varying vec4 worldPosition;

  uniform vec3 worldCamProjPosition;
	uniform vec3 worldPlanePosition;
	uniform float fadeDistance;
	uniform bool infiniteGrid;
	uniform bool followCamera;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	void main() {
		localPosition = vec3(
		  position[coord0],
			position[coord1],
			position[coord2]
		);

		if (infiniteGrid) {
		  localPosition *= 1.0 + fadeDistance;
		}

		worldPosition = modelMatrix * vec4(localPosition, 1.0);
		if (followCamera) {
		  worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
      localPosition = (inverse(modelMatrix) * worldPosition).xyz;
		}

		gl_Position = projectionMatrix * viewMatrix * worldPosition;
	}
`
), f9 = (
  /*glsl*/
  `
  #define PI 3.141592653589793

	varying vec3 localPosition;
	varying vec4 worldPosition;

	uniform vec3 worldCamProjPosition;
	uniform float cellSize;
	uniform float sectionSize;
	uniform vec3 cellColor;
	uniform vec3 sectionColor;
	uniform float fadeDistance;
	uniform float fadeStrength;
	uniform float cellThickness;
	uniform float sectionThickness;
	uniform vec3 backgroundColor;
	uniform float backgroundOpacity;

	uniform bool infiniteGrid;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int gridType;

  // lineGrid coord for lines
	uniform int lineGridCoord;

	// circlegrid max radius
	uniform float circleGridMaxRadius;

	// polar grid dividers
	uniform float polarCellDividers;
	uniform float polarSectionDividers;

	float getSquareGrid(float size, float thickness, vec3 localPos) {
		vec2 coord = localPos.xy / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1.0 - thickness;

		return 1.0 - min(line, 1.0);
	}

	float getLinesGrid(float size, float thickness, vec3 localPos) {
		float coord = localPos[lineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.0);
	}

	float getCirclesGrid(float size, float thickness, vec3 localPos) {
		float coord = length(localPos.xy) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if (!infiniteGrid && circleGridMaxRadius > 0. && coord > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	float getPolarGrid(float size, float thickness, float polarDividers, vec3 localPos) {
		float rad = length(localPos.xy) / size;
		vec2 coord = vec2(rad, atan(localPos.x, localPos.y) * polarDividers / PI) ;

		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);

if (!infiniteGrid && circleGridMaxRadius > 0.0 && rad > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	void main() {
		float g1 = 0.0;
		float g2 = 0.0;

		vec3 localPos = vec3(localPosition[coord0], localPosition[coord1], localPosition[coord2]);

		if (gridType == 0) {
			g1 = getSquareGrid(cellSize, cellThickness, localPos);
			g2 = getSquareGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 1) {
			g1 = getLinesGrid(cellSize, cellThickness, localPos);
			g2 = getLinesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 2) {
			g1 = getCirclesGrid(cellSize, cellThickness, localPos);
			g2 = getCirclesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 3) {
			g1 = getPolarGrid(cellSize, cellThickness, polarCellDividers, localPos);
			g2 = getPolarGrid(sectionSize, sectionThickness, polarSectionDividers, localPos);
		}

		float dist = distance(worldCamProjPosition, worldPosition.xyz);
		float d = 1.0 - min(dist / fadeDistance, 1.0);
		float fadeFactor = pow(d, fadeStrength) * 0.95;

		vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

		if (backgroundOpacity > 0.0) {
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.0,1.0);
			vec3 finalColor = mix(backgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, backgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);

		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}

		if (gl_FragColor.a <= 0.0) {
		  discard;
		}

		#include <tonemapping_fragment>
		#include <${iy < 154 ? "encodings_fragment" : "colorspace_fragment"}>
	}
`
);
var p9 = /* @__PURE__ */ ni("<!> <!>", 1);
function IL(s, e) {
  if (new.target) return Rt({ component: IL, ...s });
  Ct(e, !0);
  let t = G(e, "cellColor", 7, "#000000"), i = G(e, "sectionColor", 7, "#0000ee"), n = G(e, "cellSize", 7, 1), r = G(e, "backgroundColor", 7, "#dadada"), o = G(e, "backgroundOpacity", 7, 0), a = G(e, "sectionSize", 7, 10), l = G(e, "plane", 7, "xz"), c = G(e, "gridSize", 23, () => [20, 20]), u = G(e, "followCamera", 7, !1), h = G(e, "infiniteGrid", 7, !1), d = G(e, "fadeDistance", 7, 100), f = G(e, "fadeStrength", 7, 1), m = G(e, "cellThickness", 7, 1), g = G(e, "sectionThickness", 7, 2), v = G(e, "side", 7, wi), _ = G(e, "type", 7, "grid"), y = G(e, "axis", 7, "x"), w = G(e, "maxRadius", 7, 0), x = G(e, "cellDividers", 7, 6), M = G(e, "sectionDividers", 7, 2), A = G(e, "ref", 15), E = G(e, "children", 7), C = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "cellColor",
    "sectionColor",
    "cellSize",
    "backgroundColor",
    "backgroundOpacity",
    "sectionSize",
    "plane",
    "gridSize",
    "followCamera",
    "infiniteGrid",
    "fadeDistance",
    "fadeStrength",
    "cellThickness",
    "sectionThickness",
    "side",
    "type",
    "axis",
    "maxRadius",
    "cellDividers",
    "sectionDividers",
    "ref",
    "children"
  ]);
  const P = new it(), { invalidate: T, camera: I } = cn(), D = new $s(), U = new H(0, 1, 0), L = new H(0, 0, 0), k = { x: 0, y: 1, z: 2 }, B = { xz: "xzy", xy: "xyz", zy: "zyx" }, j = { grid: 0, lines: 1, circular: 2, polar: 3 }, q = {
    cellSize: { value: n() },
    sectionSize: { value: a() },
    cellColor: { value: new rt(t()) },
    sectionColor: { value: new rt(i()) },
    backgroundColor: { value: new rt(r()) },
    backgroundOpacity: { value: o() },
    fadeDistance: { value: d() },
    fadeStrength: { value: f() },
    cellThickness: { value: m() },
    sectionThickness: { value: g() },
    infiniteGrid: { value: h() },
    followCamera: { value: u() },
    coord0: { value: 0 },
    coord1: { value: 2 },
    coord2: { value: 1 },
    gridType: { value: j.grid },
    lineGridCoord: { value: k[y()] },
    circleGridMaxRadius: { value: w() },
    polarCellDividers: { value: x() },
    polarSectionDividers: { value: M() },
    worldCamProjPosition: { value: new H() },
    worldPlanePosition: { value: new H() }
  };
  return $e(() => {
    const Z = B[l()], N = Z.charAt(0), z = Z.charAt(1), J = Z.charAt(2);
    q.coord0.value = k[N], q.coord1.value = k[z], q.coord2.value = k[J], T();
  }), $e(() => {
    q.cellSize.value = n(), T();
  }), $e(() => {
    q.sectionSize.value = a(), T();
  }), $e(() => {
    q.cellColor.value.set(t()), T();
  }), $e(() => {
    q.sectionColor.value.set(i()), T();
  }), $e(() => {
    q.backgroundColor.value.set(r()), T();
  }), $e(() => {
    q.backgroundOpacity.value = o(), T();
  }), $e(() => {
    q.fadeDistance.value = d(), T();
  }), $e(() => {
    q.fadeStrength.value = f(), T();
  }), $e(() => {
    q.cellThickness.value = m(), T();
  }), $e(() => {
    q.sectionThickness.value = g(), T();
  }), $e(() => {
    q.followCamera.value = u(), T();
  }), $e(() => {
    q.infiniteGrid.value = h(), T();
  }), $e(() => {
    switch (_()) {
      case "grid": {
        q.gridType.value = j.grid;
        break;
      }
      case "lines": {
        q.gridType.value = j.lines, q.lineGridCoord.value = k[y()];
        break;
      }
      case "circular": {
        q.gridType.value = j.circular, q.circleGridMaxRadius.value = w();
        break;
      }
      case "polar": {
        q.gridType.value = j.polar, q.circleGridMaxRadius.value = w(), q.polarCellDividers.value = x(), q.polarSectionDividers.value = M();
        break;
      }
    }
    T();
  }), ti(
    () => {
      D.setFromNormalAndCoplanarPoint(U, L).applyMatrix4(P.matrixWorld);
      const Z = P.material, N = Z.uniforms.worldCamProjPosition, z = Z.uniforms.worldPlanePosition;
      D.projectPoint(I.current.position, N.value), z.value.set(0, 0, 0).applyMatrix4(P.matrixWorld);
    },
    { autoInvalidate: !1 }
  ), pt(s, sn({ is: P, frustumCulled: !1 }, () => C, {
    get ref() {
      return A();
    },
    set ref(Z) {
      A(Z);
    },
    children: (Z, N) => {
      var z = p9(), J = dt(z);
      Rs(J, () => pt.ShaderMaterial, (de, ce) => {
        ce(de, {
          fragmentShader: f9,
          vertexShader: d9,
          uniforms: q,
          transparent: !0,
          get side() {
            return v();
          }
        });
      });
      var se = Wn(J, 2);
      {
        var K = (de) => {
          var ce = At(), _e = dt(ce);
          Wt(_e, E, () => ({ ref: P })), ut(de, ce);
        }, Q = (de) => {
          var ce = At(), _e = dt(ce);
          const Fe = /* @__PURE__ */ wt(() => typeof c() == "number" ? [c(), c()] : c());
          Rs(_e, () => pt.PlaneGeometry, (Ie, Ee) => {
            Ee(Ie, {
              get args() {
                return pe(Fe);
              }
            });
          }), ut(de, ce);
        };
        Ai(se, (de) => {
          E() ? de(K) : de(Q, !1);
        });
      }
      ut(Z, z);
    },
    $$slots: { default: !0 }
  })), Pt({
    get cellColor() {
      return t();
    },
    set cellColor(Z = "#000000") {
      t(Z), V();
    },
    get sectionColor() {
      return i();
    },
    set sectionColor(Z = "#0000ee") {
      i(Z), V();
    },
    get cellSize() {
      return n();
    },
    set cellSize(Z = 1) {
      n(Z), V();
    },
    get backgroundColor() {
      return r();
    },
    set backgroundColor(Z = "#dadada") {
      r(Z), V();
    },
    get backgroundOpacity() {
      return o();
    },
    set backgroundOpacity(Z = 0) {
      o(Z), V();
    },
    get sectionSize() {
      return a();
    },
    set sectionSize(Z = 10) {
      a(Z), V();
    },
    get plane() {
      return l();
    },
    set plane(Z = "xz") {
      l(Z), V();
    },
    get gridSize() {
      return c();
    },
    set gridSize(Z = [20, 20]) {
      c(Z), V();
    },
    get followCamera() {
      return u();
    },
    set followCamera(Z = !1) {
      u(Z), V();
    },
    get infiniteGrid() {
      return h();
    },
    set infiniteGrid(Z = !1) {
      h(Z), V();
    },
    get fadeDistance() {
      return d();
    },
    set fadeDistance(Z = 100) {
      d(Z), V();
    },
    get fadeStrength() {
      return f();
    },
    set fadeStrength(Z = 1) {
      f(Z), V();
    },
    get cellThickness() {
      return m();
    },
    set cellThickness(Z = 1) {
      m(Z), V();
    },
    get sectionThickness() {
      return g();
    },
    set sectionThickness(Z = 2) {
      g(Z), V();
    },
    get side() {
      return v();
    },
    set side(Z = wi) {
      v(Z), V();
    },
    get type() {
      return _();
    },
    set type(Z = "grid") {
      _(Z), V();
    },
    get axis() {
      return y();
    },
    set axis(Z = "x") {
      y(Z), V();
    },
    get maxRadius() {
      return w();
    },
    set maxRadius(Z = 0) {
      w(Z), V();
    },
    get cellDividers() {
      return x();
    },
    set cellDividers(Z = 6) {
      x(Z), V();
    },
    get sectionDividers() {
      return M();
    },
    set sectionDividers(Z = 2) {
      M(Z), V();
    },
    get ref() {
      return A();
    },
    set ref(Z) {
      A(Z), V();
    },
    get children() {
      return E();
    },
    set children(Z) {
      E(Z), V();
    },
    $set: Lt,
    $on: (Z, N) => It(e, Z, N)
  });
}
Ut(
  IL,
  {
    cellColor: {},
    sectionColor: {},
    cellSize: {},
    backgroundColor: {},
    backgroundOpacity: {},
    sectionSize: {},
    plane: {},
    gridSize: {},
    followCamera: {},
    infiniteGrid: {},
    fadeDistance: {},
    fadeStrength: {},
    cellThickness: {},
    sectionThickness: {},
    side: {},
    type: {},
    axis: {},
    maxRadius: {},
    cellDividers: {},
    sectionDividers: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
function LL(s, e) {
  if (new.target) return Rt({ component: LL, ...s });
  Ct(e, !0);
  let t = G(e, "args", 23, () => []), i = G(e, "radius", 7, 0.05), n = G(e, "smoothness", 7, 4), r = G(e, "creaseAngle", 7, 0.4), o = G(e, "steps", 7, 1), a = G(e, "ref", 15), l = G(e, "children", 7), c = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "args",
    "radius",
    "smoothness",
    "creaseAngle",
    "steps",
    "ref",
    "children"
  ]);
  const u = 1e-5, h = (y, w, x) => {
    const M = new El(), A = x - u;
    return M.absarc(u, u, u, -Math.PI / 2, -Math.PI, !0), M.absarc(u, w - A * 2, u, Math.PI, Math.PI / 2, !0), M.absarc(y - A * 2, w - A * 2, u, Math.PI / 2, 0, !0), M.absarc(y - A * 2, u, u, 0, -Math.PI / 2, !0), M;
  };
  let d = /* @__PURE__ */ wt(() => t()[0] ?? 1), f = /* @__PURE__ */ wt(() => t()[1] ?? 1), m = /* @__PURE__ */ wt(() => t()[2] ?? 1), g = /* @__PURE__ */ wt(() => h(pe(d), pe(f), i())), v = /* @__PURE__ */ wt(() => ({
    depth: pe(m) - i() * 2,
    bevelEnabled: !0,
    bevelSegments: n() * 2,
    steps: o(),
    bevelSize: i() - u,
    bevelThickness: i(),
    curveSegments: n()
  })), _ = /* @__PURE__ */ wt(() => new Ad(pe(g), pe(v)));
  return $e(() => {
    pe(_).center(), FS(pe(_), r());
  }), pt(s, sn(
    {
      get is() {
        return pe(_);
      }
    },
    () => c,
    {
      get ref() {
        return a();
      },
      set ref(y) {
        a(y);
      },
      children: (y, w) => {
        var x = At(), M = dt(x);
        Wt(M, () => l() ?? Bt, () => ({ ref: pe(_) })), ut(y, x);
      },
      $$slots: { default: !0 }
    }
  )), Pt({
    get args() {
      return t();
    },
    set args(y = []) {
      t(y), V();
    },
    get radius() {
      return i();
    },
    set radius(y = 0.05) {
      i(y), V();
    },
    get smoothness() {
      return n();
    },
    set smoothness(y = 4) {
      n(y), V();
    },
    get creaseAngle() {
      return r();
    },
    set creaseAngle(y = 0.4) {
      r(y), V();
    },
    get steps() {
      return o();
    },
    set steps(y = 1) {
      o(y), V();
    },
    get ref() {
      return a();
    },
    set ref(y) {
      a(y), V();
    },
    get children() {
      return l();
    },
    set children(y) {
      l(y), V();
    },
    $set: Lt,
    $on: (y, w) => It(e, y, w)
  });
}
Ut(
  LL,
  {
    args: {},
    radius: {},
    smoothness: {},
    creaseAngle: {},
    steps: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
const _c = new K_(), Cr = new H(), sl = new H(), ci = new En(), y2 = {
  X: new H(1, 0, 0),
  Y: new H(0, 1, 0),
  Z: new H(0, 0, 1)
}, sb = { type: "change" }, x2 = { type: "mouseDown", mode: null }, b2 = { type: "mouseUp", mode: null }, w2 = { type: "objectChange" };
class m9 extends $_ {
  constructor(e, t = null) {
    super(void 0, t);
    const i = new b9(this);
    this._root = i;
    const n = new w9();
    this._gizmo = n, i.add(n);
    const r = new S9();
    this._plane = r, i.add(r);
    const o = this;
    function a(w, x) {
      let M = x;
      Object.defineProperty(o, w, {
        get: function() {
          return M !== void 0 ? M : x;
        },
        set: function(A) {
          M !== A && (M = A, r[w] = A, n[w] = A, o.dispatchEvent({ type: w + "-changed", value: A }), o.dispatchEvent(sb));
        }
      }), o[w] = x, r[w] = x, n[w] = x;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0), a("minX", -1 / 0), a("maxX", 1 / 0), a("minY", -1 / 0), a("maxY", 1 / 0), a("minZ", -1 / 0), a("maxZ", 1 / 0);
    const l = new H(), c = new H(), u = new En(), h = new En(), d = new H(), f = new En(), m = new H(), g = new H(), v = new H(), _ = 0, y = new H();
    a("worldPosition", l), a("worldPositionStart", c), a("worldQuaternion", u), a("worldQuaternionStart", h), a("cameraPosition", d), a("cameraQuaternion", f), a("pointStart", m), a("pointEnd", g), a("rotationAxis", v), a("rotationAngle", _), a("eye", y), this._offset = new H(), this._startNorm = new H(), this._endNorm = new H(), this._cameraScale = new H(), this._parentPosition = new H(), this._parentQuaternion = new En(), this._parentQuaternionInv = new En(), this._parentScale = new H(), this._worldScaleStart = new H(), this._worldQuaternionInv = new En(), this._worldScale = new H(), this._positionStart = new H(), this._quaternionStart = new En(), this._scaleStart = new H(), this._getPointer = g9.bind(this), this._onPointerDown = _9.bind(this), this._onPointerHover = v9.bind(this), this._onPointerMove = y9.bind(this), this._onPointerUp = x9.bind(this), t !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && _c.setFromCamera(e, this.camera);
    const t = ob(this._gizmo.picker[this.mode], _c);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && _c.setFromCamera(e, this.camera);
      const t = ob(this._plane, _c, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, x2.mode = this.mode, this.dispatchEvent(x2);
    }
  }
  pointerMove(e) {
    const t = this.axis, i = this.mode, n = this.object;
    let r = this.space;
    if (i === "scale" ? r = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (r = "world"), n === void 0 || t === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && _c.setFromCamera(e, this.camera);
    const o = ob(this._plane, _c, !0);
    if (o) {
      if (this.pointEnd.copy(o.point).sub(this.worldPositionStart), i === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), r === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), r === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), n.position.copy(this._offset).add(this._positionStart), this.translationSnap && (r === "local" && (n.position.applyQuaternion(ci.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.position.applyQuaternion(this._quaternionStart)), r === "world" && (n.parent && n.position.add(Cr.setFromMatrixPosition(n.parent.matrixWorld)), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.parent && n.position.sub(Cr.setFromMatrixPosition(n.parent.matrixWorld)))), n.position.x = Math.max(this.minX, Math.min(this.maxX, n.position.x)), n.position.y = Math.max(this.minY, Math.min(this.maxY, n.position.y)), n.position.z = Math.max(this.minZ, Math.min(this.maxZ, n.position.z));
      else if (i === "scale") {
        if (t.search("XYZ") !== -1) {
          let a = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (a *= -1), sl.set(a, a, a);
        } else
          Cr.copy(this.pointStart), sl.copy(this.pointEnd), Cr.applyQuaternion(this._worldQuaternionInv), sl.applyQuaternion(this._worldQuaternionInv), sl.divide(Cr), t.search("X") === -1 && (sl.x = 1), t.search("Y") === -1 && (sl.y = 1), t.search("Z") === -1 && (sl.z = 1);
        n.scale.copy(this._scaleStart).multiply(sl), this.scaleSnap && (t.search("X") !== -1 && (n.scale.x = Math.round(n.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (n.scale.y = Math.round(n.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (n.scale.z = Math.round(n.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const a = 20 / this.worldPosition.distanceTo(Cr.setFromMatrixPosition(this.camera.matrixWorld));
        let l = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Cr.copy(this.rotationAxis).cross(this.eye)) * a) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(y2[t]), Cr.copy(y2[t]), r === "local" && Cr.applyQuaternion(this.worldQuaternion), Cr.cross(this.eye), Cr.length() === 0 ? l = !0 : this.rotationAngle = this._offset.dot(Cr.normalize()) * a), (t === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), r === "local" && t !== "E" && t !== "XYZE" ? (n.quaternion.copy(this._quaternionStart), n.quaternion.multiply(ci.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), n.quaternion.copy(ci.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), n.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(sb), this.dispatchEvent(w2);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (b2.mode = this.mode, this.dispatchEvent(b2)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(sb), this.dispatchEvent(w2), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return _c;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function g9(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button
    };
  }
}
function v9(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function _9(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function y9(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function x9(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function ob(s, e, t) {
  const i = e.intersectObject(s, !0);
  for (let n = 0; n < i.length; n++)
    if (i[n].object.visible || t)
      return i[n];
  return !1;
}
const $g = new fs(), Yn = new H(0, 1, 0), S2 = new H(0, 0, 0), M2 = new _t(), Jg = new En(), Bv = new En(), Do = new H(), E2 = new _t(), Nf = new H(1, 0, 0), Pc = new H(0, 1, 0), Bf = new H(0, 0, 1), Qg = new H(), gf = new H(), vf = new H();
class b9 extends tn {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const t = this.controls;
    t.object !== void 0 && (t.object.updateMatrixWorld(), t.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : t.object.parent.matrixWorld.decompose(t._parentPosition, t._parentQuaternion, t._parentScale), t.object.matrixWorld.decompose(t.worldPosition, t.worldQuaternion, t._worldScale), t._parentQuaternionInv.copy(t._parentQuaternion).invert(), t._worldQuaternionInv.copy(t.worldQuaternion).invert()), t.camera.updateMatrixWorld(), t.camera.matrixWorld.decompose(t.cameraPosition, t.cameraQuaternion, t._cameraScale), t.camera.isOrthographicCamera ? t.camera.getWorldDirection(t.eye).negate() : t.eye.copy(t.cameraPosition).sub(t.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  dispose() {
    this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
}
class w9 extends tn {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new qn({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new Bi({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = e.clone();
    i.opacity = 0.15;
    const n = t.clone();
    n.opacity = 0.5;
    const r = e.clone();
    r.color.setHex(16711680);
    const o = e.clone();
    o.color.setHex(65280);
    const a = e.clone();
    a.color.setHex(255);
    const l = e.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(255), u.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const d = e.clone();
    d.color.setHex(16776960), d.opacity = 0.25, e.clone().color.setHex(16776960);
    const m = e.clone();
    m.color.setHex(7895160);
    const g = new Di(0, 0.04, 0.1, 12);
    g.translate(0, 0.05, 0);
    const v = new pi(0.08, 0.08, 0.08);
    v.translate(0, 0.04, 0);
    const _ = new Gt();
    _.setAttribute("position", new Tt([0, 0, 0, 1, 0, 0], 3));
    const y = new Di(75e-4, 75e-4, 0.5, 3);
    y.translate(0, 0.25, 0);
    function w(k, B) {
      const j = new wa(k, 75e-4, 3, 64, B * Math.PI * 2);
      return j.rotateY(Math.PI / 2), j.rotateX(Math.PI / 2), j;
    }
    function x() {
      const k = new Gt();
      return k.setAttribute("position", new Tt([0, 0, 0, 1, 1, 1], 3)), k;
    }
    const M = {
      X: [
        [new it(g, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new it(g, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new it(y, r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new it(g, o), [0, 0.5, 0]],
        [new it(g, o), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new it(y, o)]
      ],
      Z: [
        [new it(g, a), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new it(g, a), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new it(y, a), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new it(new Ma(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new it(new pi(0.15, 0.15, 0.01), u.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new it(new pi(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new it(new pi(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, A = {
      X: [
        [new it(new Di(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new it(new Di(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new it(new Ma(0.2, 0), i)]
      ],
      XY: [
        [new it(new pi(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new it(new pi(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new it(new pi(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, E = {
      START: [
        [new it(new Ma(0.01, 2), n), null, null, null, "helper"]
      ],
      END: [
        [new it(new Ma(0.01, 2), n), null, null, null, "helper"]
      ],
      DELTA: [
        [new Ui(x(), n), null, null, null, "helper"]
      ],
      X: [
        [new Ui(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Ui(_, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Ui(_, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, C = {
      XYZE: [
        [new it(w(0.5, 1), m), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new it(w(0.5, 0.5), r)]
      ],
      Y: [
        [new it(w(0.5, 0.5), o), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new it(w(0.5, 0.5), a), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new it(w(0.75, 1), d), null, [0, Math.PI / 2, 0]]
      ]
    }, P = {
      AXIS: [
        [new Ui(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, T = {
      XYZE: [
        [new it(new Bl(0.25, 10, 8), i)]
      ],
      X: [
        [new it(new wa(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new it(new wa(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new it(new wa(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new it(new wa(0.75, 0.1, 2, 24), i)]
      ]
    }, I = {
      X: [
        [new it(v, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new it(y, r), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new it(v, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new it(v, o), [0, 0.5, 0]],
        [new it(y, o)],
        [new it(v, o), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new it(v, a), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new it(y, a), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new it(v, a), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new it(new pi(0.15, 0.15, 0.01), u), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new it(new pi(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new it(new pi(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new it(new pi(0.1, 0.1, 0.1), h.clone())]
      ]
    }, D = {
      X: [
        [new it(new Di(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new it(new Di(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new it(new Di(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new it(new pi(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new it(new pi(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new it(new pi(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new it(new pi(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, U = {
      X: [
        [new Ui(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Ui(_, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Ui(_, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function L(k) {
      const B = new tn();
      for (const j in k)
        for (let q = k[j].length; q--; ) {
          const Z = k[j][q][0].clone(), N = k[j][q][1], z = k[j][q][2], J = k[j][q][3], se = k[j][q][4];
          Z.name = j, Z.tag = se, N && Z.position.set(N[0], N[1], N[2]), z && Z.rotation.set(z[0], z[1], z[2]), J && Z.scale.set(J[0], J[1], J[2]), Z.updateMatrix();
          const K = Z.geometry.clone();
          K.applyMatrix4(Z.matrix), Z.geometry = K, Z.renderOrder = 1 / 0, Z.position.set(0, 0, 0), Z.rotation.set(0, 0, 0), Z.scale.set(1, 1, 1), B.add(Z);
        }
      return B;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = L(M)), this.add(this.gizmo.rotate = L(C)), this.add(this.gizmo.scale = L(I)), this.add(this.picker.translate = L(A)), this.add(this.picker.rotate = L(T)), this.add(this.picker.scale = L(D)), this.add(this.helper.translate = L(E)), this.add(this.helper.rotate = L(P)), this.add(this.helper.scale = L(U)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Bv;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let r = 0; r < n.length; r++) {
      const o = n[r];
      o.visible = !0, o.rotation.set(0, 0, 0), o.position.copy(this.worldPosition);
      let a;
      if (this.camera.isOrthographicCamera ? a = (this.camera.top - this.camera.bottom) / this.camera.zoom : a = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), o.scale.set(1, 1, 1).multiplyScalar(a * this.size / 4), o.tag === "helper") {
        o.visible = !1, o.name === "AXIS" ? (o.visible = !!this.axis, this.axis === "X" && (ci.setFromEuler($g.set(0, 0, 0)), o.quaternion.copy(i).multiply(ci), Math.abs(Yn.copy(Nf).applyQuaternion(i).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Y" && (ci.setFromEuler($g.set(0, 0, Math.PI / 2)), o.quaternion.copy(i).multiply(ci), Math.abs(Yn.copy(Pc).applyQuaternion(i).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Z" && (ci.setFromEuler($g.set(0, Math.PI / 2, 0)), o.quaternion.copy(i).multiply(ci), Math.abs(Yn.copy(Bf).applyQuaternion(i).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "XYZE" && (ci.setFromEuler($g.set(0, Math.PI / 2, 0)), Yn.copy(this.rotationAxis), o.quaternion.setFromRotationMatrix(M2.lookAt(S2, Yn, Pc)), o.quaternion.multiply(ci), o.visible = this.dragging), this.axis === "E" && (o.visible = !1)) : o.name === "START" ? (o.position.copy(this.worldPositionStart), o.visible = this.dragging) : o.name === "END" ? (o.position.copy(this.worldPosition), o.visible = this.dragging) : o.name === "DELTA" ? (o.position.copy(this.worldPositionStart), o.quaternion.copy(this.worldQuaternionStart), Cr.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Cr.applyQuaternion(this.worldQuaternionStart.clone().invert()), o.scale.copy(Cr), o.visible = this.dragging) : (o.quaternion.copy(i), this.dragging ? o.position.copy(this.worldPositionStart) : o.position.copy(this.worldPosition), this.axis && (o.visible = this.axis.search(o.name) !== -1));
        continue;
      }
      o.quaternion.copy(i), this.mode === "translate" || this.mode === "scale" ? (o.name === "X" && Math.abs(Yn.copy(Nf).applyQuaternion(i).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Y" && Math.abs(Yn.copy(Pc).applyQuaternion(i).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Z" && Math.abs(Yn.copy(Bf).applyQuaternion(i).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XY" && Math.abs(Yn.copy(Bf).applyQuaternion(i).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "YZ" && Math.abs(Yn.copy(Nf).applyQuaternion(i).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XZ" && Math.abs(Yn.copy(Pc).applyQuaternion(i).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1)) : this.mode === "rotate" && (Jg.copy(i), Yn.copy(this.eye).applyQuaternion(ci.copy(i).invert()), o.name.search("E") !== -1 && o.quaternion.setFromRotationMatrix(M2.lookAt(this.eye, S2, Pc)), o.name === "X" && (ci.setFromAxisAngle(Nf, Math.atan2(-Yn.y, Yn.z)), ci.multiplyQuaternions(Jg, ci), o.quaternion.copy(ci)), o.name === "Y" && (ci.setFromAxisAngle(Pc, Math.atan2(Yn.x, Yn.z)), ci.multiplyQuaternions(Jg, ci), o.quaternion.copy(ci)), o.name === "Z" && (ci.setFromAxisAngle(Bf, Math.atan2(Yn.y, Yn.x)), ci.multiplyQuaternions(Jg, ci), o.quaternion.copy(ci))), o.visible = o.visible && (o.name.indexOf("X") === -1 || this.showX), o.visible = o.visible && (o.name.indexOf("Y") === -1 || this.showY), o.visible = o.visible && (o.name.indexOf("Z") === -1 || this.showZ), o.visible = o.visible && (o.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), o.material._color = o.material._color || o.material.color.clone(), o.material._opacity = o.material._opacity || o.material.opacity, o.material.color.copy(o.material._color), o.material.opacity = o.material._opacity, this.enabled && this.axis && (o.name === this.axis || this.axis.split("").some(function(l) {
        return o.name === l;
      })) && (o.material.color.setHex(16776960), o.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class S9 extends it {
  constructor() {
    super(
      new $r(1e5, 1e5, 2, 2),
      new qn({ visible: !1, wireframe: !0, side: wi, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), Qg.copy(Nf).applyQuaternion(t === "local" ? this.worldQuaternion : Bv), gf.copy(Pc).applyQuaternion(t === "local" ? this.worldQuaternion : Bv), vf.copy(Bf).applyQuaternion(t === "local" ? this.worldQuaternion : Bv), Yn.copy(gf), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Yn.copy(this.eye).cross(Qg), Do.copy(Qg).cross(Yn);
            break;
          case "Y":
            Yn.copy(this.eye).cross(gf), Do.copy(gf).cross(Yn);
            break;
          case "Z":
            Yn.copy(this.eye).cross(vf), Do.copy(vf).cross(Yn);
            break;
          case "XY":
            Do.copy(vf);
            break;
          case "YZ":
            Do.copy(Qg);
            break;
          case "XZ":
            Yn.copy(vf), Do.copy(gf);
            break;
          case "XYZ":
          case "E":
            Do.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Do.set(0, 0, 0);
    }
    Do.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (E2.lookAt(Cr.set(0, 0, 0), Do, Yn), this.quaternion.setFromRotationMatrix(E2)), super.updateMatrixWorld(e);
  }
}
const KS = () => OS("threlte-controls", {
  orbitControls: Gn(void 0),
  trackballControls: Gn(void 0)
});
var M9 = /* @__PURE__ */ ni("<!> <!>", 1);
function UL(s, e) {
  if (new.target) return Rt({ component: UL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(d, "$camera", t);
  let r = G(e, "autoPauseOrbitControls", 7, !0), o = G(e, "autoPauseTrackballControls", 7, !0), a = G(e, "object", 7), l = G(e, "controls", 15), c = G(e, "group", 15), u = G(e, "children", 7), h = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "autoPauseOrbitControls",
    "autoPauseTrackballControls",
    "object",
    "controls",
    "group",
    "children"
  ]);
  const { camera: d, dom: f, invalidate: m, scene: g } = cn(), { orbitControls: v, trackballControls: _ } = KS(), y = Xn(!1), w = Gn(r() ?? !0);
  $e(() => w.set(r() ?? !0));
  const x = Gn(o() ?? !0);
  $e(() => x.set(o() ?? !0)), ui(
    [
      v,
      y,
      w
    ],
    ([
      k,
      B,
      j
    ]) => {
      if (!(!k || !k.enabled && B))
        return k.enabled = !(B && j), () => {
          k.enabled = !0;
        };
    }
  ), ui(
    [
      _,
      y,
      x
    ],
    ([
      k,
      B,
      j
    ]) => {
      if (!(!k || !k.enabled && B))
        return k.enabled = !(B && j), () => {
          k.enabled = !0;
        };
    }
  );
  const M = new Zn();
  let A = /* @__PURE__ */ wt(() => new m9(n(), f));
  $e(() => {
    var k;
    return (k = pe(A)) == null || k.attach(a() ?? M), () => {
      var B;
      return (B = pe(A)) == null ? void 0 : B.detach();
    };
  });
  const E = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible",
    "onmouseDown",
    "onmouseUp",
    "onobjectChange"
  ];
  let C = Us(pr({})), P = Us(pr({}));
  $e(() => {
    In(C, pr({})), In(P, pr({})), Object.keys(h).forEach((k) => {
      $e(() => {
        E.includes(k) ? pe(C)[k] = h[k] : pe(P)[k] = h[k];
      });
    });
  });
  const T = (k) => {
    var B;
    m(), pe(A).dragging && !y.current ? y.set(!0) : !pe(A).dragging && y.current && y.set(!1), (B = e.onchange) == null || B.call(e, k);
  };
  var I = M9(), D = dt(I);
  pt(D, sn(
    {
      get is() {
        return pe(A);
      },
      onchange: T
    },
    () => pe(C),
    {
      attach: ({ ref: k }) => {
        const B = k.getHelper();
        return g.add(B), () => {
          g.remove(B);
        };
      },
      dispose: !1,
      oncreate: (k) => () => k.dispose(),
      get ref() {
        return l();
      },
      set ref(k) {
        l(k);
      }
    }
  ));
  var U = Wn(D, 2);
  pt(U, sn({ is: M }, () => pe(P), {
    get ref() {
      return c();
    },
    set ref(k) {
      c(k);
    },
    children: (k, B) => {
      var j = At(), q = dt(j);
      {
        var Z = (N) => {
          var z = At(), J = dt(z);
          Wt(J, u, () => ({ ref: M })), ut(N, z);
        };
        Ai(q, (N) => {
          u() && N(Z);
        });
      }
      ut(k, j);
    },
    $$slots: { default: !0 }
  })), ut(s, I);
  var L = Pt({
    get autoPauseOrbitControls() {
      return r();
    },
    set autoPauseOrbitControls(k = !0) {
      r(k), V();
    },
    get autoPauseTrackballControls() {
      return o();
    },
    set autoPauseTrackballControls(k = !0) {
      o(k), V();
    },
    get object() {
      return a();
    },
    set object(k) {
      a(k), V();
    },
    get controls() {
      return l();
    },
    set controls(k) {
      l(k), V();
    },
    get group() {
      return c();
    },
    set group(k) {
      c(k), V();
    },
    get children() {
      return u();
    },
    set children(k) {
      u(k), V();
    },
    $set: Lt,
    $on: (k, B) => It(e, k, B)
  });
  return i(), L;
}
Ut(
  UL,
  {
    autoPauseOrbitControls: {},
    autoPauseTrackballControls: {},
    object: {},
    controls: {},
    group: {},
    children: {}
  },
  [],
  [],
  !0
);
function kL(s, e) {
  if (new.target) return Rt({ component: kL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(l, "$parent", t);
  let r = G(e, "ref", 15), o = G(e, "children", 7), a = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "children"
  ]);
  const l = To(), { dom: c, invalidate: u } = cn();
  if (!bn(n(), "Camera"))
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  const h = new vL(n(), c), { orbitControls: d } = KS(), { start: f, stop: m } = ti(
    () => {
      h.update();
    },
    { autoStart: !1, autoInvalidate: !1 }
  );
  $e(() => {
    e.autoRotate || e.enableDamping ? f() : m();
  }), $e(() => {
    const v = (_) => {
      var y;
      u(), (y = e.onchange) == null || y.call(e, _);
    };
    return d.set(h), h.addEventListener("change", v), () => {
      d.set(void 0), h.removeEventListener("change", v);
    };
  }), pt(s, sn({ is: h }, () => a, {
    get ref() {
      return r();
    },
    set ref(v) {
      r(v);
    },
    children: (v, _) => {
      var y = At(), w = dt(y);
      Wt(w, () => o() ?? Bt, () => ({ ref: h })), ut(v, y);
    },
    $$slots: { default: !0 }
  }));
  var g = Pt({
    get ref() {
      return r();
    },
    set ref(v) {
      r(v), V();
    },
    get children() {
      return o();
    },
    set children(v) {
      o(v), V();
    },
    $set: Lt,
    $on: (v, _) => It(e, v, _)
  });
  return i(), g;
}
Ut(kL, { ref: {}, children: {} }, [], [], !0);
function OL(s, e) {
  if (new.target) return Rt({ component: OL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(l, "$parent", t);
  let r = G(e, "ref", 15), o = G(e, "children", 7), a = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "children"
  ]);
  const l = To(), { dom: c, invalidate: u } = cn();
  if (!bn(n(), "Camera"))
    throw new Error("Parent missing: <TrackballControls> need to be a child of a <Camera>");
  const h = new _L(n(), c), { trackballControls: d } = KS();
  ti(
    () => {
      h.update();
    },
    { autoInvalidate: !1 }
  ), Ht(() => {
    const m = (g) => {
      var v;
      u(), (v = e.onchange) == null || v.call(e, g);
    };
    return d.set(h), h.addEventListener("change", m), () => {
      d.set(void 0), h.removeEventListener("change", m);
    };
  }), pt(s, sn({ is: h }, () => a, {
    get ref() {
      return r();
    },
    set ref(m) {
      r(m);
    },
    children: (m, g) => {
      var v = At(), _ = dt(v);
      Wt(_, () => o() ?? Bt, () => ({ ref: h })), ut(m, v);
    },
    $$slots: { default: !0 }
  }));
  var f = Pt({
    get ref() {
      return r();
    },
    set ref(m) {
      r(m), V();
    },
    get children() {
      return o();
    },
    set children(m) {
      o(m), V();
    },
    $set: Lt,
    $on: (m, g) => It(e, m, g)
  });
  return i(), f;
}
Ut(OL, { ref: {}, children: {} }, [], [], !0);
const FL = (s) => `threlte-instanced-mesh-${s}`, E9 = (s, e) => {
  const t = {
    instancedMesh: Xn(s),
    addInstance(i) {
      t.instances.update((n) => (n.push(i), n));
    },
    removeInstance(i) {
      t.instances.update((n) => {
        const r = n.indexOf(i);
        return r > -1 && n.splice(r, 1), n;
      });
    },
    instances: Xn([])
  };
  return xr(FL(e), t), t;
}, T9 = (s) => {
  const e = sr(FL(s));
  if (!e)
    throw new Error(`No <InstancedMesh> component found for id ${s}`);
  return e;
};
var A9 = /* @__PURE__ */ ni("<!> <!> <!>", 1);
function $S(s, e) {
  if (new.target) return Rt({ component: $S, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(h, "$instances", t);
  let r = G(e, "instancedMesh", 7), o = G(e, "id", 7), a = G(e, "limit", 7), l = G(e, "range", 7), c = G(e, "update", 7), u = G(e, "children", 7);
  const { instances: h } = E9(r(), o()), d = new _t(), f = new Float32Array(a() * 16);
  for (let D = 0; D < a(); D++) d.identity().toArray(f, D * 16);
  const m = new Float32Array(a() * 3).fill(1), g = new _t(), v = new _t(), _ = new H(), y = new En(), w = new H();
  let x = !1;
  ti(() => {
    if (r().updateMatrix(), c() || !x) {
      r().updateMatrixWorld(), g.copy(r().matrixWorld).invert(), r().instanceColor && (r().instanceColor.needsUpdate = !0), r().instanceMatrix.needsUpdate = !0;
      for (let D = 0, U = h.current.length; D < U; D++) {
        const L = h.current[D];
        L.matrixWorld.decompose(_, y, w), v.compose(_, y, w).premultiply(g), v.toArray(f, D * 16), L.color.toArray(m, D * 3);
      }
      x = !0;
    }
  }), $e(() => {
    const D = Math.min(a(), l() !== void 0 ? l() : a(), n().length);
    r().count = D, zA >= 159 ? (r().instanceMatrix.clearUpdateRanges(), r().instanceMatrix.addUpdateRange(0, D * 16)) : r().instanceMatrix.updateRange.count = D * 16, r().instanceColor && (zA >= 159 ? (r().instanceColor.clearUpdateRanges(), r().instanceColor.addUpdateRange(0, D * 3)) : r().instanceColor.updateRange.count = D * 3);
  });
  var M = A9(), A = dt(M);
  const E = /* @__PURE__ */ wt(() => f.length / 16);
  Rs(A, () => pt.InstancedBufferAttribute, (D, U) => {
    U(D, {
      attach: "instanceMatrix",
      get count() {
        return pe(E);
      },
      array: f,
      itemSize: 16,
      usage: Zh
    });
  });
  var C = Wn(A, 2);
  const P = /* @__PURE__ */ wt(() => m.length / 3);
  Rs(C, () => pt.InstancedBufferAttribute, (D, U) => {
    U(D, {
      attach: "instanceColor",
      get count() {
        return pe(P);
      },
      array: m,
      itemSize: 3,
      usage: Zh
    });
  });
  var T = Wn(C, 2);
  Wt(T, () => u() ?? Bt), ut(s, M);
  var I = Pt({
    get instancedMesh() {
      return r();
    },
    set instancedMesh(D) {
      r(D), V();
    },
    get id() {
      return o();
    },
    set id(D) {
      o(D), V();
    },
    get limit() {
      return a();
    },
    set limit(D) {
      a(D), V();
    },
    get range() {
      return l();
    },
    set range(D) {
      l(D), V();
    },
    get update() {
      return c();
    },
    set update(D) {
      c(D), V();
    },
    get children() {
      return u();
    },
    set children(D) {
      u(D), V();
    },
    $set: Lt,
    $on: (D, U) => It(e, D, U)
  });
  return i(), I;
}
Ut(
  $S,
  {
    instancedMesh: {},
    id: {},
    limit: {},
    range: {},
    update: {},
    children: {}
  },
  [],
  [],
  !0
);
function JS(s, e) {
  if (new.target) return Rt({ component: JS, ...s });
  Ct(e, !0);
  let t = G(e, "id", 7, "default"), i = G(e, "limit", 7, 1e3), n = G(e, "range", 7, 1e3), r = G(e, "update", 7, !0), o = G(e, "ref", 15), a = G(e, "children", 7), l = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "limit",
    "range",
    "update",
    "ref",
    "children"
  ]);
  const c = new Td(null, null, 0);
  return pt(s, sn(
    {
      is: c,
      raycast: () => null,
      matrixAutoUpdate: !1,
      args: [null, null, 0]
    },
    () => l,
    {
      get ref() {
        return o();
      },
      set ref(h) {
        o(h);
      },
      children: (h, d) => {
        $S(h, {
          instancedMesh: c,
          get id() {
            return t();
          },
          get limit() {
            return i();
          },
          get range() {
            return n();
          },
          get update() {
            return r();
          },
          children: (f, m) => {
            var g = At(), v = dt(g);
            Wt(v, () => a() ?? Bt, () => ({ ref: c })), ut(f, g);
          },
          $$slots: { default: !0 }
        });
      },
      $$slots: { default: !0 }
    }
  )), Pt({
    get id() {
      return t();
    },
    set id(h = "default") {
      t(h), V();
    },
    get limit() {
      return i();
    },
    set limit(h = 1e3) {
      i(h), V();
    },
    get range() {
      return n();
    },
    set range(h = 1e3) {
      n(h), V();
    },
    get update() {
      return r();
    },
    set update(h = !0) {
      r(h), V();
    },
    get ref() {
      return o();
    },
    set ref(h) {
      o(h), V();
    },
    get children() {
      return a();
    },
    set children(h) {
      a(h), V();
    },
    $set: Lt,
    $on: (h, d) => It(e, h, d)
  });
}
Ut(
  JS,
  {
    id: {},
    limit: {},
    range: {},
    update: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
const T2 = new _t(), A2 = new _t(), ev = [], _f = new it();
class C9 extends Zn {
  constructor(t, i) {
    super();
    ht(this, "color");
    ht(this, "instancedMesh");
    ht(this, "instances");
    this.color = new rt("white"), this.instancedMesh = t, this.instances = i;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var t;
    return (t = this.instancedMesh.current) == null ? void 0 : t.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(t, i) {
    var a;
    const n = this.instancedMesh.current;
    if (n === void 0 || n.geometry === void 0 || n.material === void 0)
      return;
    _f.geometry = n.geometry;
    const r = n.matrixWorld, o = this.instances.current.indexOf(this);
    if (!(o === -1 || o > n.count)) {
      n.getMatrixAt(o, T2), A2.multiplyMatrices(r, T2), _f.matrixWorld = A2, bn(n.material, "Material") ? _f.material.side = n.material.side : _f.material.side = ((a = n.material[0]) == null ? void 0 : a.side) ?? Fs, _f.raycast(t, ev);
      for (let l = 0, c = ev.length; l < c; l++) {
        const u = ev[l];
        u.instanceId = o, u.object = this, i.push(u);
      }
      ev.length = 0;
    }
  }
}
const NL = Symbol("threlte-instance-id"), P9 = (s) => {
  xr(NL, s);
}, C2 = () => sr(NL) ?? "default";
function QS(s, e) {
  if (new.target) return Rt({ component: QS, ...s });
  Ct(e, !0);
  let t = G(e, "id", 23, C2), i = G(e, "ref", 15), n = G(e, "children", 7), r = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children"
  ]);
  const {
    addInstance: o,
    removeInstance: a,
    instancedMesh: l,
    instances: c
  } = T9(t()), u = new C9(l, c);
  return o(u), Ki(() => {
    a(u);
  }), pt(s, sn({ is: u }, () => r, {
    get ref() {
      return i();
    },
    set ref(h) {
      i(h);
    },
    children: (h, d) => {
      var f = At(), m = dt(f);
      Wt(m, () => n() ?? Bt, () => ({ ref: u })), ut(h, f);
    },
    $$slots: { default: !0 }
  })), Pt({
    get id() {
      return t();
    },
    set id(h = C2()) {
      t(h), V();
    },
    get ref() {
      return i();
    },
    set ref(h) {
      i(h), V();
    },
    get children() {
      return n();
    },
    set children(h) {
      n(h), V();
    },
    $set: Lt,
    $on: (h, d) => It(e, h, d)
  });
}
Ut(QS, { id: {}, ref: {}, children: {} }, [], [], !0);
function e_(s, e) {
  if (new.target) return Rt({ component: e_, ...s });
  Ct(e, !0);
  let t = G(e, "meshes", 7), i = G(e, "index", 23, () => t().length - 1), n = G(e, "children", 7), r = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "meshes",
    "index",
    "children"
  ]);
  const o = t()[i()];
  var a = At(), l = dt(a);
  {
    var c = (h) => {
      JS(h, sn(
        {
          get geometry() {
            return o.geometry;
          },
          get material() {
            return o.material;
          },
          get id() {
            return o.uuid;
          }
        },
        () => r,
        {
          children: (d, f) => {
            const m = /* @__PURE__ */ wt(() => i() - 1);
            e_(d, sn(
              {
                get meshes() {
                  return t();
                },
                get index() {
                  return pe(m);
                }
              },
              () => r,
              {
                children: (g, v) => {
                  var _ = At(), y = dt(_);
                  Wt(y, () => n() ?? Bt), ut(g, _);
                },
                $$slots: { default: !0 }
              }
            ));
          },
          $$slots: { default: !0 }
        }
      ));
    }, u = (h) => {
      var d = At(), f = dt(d);
      Wt(f, () => n() ?? Bt), ut(h, d);
    };
    Ai(l, (h) => {
      i() > -1 ? h(c) : h(u, !1);
    });
  }
  return ut(s, a), Pt({
    get meshes() {
      return t();
    },
    set meshes(h) {
      t(h), V();
    },
    get index() {
      return i();
    },
    set index(h = t.length - 1) {
      i(h), V();
    },
    get children() {
      return n();
    },
    set children(h) {
      n(h), V();
    },
    $set: Lt,
    $on: (h, d) => It(e, h, d)
  });
}
Ut(e_, { meshes: {}, index: {}, children: {} }, [], [], !0);
function BL(s, e) {
  if (new.target) return Rt({ component: BL, ...s });
  Ct(e, !0);
  let t = G(e, "meshes", 7), i = G(e, "children", 7), n = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "meshes",
    "children"
  ]);
  const r = (h) => (...d) => (P9(h), QS(...d)), o = (h) => h.filter((d) => d.isMesh).map((d) => r(d.uuid)), a = (h) => Object.entries(h).reduce(
    (d, [f, m]) => (m.isMesh && (d[f] = r(m.uuid)), d),
    {}
  );
  let l = /* @__PURE__ */ wt(() => Array.isArray(t()) ? o(t()) : a(t())), c = /* @__PURE__ */ wt(() => Array.isArray(t()) ? t() : Object.values(t())), u = /* @__PURE__ */ wt(() => pe(c).filter((h) => h.isMesh));
  return e_(s, sn(
    {
      get meshes() {
        return pe(u);
      }
    },
    () => n,
    {
      children: (h, d) => {
        var f = At(), m = dt(f);
        Wt(m, () => i() ?? Bt, () => ({ components: pe(l) })), ut(h, f);
      },
      $$slots: { default: !0 }
    }
  )), Pt({
    get meshes() {
      return t();
    },
    set meshes(h) {
      t(h), V();
    },
    get children() {
      return i();
    },
    set children(h) {
      i(h), V();
    },
    $set: Lt,
    $on: (h, d) => It(e, h, d)
  });
}
Ut(BL, { meshes: {}, children: {} }, [], [], !0);
function zL(s, e) {
  if (new.target) return Rt({ component: zL, ...s });
  Ct(e, !0);
  const { renderer: t, camera: i, scene: n } = cn();
  let r = G(e, "size", 7, 25), o = G(e, "focus", 7, 0), a = G(e, "samples", 7, 10);
  const l = Ft.shadowmap_pars_fragment;
  let c = /* @__PURE__ */ wt(() => `
		#define PENUMBRA_FILTER_SIZE float(${r()})
		#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
		vec3 randRGB(vec2 uv) {
			return vec3(
				fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
				fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
				fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
			);
		}

		vec3 lowPassRandRGB(vec2 uv) {
			// 3x3 convolution (average)
			// can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
			vec3 result = vec3(0);
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
			result *= 0.111111111; // 1.0 / 9.0
			return result;
		}
		vec3 highPassRandRGB(vec2 uv) {
			// by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
			// hp(x) = x - lp(x)
			return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
		}


		vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
			const float goldenAngle = 2.399963f; // radians
			float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
			float theta = float(sampleIndex) * goldenAngle + angle;
			float sine = sin(theta);
			float cosine = cos(theta);
			return vec2(cosine, sine) * r;
		}
		float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
			return (zReceiver - zBlocker) / zBlocker;
		}
		float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float blockerDepthSum = float(${o()});
			float blockers = 0.0;

			int j = 0;
			vec2 offset = vec2(0.);
			float depth = 0.;

			#pragma unroll_loop_start
			for(int i = 0; i < ${a()}; i ++) {
				offset = (vogelDiskSample(j, ${a()}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
				depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
				if (depth < compare) {
					blockerDepthSum += depth;
					blockers++;
				}
				j++;
			}
			#pragma unroll_loop_end

			if (blockers > 0.0) {
				return blockerDepthSum / blockers;
			}
			return -1.0;
		}


		float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float shadow = 0.0f;
			int j = 0;
			vec2 vogelSample = vec2(0.0);
			vec2 offset = vec2(0.0);
			#pragma unroll_loop_start
			for (int i = 0; i < ${a()}; i++) {
				vogelSample = vogelDiskSample(j, ${a()}, angle) * texelSize;
				offset = vogelSample * (1.0 + filterRadius * float(${r()}));
				shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
				j++;
			}
			#pragma unroll_loop_end
			return shadow * 1.0 / ${a()}.0;
		}

		float PCSS (sampler2D shadowMap, vec4 coords) {
			vec2 uv = coords.xy;
			float zReceiver = coords.z; // Assumed to be eye-space z in this code
			float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
			float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
			if (avgBlockerDepth == -1.0) {
				return 1.0;
			}
			float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
			return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
	}`);
  const u = () => {
    n.traverse((h) => {
      var f, m;
      const d = h;
      d.material && (t == null || t.properties.remove(d.material), (m = (f = d.material).dispose) == null || m.call(f));
    }), t != null && t.info.programs && (t.info.programs.length = 0), t == null || t.compile(n, i.current);
  };
  return $e(() => {
    Ft.shadowmap_pars_fragment = l.replace("#ifdef USE_SHADOWMAP", `#ifdef USE_SHADOWMAP
${pe(c)}`).replace("#if defined( SHADOWMAP_TYPE_PCF )", `
return PCSS(shadowMap, shadowCoord);
#if defined( SHADOWMAP_TYPE_PCF )`), u();
  }), Ki(() => {
    Ft.shadowmap_pars_fragment = l, u();
  }), Pt({
    get size() {
      return r();
    },
    set size(h = 25) {
      r(h), V();
    },
    get focus() {
      return o();
    },
    set focus(h = 0) {
      o(h), V();
    },
    get samples() {
      return a();
    },
    set samples(h = 10) {
      a(h), V();
    },
    $set: Lt,
    $on: (h, d) => It(e, h, d)
  });
}
Ut(zL, { size: {}, focus: {}, samples: {} }, [], [], !0);
function VL(s, e) {
  if (new.target) return Rt({ component: VL, ...s });
  Ct(e, !0);
  let t = G(e, "points", 23, () => []), i = G(e, "shape", 7, "none"), n = G(e, "shapeFunction", 7, () => 1), r = G(e, "ref", 15), o = G(e, "children", 7), a = G(e, "props", 7), l = t().length;
  const { invalidate: c } = cn(), u = new Nt(new Float32Array(l * 6), 3), h = new Nt(new Float32Array(l * 6), 3), d = new Nt(new Float32Array(l * 6), 3), f = new Nt(new Float32Array(l * 2), 1), m = new Nt(new Float32Array(l * 2), 1), g = new Nt(new Float32Array(l * 2), 1), v = new Nt(new Float32Array(l * 4), 2), _ = new Nt(new Uint16Array(l * 6), 1);
  i() === "taper" && n((x) => 1 * Math.pow(4 * x * (1 - x), 1));
  for (let x = 0, M = 0, A = 0, E = 0; x < l; x += 1, M += 2, A += 4, E += 6) {
    f.setX(M, x / t().length), f.setX(M + 1, x / t().length), m.setX(M, 1), m.setX(M + 1, -1);
    const C = i() === "none" ? 1 : n()(x / (l - 1));
    if (g.setX(M, C), g.setX(M + 1, C), v.setXYZW(M, x / (l - 1), 0, x / (l - 1), 1), x < l - 1) {
      const P = x * 2;
      _.setX(E + 0, P + 0), _.setX(E + 1, P + 1), _.setX(E + 2, P + 2), _.setX(E + 3, P + 2), _.setX(E + 4, P + 1), _.setX(E + 5, P + 3);
    }
  }
  const y = new Gt();
  y.setAttribute("position", u), y.setAttribute("previous", h), y.setAttribute("next", d), y.setAttribute("counters", f), y.setAttribute("side", m), y.setAttribute("width", g), y.setAttribute("uv", v), y.setIndex(_);
  const w = (x) => {
    if (x.length === 0 || x.length !== l) return;
    let M = 0, A = 0, E = 0;
    const C = x[0];
    h.setXYZ(A, C.x, C.y, C.z), A += 1, h.setXYZ(A, C.x, C.y, C.z), A += 1;
    for (let T = 0; T < l; T++) {
      const I = x[T];
      u.setXYZ(M, I.x, I.y, I.z), M += 1, u.setXYZ(M, I.x, I.y, I.z), M += 1, T < l - 1 && (h.setXYZ(A, I.x, I.y, I.z), A += 1, h.setXYZ(A, I.x, I.y, I.z), A += 1), T > 0 && T + 1 <= l && (d.setXYZ(E, I.x, I.y, I.z), E += 1, d.setXYZ(E, I.x, I.y, I.z), E += 1);
    }
    const P = x[l - 1];
    d.setXYZ(E, P.x, P.y, P.z), E += 1, d.setXYZ(E, P.x, P.y, P.z), E += 1, u.needsUpdate = !0, h.needsUpdate = !0, d.needsUpdate = !0, y.computeBoundingSphere(), c();
  };
  return $e(() => w(t())), pt(s, sn({ is: y }, a, {
    get ref() {
      return r();
    },
    set ref(x) {
      r(x);
    },
    children: (x, M) => {
      var A = At(), E = dt(A);
      Wt(E, () => o() ?? Bt, () => ({ ref: y })), ut(x, A);
    },
    $$slots: { default: !0 }
  })), Pt({
    get points() {
      return t();
    },
    set points(x = []) {
      t(x), V();
    },
    get shape() {
      return i();
    },
    set shape(x = "none") {
      i(x), V();
    },
    get shapeFunction() {
      return n();
    },
    set shapeFunction(x = () => 1) {
      n(x), V();
    },
    get ref() {
      return r();
    },
    set ref(x) {
      r(x), V();
    },
    get children() {
      return o();
    },
    set children(x) {
      o(x), V();
    },
    get props() {
      return a();
    },
    set props(x) {
      a(x), V();
    },
    $set: Lt,
    $on: (x, M) => It(e, x, M)
  });
}
Ut(
  VL,
  {
    points: {},
    shape: {},
    shapeFunction: {},
    ref: {},
    children: {},
    props: {}
  },
  [],
  [],
  !0
);
const R9 = `
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform float useDash;
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
uniform sampler2D alphaMap;
uniform float useAlphaMap;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounters;

vec4 CustomLinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

void main()	{
	#include <logdepthbuf_fragment>
	#include <${iy < 154 ? "encodings_fragment" : "colorspace_fragment"}>

	vec4 c = vColor;

	if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV ).r;

	if( useDash == 1. ){
			c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
	}

	gl_FragColor = CustomLinearTosRGB(c);
}
`, D9 = `
    #include <common>
    ${Ft.logdepthbuf_pars_vertex}
    ${Ft.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${Ft.logdepthbuf_vertex}
        ${Ft.fog_vertex}
    }
`;
function GL(s, e) {
  if (new.target) return Rt({ component: GL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(y, "$size", t);
  let r = G(e, "opacity", 7, 1), o = G(e, "color", 7, "#ffffff"), a = G(e, "dashOffset", 7, 0), l = G(e, "dashArray", 7, 0), c = G(e, "dashRatio", 7, 0), u = G(e, "attenuate", 7, !0), h = G(e, "width", 7, 1), d = G(e, "scaleDown", 7, 0), f = G(e, "alphaMap", 7), m = G(e, "ref", 15), g = G(e, "children", 7), v = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "opacity",
    "color",
    "dashOffset",
    "dashArray",
    "dashRatio",
    "attenuate",
    "width",
    "scaleDown",
    "alphaMap",
    "ref",
    "children"
  ]), { invalidate: _, size: y } = cn();
  const w = {
    lineWidth: { value: h() },
    color: { value: new rt(o()) },
    opacity: { value: r() },
    resolution: { value: new Be(1, 1) },
    sizeAttenuation: { value: u() ? 1 : 0 },
    dashArray: { value: l() },
    dashOffset: { value: a() },
    dashRatio: { value: c() },
    useDash: { value: l() > 0 ? 1 : 0 },
    scaleDown: { value: d() / 10 },
    alphaTest: { value: 0 },
    alphaMap: { value: f() },
    useAlphaMap: { value: f() ? 1 : 0 }
  }, x = new Mi({ uniforms: w });
  $e(() => {
    w.resolution.value.set(n().width, n().height), _();
  }), $e(() => {
    w.dashRatio.value = c(), w.dashArray.value = l(), w.dashOffset.value = a(), w.lineWidth.value = h(), w.opacity.value = r(), w.color.value.set(o()), _();
  }), pt(s, sn({ is: x, fragmentShader: R9, vertexShader: D9 }, () => v, {
    get ref() {
      return m();
    },
    set ref(A) {
      m(A);
    },
    children: (A, E) => {
      var C = At(), P = dt(C);
      Wt(P, () => g() ?? Bt, () => ({ ref: x })), ut(A, C);
    },
    $$slots: { default: !0 }
  }));
  var M = Pt({
    get opacity() {
      return r();
    },
    set opacity(A = 1) {
      r(A), V();
    },
    get color() {
      return o();
    },
    set color(A = "#ffffff") {
      o(A), V();
    },
    get dashOffset() {
      return a();
    },
    set dashOffset(A = 0) {
      a(A), V();
    },
    get dashArray() {
      return l();
    },
    set dashArray(A = 0) {
      l(A), V();
    },
    get dashRatio() {
      return c();
    },
    set dashRatio(A = 0) {
      c(A), V();
    },
    get attenuate() {
      return u();
    },
    set attenuate(A = !0) {
      u(A), V();
    },
    get width() {
      return h();
    },
    set width(A = 1) {
      h(A), V();
    },
    get scaleDown() {
      return d();
    },
    set scaleDown(A = 0) {
      d(A), V();
    },
    get alphaMap() {
      return f();
    },
    set alphaMap(A) {
      f(A), V();
    },
    get ref() {
      return m();
    },
    set ref(A) {
      m(A), V();
    },
    get children() {
      return g();
    },
    set children(A) {
      g(A), V();
    },
    $set: Lt,
    $on: (A, E) => It(e, A, E)
  });
  return i(), M;
}
Ut(
  GL,
  {
    opacity: {},
    color: {},
    dashOffset: {},
    dashArray: {},
    dashRatio: {},
    attenuate: {},
    width: {},
    scaleDown: {},
    alphaMap: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
class ry extends it {
  constructor() {
    const e = ry.SkyShader, t = new Mi({
      name: e.name,
      uniforms: Fl.clone(e.uniforms),
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      side: Yi,
      depthWrite: !1
    });
    super(new pi(1, 1, 1), t), this.isSky = !0;
  }
}
ry.SkyShader = {
  name: "SkyShader",
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new H() },
    up: { value: new H(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorption + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
function HL(s, e) {
  if (new.target) return Rt({ component: HL, ...s });
  Ct(e, !0);
  let t = G(e, "scale", 7, 1e3), i = G(e, "turbidity", 7, 10), n = G(e, "rayleigh", 7, 3), r = G(e, "mieCoefficient", 7, 5e-3), o = G(e, "mieDirectionalG", 7, 0.7), a = G(e, "elevation", 7, 2), l = G(e, "azimuth", 7, 180), c = G(e, "setEnvironment", 7, !0), u = G(e, "cubeMapSize", 7, 128), h = G(e, "webGLRenderTargetOptions", 23, () => ({})), d = G(e, "ref", 15), f = G(e, "children", 7), m = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "scale",
    "turbidity",
    "rayleigh",
    "mieCoefficient",
    "mieDirectionalG",
    "elevation",
    "azimuth",
    "setEnvironment",
    "cubeMapSize",
    "webGLRenderTargetOptions",
    "ref",
    "children"
  ]);
  const g = new ry(), v = new H(), { uniforms: _ } = g.material, { renderer: y, scene: w, invalidate: x } = cn();
  let M = Us(void 0), A;
  const E = () => {
    In(M, pr(new T_(u(), {
      type: vr,
      generateMipmaps: !0,
      minFilter: As,
      ...h()
    }))), A = new E_(1, 1.1, pe(M));
  }, C = w.environment;
  $e(() => {
    c() && pe(M) ? (w.environment = pe(M).texture, x()) : c() || (w.environment = C, x());
  });
  const { start: P, stop: T } = ti(
    () => {
      g.scale.setScalar(t()), _.turbidity.value = i(), _.rayleigh.value = n(), _.mieCoefficient.value = r(), _.mieDirectionalG.value = o();
      const I = Kr.degToRad(90 - a()), D = Kr.degToRad(l());
      v.setFromSphericalCoords(1, I, D), _.sunPosition.value.copy(v), c() && ((!pe(M) || !A) && E(), A == null || A.update(y, g)), x(), T();
    },
    { autoStart: !1, autoInvalidate: !1 }
  );
  return $e(() => {
    t(), i(), n(), r(), o(), a(), l(), P();
  }), Ki(() => {
    var I;
    g.material.dispose(), w.environment = C;
    try {
      (I = pe(M)) == null || I.dispose();
    } catch (D) {
      console.warn("Could not dispose renderTarget:", D);
    }
  }), pt(s, sn({ is: g }, () => m, {
    get ref() {
      return d();
    },
    set ref(I) {
      d(I);
    },
    children: (I, D) => {
      var U = At(), L = dt(U);
      Wt(L, () => f() ?? Bt, () => ({
        ref: g,
        sunPosition: v,
        renderTarget: pe(M)
      })), ut(I, U);
    },
    $$slots: { default: !0 }
  })), Pt({
    get scale() {
      return t();
    },
    set scale(I = 1e3) {
      t(I), V();
    },
    get turbidity() {
      return i();
    },
    set turbidity(I = 10) {
      i(I), V();
    },
    get rayleigh() {
      return n();
    },
    set rayleigh(I = 3) {
      n(I), V();
    },
    get mieCoefficient() {
      return r();
    },
    set mieCoefficient(I = 5e-3) {
      r(I), V();
    },
    get mieDirectionalG() {
      return o();
    },
    set mieDirectionalG(I = 0.7) {
      o(I), V();
    },
    get elevation() {
      return a();
    },
    set elevation(I = 2) {
      a(I), V();
    },
    get azimuth() {
      return l();
    },
    set azimuth(I = 180) {
      l(I), V();
    },
    get setEnvironment() {
      return c();
    },
    set setEnvironment(I = !0) {
      c(I), V();
    },
    get cubeMapSize() {
      return u();
    },
    set cubeMapSize(I = 128) {
      u(I), V();
    },
    get webGLRenderTargetOptions() {
      return h();
    },
    set webGLRenderTargetOptions(I = {}) {
      h(I), V();
    },
    get ref() {
      return d();
    },
    set ref(I) {
      d(I), V();
    },
    get children() {
      return f();
    },
    set children(I) {
      f(I), V();
    },
    $set: Lt,
    $on: (I, D) => It(e, I, D)
  });
}
Ut(
  HL,
  {
    scale: {},
    turbidity: {},
    rayleigh: {},
    mieCoefficient: {},
    mieDirectionalG: {},
    elevation: {},
    azimuth: {},
    setEnvironment: {},
    cubeMapSize: {},
    webGLRenderTargetOptions: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
function sy(s, e) {
  if (new.target) return Rt({ component: sy, ...s });
  Ct(e, !0);
  let t = G(e, "name", 7), i = G(e, "plugin", 7), n = G(e, "children", 7);
  kS(t(), i());
  var r = At(), o = dt(r);
  return Wt(o, () => n() ?? Bt), ut(s, r), Pt({
    get name() {
      return t();
    },
    set name(a) {
      t(a), V();
    },
    get plugin() {
      return i();
    },
    set plugin(a) {
      i(a), V();
    },
    get children() {
      return n();
    },
    set children(a) {
      n(a), V();
    },
    $set: Lt,
    $on: (a, l) => It(e, a, l)
  });
}
Ut(sy, { name: {}, plugin: {}, children: {} }, [], [], !0);
function WL(s, e) {
  if (new.target) return Rt({ component: WL, ...s });
  Ct(e, !0);
  const { renderStage: t } = cn();
  let i = G(e, "x", 7, 0), n = G(e, "y", 7, 0), r = G(e, "z", 7, 0), o = G(e, "precise", 7, !1), a = G(e, "auto", 7, !1), l = G(e, "ref", 15), c = G(e, "onalign", 7), u = G(e, "children", 7), h = G(e, "stage", 23, () => wu("<Align>", { before: t })), d = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "x",
    "y",
    "z",
    "precise",
    "auto",
    "ref",
    "onalign",
    "children",
    "stage"
  ]);
  const f = new Zn(), m = new Zn(), g = new Zn(), v = () => {
    var L;
    if (i() === !1 && n() === !1 && r() === !1) return;
    g.matrixWorld.identity();
    const M = new yn().setFromObject(m, o()), A = new H(), E = new fi(), C = M.max.x - M.min.x, P = M.max.y - M.min.y, T = M.max.z - M.min.z;
    M.getCenter(A), M.getBoundingSphere(E);
    const I = (n() || 0) * P / 2, D = (i() || 0) * C / 2, U = (r() || 0) * T / 2;
    g.position.set(i() === !1 ? 0 : -A.x + D, n() === !1 ? 0 : -A.y + I, r() === !1 ? 0 : -A.z + U), (L = c()) == null || L({
      boundingBox: M,
      center: g.position.clone(),
      boundingSphere: E,
      container: f,
      depth: T,
      depthAlignment: U,
      height: P,
      verticalAlignment: I,
      width: C,
      horizontalAlignment: D
    });
  }, { start: _, stop: y } = ti(
    () => {
      v(), y();
    },
    { autoStart: !1, stage: h() }
  ), w = _;
  zs(() => [i(), n(), r(), o()], _);
  const x = (M) => {
    bn(M.ref, "Object3D") && zs.pre(() => [M.ref], () => (a() && _(), () => {
      a() && _();
    }));
  };
  return pt(s, sn({ is: f }, () => d, {
    get ref() {
      return l();
    },
    set ref(M) {
      l(M);
    },
    children: (M, A) => {
      pt(M, {
        is: g,
        children: (E, C) => {
          pt(E, {
            is: m,
            children: (P, T) => {
              sy(P, {
                name: "align",
                plugin: x,
                children: (I, D) => {
                  var U = At(), L = dt(U);
                  Wt(L, () => u() ?? Bt, () => ({ align: _, ref: f })), ut(I, U);
                },
                $$slots: { default: !0 }
              });
            },
            $$slots: { default: !0 }
          });
        },
        $$slots: { default: !0 }
      });
    },
    $$slots: { default: !0 }
  })), Pt({
    align: w,
    get x() {
      return i();
    },
    set x(M = 0) {
      i(M), V();
    },
    get y() {
      return n();
    },
    set y(M = 0) {
      n(M), V();
    },
    get z() {
      return r();
    },
    set z(M = 0) {
      r(M), V();
    },
    get precise() {
      return o();
    },
    set precise(M = !1) {
      o(M), V();
    },
    get auto() {
      return a();
    },
    set auto(M = !1) {
      a(M), V();
    },
    get ref() {
      return l();
    },
    set ref(M) {
      l(M), V();
    },
    get onalign() {
      return c();
    },
    set onalign(M) {
      c(M), V();
    },
    get children() {
      return u();
    },
    set children(M) {
      u(M), V();
    },
    get stage() {
      return h();
    },
    set stage(M = wu("<Align>", { before: t })) {
      h(M), V();
    },
    $set: Lt,
    $on: (M, A) => It(e, M, A)
  });
}
Ut(
  WL,
  {
    x: {},
    y: {},
    z: {},
    precise: {},
    auto: {},
    ref: {},
    onalign: {},
    children: {},
    stage: {}
  },
  [],
  ["align"],
  !0
);
const ab = new _t();
class oy {
  constructor(e) {
    e = e || {}, this.zNear = e.webGL === !0 ? -1 : 0, this.vertices = {
      near: [
        new H(),
        new H(),
        new H(),
        new H()
      ],
      far: [
        new H(),
        new H(),
        new H(),
        new H()
      ]
    }, e.projectionMatrix !== void 0 && this.setFromProjectionMatrix(e.projectionMatrix, e.maxFar || 1e4);
  }
  setFromProjectionMatrix(e, t) {
    const i = this.zNear, n = e.elements[2 * 4 + 3] === 0;
    return ab.copy(e).invert(), this.vertices.near[0].set(1, 1, i), this.vertices.near[1].set(1, -1, i), this.vertices.near[2].set(-1, -1, i), this.vertices.near[3].set(-1, 1, i), this.vertices.near.forEach(function(r) {
      r.applyMatrix4(ab);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(r) {
      r.applyMatrix4(ab);
      const o = Math.abs(r.z);
      n ? r.z *= Math.min(t / o, 1) : r.multiplyScalar(Math.min(t / o, 1));
    }), this.vertices;
  }
  split(e, t) {
    for (; e.length > t.length; )
      t.push(new oy());
    t.length = e.length;
    for (let i = 0; i < e.length; i++) {
      const n = t[i];
      if (i === 0)
        for (let r = 0; r < 4; r++)
          n.vertices.near[r].copy(this.vertices.near[r]);
      else
        for (let r = 0; r < 4; r++)
          n.vertices.near[r].lerpVectors(this.vertices.near[r], this.vertices.far[r], e[i - 1]);
      if (i === e.length - 1)
        for (let r = 0; r < 4; r++)
          n.vertices.far[r].copy(this.vertices.far[r]);
      else
        for (let r = 0; r < 4; r++)
          n.vertices.far[r].lerpVectors(this.vertices.near[r], this.vertices.far[r], e[i]);
    }
  }
  toSpace(e, t) {
    for (let i = 0; i < 4; i++)
      t.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(e), t.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(e);
  }
}
const P2 = {
  lights_fragment_begin: (
    /* glsl */
    `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
		vec2 cascade;
		float cascadeCenter;
		float closestEdge;
		float margin;
		float csmx;
		float csmy;

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
				// NOTE: Depth gets larger away from the camera.
				// cascade.x is closer, cascade.y is further
				cascade = CSM_cascades[ i ];
				cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
				closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
				margin = 0.25 * pow( closestEdge, 2.0 );
				csmx = cascade.x - margin / 2.0;
				csmy = cascade.y + margin / 2.0;
				if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

					float dist = min( linearDepth - csmx, csmy - linearDepth );
					float ratio = clamp( dist / margin, 0.0, 1.0 );

					vec3 prevColor = directLight.color;
					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
					directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

					ReflectedLight prevLight = reflectedLight;
					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

					bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
					float blendRatio = shouldBlend ? ratio : 1.0;

					reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
					reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
					reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
					reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

				}
			#endif

		}
		#pragma unroll_loop_end
	#elif defined (USE_SHADOWMAP)

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

				directionalLightShadow = directionalLightShadows[ i ];
				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )
		// note: no loop here - all CSM lights are in fact one light only
		getDirectionalLightInfo( directionalLights[0], directLight );
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  ),
  lights_pars_begin: (
    /* glsl */
    `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + Ft.lights_pars_begin
  )
}, R2 = new _t(), lb = new oy({ webGL: !0 }), fa = new H(), yf = new yn(), cb = [], ub = [], hb = new _t(), D2 = new _t(), I9 = new H(0, 1, 0);
class L9 {
  constructor(e) {
    this.camera = e.camera, this.parent = e.parent, this.cascades = e.cascades || 3, this.maxFar = e.maxFar || 1e5, this.mode = e.mode || "practical", this.shadowMapSize = e.shadowMapSize || 2048, this.shadowBias = e.shadowBias || 1e-6, this.lightDirection = e.lightDirection || new H(1, -1, 1).normalize(), this.lightIntensity = e.lightIntensity || 3, this.lightNear = e.lightNear || 1, this.lightFar = e.lightFar || 2e3, this.lightMargin = e.lightMargin || 200, this.customSplitsCallback = e.customSplitsCallback, this.fade = !1, this.mainFrustum = new oy({ webGL: !0 }), this.frustums = [], this.breaks = [], this.lights = [], this.shaders = /* @__PURE__ */ new Map(), this.createLights(), this.updateFrustums(), this.injectInclude();
  }
  createLights() {
    for (let e = 0; e < this.cascades; e++) {
      const t = new q_(16777215, this.lightIntensity);
      t.castShadow = !0, t.shadow.mapSize.width = this.shadowMapSize, t.shadow.mapSize.height = this.shadowMapSize, t.shadow.camera.near = this.lightNear, t.shadow.camera.far = this.lightFar, t.shadow.bias = this.shadowBias, this.parent.add(t), this.parent.add(t.target), this.lights.push(t);
    }
  }
  initCascades() {
    const e = this.camera;
    e.updateProjectionMatrix(), this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this.maxFar), this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const e = this.frustums;
    for (let t = 0; t < e.length; t++) {
      const n = this.lights[t].shadow.camera, r = this.frustums[t], o = r.vertices.near, a = r.vertices.far, l = a[0];
      let c;
      l.distanceTo(a[2]) > l.distanceTo(o[2]) ? c = a[2] : c = o[2];
      let u = l.distanceTo(c);
      if (this.fade) {
        const h = this.camera, d = Math.max(h.far, this.maxFar), f = r.vertices.far[0].z / (d - h.near), m = 0.25 * Math.pow(f, 2) * (d - h.near);
        u += m;
      }
      n.left = -u / 2, n.right = u / 2, n.top = u / 2, n.bottom = -u / 2, n.updateProjectionMatrix();
    }
  }
  getBreaks() {
    const e = this.camera, t = Math.min(e.far, this.maxFar);
    switch (this.breaks.length = 0, this.mode) {
      case "uniform":
        i(this.cascades, e.near, t, this.breaks);
        break;
      case "logarithmic":
        n(this.cascades, e.near, t, this.breaks);
        break;
      case "practical":
        r(this.cascades, e.near, t, 0.5, this.breaks);
        break;
      case "custom":
        this.customSplitsCallback === void 0 && console.error("CSM: Custom split scheme callback not defined."), this.customSplitsCallback(this.cascades, e.near, t, this.breaks);
        break;
    }
    function i(o, a, l, c) {
      for (let u = 1; u < o; u++)
        c.push((a + (l - a) * u / o) / l);
      c.push(1);
    }
    function n(o, a, l, c) {
      for (let u = 1; u < o; u++)
        c.push(a * (l / a) ** (u / o) / l);
      c.push(1);
    }
    function r(o, a, l, c, u) {
      cb.length = 0, ub.length = 0, n(o, a, l, ub), i(o, a, l, cb);
      for (let h = 1; h < o; h++)
        u.push(Kr.lerp(cb[h - 1], ub[h - 1], c));
      u.push(1);
    }
  }
  update() {
    const e = this.camera, t = this.frustums;
    hb.lookAt(new H(), this.lightDirection, I9), D2.copy(hb).invert();
    for (let i = 0; i < t.length; i++) {
      const n = this.lights[i], r = n.shadow.camera, o = (r.right - r.left) / this.shadowMapSize, a = (r.top - r.bottom) / this.shadowMapSize;
      R2.multiplyMatrices(D2, e.matrixWorld), t[i].toSpace(R2, lb);
      const l = lb.vertices.near, c = lb.vertices.far;
      yf.makeEmpty();
      for (let u = 0; u < 4; u++)
        yf.expandByPoint(l[u]), yf.expandByPoint(c[u]);
      yf.getCenter(fa), fa.z = yf.max.z + this.lightMargin, fa.x = Math.floor(fa.x / o) * o, fa.y = Math.floor(fa.y / a) * a, fa.applyMatrix4(hb), n.position.copy(fa), n.target.position.copy(fa), n.target.position.x += this.lightDirection.x, n.target.position.y += this.lightDirection.y, n.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    Ft.lights_fragment_begin = P2.lights_fragment_begin, Ft.lights_pars_begin = P2.lights_pars_begin;
  }
  setupMaterial(e) {
    e.defines = e.defines || {}, e.defines.USE_CSM = 1, e.defines.CSM_CASCADES = this.cascades, this.fade && (e.defines.CSM_FADE = "");
    const t = [], i = this, n = this.shaders;
    e.onBeforeCompile = function(r) {
      const o = Math.min(i.camera.far, i.maxFar);
      i.getExtendedBreaks(t), r.uniforms.CSM_cascades = { value: t }, r.uniforms.cameraNear = { value: i.camera.near }, r.uniforms.shadowFar = { value: o }, n.set(e, r);
    }, n.set(e, null);
  }
  updateUniforms() {
    const e = Math.min(this.camera.far, this.maxFar);
    this.shaders.forEach(function(i, n) {
      if (i !== null) {
        const r = i.uniforms;
        this.getExtendedBreaks(r.CSM_cascades.value), r.cameraNear.value = this.camera.near, r.shadowFar.value = e;
      }
      !this.fade && "CSM_FADE" in n.defines ? (delete n.defines.CSM_FADE, n.needsUpdate = !0) : this.fade && !("CSM_FADE" in n.defines) && (n.defines.CSM_FADE = "", n.needsUpdate = !0);
    }, this);
  }
  getExtendedBreaks(e) {
    for (; e.length < this.breaks.length; )
      e.push(new Be());
    e.length = this.breaks.length;
    for (let t = 0; t < this.cascades; t++) {
      const i = this.breaks[t], n = this.breaks[t - 1] || 0;
      e[t].x = n, e[t].y = i;
    }
  }
  updateFrustums() {
    this.getBreaks(), this.initCascades(), this.updateShadowBounds(), this.updateUniforms();
  }
  remove() {
    for (let e = 0; e < this.lights.length; e++)
      this.parent.remove(this.lights[e].target), this.parent.remove(this.lights[e]);
  }
  dispose() {
    const e = this.shaders;
    e.forEach(function(t, i) {
      delete i.onBeforeCompile, delete i.defines.USE_CSM, delete i.defines.CSM_CASCADES, delete i.defines.CSM_FADE, t !== null && (delete t.uniforms.CSM_cascades, delete t.uniforms.cameraNear, delete t.uniforms.shadowFar), i.needsUpdate = !0;
    }), e.clear();
  }
}
const U9 = () => {
  let s;
  const e = /* @__PURE__ */ new Set(), t = (o) => bn(o, "MeshStandardMaterial") || bn(o, "MeshPhongMaterial"), i = (o) => {
    e.has(o) || (e.add(o), s == null || s(o));
  }, n = (o) => {
    t(o) ? i(o) : bn(o, "Mesh") && (Array.isArray(o.material) ? o.material.forEach((a) => {
      t(a) && i(a);
    }) : t(o.material) && i(o.material));
  }, r = (o) => {
    s = o;
  };
  return kS("csm", (o) => {
    So(() => {
      n(o.ref);
    });
  }), Ki(() => s = void 0), { onNewMaterial: r, allMaterials: e };
};
var k9 = /* @__PURE__ */ ni("<!> <!>", 1);
function XL(s, e) {
  if (new.target) return Rt({ component: XL, ...s });
  Ct(e, !1);
  const [t, i] = $i(), n = () => Bn(_, "$csmStore", t), r = () => Bn(m, "$defaultCamera", t);
  let o = G(e, "enabled", 12, !0), a = G(e, "args", 28, () => ({})), l = G(e, "camera", 12, void 0), c = G(e, "configure", 12, void 0), u = G(e, "lightIntensity", 12, void 0), h = G(e, "lightColor", 12, void 0), d = G(e, "lightDirection", 28, () => [1, -1, 1]);
  const f = Gn(o()), { camera: m, scene: g, size: v } = cn(), _ = Xn(void 0);
  ti(() => {
    var L;
    return (L = n()) == null ? void 0 : L.update();
  }, { autoInvalidate: !1 });
  const { onNewMaterial: y, allMaterials: w } = U9(), x = () => {
    var L, k;
    (L = n()) == null || L.remove(), (k = n()) == null || k.dispose(), Nb(_, void 0);
  };
  ui([v, _], ([L, k]) => {
    k && k.updateFrustums();
  });
  const M = Gn(l());
  ui([m, M, _], ([L, k, B]) => {
    B && (B.camera = k ?? L, a().maxFar !== void 0 && (B.maxFar = a().maxFar), a().mode !== void 0 && (B.mode = a().mode), B.updateFrustums());
  }), ui(f, (L) => {
    var k;
    if (L) {
      const B = new L9({
        camera: l() ?? r(),
        parent: g,
        ...a()
      });
      (k = c()) == null || k(B);
      for (const j of w)
        B.setupMaterial(j);
      y((j) => B.setupMaterial(j)), _.set(B);
    } else
      y(void 0), x();
  });
  const A = Gn(u()), E = Gn(h());
  ui(
    [
      _,
      A,
      E
    ],
    ([L, k, B]) => {
      L == null || L.lights.forEach((j) => {
        k !== void 0 && (j.intensity = k / Math.PI), B !== void 0 && j.color.set(B);
      });
    }
  );
  const C = Gn(d());
  ui([_, C], ([L, k]) => {
    L == null || L.lightDirection.set(...k).normalize();
  }), Ki(x), ul(() => Ah(o()), () => {
    f.set(o());
  }), ul(() => Ah(l()), () => {
    M.set(l());
  }), ul(() => Ah(u()), () => {
    A.set(u());
  }), ul(() => Ah(h()), () => {
    E.set(h());
  }), ul(() => Ah(d()), () => {
    C.set(d());
  }), lw(), Au();
  var P = k9(), T = dt(P);
  dE(T, e, "default", {});
  var I = Wn(T, 2);
  {
    var D = (L) => {
      var k = At(), B = dt(k);
      dE(B, e, "disabled", {}), ut(L, k);
    };
    Ai(I, (L) => {
      o() || L(D);
    });
  }
  ut(s, P);
  var U = Pt({
    get enabled() {
      return o();
    },
    set enabled(L) {
      o(L), V();
    },
    get args() {
      return a();
    },
    set args(L) {
      a(L), V();
    },
    get camera() {
      return l();
    },
    set camera(L) {
      l(L), V();
    },
    get configure() {
      return c();
    },
    set configure(L) {
      c(L), V();
    },
    get lightIntensity() {
      return u();
    },
    set lightIntensity(L) {
      u(L), V();
    },
    get lightColor() {
      return h();
    },
    set lightColor(L) {
      h(L), V();
    },
    get lightDirection() {
      return d();
    },
    set lightDirection(L) {
      d(L), V();
    },
    $set: Lt,
    $on: (L, k) => It(e, L, k)
  });
  return i(), U;
}
Ut(
  XL,
  {
    enabled: {},
    args: {},
    camera: {},
    configure: {},
    lightIntensity: {},
    lightColor: {},
    lightDirection: {}
  },
  ["default", "disabled"],
  [],
  !0
);
function YL(s, e) {
  if (new.target) return Rt({ component: YL, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(h, "$camera", t);
  let r = G(e, "follow", 7, !0), o = G(e, "ref", 15), a = G(e, "children", 7), l = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "follow",
    "ref",
    "children"
  ]);
  const c = new Zn(), u = new Zn(), { camera: h, renderStage: d } = cn(), f = new En();
  let m = /* @__PURE__ */ wt(() => r() === !0 ? n() : r() === !1 ? void 0 : r());
  const g = wu("<Billboard>", { before: d }), { start: v, stop: _ } = ti(
    () => {
      var w;
      u.updateMatrix(), u.updateWorldMatrix(!1, !1), u.getWorldQuaternion(f), (w = pe(m)) == null || w.getWorldQuaternion(c.quaternion).premultiply(f.invert());
    },
    { autoStart: !1, stage: g }
  );
  $e(() => {
    r() ? v() : _();
  }), pt(s, sn({ is: u }, () => l, {
    get ref() {
      return o();
    },
    set ref(w) {
      o(w);
    },
    children: (w, x) => {
      pt(w, {
        is: c,
        children: (M, A) => {
          var E = At(), C = dt(E);
          Wt(C, () => a() ?? Bt, () => ({ ref: u })), ut(M, E);
        },
        $$slots: { default: !0 }
      });
    },
    $$slots: { default: !0 }
  }));
  var y = Pt({
    get follow() {
      return r();
    },
    set follow(w = !0) {
      r(w), V();
    },
    get ref() {
      return o();
    },
    set ref(w) {
      o(w), V();
    },
    get children() {
      return a();
    },
    set children(w) {
      a(w), V();
    },
    $set: Lt,
    $on: (w, x) => It(e, w, x)
  });
  return i(), y;
}
Ut(YL, { follow: {}, ref: {}, children: {} }, [], [], !0);
const O9 = `
uniform vec3 glowColor;
uniform float falloffAmount;
uniform float glowSharpness;
uniform float glowInternalRadius;

varying vec3 vPosition;
varying vec3 vNormal;

void main()
{
	// Normal
	vec3 normal = normalize(vNormal);
	if(!gl_FrontFacing)
			normal *= - 1.0;
	vec3 viewDirection = normalize(cameraPosition - vPosition);
	float fresnel = dot(viewDirection, normal);
	fresnel = pow(fresnel, glowInternalRadius + 0.1);
	float falloff = smoothstep(0., falloffAmount, fresnel);
	float fakeGlow = fresnel;
	fakeGlow += fresnel * glowSharpness;
	fakeGlow *= falloff;
	gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));

	${Ft.tonemapping_fragment}
	${Ft.colorspace_fragment}
}`, F9 = `varying vec3 vPosition;
varying vec3 vNormal;

void main() {
	vec4 modelPosition = modelMatrix * vec4(position, 1.0);
	gl_Position = projectionMatrix * viewMatrix * modelPosition;
	vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
	vPosition = modelPosition.xyz;
	vNormal = modelNormal.xyz;
}`;
function jL(s, e) {
  if (new.target) return Rt({ component: jL, ...s });
  Ct(e, !0);
  let t = G(e, "falloff", 7, 0.1), i = G(e, "glowInternalRadius", 7, 6), n = G(e, "glowColor", 7, "green"), r = G(e, "glowSharpness", 7, 1), o = G(e, "ref", 15), a = G(e, "children", 7), l = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "falloff",
    "glowInternalRadius",
    "glowColor",
    "glowSharpness",
    "ref",
    "children"
  ]);
  const c = {
    falloff: { value: t() },
    glowInternalRadius: { value: i() },
    glowColor: { value: new rt(n()) },
    glowSharpness: { value: r() }
  }, u = new Mi({
    uniforms: c,
    fragmentShader: O9,
    vertexShader: F9,
    transparent: !0,
    blending: kp,
    depthTest: !1
  }), { invalidate: h } = cn();
  return $e(() => {
    u.uniforms.falloff.value = t(), h();
  }), $e(() => {
    u.uniforms.glowInternalRadius.value = i(), h();
  }), $e(() => {
    u.uniforms.glowColor.value.set(n()), h();
  }), $e(() => {
    u.uniforms.glowSharpness.value = r(), h();
  }), pt(s, sn({ is: u }, () => l, {
    get ref() {
      return o();
    },
    set ref(d) {
      o(d);
    },
    children: (d, f) => {
      var m = At(), g = dt(m);
      Wt(g, () => a() ?? Bt, () => ({ ref: u })), ut(d, m);
    },
    $$slots: { default: !0 }
  })), Pt({
    get falloff() {
      return t();
    },
    set falloff(d = 0.1) {
      t(d), V();
    },
    get glowInternalRadius() {
      return i();
    },
    set glowInternalRadius(d = 6) {
      i(d), V();
    },
    get glowColor() {
      return n();
    },
    set glowColor(d = "green") {
      n(d), V();
    },
    get glowSharpness() {
      return r();
    },
    set glowSharpness(d = 1) {
      r(d), V();
    },
    get ref() {
      return o();
    },
    set ref(d) {
      o(d), V();
    },
    get children() {
      return a();
    },
    set children(d) {
      a(d), V();
    },
    $set: Lt,
    $on: (d, f) => It(e, d, f)
  });
}
Ut(
  jL,
  {
    falloff: {},
    glowInternalRadius: {},
    glowColor: {},
    glowSharpness: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
const N9 = `
uniform sampler2D pointTexture;
uniform float fade;
uniform float opacity;

varying vec3 vColor;
void main() {
	float pointOpacity = 1.0;
	if (fade == 1.0) {
		float d = distance(gl_PointCoord, vec2(0.5, 0.5));
		pointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
	}
	gl_FragColor = vec4(vColor, pointOpacity * opacity);

	${Ft.tonemapping_fragment}
	${Ft.colorspace_fragment}
}`, B9 = `uniform float time;
attribute float size;
varying vec3 vColor;
void main() {
	vColor = color;
	vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
	gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
	gl_Position = projectionMatrix * mvPosition;
}`;
var z9 = /* @__PURE__ */ ni("<!> <!> <!>", 1);
function qL(s, e) {
  if (new.target) return Rt({ component: qL, ...s });
  Ct(e, !0);
  let t = G(e, "count", 7, 5e3), i = G(e, "radius", 7, 50), n = G(e, "depth", 7, 50), r = G(e, "factor", 7, 6), o = G(e, "saturation", 7, 1), a = G(e, "lightness", 7, 0.8), l = G(e, "speed", 7, 1), c = G(e, "fade", 7, !0), u = G(e, "opacity", 7, 1), h = G(e, "ref", 15), d = G(e, "children", 7), f = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "count",
    "radius",
    "depth",
    "factor",
    "saturation",
    "lightness",
    "speed",
    "fade",
    "opacity",
    "ref",
    "children"
  ]);
  const m = new I_(), g = new H(), v = new md(), _ = new rt(), y = (I) => g.setFromSpherical(v.set(I, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
  let w = new Nt(new Float32Array(t() * 3), 3), x = new Nt(new Float32Array(t() * 3), 3), M = new Nt(new Float32Array(t()), 1);
  $e(() => {
    w = new Nt(new Float32Array(t() * 3), 3), x = new Nt(new Float32Array(t() * 3), 3), M = new Nt(new Float32Array(t()), 1);
  }), $e(() => {
    const I = n() / t();
    let D = i() + n();
    for (let U = 0; U < t(); U += 1) {
      D -= I * Math.random();
      const L = y(D);
      w.setXYZ(U, L.x, L.y, L.z), _.setHSL(U / t(), o(), a()), x.setXYZ(U, _.r, _.g, _.b), M.setX(U, (0.5 + 0.5 * Math.random()) * r());
    }
  });
  const { stop: A, start: E } = ti(
    (I) => {
      C.time.value += I * l();
    },
    { autoStart: !1 }
  );
  $e(() => l() === 0 ? A() : E());
  const C = {
    time: { value: 0 },
    fade: { value: 1 },
    opacity: { value: 1 }
  }, P = new Mi({ uniforms: C, vertexShader: B9, fragmentShader: N9 });
  $e(() => {
    C.fade.value = c() ? 1 : 0;
  }), $e(() => {
    C.opacity.value = u();
  });
  const T = new Gt();
  return T.setAttribute("position", w), T.setAttribute("color", x), T.setAttribute("size", M), pt(s, sn({ is: m }, () => f, {
    get ref() {
      return h();
    },
    set ref(I) {
      h(I);
    },
    children: (I, D) => {
      var U = z9(), L = dt(U);
      pt(L, { is: T });
      var k = Wn(L, 2);
      pt(k, {
        is: P,
        blending: kp,
        depthWrite: !1,
        transparent: !0,
        vertexColors: !0
      });
      var B = Wn(k, 2);
      Wt(B, () => d() ?? Bt, () => ({ ref: m })), ut(I, U);
    },
    $$slots: { default: !0 }
  })), Pt({
    get count() {
      return t();
    },
    set count(I = 5e3) {
      t(I), V();
    },
    get radius() {
      return i();
    },
    set radius(I = 50) {
      i(I), V();
    },
    get depth() {
      return n();
    },
    set depth(I = 50) {
      n(I), V();
    },
    get factor() {
      return r();
    },
    set factor(I = 6) {
      r(I), V();
    },
    get saturation() {
      return o();
    },
    set saturation(I = 1) {
      o(I), V();
    },
    get lightness() {
      return a();
    },
    set lightness(I = 0.8) {
      a(I), V();
    },
    get speed() {
      return l();
    },
    set speed(I = 1) {
      l(I), V();
    },
    get fade() {
      return c();
    },
    set fade(I = !0) {
      c(I), V();
    },
    get opacity() {
      return u();
    },
    set opacity(I = 1) {
      u(I), V();
    },
    get ref() {
      return h();
    },
    set ref(I) {
      h(I), V();
    },
    get children() {
      return d();
    },
    set children(I) {
      d(I), V();
    },
    $set: Lt,
    $on: (I, D) => It(e, I, D)
  });
}
Ut(
  qL,
  {
    count: {},
    radius: {},
    depth: {},
    factor: {},
    saturation: {},
    lightness: {},
    speed: {},
    fade: {},
    opacity: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
const ZL = 0, V9 = 1, KL = 2, I2 = 2, db = 1.25, L2 = 1, Al = 6 * 4 + 4 + 4, ay = 65535, G9 = Math.pow(2, -24), fb = Symbol("SKIP_GENERATION");
function $L(s) {
  return s.index ? s.index.count : s.attributes.position.count;
}
function Dd(s) {
  return $L(s) / 3;
}
function JL(s, e = ArrayBuffer) {
  return s > 65535 ? new Uint32Array(new e(4 * s)) : new Uint16Array(new e(2 * s));
}
function H9(s, e) {
  if (!s.index) {
    const t = s.attributes.position.count, i = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, n = JL(t, i);
    s.setIndex(new Nt(n, 1));
    for (let r = 0; r < t; r++)
      n[r] = r;
  }
}
function QL(s, e) {
  const t = Dd(s), i = e || s.drawRange, n = i.start / 3, r = (i.start + i.count) / 3, o = Math.max(0, n), a = Math.min(t, r) - o;
  return [{
    offset: Math.floor(o),
    count: Math.floor(a)
  }];
}
function e3(s, e) {
  if (!s.groups || !s.groups.length)
    return QL(s, e);
  const t = [], i = /* @__PURE__ */ new Set(), n = e || s.drawRange, r = n.start / 3, o = (n.start + n.count) / 3;
  for (const l of s.groups) {
    const c = l.start / 3, u = (l.start + l.count) / 3;
    i.add(Math.max(r, c)), i.add(Math.min(o, u));
  }
  const a = Array.from(i.values()).sort((l, c) => l - c);
  for (let l = 0; l < a.length - 1; l++) {
    const c = a[l], u = a[l + 1];
    t.push({
      offset: Math.floor(c),
      count: Math.floor(u - c)
    });
  }
  return t;
}
function W9(s, e) {
  const t = Dd(s), i = e3(s, e).sort((o, a) => o.offset - a.offset), n = i[i.length - 1];
  n.count = Math.min(t - n.offset, n.count);
  let r = 0;
  return i.forEach(({ count: o }) => r += o), t !== r;
}
function pb(s, e, t, i, n) {
  let r = 1 / 0, o = 1 / 0, a = 1 / 0, l = -1 / 0, c = -1 / 0, u = -1 / 0, h = 1 / 0, d = 1 / 0, f = 1 / 0, m = -1 / 0, g = -1 / 0, v = -1 / 0;
  for (let _ = e * 6, y = (e + t) * 6; _ < y; _ += 6) {
    const w = s[_ + 0], x = s[_ + 1], M = w - x, A = w + x;
    M < r && (r = M), A > l && (l = A), w < h && (h = w), w > m && (m = w);
    const E = s[_ + 2], C = s[_ + 3], P = E - C, T = E + C;
    P < o && (o = P), T > c && (c = T), E < d && (d = E), E > g && (g = E);
    const I = s[_ + 4], D = s[_ + 5], U = I - D, L = I + D;
    U < a && (a = U), L > u && (u = L), I < f && (f = I), I > v && (v = I);
  }
  i[0] = r, i[1] = o, i[2] = a, i[3] = l, i[4] = c, i[5] = u, n[0] = h, n[1] = d, n[2] = f, n[3] = m, n[4] = g, n[5] = v;
}
function X9(s, e = null, t = null, i = null) {
  const n = s.attributes.position, r = s.index ? s.index.array : null, o = Dd(s), a = n.normalized;
  let l;
  e === null ? (l = new Float32Array(o * 6 * 4), t = 0, i = o) : (l = e, t = t || 0, i = i || o);
  const c = n.array, u = n.offset || 0;
  let h = 3;
  n.isInterleavedBufferAttribute && (h = n.data.stride);
  const d = ["getX", "getY", "getZ"];
  for (let f = t; f < t + i; f++) {
    const m = f * 3, g = f * 6;
    let v = m + 0, _ = m + 1, y = m + 2;
    r && (v = r[v], _ = r[_], y = r[y]), a || (v = v * h + u, _ = _ * h + u, y = y * h + u);
    for (let w = 0; w < 3; w++) {
      let x, M, A;
      a ? (x = n[d[w]](v), M = n[d[w]](_), A = n[d[w]](y)) : (x = c[v + w], M = c[_ + w], A = c[y + w]);
      let E = x;
      M < E && (E = M), A < E && (E = A);
      let C = x;
      M > C && (C = M), A > C && (C = A);
      const P = (C - E) / 2, T = w * 2;
      l[g + T + 0] = E + P, l[g + T + 1] = P + (Math.abs(E) + P) * G9;
    }
  }
  return l;
}
function bi(s, e, t) {
  return t.min.x = e[s], t.min.y = e[s + 1], t.min.z = e[s + 2], t.max.x = e[s + 3], t.max.y = e[s + 4], t.max.z = e[s + 5], t;
}
function U2(s) {
  let e = -1, t = -1 / 0;
  for (let i = 0; i < 3; i++) {
    const n = s[i + 3] - s[i];
    n > t && (t = n, e = i);
  }
  return e;
}
function k2(s, e) {
  e.set(s);
}
function O2(s, e, t) {
  let i, n;
  for (let r = 0; r < 3; r++) {
    const o = r + 3;
    i = s[r], n = e[r], t[r] = i < n ? i : n, i = s[o], n = e[o], t[o] = i > n ? i : n;
  }
}
function tv(s, e, t) {
  for (let i = 0; i < 3; i++) {
    const n = e[s + 2 * i], r = e[s + 2 * i + 1], o = n - r, a = n + r;
    o < t[i] && (t[i] = o), a > t[i + 3] && (t[i + 3] = a);
  }
}
function xf(s) {
  const e = s[3] - s[0], t = s[4] - s[1], i = s[5] - s[2];
  return 2 * (e * t + t * i + i * e);
}
const pa = 32, Y9 = (s, e) => s.candidate - e.candidate, ol = new Array(pa).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
})), nv = new Float32Array(6);
function j9(s, e, t, i, n, r) {
  let o = -1, a = 0;
  if (r === ZL)
    o = U2(e), o !== -1 && (a = (e[o] + e[o + 3]) / 2);
  else if (r === V9)
    o = U2(s), o !== -1 && (a = q9(t, i, n, o));
  else if (r === KL) {
    const l = xf(s);
    let c = db * n;
    const u = i * 6, h = (i + n) * 6;
    for (let d = 0; d < 3; d++) {
      const f = e[d], v = (e[d + 3] - f) / pa;
      if (n < pa / 4) {
        const _ = [...ol];
        _.length = n;
        let y = 0;
        for (let x = u; x < h; x += 6, y++) {
          const M = _[y];
          M.candidate = t[x + 2 * d], M.count = 0;
          const {
            bounds: A,
            leftCacheBounds: E,
            rightCacheBounds: C
          } = M;
          for (let P = 0; P < 3; P++)
            C[P] = 1 / 0, C[P + 3] = -1 / 0, E[P] = 1 / 0, E[P + 3] = -1 / 0, A[P] = 1 / 0, A[P + 3] = -1 / 0;
          tv(x, t, A);
        }
        _.sort(Y9);
        let w = n;
        for (let x = 0; x < w; x++) {
          const M = _[x];
          for (; x + 1 < w && _[x + 1].candidate === M.candidate; )
            _.splice(x + 1, 1), w--;
        }
        for (let x = u; x < h; x += 6) {
          const M = t[x + 2 * d];
          for (let A = 0; A < w; A++) {
            const E = _[A];
            M >= E.candidate ? tv(x, t, E.rightCacheBounds) : (tv(x, t, E.leftCacheBounds), E.count++);
          }
        }
        for (let x = 0; x < w; x++) {
          const M = _[x], A = M.count, E = n - M.count, C = M.leftCacheBounds, P = M.rightCacheBounds;
          let T = 0;
          A !== 0 && (T = xf(C) / l);
          let I = 0;
          E !== 0 && (I = xf(P) / l);
          const D = L2 + db * (T * A + I * E);
          D < c && (o = d, c = D, a = M.candidate);
        }
      } else {
        for (let w = 0; w < pa; w++) {
          const x = ol[w];
          x.count = 0, x.candidate = f + v + w * v;
          const M = x.bounds;
          for (let A = 0; A < 3; A++)
            M[A] = 1 / 0, M[A + 3] = -1 / 0;
        }
        for (let w = u; w < h; w += 6) {
          let A = ~~((t[w + 2 * d] - f) / v);
          A >= pa && (A = pa - 1);
          const E = ol[A];
          E.count++, tv(w, t, E.bounds);
        }
        const _ = ol[pa - 1];
        k2(_.bounds, _.rightCacheBounds);
        for (let w = pa - 2; w >= 0; w--) {
          const x = ol[w], M = ol[w + 1];
          O2(x.bounds, M.rightCacheBounds, x.rightCacheBounds);
        }
        let y = 0;
        for (let w = 0; w < pa - 1; w++) {
          const x = ol[w], M = x.count, A = x.bounds, C = ol[w + 1].rightCacheBounds;
          M !== 0 && (y === 0 ? k2(A, nv) : O2(A, nv, nv)), y += M;
          let P = 0, T = 0;
          y !== 0 && (P = xf(nv) / l);
          const I = n - y;
          I !== 0 && (T = xf(C) / l);
          const D = L2 + db * (P * y + T * I);
          D < c && (o = d, c = D, a = x.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);
  return { axis: o, pos: a };
}
function q9(s, e, t, i) {
  let n = 0;
  for (let r = e, o = e + t; r < o; r++)
    n += s[r * 6 + i * 2];
  return n / t;
}
class mb {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
}
function Z9(s, e, t, i, n, r) {
  let o = i, a = i + n - 1;
  const l = r.pos, c = r.axis * 2;
  for (; ; ) {
    for (; o <= a && t[o * 6 + c] < l; )
      o++;
    for (; o <= a && t[a * 6 + c] >= l; )
      a--;
    if (o < a) {
      for (let u = 0; u < 3; u++) {
        let h = e[o * 3 + u];
        e[o * 3 + u] = e[a * 3 + u], e[a * 3 + u] = h;
      }
      for (let u = 0; u < 6; u++) {
        let h = t[o * 6 + u];
        t[o * 6 + u] = t[a * 6 + u], t[a * 6 + u] = h;
      }
      o++, a--;
    } else
      return o;
  }
}
function K9(s, e, t, i, n, r) {
  let o = i, a = i + n - 1;
  const l = r.pos, c = r.axis * 2;
  for (; ; ) {
    for (; o <= a && t[o * 6 + c] < l; )
      o++;
    for (; o <= a && t[a * 6 + c] >= l; )
      a--;
    if (o < a) {
      let u = s[o];
      s[o] = s[a], s[a] = u;
      for (let h = 0; h < 6; h++) {
        let d = t[o * 6 + h];
        t[o * 6 + h] = t[a * 6 + h], t[a * 6 + h] = d;
      }
      o++, a--;
    } else
      return o;
  }
}
function Zr(s, e) {
  return e[s + 15] === 65535;
}
function os(s, e) {
  return e[s + 6];
}
function Cs(s, e) {
  return e[s + 14];
}
function eo(s) {
  return s + 8;
}
function Ps(s, e) {
  return e[s + 6];
}
function eM(s, e) {
  return e[s + 7];
}
let t3, zf, zv, n3;
const $9 = Math.pow(2, 32);
function U1(s) {
  return "count" in s ? 1 : 1 + U1(s.left) + U1(s.right);
}
function J9(s, e, t) {
  return t3 = new Float32Array(t), zf = new Uint32Array(t), zv = new Uint16Array(t), n3 = new Uint8Array(t), k1(s, e);
}
function k1(s, e) {
  const t = s / 4, i = s / 2, n = "count" in e, r = e.boundingData;
  for (let o = 0; o < 6; o++)
    t3[t + o] = r[o];
  if (n)
    if (e.buffer) {
      const o = e.buffer;
      n3.set(new Uint8Array(o), s);
      for (let a = s, l = s + o.byteLength; a < l; a += Al) {
        const c = a / 2;
        Zr(c, zv) || (zf[a / 4 + 6] += t);
      }
      return s + o.byteLength;
    } else {
      const o = e.offset, a = e.count;
      return zf[t + 6] = o, zv[i + 14] = a, zv[i + 15] = ay, s + Al;
    }
  else {
    const o = e.left, a = e.right, l = e.splitAxis;
    let c;
    if (c = k1(s + Al, o), c / 4 > $9)
      throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
    return zf[t + 6] = c / 4, c = k1(c, a), zf[t + 7] = l, c;
  }
}
function Q9(s, e) {
  const t = (s.index ? s.index.count : s.attributes.position.count) / 3, i = t > 2 ** 16, n = i ? 4 : 2, r = e ? new SharedArrayBuffer(t * n) : new ArrayBuffer(t * n), o = i ? new Uint32Array(r) : new Uint16Array(r);
  for (let a = 0, l = o.length; a < l; a++)
    o[a] = a;
  return o;
}
function eY(s, e, t, i, n) {
  const {
    maxDepth: r,
    verbose: o,
    maxLeafTris: a,
    strategy: l,
    onProgress: c,
    indirect: u
  } = n, h = s._indirectBuffer, d = s.geometry, f = d.index ? d.index.array : null, m = u ? K9 : Z9, g = Dd(d), v = new Float32Array(6);
  let _ = !1;
  const y = new mb();
  return pb(e, t, i, y.boundingData, v), x(y, t, i, v), y;
  function w(M) {
    c && c(M / g);
  }
  function x(M, A, E, C = null, P = 0) {
    if (!_ && P >= r && (_ = !0, o && (console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`), console.warn(d))), E <= a || P >= r)
      return w(A + E), M.offset = A, M.count = E, M;
    const T = j9(M.boundingData, C, e, A, E, l);
    if (T.axis === -1)
      return w(A + E), M.offset = A, M.count = E, M;
    const I = m(h, f, e, A, E, T);
    if (I === A || I === A + E)
      w(A + E), M.offset = A, M.count = E;
    else {
      M.splitAxis = T.axis;
      const D = new mb(), U = A, L = I - A;
      M.left = D, pb(e, U, L, D.boundingData, v), x(D, U, L, v, P + 1);
      const k = new mb(), B = I, j = E - L;
      M.right = k, pb(e, B, j, k.boundingData, v), x(k, B, j, v, P + 1);
    }
    return M;
  }
}
function tY(s, e) {
  const t = s.geometry;
  e.indirect && (s._indirectBuffer = Q9(t, e.useSharedArrayBuffer), W9(t, e.range) && !e.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), s._indirectBuffer || H9(t, e);
  const i = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, n = X9(t), r = e.indirect ? QL(t, e.range) : e3(t, e.range);
  s._roots = r.map((o) => {
    const a = eY(s, n, o.offset, o.count, e), l = U1(a), c = new i(Al * l);
    return J9(0, a, c), c;
  });
}
class La {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(e, t) {
    let i = 1 / 0, n = -1 / 0;
    for (let r = 0, o = e.length; r < o; r++) {
      const l = e[r][t];
      i = l < i ? l : i, n = l > n ? l : n;
    }
    this.min = i, this.max = n;
  }
  setFromPoints(e, t) {
    let i = 1 / 0, n = -1 / 0;
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = e.dot(a);
      i = l < i ? l : i, n = l > n ? l : n;
    }
    this.min = i, this.max = n;
  }
  isSeparated(e) {
    return this.min > e.max || e.min > this.max;
  }
}
La.prototype.setFromBox = function() {
  const s = new H();
  return function(t, i) {
    const n = i.min, r = i.max;
    let o = 1 / 0, a = -1 / 0;
    for (let l = 0; l <= 1; l++)
      for (let c = 0; c <= 1; c++)
        for (let u = 0; u <= 1; u++) {
          s.x = n.x * l + r.x * (1 - l), s.y = n.y * c + r.y * (1 - c), s.z = n.z * u + r.z * (1 - u);
          const h = t.dot(s);
          o = Math.min(h, o), a = Math.max(h, a);
        }
    this.min = o, this.max = a;
  };
}();
const nY = function() {
  const s = new H(), e = new H(), t = new H();
  return function(n, r, o) {
    const a = n.start, l = s, c = r.start, u = e;
    t.subVectors(a, c), s.subVectors(n.end, n.start), e.subVectors(r.end, r.start);
    const h = t.dot(u), d = u.dot(l), f = u.dot(u), m = t.dot(l), v = l.dot(l) * f - d * d;
    let _, y;
    v !== 0 ? _ = (h * d - m * f) / v : _ = 0, y = (h + _ * d) / f, o.x = _, o.y = y;
  };
}(), tM = function() {
  const s = new Be(), e = new H(), t = new H();
  return function(n, r, o, a) {
    nY(n, r, s);
    let l = s.x, c = s.y;
    if (l >= 0 && l <= 1 && c >= 0 && c <= 1) {
      n.at(l, o), r.at(c, a);
      return;
    } else if (l >= 0 && l <= 1) {
      c < 0 ? r.at(0, a) : r.at(1, a), n.closestPointToPoint(a, !0, o);
      return;
    } else if (c >= 0 && c <= 1) {
      l < 0 ? n.at(0, o) : n.at(1, o), r.closestPointToPoint(o, !0, a);
      return;
    } else {
      let u;
      l < 0 ? u = n.start : u = n.end;
      let h;
      c < 0 ? h = r.start : h = r.end;
      const d = e, f = t;
      if (n.closestPointToPoint(h, !0, e), r.closestPointToPoint(u, !0, t), d.distanceToSquared(h) <= f.distanceToSquared(u)) {
        o.copy(d), a.copy(h);
        return;
      } else {
        o.copy(u), a.copy(f);
        return;
      }
    }
  };
}(), iY = function() {
  const s = new H(), e = new H(), t = new $s(), i = new xo();
  return function(r, o) {
    const { radius: a, center: l } = r, { a: c, b: u, c: h } = o;
    if (i.start = c, i.end = u, i.closestPointToPoint(l, !0, s).distanceTo(l) <= a || (i.start = c, i.end = h, i.closestPointToPoint(l, !0, s).distanceTo(l) <= a) || (i.start = u, i.end = h, i.closestPointToPoint(l, !0, s).distanceTo(l) <= a)) return !0;
    const g = o.getPlane(t);
    if (Math.abs(g.distanceToPoint(l)) <= a) {
      const _ = g.projectPoint(l, e);
      if (o.containsPoint(_)) return !0;
    }
    return !1;
  };
}(), rY = 1e-15;
function gb(s) {
  return Math.abs(s) < rY;
}
class wo extends Xi {
  constructor(...e) {
    super(...e), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new H()), this.satBounds = new Array(4).fill().map(() => new La()), this.points = [this.a, this.b, this.c], this.sphere = new fi(), this.plane = new $s(), this.needsUpdate = !0;
  }
  intersectsSphere(e) {
    return iY(e, this);
  }
  update() {
    const e = this.a, t = this.b, i = this.c, n = this.points, r = this.satAxes, o = this.satBounds, a = r[0], l = o[0];
    this.getNormal(a), l.setFromPoints(a, n);
    const c = r[1], u = o[1];
    c.subVectors(e, t), u.setFromPoints(c, n);
    const h = r[2], d = o[2];
    h.subVectors(t, i), d.setFromPoints(h, n);
    const f = r[3], m = o[3];
    f.subVectors(i, e), m.setFromPoints(f, n), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(a, e), this.needsUpdate = !1;
  }
}
wo.prototype.closestPointToSegment = function() {
  const s = new H(), e = new H(), t = new xo();
  return function(n, r = null, o = null) {
    const { start: a, end: l } = n, c = this.points;
    let u, h = 1 / 0;
    for (let d = 0; d < 3; d++) {
      const f = (d + 1) % 3;
      t.start.copy(c[d]), t.end.copy(c[f]), tM(t, n, s, e), u = s.distanceToSquared(e), u < h && (h = u, r && r.copy(s), o && o.copy(e));
    }
    return this.closestPointToPoint(a, s), u = a.distanceToSquared(s), u < h && (h = u, r && r.copy(s), o && o.copy(a)), this.closestPointToPoint(l, s), u = l.distanceToSquared(s), u < h && (h = u, r && r.copy(s), o && o.copy(l)), Math.sqrt(h);
  };
}();
wo.prototype.intersectsTriangle = function() {
  const s = new wo(), e = new Array(3), t = new Array(3), i = new La(), n = new La(), r = new H(), o = new H(), a = new H(), l = new H(), c = new H(), u = new xo(), h = new xo(), d = new xo(), f = new H();
  function m(g, v, _) {
    const y = g.points;
    let w = 0, x = -1;
    for (let M = 0; M < 3; M++) {
      const { start: A, end: E } = u;
      A.copy(y[M]), E.copy(y[(M + 1) % 3]), u.delta(o);
      const C = gb(v.distanceToPoint(A));
      if (gb(v.normal.dot(o)) && C) {
        _.copy(u), w = 2;
        break;
      }
      const P = v.intersectLine(u, f);
      if (!P && C && f.copy(A), (P || C) && !gb(f.distanceTo(E))) {
        if (w <= 1)
          (w === 1 ? _.start : _.end).copy(f), C && (x = w);
        else if (w >= 2) {
          (x === 1 ? _.start : _.end).copy(f), w = 2;
          break;
        }
        if (w++, w === 2 && x === -1)
          break;
      }
    }
    return w;
  }
  return function(v, _ = null, y = !1) {
    this.needsUpdate && this.update(), v.isExtendedTriangle ? v.needsUpdate && v.update() : (s.copy(v), s.update(), v = s);
    const w = this.plane, x = v.plane;
    if (Math.abs(w.normal.dot(x.normal)) > 1 - 1e-10) {
      const M = this.satBounds, A = this.satAxes;
      t[0] = v.a, t[1] = v.b, t[2] = v.c;
      for (let P = 0; P < 4; P++) {
        const T = M[P], I = A[P];
        if (i.setFromPoints(I, t), T.isSeparated(i)) return !1;
      }
      const E = v.satBounds, C = v.satAxes;
      e[0] = this.a, e[1] = this.b, e[2] = this.c;
      for (let P = 0; P < 4; P++) {
        const T = E[P], I = C[P];
        if (i.setFromPoints(I, e), T.isSeparated(i)) return !1;
      }
      for (let P = 0; P < 4; P++) {
        const T = A[P];
        for (let I = 0; I < 4; I++) {
          const D = C[I];
          if (r.crossVectors(T, D), i.setFromPoints(r, e), n.setFromPoints(r, t), i.isSeparated(n)) return !1;
        }
      }
      return _ && (y || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), _.start.set(0, 0, 0), _.end.set(0, 0, 0)), !0;
    } else {
      const M = m(this, x, h);
      if (M === 1 && v.containsPoint(h.end))
        return _ && (_.start.copy(h.end), _.end.copy(h.end)), !0;
      if (M !== 2)
        return !1;
      const A = m(v, w, d);
      if (A === 1 && this.containsPoint(d.end))
        return _ && (_.start.copy(d.end), _.end.copy(d.end)), !0;
      if (A !== 2)
        return !1;
      if (h.delta(a), d.delta(l), a.dot(l) < 0) {
        let U = d.start;
        d.start = d.end, d.end = U;
      }
      const E = h.start.dot(a), C = h.end.dot(a), P = d.start.dot(a), T = d.end.dot(a), I = C < P, D = E < T;
      return E !== T && P !== C && I === D ? !1 : (_ && (c.subVectors(h.start, d.start), c.dot(a) > 0 ? _.start.copy(h.start) : _.start.copy(d.start), c.subVectors(h.end, d.end), c.dot(a) < 0 ? _.end.copy(h.end) : _.end.copy(d.end)), !0);
    }
  };
}();
wo.prototype.distanceToPoint = function() {
  const s = new H();
  return function(t) {
    return this.closestPointToPoint(t, s), t.distanceTo(s);
  };
}();
wo.prototype.distanceToTriangle = function() {
  const s = new H(), e = new H(), t = ["a", "b", "c"], i = new xo(), n = new xo();
  return function(o, a = null, l = null) {
    const c = a || l ? i : null;
    if (this.intersectsTriangle(o, c))
      return (a || l) && (a && c.getCenter(a), l && c.getCenter(l)), 0;
    let u = 1 / 0;
    for (let h = 0; h < 3; h++) {
      let d;
      const f = t[h], m = o[f];
      this.closestPointToPoint(m, s), d = m.distanceToSquared(s), d < u && (u = d, a && a.copy(s), l && l.copy(m));
      const g = this[f];
      o.closestPointToPoint(g, s), d = g.distanceToSquared(s), d < u && (u = d, a && a.copy(g), l && l.copy(s));
    }
    for (let h = 0; h < 3; h++) {
      const d = t[h], f = t[(h + 1) % 3];
      i.set(this[d], this[f]);
      for (let m = 0; m < 3; m++) {
        const g = t[m], v = t[(m + 1) % 3];
        n.set(o[g], o[v]), tM(i, n, s, e);
        const _ = s.distanceToSquared(e);
        _ < u && (u = _, a && a.copy(s), l && l.copy(e));
      }
    }
    return Math.sqrt(u);
  };
}();
class Jr {
  constructor(e, t, i) {
    this.isOrientedBox = !0, this.min = new H(), this.max = new H(), this.matrix = new _t(), this.invMatrix = new _t(), this.points = new Array(8).fill().map(() => new H()), this.satAxes = new Array(3).fill().map(() => new H()), this.satBounds = new Array(3).fill().map(() => new La()), this.alignedSatBounds = new Array(3).fill().map(() => new La()), this.needsUpdate = !1, e && this.min.copy(e), t && this.max.copy(t), i && this.matrix.copy(i);
  }
  set(e, t, i) {
    this.min.copy(e), this.max.copy(t), this.matrix.copy(i), this.needsUpdate = !0;
  }
  copy(e) {
    this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = !0;
  }
}
Jr.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const e = this.matrix, t = this.min, i = this.max, n = this.points;
    for (let c = 0; c <= 1; c++)
      for (let u = 0; u <= 1; u++)
        for (let h = 0; h <= 1; h++) {
          const d = 1 * c | 2 * u | 4 * h, f = n[d];
          f.x = c ? i.x : t.x, f.y = u ? i.y : t.y, f.z = h ? i.z : t.z, f.applyMatrix4(e);
        }
    const r = this.satBounds, o = this.satAxes, a = n[0];
    for (let c = 0; c < 3; c++) {
      const u = o[c], h = r[c], d = 1 << c, f = n[d];
      u.subVectors(a, f), h.setFromPoints(u, n);
    }
    const l = this.alignedSatBounds;
    l[0].setFromPointsField(n, "x"), l[1].setFromPointsField(n, "y"), l[2].setFromPointsField(n, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  };
}();
Jr.prototype.intersectsBox = function() {
  const s = new La();
  return function(t) {
    this.needsUpdate && this.update();
    const i = t.min, n = t.max, r = this.satBounds, o = this.satAxes, a = this.alignedSatBounds;
    if (s.min = i.x, s.max = n.x, a[0].isSeparated(s) || (s.min = i.y, s.max = n.y, a[1].isSeparated(s)) || (s.min = i.z, s.max = n.z, a[2].isSeparated(s))) return !1;
    for (let l = 0; l < 3; l++) {
      const c = o[l], u = r[l];
      if (s.setFromBox(c, t), u.isSeparated(s)) return !1;
    }
    return !0;
  };
}();
Jr.prototype.intersectsTriangle = function() {
  const s = new wo(), e = new Array(3), t = new La(), i = new La(), n = new H();
  return function(o) {
    this.needsUpdate && this.update(), o.isExtendedTriangle ? o.needsUpdate && o.update() : (s.copy(o), s.update(), o = s);
    const a = this.satBounds, l = this.satAxes;
    e[0] = o.a, e[1] = o.b, e[2] = o.c;
    for (let d = 0; d < 3; d++) {
      const f = a[d], m = l[d];
      if (t.setFromPoints(m, e), f.isSeparated(t)) return !1;
    }
    const c = o.satBounds, u = o.satAxes, h = this.points;
    for (let d = 0; d < 3; d++) {
      const f = c[d], m = u[d];
      if (t.setFromPoints(m, h), f.isSeparated(t)) return !1;
    }
    for (let d = 0; d < 3; d++) {
      const f = l[d];
      for (let m = 0; m < 4; m++) {
        const g = u[m];
        if (n.crossVectors(f, g), t.setFromPoints(n, e), i.setFromPoints(n, h), t.isSeparated(i)) return !1;
      }
    }
    return !0;
  };
}();
Jr.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(e, t) {
    return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
Jr.prototype.distanceToPoint = function() {
  const s = new H();
  return function(t) {
    return this.closestPointToPoint(t, s), t.distanceTo(s);
  };
}();
Jr.prototype.distanceToBox = function() {
  const s = ["x", "y", "z"], e = new Array(12).fill().map(() => new xo()), t = new Array(12).fill().map(() => new xo()), i = new H(), n = new H();
  return function(o, a = 0, l = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(o))
      return (l || c) && (o.getCenter(n), this.closestPointToPoint(n, i), o.closestPointToPoint(i, n), l && l.copy(i), c && c.copy(n)), 0;
    const u = a * a, h = o.min, d = o.max, f = this.points;
    let m = 1 / 0;
    for (let v = 0; v < 8; v++) {
      const _ = f[v];
      n.copy(_).clamp(h, d);
      const y = _.distanceToSquared(n);
      if (y < m && (m = y, l && l.copy(_), c && c.copy(n), y < u))
        return Math.sqrt(y);
    }
    let g = 0;
    for (let v = 0; v < 3; v++)
      for (let _ = 0; _ <= 1; _++)
        for (let y = 0; y <= 1; y++) {
          const w = (v + 1) % 3, x = (v + 2) % 3, M = _ << w | y << x, A = 1 << v | _ << w | y << x, E = f[M], C = f[A];
          e[g].set(E, C);
          const T = s[v], I = s[w], D = s[x], U = t[g], L = U.start, k = U.end;
          L[T] = h[T], L[I] = _ ? h[I] : d[I], L[D] = y ? h[D] : d[I], k[T] = d[T], k[I] = _ ? h[I] : d[I], k[D] = y ? h[D] : d[I], g++;
        }
    for (let v = 0; v <= 1; v++)
      for (let _ = 0; _ <= 1; _++)
        for (let y = 0; y <= 1; y++) {
          n.x = v ? d.x : h.x, n.y = _ ? d.y : h.y, n.z = y ? d.z : h.z, this.closestPointToPoint(n, i);
          const w = n.distanceToSquared(i);
          if (w < m && (m = w, l && l.copy(i), c && c.copy(n), w < u))
            return Math.sqrt(w);
        }
    for (let v = 0; v < 12; v++) {
      const _ = e[v];
      for (let y = 0; y < 12; y++) {
        const w = t[y];
        tM(_, w, i, n);
        const x = i.distanceToSquared(n);
        if (x < m && (m = x, l && l.copy(i), c && c.copy(n), x < u))
          return Math.sqrt(x);
      }
    }
    return Math.sqrt(m);
  };
}();
class nM {
  constructor(e) {
    this._getNewPrimitive = e, this._primitives = [];
  }
  getPrimitive() {
    const e = this._primitives;
    return e.length === 0 ? this._getNewPrimitive() : e.pop();
  }
  releasePrimitive(e) {
    this._primitives.push(e);
  }
}
class sY extends nM {
  constructor() {
    super(() => new wo());
  }
}
const to = /* @__PURE__ */ new sY();
class oY {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const e = [];
    let t = null;
    this.setBuffer = (i) => {
      t && e.push(t), t = i, this.float32Array = new Float32Array(i), this.uint16Array = new Uint16Array(i), this.uint32Array = new Uint32Array(i);
    }, this.clearBuffer = () => {
      t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, e.length !== 0 && this.setBuffer(e.pop());
    };
  }
}
const ai = new oY();
let xl, Fh;
const mh = [], iv = /* @__PURE__ */ new nM(() => new yn());
function aY(s, e, t, i, n, r) {
  xl = iv.getPrimitive(), Fh = iv.getPrimitive(), mh.push(xl, Fh), ai.setBuffer(s._roots[e]);
  const o = O1(0, s.geometry, t, i, n, r);
  ai.clearBuffer(), iv.releasePrimitive(xl), iv.releasePrimitive(Fh), mh.pop(), mh.pop();
  const a = mh.length;
  return a > 0 && (Fh = mh[a - 1], xl = mh[a - 2]), o;
}
function O1(s, e, t, i, n = null, r = 0, o = 0) {
  const { float32Array: a, uint16Array: l, uint32Array: c } = ai;
  let u = s * 2;
  if (Zr(u, l)) {
    const d = os(s, c), f = Cs(u, l);
    return bi(s, a, xl), i(d, f, !1, o, r + s, xl);
  } else {
    let T = function(D) {
      const { uint16Array: U, uint32Array: L } = ai;
      let k = D * 2;
      for (; !Zr(k, U); )
        D = eo(D), k = D * 2;
      return os(D, L);
    }, I = function(D) {
      const { uint16Array: U, uint32Array: L } = ai;
      let k = D * 2;
      for (; !Zr(k, U); )
        D = Ps(D, L), k = D * 2;
      return os(D, L) + Cs(k, U);
    };
    const d = eo(s), f = Ps(s, c);
    let m = d, g = f, v, _, y, w;
    if (n && (y = xl, w = Fh, bi(m, a, y), bi(g, a, w), v = n(y), _ = n(w), _ < v)) {
      m = f, g = d;
      const D = v;
      v = _, _ = D, y = w;
    }
    y || (y = xl, bi(m, a, y));
    const x = Zr(m * 2, l), M = t(y, x, v, o + 1, r + m);
    let A;
    if (M === I2) {
      const D = T(m), L = I(m) - D;
      A = i(D, L, !0, o + 1, r + m, y);
    } else
      A = M && O1(
        m,
        e,
        t,
        i,
        n,
        r,
        o + 1
      );
    if (A) return !0;
    w = Fh, bi(g, a, w);
    const E = Zr(g * 2, l), C = t(w, E, _, o + 1, r + g);
    let P;
    if (C === I2) {
      const D = T(g), L = I(g) - D;
      P = i(D, L, !0, o + 1, r + g, w);
    } else
      P = C && O1(
        g,
        e,
        t,
        i,
        n,
        r,
        o + 1
      );
    return !!P;
  }
}
const bf = /* @__PURE__ */ new H(), vb = /* @__PURE__ */ new H();
function lY(s, e, t = {}, i = 0, n = 1 / 0) {
  const r = i * i, o = n * n;
  let a = 1 / 0, l = null;
  if (s.shapecast(
    {
      boundsTraverseOrder: (u) => (bf.copy(e).clamp(u.min, u.max), bf.distanceToSquared(e)),
      intersectsBounds: (u, h, d) => d < a && d < o,
      intersectsTriangle: (u, h) => {
        u.closestPointToPoint(e, bf);
        const d = e.distanceToSquared(bf);
        return d < a && (vb.copy(bf), a = d, l = h), d < r;
      }
    }
  ), a === 1 / 0) return null;
  const c = Math.sqrt(a);
  return t.point ? t.point.copy(vb) : t.point = vb.clone(), t.distance = c, t.faceIndex = l, t;
}
const gh = /* @__PURE__ */ new H(), vh = /* @__PURE__ */ new H(), _h = /* @__PURE__ */ new H(), rv = /* @__PURE__ */ new Be(), sv = /* @__PURE__ */ new Be(), ov = /* @__PURE__ */ new Be(), F2 = /* @__PURE__ */ new H(), N2 = /* @__PURE__ */ new H(), B2 = /* @__PURE__ */ new H(), av = /* @__PURE__ */ new H();
function cY(s, e, t, i, n, r, o, a) {
  let l;
  if (r === Yi ? l = s.intersectTriangle(i, t, e, !0, n) : l = s.intersectTriangle(e, t, i, r !== wi, n), l === null) return null;
  const c = s.origin.distanceTo(n);
  return c < o || c > a ? null : {
    distance: c,
    point: n.clone()
  };
}
function uY(s, e, t, i, n, r, o, a, l, c, u) {
  gh.fromBufferAttribute(e, r), vh.fromBufferAttribute(e, o), _h.fromBufferAttribute(e, a);
  const h = cY(s, gh, vh, _h, av, l, c, u);
  if (h) {
    i && (rv.fromBufferAttribute(i, r), sv.fromBufferAttribute(i, o), ov.fromBufferAttribute(i, a), h.uv = Xi.getInterpolation(av, gh, vh, _h, rv, sv, ov, new Be())), n && (rv.fromBufferAttribute(n, r), sv.fromBufferAttribute(n, o), ov.fromBufferAttribute(n, a), h.uv1 = Xi.getInterpolation(av, gh, vh, _h, rv, sv, ov, new Be())), t && (F2.fromBufferAttribute(t, r), N2.fromBufferAttribute(t, o), B2.fromBufferAttribute(t, a), h.normal = Xi.getInterpolation(av, gh, vh, _h, F2, N2, B2, new H()), h.normal.dot(s.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = {
      a: r,
      b: o,
      c: a,
      normal: new H(),
      materialIndex: 0
    };
    Xi.getNormal(gh, vh, _h, d.normal), h.face = d, h.faceIndex = r;
  }
  return h;
}
function ly(s, e, t, i, n, r, o) {
  const a = i * 3;
  let l = a + 0, c = a + 1, u = a + 2;
  const h = s.index;
  s.index && (l = h.getX(l), c = h.getX(c), u = h.getX(u));
  const { position: d, normal: f, uv: m, uv1: g } = s.attributes, v = uY(t, d, f, m, g, l, c, u, e, r, o);
  return v ? (v.faceIndex = i, n && n.push(v), v) : null;
}
function Ni(s, e, t, i) {
  const n = s.a, r = s.b, o = s.c;
  let a = e, l = e + 1, c = e + 2;
  t && (a = t.getX(a), l = t.getX(l), c = t.getX(c)), n.x = i.getX(a), n.y = i.getY(a), n.z = i.getZ(a), r.x = i.getX(l), r.y = i.getY(l), r.z = i.getZ(l), o.x = i.getX(c), o.y = i.getY(c), o.z = i.getZ(c);
}
function hY(s, e, t, i, n, r, o, a) {
  const { geometry: l, _indirectBuffer: c } = s;
  for (let u = i, h = i + n; u < h; u++)
    ly(l, e, t, u, r, o, a);
}
function dY(s, e, t, i, n, r, o) {
  const { geometry: a, _indirectBuffer: l } = s;
  let c = 1 / 0, u = null;
  for (let h = i, d = i + n; h < d; h++) {
    let f;
    f = ly(a, e, t, h, null, r, o), f && f.distance < c && (u = f, c = f.distance);
  }
  return u;
}
function fY(s, e, t, i, n, r, o) {
  const { geometry: a } = t, { index: l } = a, c = a.attributes.position;
  for (let u = s, h = e + s; u < h; u++) {
    let d;
    if (d = u, Ni(o, d * 3, l, c), o.needsUpdate = !0, i(o, d, n, r))
      return !0;
  }
  return !1;
}
function pY(s, e = null) {
  e && Array.isArray(e) && (e = new Set(e));
  const t = s.geometry, i = t.index ? t.index.array : null, n = t.attributes.position;
  let r, o, a, l, c = 0;
  const u = s._roots;
  for (let d = 0, f = u.length; d < f; d++)
    r = u[d], o = new Uint32Array(r), a = new Uint16Array(r), l = new Float32Array(r), h(0, c), c += r.byteLength;
  function h(d, f, m = !1) {
    const g = d * 2;
    if (a[g + 15] === ay) {
      const _ = o[d + 6], y = a[g + 14];
      let w = 1 / 0, x = 1 / 0, M = 1 / 0, A = -1 / 0, E = -1 / 0, C = -1 / 0;
      for (let P = 3 * _, T = 3 * (_ + y); P < T; P++) {
        let I = i[P];
        const D = n.getX(I), U = n.getY(I), L = n.getZ(I);
        D < w && (w = D), D > A && (A = D), U < x && (x = U), U > E && (E = U), L < M && (M = L), L > C && (C = L);
      }
      return l[d + 0] !== w || l[d + 1] !== x || l[d + 2] !== M || l[d + 3] !== A || l[d + 4] !== E || l[d + 5] !== C ? (l[d + 0] = w, l[d + 1] = x, l[d + 2] = M, l[d + 3] = A, l[d + 4] = E, l[d + 5] = C, !0) : !1;
    } else {
      const _ = d + 8, y = o[d + 6], w = _ + f, x = y + f;
      let M = m, A = !1, E = !1;
      e ? M || (A = e.has(w), E = e.has(x), M = !A && !E) : (A = !0, E = !0);
      const C = M || A, P = M || E;
      let T = !1;
      C && (T = h(_, f, M));
      let I = !1;
      P && (I = h(y, f, M));
      const D = T || I;
      if (D)
        for (let U = 0; U < 3; U++) {
          const L = _ + U, k = y + U, B = l[L], j = l[L + 3], q = l[k], Z = l[k + 3];
          l[d + U] = B < q ? B : q, l[d + U + 3] = j > Z ? j : Z;
        }
      return D;
    }
  }
}
function Ll(s, e, t, i, n) {
  let r, o, a, l, c, u;
  const h = 1 / t.direction.x, d = 1 / t.direction.y, f = 1 / t.direction.z, m = t.origin.x, g = t.origin.y, v = t.origin.z;
  let _ = e[s], y = e[s + 3], w = e[s + 1], x = e[s + 3 + 1], M = e[s + 2], A = e[s + 3 + 2];
  return h >= 0 ? (r = (_ - m) * h, o = (y - m) * h) : (r = (y - m) * h, o = (_ - m) * h), d >= 0 ? (a = (w - g) * d, l = (x - g) * d) : (a = (x - g) * d, l = (w - g) * d), r > l || a > o || ((a > r || isNaN(r)) && (r = a), (l < o || isNaN(o)) && (o = l), f >= 0 ? (c = (M - v) * f, u = (A - v) * f) : (c = (A - v) * f, u = (M - v) * f), r > u || c > o) ? !1 : ((c > r || r !== r) && (r = c), (u < o || o !== o) && (o = u), r <= n && o >= i);
}
function mY(s, e, t, i, n, r, o, a) {
  const { geometry: l, _indirectBuffer: c } = s;
  for (let u = i, h = i + n; u < h; u++) {
    let d = c ? c[u] : u;
    ly(l, e, t, d, r, o, a);
  }
}
function gY(s, e, t, i, n, r, o) {
  const { geometry: a, _indirectBuffer: l } = s;
  let c = 1 / 0, u = null;
  for (let h = i, d = i + n; h < d; h++) {
    let f;
    f = ly(a, e, t, l ? l[h] : h, null, r, o), f && f.distance < c && (u = f, c = f.distance);
  }
  return u;
}
function vY(s, e, t, i, n, r, o) {
  const { geometry: a } = t, { index: l } = a, c = a.attributes.position;
  for (let u = s, h = e + s; u < h; u++) {
    let d;
    if (d = t.resolveTriangleIndex(u), Ni(o, d * 3, l, c), o.needsUpdate = !0, i(o, d, n, r))
      return !0;
  }
  return !1;
}
function _Y(s, e, t, i, n, r, o) {
  ai.setBuffer(s._roots[e]), F1(0, s, t, i, n, r, o), ai.clearBuffer();
}
function F1(s, e, t, i, n, r, o) {
  const { float32Array: a, uint16Array: l, uint32Array: c } = ai, u = s * 2;
  if (Zr(u, l)) {
    const d = os(s, c), f = Cs(u, l);
    hY(e, t, i, d, f, n, r, o);
  } else {
    const d = eo(s);
    Ll(d, a, i, r, o) && F1(d, e, t, i, n, r, o);
    const f = Ps(s, c);
    Ll(f, a, i, r, o) && F1(f, e, t, i, n, r, o);
  }
}
const yY = ["x", "y", "z"];
function xY(s, e, t, i, n, r) {
  ai.setBuffer(s._roots[e]);
  const o = N1(0, s, t, i, n, r);
  return ai.clearBuffer(), o;
}
function N1(s, e, t, i, n, r) {
  const { float32Array: o, uint16Array: a, uint32Array: l } = ai;
  let c = s * 2;
  if (Zr(c, a)) {
    const h = os(s, l), d = Cs(c, a);
    return dY(e, t, i, h, d, n, r);
  } else {
    const h = eM(s, l), d = yY[h], m = i.direction[d] >= 0;
    let g, v;
    m ? (g = eo(s), v = Ps(s, l)) : (g = Ps(s, l), v = eo(s));
    const y = Ll(g, o, i, n, r) ? N1(g, e, t, i, n, r) : null;
    if (y) {
      const M = y.point[d];
      if (m ? M <= o[v + h] : (
        // min bounding data
        M >= o[v + h + 3]
      ))
        return y;
    }
    const x = Ll(v, o, i, n, r) ? N1(v, e, t, i, n, r) : null;
    return y && x ? y.distance <= x.distance ? y : x : y || x || null;
  }
}
const lv = /* @__PURE__ */ new yn(), yh = /* @__PURE__ */ new wo(), xh = /* @__PURE__ */ new wo(), wf = /* @__PURE__ */ new _t(), z2 = /* @__PURE__ */ new Jr(), cv = /* @__PURE__ */ new Jr();
function bY(s, e, t, i) {
  ai.setBuffer(s._roots[e]);
  const n = B1(0, s, t, i);
  return ai.clearBuffer(), n;
}
function B1(s, e, t, i, n = null) {
  const { float32Array: r, uint16Array: o, uint32Array: a } = ai;
  let l = s * 2;
  if (n === null && (t.boundingBox || t.computeBoundingBox(), z2.set(t.boundingBox.min, t.boundingBox.max, i), n = z2), Zr(l, o)) {
    const u = e.geometry, h = u.index, d = u.attributes.position, f = t.index, m = t.attributes.position, g = os(s, a), v = Cs(l, o);
    if (wf.copy(i).invert(), t.boundsTree)
      return bi(s, r, cv), cv.matrix.copy(wf), cv.needsUpdate = !0, t.boundsTree.shapecast({
        intersectsBounds: (y) => cv.intersectsBox(y),
        intersectsTriangle: (y) => {
          y.a.applyMatrix4(i), y.b.applyMatrix4(i), y.c.applyMatrix4(i), y.needsUpdate = !0;
          for (let w = g * 3, x = (v + g) * 3; w < x; w += 3)
            if (Ni(xh, w, h, d), xh.needsUpdate = !0, y.intersectsTriangle(xh))
              return !0;
          return !1;
        }
      });
    for (let _ = g * 3, y = (v + g) * 3; _ < y; _ += 3) {
      Ni(yh, _, h, d), yh.a.applyMatrix4(wf), yh.b.applyMatrix4(wf), yh.c.applyMatrix4(wf), yh.needsUpdate = !0;
      for (let w = 0, x = f.count; w < x; w += 3)
        if (Ni(xh, w, f, m), xh.needsUpdate = !0, yh.intersectsTriangle(xh))
          return !0;
    }
  } else {
    const u = s + 8, h = a[s + 6];
    return bi(u, r, lv), !!(n.intersectsBox(lv) && B1(u, e, t, i, n) || (bi(h, r, lv), n.intersectsBox(lv) && B1(h, e, t, i, n)));
  }
}
const uv = /* @__PURE__ */ new _t(), _b = /* @__PURE__ */ new Jr(), Sf = /* @__PURE__ */ new Jr(), wY = /* @__PURE__ */ new H(), SY = /* @__PURE__ */ new H(), MY = /* @__PURE__ */ new H(), EY = /* @__PURE__ */ new H();
function TY(s, e, t, i = {}, n = {}, r = 0, o = 1 / 0) {
  e.boundingBox || e.computeBoundingBox(), _b.set(e.boundingBox.min, e.boundingBox.max, t), _b.needsUpdate = !0;
  const a = s.geometry, l = a.attributes.position, c = a.index, u = e.attributes.position, h = e.index, d = to.getPrimitive(), f = to.getPrimitive();
  let m = wY, g = SY, v = null, _ = null;
  n && (v = MY, _ = EY);
  let y = 1 / 0, w = null, x = null;
  return uv.copy(t).invert(), Sf.matrix.copy(uv), s.shapecast(
    {
      boundsTraverseOrder: (M) => _b.distanceToBox(M),
      intersectsBounds: (M, A, E) => E < y && E < o ? (A && (Sf.min.copy(M.min), Sf.max.copy(M.max), Sf.needsUpdate = !0), !0) : !1,
      intersectsRange: (M, A) => {
        if (e.boundsTree)
          return e.boundsTree.shapecast({
            boundsTraverseOrder: (C) => Sf.distanceToBox(C),
            intersectsBounds: (C, P, T) => T < y && T < o,
            intersectsRange: (C, P) => {
              for (let T = C, I = C + P; T < I; T++) {
                Ni(f, 3 * T, h, u), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
                for (let D = M, U = M + A; D < U; D++) {
                  Ni(d, 3 * D, c, l), d.needsUpdate = !0;
                  const L = d.distanceToTriangle(f, m, v);
                  if (L < y && (g.copy(m), _ && _.copy(v), y = L, w = D, x = T), L < r)
                    return !0;
                }
              }
            }
          });
        {
          const E = Dd(e);
          for (let C = 0, P = E; C < P; C++) {
            Ni(f, 3 * C, h, u), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
            for (let T = M, I = M + A; T < I; T++) {
              Ni(d, 3 * T, c, l), d.needsUpdate = !0;
              const D = d.distanceToTriangle(f, m, v);
              if (D < y && (g.copy(m), _ && _.copy(v), y = D, w = T, x = C), D < r)
                return !0;
            }
          }
        }
      }
    }
  ), to.releasePrimitive(d), to.releasePrimitive(f), y === 1 / 0 ? null : (i.point ? i.point.copy(g) : i.point = g.clone(), i.distance = y, i.faceIndex = w, n && (n.point ? n.point.copy(_) : n.point = _.clone(), n.point.applyMatrix4(uv), g.applyMatrix4(uv), n.distance = g.sub(n.point).length(), n.faceIndex = x), i);
}
function AY(s, e = null) {
  e && Array.isArray(e) && (e = new Set(e));
  const t = s.geometry, i = t.index ? t.index.array : null, n = t.attributes.position;
  let r, o, a, l, c = 0;
  const u = s._roots;
  for (let d = 0, f = u.length; d < f; d++)
    r = u[d], o = new Uint32Array(r), a = new Uint16Array(r), l = new Float32Array(r), h(0, c), c += r.byteLength;
  function h(d, f, m = !1) {
    const g = d * 2;
    if (a[g + 15] === ay) {
      const _ = o[d + 6], y = a[g + 14];
      let w = 1 / 0, x = 1 / 0, M = 1 / 0, A = -1 / 0, E = -1 / 0, C = -1 / 0;
      for (let P = _, T = _ + y; P < T; P++) {
        const I = 3 * s.resolveTriangleIndex(P);
        for (let D = 0; D < 3; D++) {
          let U = I + D;
          U = i ? i[U] : U;
          const L = n.getX(U), k = n.getY(U), B = n.getZ(U);
          L < w && (w = L), L > A && (A = L), k < x && (x = k), k > E && (E = k), B < M && (M = B), B > C && (C = B);
        }
      }
      return l[d + 0] !== w || l[d + 1] !== x || l[d + 2] !== M || l[d + 3] !== A || l[d + 4] !== E || l[d + 5] !== C ? (l[d + 0] = w, l[d + 1] = x, l[d + 2] = M, l[d + 3] = A, l[d + 4] = E, l[d + 5] = C, !0) : !1;
    } else {
      const _ = d + 8, y = o[d + 6], w = _ + f, x = y + f;
      let M = m, A = !1, E = !1;
      e ? M || (A = e.has(w), E = e.has(x), M = !A && !E) : (A = !0, E = !0);
      const C = M || A, P = M || E;
      let T = !1;
      C && (T = h(_, f, M));
      let I = !1;
      P && (I = h(y, f, M));
      const D = T || I;
      if (D)
        for (let U = 0; U < 3; U++) {
          const L = _ + U, k = y + U, B = l[L], j = l[L + 3], q = l[k], Z = l[k + 3];
          l[d + U] = B < q ? B : q, l[d + U + 3] = j > Z ? j : Z;
        }
      return D;
    }
  }
}
function CY(s, e, t, i, n, r, o) {
  ai.setBuffer(s._roots[e]), z1(0, s, t, i, n, r, o), ai.clearBuffer();
}
function z1(s, e, t, i, n, r, o) {
  const { float32Array: a, uint16Array: l, uint32Array: c } = ai, u = s * 2;
  if (Zr(u, l)) {
    const d = os(s, c), f = Cs(u, l);
    mY(e, t, i, d, f, n, r, o);
  } else {
    const d = eo(s);
    Ll(d, a, i, r, o) && z1(d, e, t, i, n, r, o);
    const f = Ps(s, c);
    Ll(f, a, i, r, o) && z1(f, e, t, i, n, r, o);
  }
}
const PY = ["x", "y", "z"];
function RY(s, e, t, i, n, r) {
  ai.setBuffer(s._roots[e]);
  const o = V1(0, s, t, i, n, r);
  return ai.clearBuffer(), o;
}
function V1(s, e, t, i, n, r) {
  const { float32Array: o, uint16Array: a, uint32Array: l } = ai;
  let c = s * 2;
  if (Zr(c, a)) {
    const h = os(s, l), d = Cs(c, a);
    return gY(e, t, i, h, d, n, r);
  } else {
    const h = eM(s, l), d = PY[h], m = i.direction[d] >= 0;
    let g, v;
    m ? (g = eo(s), v = Ps(s, l)) : (g = Ps(s, l), v = eo(s));
    const y = Ll(g, o, i, n, r) ? V1(g, e, t, i, n, r) : null;
    if (y) {
      const M = y.point[d];
      if (m ? M <= o[v + h] : (
        // min bounding data
        M >= o[v + h + 3]
      ))
        return y;
    }
    const x = Ll(v, o, i, n, r) ? V1(v, e, t, i, n, r) : null;
    return y && x ? y.distance <= x.distance ? y : x : y || x || null;
  }
}
const hv = /* @__PURE__ */ new yn(), bh = /* @__PURE__ */ new wo(), wh = /* @__PURE__ */ new wo(), Mf = /* @__PURE__ */ new _t(), V2 = /* @__PURE__ */ new Jr(), dv = /* @__PURE__ */ new Jr();
function DY(s, e, t, i) {
  ai.setBuffer(s._roots[e]);
  const n = G1(0, s, t, i);
  return ai.clearBuffer(), n;
}
function G1(s, e, t, i, n = null) {
  const { float32Array: r, uint16Array: o, uint32Array: a } = ai;
  let l = s * 2;
  if (n === null && (t.boundingBox || t.computeBoundingBox(), V2.set(t.boundingBox.min, t.boundingBox.max, i), n = V2), Zr(l, o)) {
    const u = e.geometry, h = u.index, d = u.attributes.position, f = t.index, m = t.attributes.position, g = os(s, a), v = Cs(l, o);
    if (Mf.copy(i).invert(), t.boundsTree)
      return bi(s, r, dv), dv.matrix.copy(Mf), dv.needsUpdate = !0, t.boundsTree.shapecast({
        intersectsBounds: (y) => dv.intersectsBox(y),
        intersectsTriangle: (y) => {
          y.a.applyMatrix4(i), y.b.applyMatrix4(i), y.c.applyMatrix4(i), y.needsUpdate = !0;
          for (let w = g, x = v + g; w < x; w++)
            if (Ni(wh, 3 * e.resolveTriangleIndex(w), h, d), wh.needsUpdate = !0, y.intersectsTriangle(wh))
              return !0;
          return !1;
        }
      });
    for (let _ = g, y = v + g; _ < y; _++) {
      const w = e.resolveTriangleIndex(_);
      Ni(bh, 3 * w, h, d), bh.a.applyMatrix4(Mf), bh.b.applyMatrix4(Mf), bh.c.applyMatrix4(Mf), bh.needsUpdate = !0;
      for (let x = 0, M = f.count; x < M; x += 3)
        if (Ni(wh, x, f, m), wh.needsUpdate = !0, bh.intersectsTriangle(wh))
          return !0;
    }
  } else {
    const u = s + 8, h = a[s + 6];
    return bi(u, r, hv), !!(n.intersectsBox(hv) && G1(u, e, t, i, n) || (bi(h, r, hv), n.intersectsBox(hv) && G1(h, e, t, i, n)));
  }
}
const fv = /* @__PURE__ */ new _t(), yb = /* @__PURE__ */ new Jr(), Ef = /* @__PURE__ */ new Jr(), IY = /* @__PURE__ */ new H(), LY = /* @__PURE__ */ new H(), UY = /* @__PURE__ */ new H(), kY = /* @__PURE__ */ new H();
function OY(s, e, t, i = {}, n = {}, r = 0, o = 1 / 0) {
  e.boundingBox || e.computeBoundingBox(), yb.set(e.boundingBox.min, e.boundingBox.max, t), yb.needsUpdate = !0;
  const a = s.geometry, l = a.attributes.position, c = a.index, u = e.attributes.position, h = e.index, d = to.getPrimitive(), f = to.getPrimitive();
  let m = IY, g = LY, v = null, _ = null;
  n && (v = UY, _ = kY);
  let y = 1 / 0, w = null, x = null;
  return fv.copy(t).invert(), Ef.matrix.copy(fv), s.shapecast(
    {
      boundsTraverseOrder: (M) => yb.distanceToBox(M),
      intersectsBounds: (M, A, E) => E < y && E < o ? (A && (Ef.min.copy(M.min), Ef.max.copy(M.max), Ef.needsUpdate = !0), !0) : !1,
      intersectsRange: (M, A) => {
        if (e.boundsTree) {
          const E = e.boundsTree;
          return E.shapecast({
            boundsTraverseOrder: (C) => Ef.distanceToBox(C),
            intersectsBounds: (C, P, T) => T < y && T < o,
            intersectsRange: (C, P) => {
              for (let T = C, I = C + P; T < I; T++) {
                const D = E.resolveTriangleIndex(T);
                Ni(f, 3 * D, h, u), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
                for (let U = M, L = M + A; U < L; U++) {
                  const k = s.resolveTriangleIndex(U);
                  Ni(d, 3 * k, c, l), d.needsUpdate = !0;
                  const B = d.distanceToTriangle(f, m, v);
                  if (B < y && (g.copy(m), _ && _.copy(v), y = B, w = U, x = T), B < r)
                    return !0;
                }
              }
            }
          });
        } else {
          const E = Dd(e);
          for (let C = 0, P = E; C < P; C++) {
            Ni(f, 3 * C, h, u), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
            for (let T = M, I = M + A; T < I; T++) {
              const D = s.resolveTriangleIndex(T);
              Ni(d, 3 * D, c, l), d.needsUpdate = !0;
              const U = d.distanceToTriangle(f, m, v);
              if (U < y && (g.copy(m), _ && _.copy(v), y = U, w = T, x = C), U < r)
                return !0;
            }
          }
        }
      }
    }
  ), to.releasePrimitive(d), to.releasePrimitive(f), y === 1 / 0 ? null : (i.point ? i.point.copy(g) : i.point = g.clone(), i.distance = y, i.faceIndex = w, n && (n.point ? n.point.copy(_) : n.point = _.clone(), n.point.applyMatrix4(fv), g.applyMatrix4(fv), n.distance = g.sub(n.point).length(), n.faceIndex = x), i);
}
function FY() {
  return typeof SharedArrayBuffer < "u";
}
const vp = new ai.constructor(), t_ = new ai.constructor(), cl = new nM(() => new yn()), Sh = new yn(), Mh = new yn(), xb = new yn(), bb = new yn();
let wb = !1;
function NY(s, e, t, i) {
  if (wb)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  wb = !0;
  const n = s._roots, r = e._roots;
  let o, a = 0, l = 0;
  const c = new _t().copy(t).invert();
  for (let u = 0, h = n.length; u < h; u++) {
    vp.setBuffer(n[u]), l = 0;
    const d = cl.getPrimitive();
    bi(0, vp.float32Array, d), d.applyMatrix4(c);
    for (let f = 0, m = r.length; f < m && (t_.setBuffer(r[f]), o = po(
      0,
      0,
      t,
      c,
      i,
      a,
      l,
      0,
      0,
      d
    ), t_.clearBuffer(), l += r[f].length, !o); f++)
      ;
    if (cl.releasePrimitive(d), vp.clearBuffer(), a += n[u].length, o)
      break;
  }
  return wb = !1, o;
}
function po(s, e, t, i, n, r = 0, o = 0, a = 0, l = 0, c = null, u = !1) {
  let h, d;
  u ? (h = t_, d = vp) : (h = vp, d = t_);
  const f = h.float32Array, m = h.uint32Array, g = h.uint16Array, v = d.float32Array, _ = d.uint32Array, y = d.uint16Array, w = s * 2, x = e * 2, M = Zr(w, g), A = Zr(x, y);
  let E = !1;
  if (A && M)
    u ? E = n(
      os(e, _),
      Cs(e * 2, y),
      os(s, m),
      Cs(s * 2, g),
      l,
      o + e,
      a,
      r + s
    ) : E = n(
      os(s, m),
      Cs(s * 2, g),
      os(e, _),
      Cs(e * 2, y),
      a,
      r + s,
      l,
      o + e
    );
  else if (A) {
    const C = cl.getPrimitive();
    bi(e, v, C), C.applyMatrix4(t);
    const P = eo(s), T = Ps(s, m);
    bi(P, f, Sh), bi(T, f, Mh);
    const I = C.intersectsBox(Sh), D = C.intersectsBox(Mh);
    E = I && po(
      e,
      P,
      i,
      t,
      n,
      o,
      r,
      l,
      a + 1,
      C,
      !u
    ) || D && po(
      e,
      T,
      i,
      t,
      n,
      o,
      r,
      l,
      a + 1,
      C,
      !u
    ), cl.releasePrimitive(C);
  } else {
    const C = eo(e), P = Ps(e, _);
    bi(C, v, xb), bi(P, v, bb);
    const T = c.intersectsBox(xb), I = c.intersectsBox(bb);
    if (T && I)
      E = po(
        s,
        C,
        t,
        i,
        n,
        r,
        o,
        a,
        l + 1,
        c,
        u
      ) || po(
        s,
        P,
        t,
        i,
        n,
        r,
        o,
        a,
        l + 1,
        c,
        u
      );
    else if (T)
      if (M)
        E = po(
          s,
          C,
          t,
          i,
          n,
          r,
          o,
          a,
          l + 1,
          c,
          u
        );
      else {
        const D = cl.getPrimitive();
        D.copy(xb).applyMatrix4(t);
        const U = eo(s), L = Ps(s, m);
        bi(U, f, Sh), bi(L, f, Mh);
        const k = D.intersectsBox(Sh), B = D.intersectsBox(Mh);
        E = k && po(
          C,
          U,
          i,
          t,
          n,
          o,
          r,
          l,
          a + 1,
          D,
          !u
        ) || B && po(
          C,
          L,
          i,
          t,
          n,
          o,
          r,
          l,
          a + 1,
          D,
          !u
        ), cl.releasePrimitive(D);
      }
    else if (I)
      if (M)
        E = po(
          s,
          P,
          t,
          i,
          n,
          r,
          o,
          a,
          l + 1,
          c,
          u
        );
      else {
        const D = cl.getPrimitive();
        D.copy(bb).applyMatrix4(t);
        const U = eo(s), L = Ps(s, m);
        bi(U, f, Sh), bi(L, f, Mh);
        const k = D.intersectsBox(Sh), B = D.intersectsBox(Mh);
        E = k && po(
          P,
          U,
          i,
          t,
          n,
          o,
          r,
          l,
          a + 1,
          D,
          !u
        ) || B && po(
          P,
          L,
          i,
          t,
          n,
          o,
          r,
          l,
          a + 1,
          D,
          !u
        ), cl.releasePrimitive(D);
      }
  }
  return E;
}
const pv = /* @__PURE__ */ new Jr(), G2 = /* @__PURE__ */ new yn(), BY = {
  strategy: ZL,
  maxDepth: 40,
  maxLeafTris: 10,
  useSharedArrayBuffer: !1,
  setBoundingBox: !0,
  onProgress: null,
  indirect: !1,
  verbose: !0,
  range: null
};
class iM {
  static serialize(e, t = {}) {
    t = {
      cloneBuffers: !0,
      ...t
    };
    const i = e.geometry, n = e._roots, r = e._indirectBuffer, o = i.getIndex();
    let a;
    return t.cloneBuffers ? a = {
      roots: n.map((l) => l.slice()),
      index: o ? o.array.slice() : null,
      indirectBuffer: r ? r.slice() : null
    } : a = {
      roots: n,
      index: o ? o.array : null,
      indirectBuffer: r
    }, a;
  }
  static deserialize(e, t, i = {}) {
    i = {
      setIndex: !0,
      indirect: !!e.indirectBuffer,
      ...i
    };
    const { index: n, roots: r, indirectBuffer: o } = e, a = new iM(t, { ...i, [fb]: !0 });
    if (a._roots = r, a._indirectBuffer = o || null, i.setIndex) {
      const l = t.getIndex();
      if (l === null) {
        const c = new Nt(e.index, 1, !1);
        t.setIndex(c);
      } else l.array !== n && (l.array.set(n), l.needsUpdate = !0);
    }
    return a;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(e, t = {}) {
    if (e.isBufferGeometry) {
      if (e.index && e.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t = Object.assign({
      ...BY,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [fb]: !1
    }, t), t.useSharedArrayBuffer && !FY())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = e, this._roots = null, this._indirectBuffer = null, t[fb] || (tY(this, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new yn()))), this.resolveTriangleIndex = t.indirect ? (i) => this._indirectBuffer[i] : (i) => i;
  }
  refit(e = null) {
    return (this.indirect ? AY : pY)(this, e);
  }
  traverse(e, t = 0) {
    const i = this._roots[t], n = new Uint32Array(i), r = new Uint16Array(i);
    o(0);
    function o(a, l = 0) {
      const c = a * 2, u = r[c + 15] === ay;
      if (u) {
        const h = n[a + 6], d = r[c + 14];
        e(l, u, new Float32Array(i, a * 4, 6), h, d);
      } else {
        const h = a + Al / 4, d = n[a + 6], f = n[a + 7];
        e(l, u, new Float32Array(i, a * 4, 6), f) || (o(h, l + 1), o(d, l + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(e, t = Fs, i = 0, n = 1 / 0) {
    const r = this._roots, o = this.geometry, a = [], l = t.isMaterial, c = Array.isArray(t), u = o.groups, h = l ? t.side : t, d = this.indirect ? CY : _Y;
    for (let f = 0, m = r.length; f < m; f++) {
      const g = c ? t[u[f].materialIndex].side : h, v = a.length;
      if (d(this, f, g, e, a, i, n), c) {
        const _ = u[f].materialIndex;
        for (let y = v, w = a.length; y < w; y++)
          a[y].face.materialIndex = _;
      }
    }
    return a;
  }
  raycastFirst(e, t = Fs, i = 0, n = 1 / 0) {
    const r = this._roots, o = this.geometry, a = t.isMaterial, l = Array.isArray(t);
    let c = null;
    const u = o.groups, h = a ? t.side : t, d = this.indirect ? RY : xY;
    for (let f = 0, m = r.length; f < m; f++) {
      const g = l ? t[u[f].materialIndex].side : h, v = d(this, f, g, e, i, n);
      v != null && (c == null || v.distance < c.distance) && (c = v, l && (v.face.materialIndex = u[f].materialIndex));
    }
    return c;
  }
  intersectsGeometry(e, t) {
    let i = !1;
    const n = this._roots, r = this.indirect ? DY : bY;
    for (let o = 0, a = n.length; o < a && (i = r(this, o, e, t), !i); o++)
      ;
    return i;
  }
  shapecast(e) {
    const t = to.getPrimitive(), i = this.indirect ? vY : fY;
    let {
      boundsTraverseOrder: n,
      intersectsBounds: r,
      intersectsRange: o,
      intersectsTriangle: a
    } = e;
    if (o && a) {
      const h = o;
      o = (d, f, m, g, v) => h(d, f, m, g, v) ? !0 : i(d, f, this, a, m, g, t);
    } else o || (a ? o = (h, d, f, m) => i(h, d, this, a, f, m, t) : o = (h, d, f) => f);
    let l = !1, c = 0;
    const u = this._roots;
    for (let h = 0, d = u.length; h < d; h++) {
      const f = u[h];
      if (l = aY(this, h, r, o, n, c), l)
        break;
      c += f.byteLength;
    }
    return to.releasePrimitive(t), l;
  }
  bvhcast(e, t, i) {
    let {
      intersectsRanges: n,
      intersectsTriangles: r
    } = i;
    const o = to.getPrimitive(), a = this.geometry.index, l = this.geometry.attributes.position, c = this.indirect ? (m) => {
      const g = this.resolveTriangleIndex(m);
      Ni(o, g * 3, a, l);
    } : (m) => {
      Ni(o, m * 3, a, l);
    }, u = to.getPrimitive(), h = e.geometry.index, d = e.geometry.attributes.position, f = e.indirect ? (m) => {
      const g = e.resolveTriangleIndex(m);
      Ni(u, g * 3, h, d);
    } : (m) => {
      Ni(u, m * 3, h, d);
    };
    if (r) {
      const m = (g, v, _, y, w, x, M, A) => {
        for (let E = _, C = _ + y; E < C; E++) {
          f(E), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = !0;
          for (let P = g, T = g + v; P < T; P++)
            if (c(P), o.needsUpdate = !0, r(o, u, P, E, w, x, M, A))
              return !0;
        }
        return !1;
      };
      if (n) {
        const g = n;
        n = function(v, _, y, w, x, M, A, E) {
          return g(v, _, y, w, x, M, A, E) ? !0 : m(v, _, y, w, x, M, A, E);
        };
      } else
        n = m;
    }
    return NY(this, e, t, n);
  }
  /* Derived Cast Functions */
  intersectsBox(e, t) {
    return pv.set(e.min, e.max, t), pv.needsUpdate = !0, this.shapecast(
      {
        intersectsBounds: (i) => pv.intersectsBox(i),
        intersectsTriangle: (i) => pv.intersectsTriangle(i)
      }
    );
  }
  intersectsSphere(e) {
    return this.shapecast(
      {
        intersectsBounds: (t) => e.intersectsBox(t),
        intersectsTriangle: (t) => t.intersectsSphere(e)
      }
    );
  }
  closestPointToGeometry(e, t, i = {}, n = {}, r = 0, o = 1 / 0) {
    return (this.indirect ? OY : TY)(
      this,
      e,
      t,
      i,
      n,
      r,
      o
    );
  }
  closestPointToPoint(e, t = {}, i = 0, n = 1 / 0) {
    return lY(
      this,
      e,
      t,
      i,
      n
    );
  }
  getBoundingBox(e) {
    return e.makeEmpty(), this._roots.forEach((i) => {
      bi(0, new Float32Array(i), G2), e.union(G2);
    }), e;
  }
}
function zY(s) {
  switch (s) {
    case 1:
      return "R";
    case 2:
      return "RG";
    case 3:
      return "RGBA";
    case 4:
      return "RGBA";
  }
  throw new Error();
}
function VY(s) {
  switch (s) {
    case 1:
      return bd;
    case 2:
      return y_;
    case 3:
      return di;
    case 4:
      return di;
  }
}
function H2(s) {
  switch (s) {
    case 1:
      return wd;
    case 2:
      return Sd;
    case 3:
      return vu;
    case 4:
      return vu;
  }
}
class i3 extends yr {
  constructor() {
    super(), this.minFilter = Tn, this.magFilter = Tn, this.generateMipmaps = !1, this.overrideItemSize = null, this._forcedType = null;
  }
  updateFrom(e) {
    const t = this.overrideItemSize, i = e.itemSize, n = e.count;
    if (t !== null) {
      if (i * n % t !== 0)
        throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");
      e.itemSize = t, e.count = n * i / t;
    }
    const r = e.itemSize, o = e.count, a = e.normalized, l = e.array.constructor, c = l.BYTES_PER_ELEMENT;
    let u = this._forcedType, h = r;
    if (u === null)
      switch (l) {
        case Float32Array:
          u = Un;
          break;
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
          u = hs;
          break;
        case Int8Array:
        case Int16Array:
        case Int32Array:
          u = Qc;
          break;
      }
    let d, f, m, g, v = zY(r);
    switch (u) {
      case Un:
        m = 1, f = VY(r), a && c === 1 ? (g = l, v += "8", l === Uint8Array ? d = ro : (d = Fp, v += "_SNORM")) : (g = Float32Array, v += "32F", d = Un);
        break;
      case Qc:
        v += c * 8 + "I", m = a ? Math.pow(2, l.BYTES_PER_ELEMENT * 8 - 1) : 1, f = H2(r), c === 1 ? (g = Int8Array, d = Fp) : c === 2 ? (g = Int16Array, d = g_) : (g = Int32Array, d = Qc);
        break;
      case hs:
        v += c * 8 + "UI", m = a ? Math.pow(2, l.BYTES_PER_ELEMENT * 8 - 1) : 1, f = H2(r), c === 1 ? (g = Uint8Array, d = ro) : c === 2 ? (g = Uint16Array, d = pu) : (g = Uint32Array, d = hs);
        break;
    }
    h === 3 && (f === di || f === vu) && (h = 4);
    const _ = Math.ceil(Math.sqrt(o)) || 1, y = h * _ * _, w = new g(y), x = e.normalized;
    e.normalized = !1;
    for (let M = 0; M < o; M++) {
      const A = h * M;
      w[A] = e.getX(M) / m, r >= 2 && (w[A + 1] = e.getY(M) / m), r >= 3 && (w[A + 2] = e.getZ(M) / m, h === 4 && (w[A + 3] = 1)), r >= 4 && (w[A + 3] = e.getW(M) / m);
    }
    e.normalized = x, this.internalFormat = v, this.format = f, this.type = d, this.image.width = _, this.image.height = _, this.image.data = w, this.needsUpdate = !0, this.dispose(), e.itemSize = i, e.count = n;
  }
}
class GY extends i3 {
  constructor() {
    super(), this._forcedType = hs;
  }
}
class HY extends i3 {
  constructor() {
    super(), this._forcedType = Un;
  }
}
class W2 {
  constructor() {
    this.index = new GY(), this.position = new HY(), this.bvhBounds = new yr(), this.bvhContents = new yr(), this._cachedIndexAttr = null, this.index.overrideItemSize = 3;
  }
  updateFrom(e) {
    const { geometry: t } = e;
    if (XY(e, this.bvhBounds, this.bvhContents), this.position.updateFrom(t.attributes.position), e.indirect) {
      const i = e._indirectBuffer;
      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== i.length)
        if (t.index)
          this._cachedIndexAttr = t.index.clone();
        else {
          const n = JL($L(t));
          this._cachedIndexAttr = new Nt(n, 1, !1);
        }
      WY(t, i, this._cachedIndexAttr), this.index.updateFrom(this._cachedIndexAttr);
    } else
      this.index.updateFrom(t.index);
  }
  dispose() {
    const { index: e, position: t, bvhBounds: i, bvhContents: n } = this;
    e && e.dispose(), t && t.dispose(), i && i.dispose(), n && n.dispose();
  }
}
function WY(s, e, t) {
  const i = t.array, n = s.index ? s.index.array : null;
  for (let r = 0, o = e.length; r < o; r++) {
    const a = 3 * r, l = 3 * e[r];
    for (let c = 0; c < 3; c++)
      i[a + c] = n ? n[l + c] : l + c;
  }
}
function XY(s, e, t) {
  const i = s._roots;
  if (i.length !== 1)
    throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");
  const n = i[0], r = new Uint16Array(n), o = new Uint32Array(n), a = new Float32Array(n), l = n.byteLength / Al, c = 2 * Math.ceil(Math.sqrt(l / 2)), u = new Float32Array(4 * c * c), h = Math.ceil(Math.sqrt(l)), d = new Uint32Array(2 * h * h);
  for (let f = 0; f < l; f++) {
    const m = f * Al / 4, g = m * 2, v = m;
    for (let _ = 0; _ < 3; _++)
      u[8 * f + 0 + _] = a[v + 0 + _], u[8 * f + 4 + _] = a[v + 3 + _];
    if (Zr(g, r)) {
      const _ = Cs(g, r), y = os(m, o), w = 4294901760 | _;
      d[f * 2 + 0] = w, d[f * 2 + 1] = y;
    } else {
      const _ = 4 * Ps(m, o) / Al, y = eM(m, o);
      d[f * 2 + 0] = y, d[f * 2 + 1] = _;
    }
  }
  e.image.data = u, e.image.width = c, e.image.height = c, e.format = di, e.type = Un, e.internalFormat = "RGBA32F", e.minFilter = Tn, e.magFilter = Tn, e.generateMipmaps = !1, e.needsUpdate = !0, e.dispose(), t.image.data = d, t.image.width = h, t.image.height = h, t.format = Sd, t.type = hs, t.internalFormat = "RG32UI", t.minFilter = Tn, t.magFilter = Tn, t.generateMipmaps = !1, t.needsUpdate = !0, t.dispose();
}
const YY = (
  /* glsl */
  `

// A stack of uint32 indices can can store the indices for
// a perfectly balanced tree with a depth up to 31. Lower stack
// depth gets higher performance.
//
// However not all trees are balanced. Best value to set this to
// is the trees max depth.
#ifndef BVH_STACK_DEPTH
#define BVH_STACK_DEPTH 60
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

// Utilities
uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}
`
), jY = (
  /* glsl */
  `

#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

// Raycasting
bool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	dist = max( t0, 0.0 );

	return t1 >= dist;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	// geometry info and triangle range
	sampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// outputs
	inout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;
		vec3 a = texelFetch1D( positionAttr, indices.x ).rgb;
		vec3 b = texelFetch1D( positionAttr, indices.y ).rgb;
		vec3 c = texelFetch1D( positionAttr, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

bool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {

	uint cni2 = currNodeIndex * 2u;
	vec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;
	vec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );

}

// use a macro to hide the fact that we need to expand the struct into separate fields
#define	bvhIntersectFirstHit(		bvh,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)	_bvhIntersectFirstHit(		bvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)

bool _bvhIntersectFirstHit(
	// bvh info
	sampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// output variables split into separate variables due to output precision
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ BVH_STACK_DEPTH ];
	stack[ 0 ] = 0u;

	float triangleDistance = INFINITY;
	bool found = false;
	while ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance;
		if (
			! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )
			|| boundsHitDistance > triangleDistance
		) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh_position, bvh_index, offset, count,
				rayOrigin, rayDirection, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}
`
), qY = (
  /* glsl */
  `
struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};
`
), ZY = qY, KY = `
	${YY}
	${jY}
`, $Y = `#define ENVMAP_TYPE_CUBE_UV
precision highp isampler2D;
precision highp usampler2D;
varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

#ifdef ENVMAP_TYPE_CUBEM
	uniform samplerCube envMap;
#else
	uniform sampler2D envMap;
#endif

uniform float bounces;
${ZY}
${KY}
uniform BVH bvh;
uniform float ior;
uniform bool correctMips;
uniform vec2 resolution;
uniform float fresnel;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 viewMatrixInverse;
uniform float aberrationStrength;
uniform vec3 color;

float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
	return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
}

vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
	vec3 rayOrigin = ro;
	vec3 rayDirection = rd;
	rayDirection = refract(rayDirection, normal, 1.0 / ior);
	rayOrigin = vWorldPosition + rayDirection * 0.001;
	rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
	rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
	for(float i = 0.0; i < bounces; i++) {
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);
		vec3 tempDir = refract(rayDirection, faceNormal, ior);
		if (length(tempDir) != 0.0) {
			rayDirection = tempDir;
			break;
		}
		rayDirection = reflect(rayDirection, faceNormal);
		rayOrigin = hitPos + rayDirection * 0.01;
	}
	rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
	return rayDirection;
}

#include <common>
#include <cube_uv_reflection_fragment>

#ifdef ENVMAP_TYPE_CUBEM
	vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
	}
#else
	vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		vec2 uvv = equirectUv( rayDirection );
		vec2 smoothUv = equirectUv( directionCamPerfect );
		return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
	}
#endif

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
	directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
	directionCamPerfect = normalize(directionCamPerfect);
	vec3 normal = vNormal;
	vec3 rayOrigin = cameraPosition;
	vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
	vec3 finalColor;
	#ifdef CHROMATIC_ABERRATIONS
		vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		#ifdef FAST_CHROMA
			vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
			vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
		#else
			vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
			vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
		#endif
		float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
		float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
		float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
		finalColor = vec3(finalColorR, finalColorG, finalColorB);
	#else
		rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;
	#endif

	finalColor *= color;
	#ifdef USE_INSTANCING_COLOR
		finalColor *= vInstanceColor;
	#endif

	vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
	float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
	gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);
	${Ft.tonemapping_fragment}
	${Ft.colorspace_fragment}
}`, JY = `uniform mat4 viewMatrixInverse;

varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

void main() {
	vec4 transformedNormal = vec4(normal, 0.0);
	vec4 transformedPosition = vec4(position, 1.0);
	#ifdef USE_INSTANCING
		transformedNormal = instanceMatrix * transformedNormal;
		transformedPosition = instanceMatrix * transformedPosition;
	#endif

	#ifdef USE_INSTANCING
		vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);
	#else
		vModelMatrixInverse = inverse(modelMatrix);
	#endif

	#ifdef USE_INSTANCING_COLOR
		vInstanceColor = instanceColor.rgb;
	#endif

	vWorldPosition = (modelMatrix * transformedPosition).xyz;
	vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;
}`;
function r3(s, e) {
  if (new.target) return Rt({
    component: r3,
    ...s
  });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(x, "$parent", t), r = () => Bn(_, "$size", t);
  let o = G(e, "envMap", 7), a = G(e, "bounces", 7, 2), l = G(e, "ior", 7, 2.4), c = G(e, "fresnel", 7, 0), u = G(e, "aberrationStrength", 7, 0), h = G(e, "color", 7, "white"), d = G(e, "fastChroma", 7, !0), f = G(e, "ref", 15), m = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "envMap",
    "bounces",
    "ior",
    "fresnel",
    "aberrationStrength",
    "color",
    "fastChroma",
    "ref"
  ]);
  const g = {
    envMap: { value: null },
    bounces: { value: 2 },
    ior: { value: 2.4 },
    correctMips: { value: !0 },
    aberrationStrength: { value: 0.01 },
    fresnel: { value: 0 },
    bvh: { value: new W2() },
    color: { value: new rt("white") },
    resolution: { value: new Be() },
    viewMatrixInverse: { value: new _t() },
    projectionMatrixInverse: { value: new _t() }
  }, v = new Mi({ fragmentShader: $Y, vertexShader: JY, uniforms: g }), { size: _, invalidate: y, camera: w } = cn(), x = To();
  let M = {};
  const A = (T, I, D) => {
    var N;
    const U = bn(T, "CubeTexture"), k = ((U ? (N = T.image[0]) == null ? void 0 : N.width : T == null ? void 0 : T.image.width) ?? 1024) / 4, B = Math.floor(Math.log2(k)), j = Math.pow(2, B), q = 3 * Math.max(j, 16 * 7), Z = 4 * j;
    U && (M.ENVMAP_TYPE_CUBEM = ""), M.CUBEUV_TEXEL_WIDTH = `${1 / q}`, M.CUBEUV_TEXEL_HEIGHT = `${1 / Z}`, M.CUBEUV_MAX_MIP = `${B}.0`, I > 0 && (M.CHROMATIC_ABERRATIONS = ""), D && (M.FAST_CHROMA = "");
  };
  $e(() => {
    A(o(), u(), d());
  }), So(() => {
    var T;
    n() && n() instanceof it && n().geometry && (g.bvh.value = new W2(), g.bvh.value.updateFrom(new iM((T = n()) == null ? void 0 : T.geometry.clone().toNonIndexed(), { strategy: KL })));
  }), ti(
    () => {
      g.viewMatrixInverse.value = w.current.matrixWorld, g.projectionMatrixInverse.value = w.current.projectionMatrixInverse;
    },
    { autoInvalidate: !1 }
  );
  const E = new rt(h());
  $e(() => {
    E.set(h()), y();
  });
  const C = /* @__PURE__ */ wt(() => [r().width, r().height]);
  pt(s, sn(
    {
      is: v,
      get "uniforms.envMap.value"() {
        return o();
      },
      get "uniforms.bounces.value"() {
        return a();
      },
      get "uniforms.ior.value"() {
        return l();
      },
      get "uniforms.fresnel.value"() {
        return c();
      },
      get "uniforms.aberrationStrength.value"() {
        return u();
      },
      "uniforms.color.value": E,
      get "uniforms.resolution.value"() {
        return pe(C);
      },
      defines: M
    },
    () => m,
    {
      get ref() {
        return f();
      },
      set ref(T) {
        f(T);
      }
    }
  ));
  var P = Pt({
    get envMap() {
      return o();
    },
    set envMap(T) {
      o(T), V();
    },
    get bounces() {
      return a();
    },
    set bounces(T = 2) {
      a(T), V();
    },
    get ior() {
      return l();
    },
    set ior(T = 2.4) {
      l(T), V();
    },
    get fresnel() {
      return c();
    },
    set fresnel(T = 0) {
      c(T), V();
    },
    get aberrationStrength() {
      return u();
    },
    set aberrationStrength(T = 0) {
      u(T), V();
    },
    get color() {
      return h();
    },
    set color(T = "white") {
      h(T), V();
    },
    get fastChroma() {
      return d();
    },
    set fastChroma(T = !0) {
      d(T), V();
    },
    get ref() {
      return f();
    },
    set ref(T) {
      f(T), V();
    },
    $set: Lt,
    $on: (T, I) => It(e, T, I)
  });
  return i(), P;
}
Ut(
  r3,
  {
    envMap: {},
    bounces: {},
    ior: {},
    fresnel: {},
    aberrationStrength: {},
    color: {},
    fastChroma: {},
    ref: {}
  },
  [],
  [],
  !0
);
class QY extends Ad {
  constructor(e, t = {}) {
    const i = t.font;
    if (i === void 0)
      super();
    else {
      const n = i.generateShapes(e, t.size);
      t.depth === void 0 && (t.depth = 50), t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(n, t);
    }
    this.type = "TextGeometry";
  }
}
class ej extends br {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, o = new ps(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
      const l = r.parse(JSON.parse(a));
      t && t(l);
    }, i, n);
  }
  parse(e) {
    return new tj(e);
  }
}
class tj {
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const i = [], n = nj(e, t, this.data);
    for (let r = 0, o = n.length; r < o; r++)
      i.push(...n[r].toShapes());
    return i;
  }
}
function nj(s, e, t) {
  const i = Array.from(s), n = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n, o = [];
  let a = 0, l = 0;
  for (let c = 0; c < i.length; c++) {
    const u = i[c];
    if (u === `
`)
      a = 0, l -= r;
    else {
      const h = ij(u, n, a, l, t);
      a += h.offsetX, o.push(h.path);
    }
  }
  return o;
}
function ij(s, e, t, i, n) {
  const r = n.glyphs[s] || n.glyphs["?"];
  if (!r) {
    console.error('THREE.Font: character "' + s + '" does not exists in font family ' + n.familyName + ".");
    return;
  }
  const o = new kI();
  let a, l, c, u, h, d, f, m;
  if (r.o) {
    const g = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
    for (let v = 0, _ = g.length; v < _; )
      switch (g[v++]) {
        case "m":
          a = g[v++] * e + t, l = g[v++] * e + i, o.moveTo(a, l);
          break;
        case "l":
          a = g[v++] * e + t, l = g[v++] * e + i, o.lineTo(a, l);
          break;
        case "q":
          c = g[v++] * e + t, u = g[v++] * e + i, h = g[v++] * e + t, d = g[v++] * e + i, o.quadraticCurveTo(h, d, c, u);
          break;
        case "b":
          c = g[v++] * e + t, u = g[v++] * e + i, h = g[v++] * e + t, d = g[v++] * e + i, f = g[v++] * e + t, m = g[v++] * e + i, o.bezierCurveTo(h, d, f, m, c, u);
          break;
      }
  }
  return { offsetX: r.ha * e, path: o };
}
function s3(s, e) {
  if (new.target) return Rt({ component: s3, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(pe(E), "$loadedFont", t);
  let r = G(e, "text", 7), o = G(e, "font", 7, "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json"), a = G(e, "size", 7), l = G(e, "depth", 7), c = G(e, "curveSegments", 7), u = G(e, "bevelEnabled", 7), h = G(e, "bevelThickness", 7), d = G(e, "bevelSize", 7), f = G(e, "bevelOffset", 7), m = G(e, "bevelSegments", 7), g = G(e, "smooth", 7), v = G(e, "extrudePath", 7), _ = G(e, "steps", 7), y = G(e, "UVGenerator", 7), w = G(e, "ref", 15), x = G(e, "children", 7), M = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "text",
    "font",
    "size",
    "depth",
    "curveSegments",
    "bevelEnabled",
    "bevelThickness",
    "bevelSize",
    "bevelOffset",
    "bevelSegments",
    "smooth",
    "extrudePath",
    "steps",
    "UVGenerator",
    "ref",
    "children"
  ]);
  const A = Vl();
  let E = /* @__PURE__ */ wt(() => A(typeof o() == "string" ? mm(ej).load(o()) : nu(new Promise((L) => L(o()))))), C = /* @__PURE__ */ wt(() => {
    if (n())
      return new QY(r(), {
        font: n(),
        size: a(),
        depth: l(),
        curveSegments: c(),
        bevelEnabled: u(),
        bevelThickness: h(),
        bevelSize: d(),
        bevelOffset: f(),
        bevelSegments: m(),
        extrudePath: v(),
        steps: _(),
        UVGenerator: y()
      });
  }), P = /* @__PURE__ */ wt(() => {
    if (pe(C))
      return g() === 0 ? pe(C) : FS(pe(C), g());
  });
  var T = At(), I = dt(T);
  {
    var D = (L) => {
      pt(L, sn(
        {
          get is() {
            return pe(P);
          }
        },
        () => M,
        {
          get ref() {
            return w();
          },
          set ref(k) {
            w(k);
          },
          children: (k, B) => {
            var j = At(), q = dt(j);
            Wt(q, () => x() ?? Bt, () => ({ ref: pe(P) })), ut(k, j);
          },
          $$slots: { default: !0 }
        }
      ));
    };
    Ai(I, (L) => {
      pe(P) && L(D);
    });
  }
  ut(s, T);
  var U = Pt({
    get text() {
      return r();
    },
    set text(L) {
      r(L), V();
    },
    get font() {
      return o();
    },
    set font(L = "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json") {
      o(L), V();
    },
    get size() {
      return a();
    },
    set size(L) {
      a(L), V();
    },
    get depth() {
      return l();
    },
    set depth(L) {
      l(L), V();
    },
    get curveSegments() {
      return c();
    },
    set curveSegments(L) {
      c(L), V();
    },
    get bevelEnabled() {
      return u();
    },
    set bevelEnabled(L) {
      u(L), V();
    },
    get bevelThickness() {
      return h();
    },
    set bevelThickness(L) {
      h(L), V();
    },
    get bevelSize() {
      return d();
    },
    set bevelSize(L) {
      d(L), V();
    },
    get bevelOffset() {
      return f();
    },
    set bevelOffset(L) {
      f(L), V();
    },
    get bevelSegments() {
      return m();
    },
    set bevelSegments(L) {
      m(L), V();
    },
    get smooth() {
      return g();
    },
    set smooth(L) {
      g(L), V();
    },
    get extrudePath() {
      return v();
    },
    set extrudePath(L) {
      v(L), V();
    },
    get steps() {
      return _();
    },
    set steps(L) {
      _(L), V();
    },
    get UVGenerator() {
      return y();
    },
    set UVGenerator(L) {
      y(L), V();
    },
    get ref() {
      return w();
    },
    set ref(L) {
      w(L), V();
    },
    get children() {
      return x();
    },
    set children(L) {
      x(L), V();
    },
    $set: Lt,
    $on: (L, k) => It(e, L, k)
  });
  return i(), U;
}
Ut(
  s3,
  {
    text: {},
    font: {},
    size: {},
    depth: {},
    curveSegments: {},
    bevelEnabled: {},
    bevelThickness: {},
    bevelSize: {},
    bevelOffset: {},
    bevelSegments: {},
    smooth: {},
    extrudePath: {},
    steps: {},
    UVGenerator: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
var Vf = { exports: {} };
/*! Tweakpane 3.1.10 (c) 2016 cocopon, licensed under the MIT license. */
var rj = Vf.exports, X2;
function sj() {
  return X2 || (X2 = 1, function(s, e) {
    (function(t, i) {
      i(e);
    })(rj, function(t) {
      class i {
        /**
         * @hidden
         */
        constructor(p) {
          const [b, R] = p.split("-"), W = b.split(".");
          this.major = parseInt(W[0], 10), this.minor = parseInt(W[1], 10), this.patch = parseInt(W[2], 10), this.prerelease = R ?? null;
        }
        toString() {
          const p = [this.major, this.minor, this.patch].join(".");
          return this.prerelease !== null ? [p, this.prerelease].join("-") : p;
        }
      }
      class n {
        constructor(p) {
          this.controller_ = p;
        }
        get element() {
          return this.controller_.view.element;
        }
        get disabled() {
          return this.controller_.viewProps.get("disabled");
        }
        set disabled(p) {
          this.controller_.viewProps.set("disabled", p);
        }
        get hidden() {
          return this.controller_.viewProps.get("hidden");
        }
        set hidden(p) {
          this.controller_.viewProps.set("hidden", p);
        }
        dispose() {
          this.controller_.viewProps.set("disposed", !0);
        }
      }
      class r {
        constructor(p) {
          this.target = p;
        }
      }
      class o extends r {
        constructor(p, b, R, W) {
          super(p), this.value = b, this.presetKey = R, this.last = W ?? !0;
        }
      }
      class a extends r {
        constructor(p, b, R) {
          super(p), this.value = b, this.presetKey = R;
        }
      }
      class l extends r {
        constructor(p, b) {
          super(p), this.expanded = b;
        }
      }
      class c extends r {
        constructor(p, b) {
          super(p), this.index = b;
        }
      }
      function u(S) {
        return S;
      }
      function h(S) {
        return S == null;
      }
      function d(S, p) {
        if (S.length !== p.length)
          return !1;
        for (let b = 0; b < S.length; b++)
          if (S[b] !== p[b])
            return !1;
        return !0;
      }
      function f(S, p) {
        let b = S;
        do {
          const R = Object.getOwnPropertyDescriptor(b, p);
          if (R && (R.set !== void 0 || R.writable === !0))
            return !0;
          b = Object.getPrototypeOf(b);
        } while (b !== null);
        return !1;
      }
      const m = {
        alreadydisposed: () => "View has been already disposed",
        invalidparams: (S) => `Invalid parameters for '${S.name}'`,
        nomatchingcontroller: (S) => `No matching controller for '${S.key}'`,
        nomatchingview: (S) => `No matching view for '${JSON.stringify(S.params)}'`,
        notbindable: () => "Value is not bindable",
        propertynotfound: (S) => `Property '${S.name}' not found`,
        shouldneverhappen: () => "This error should never happen"
      };
      class g {
        static alreadyDisposed() {
          return new g({ type: "alreadydisposed" });
        }
        static notBindable() {
          return new g({
            type: "notbindable"
          });
        }
        static propertyNotFound(p) {
          return new g({
            type: "propertynotfound",
            context: {
              name: p
            }
          });
        }
        static shouldNeverHappen() {
          return new g({ type: "shouldneverhappen" });
        }
        constructor(p) {
          var b;
          this.message = (b = m[p.type](p.context)) !== null && b !== void 0 ? b : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = p.type;
        }
      }
      class v {
        constructor(p, b, R) {
          this.obj_ = p, this.key_ = b, this.presetKey_ = R ?? b;
        }
        static isBindable(p) {
          return !(p === null || typeof p != "object" && typeof p != "function");
        }
        get key() {
          return this.key_;
        }
        get presetKey() {
          return this.presetKey_;
        }
        read() {
          return this.obj_[this.key_];
        }
        write(p) {
          this.obj_[this.key_] = p;
        }
        writeProperty(p, b) {
          const R = this.read();
          if (!v.isBindable(R))
            throw g.notBindable();
          if (!(p in R))
            throw g.propertyNotFound(p);
          R[p] = b;
        }
      }
      class _ extends n {
        get label() {
          return this.controller_.props.get("label");
        }
        set label(p) {
          this.controller_.props.set("label", p);
        }
        get title() {
          var p;
          return (p = this.controller_.valueController.props.get("title")) !== null && p !== void 0 ? p : "";
        }
        set title(p) {
          this.controller_.valueController.props.set("title", p);
        }
        on(p, b) {
          const R = b.bind(this);
          return this.controller_.valueController.emitter.on(p, () => {
            R(new r(this));
          }), this;
        }
      }
      class y {
        constructor() {
          this.observers_ = {};
        }
        on(p, b) {
          let R = this.observers_[p];
          return R || (R = this.observers_[p] = []), R.push({
            handler: b
          }), this;
        }
        off(p, b) {
          const R = this.observers_[p];
          return R && (this.observers_[p] = R.filter((W) => W.handler !== b)), this;
        }
        emit(p, b) {
          const R = this.observers_[p];
          R && R.forEach((W) => {
            W.handler(b);
          });
        }
      }
      const w = "tp";
      function x(S) {
        return (b, R) => [
          w,
          "-",
          S,
          "v",
          b ? `_${b}` : "",
          R ? `-${R}` : ""
        ].join("");
      }
      function M(S, p) {
        return (b) => p(S(b));
      }
      function A(S) {
        return S.rawValue;
      }
      function E(S, p) {
        S.emitter.on("change", M(A, p)), p(S.rawValue);
      }
      function C(S, p, b) {
        E(S.value(p), b);
      }
      function P(S, p, b) {
        b ? S.classList.add(p) : S.classList.remove(p);
      }
      function T(S, p) {
        return (b) => {
          P(S, p, b);
        };
      }
      function I(S, p) {
        E(S, (b) => {
          p.textContent = b ?? "";
        });
      }
      const D = x("btn");
      class U {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(D()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("button");
          R.classList.add(D("b")), b.viewProps.bindDisabled(R), this.element.appendChild(R), this.buttonElement = R;
          const W = p.createElement("div");
          W.classList.add(D("t")), I(b.props.value("title"), W), this.buttonElement.appendChild(W);
        }
      }
      class L {
        constructor(p, b) {
          this.emitter = new y(), this.onClick_ = this.onClick_.bind(this), this.props = b.props, this.viewProps = b.viewProps, this.view = new U(p, {
            props: this.props,
            viewProps: this.viewProps
          }), this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class k {
        constructor(p, b) {
          var R;
          this.constraint_ = b == null ? void 0 : b.constraint, this.equals_ = (R = b == null ? void 0 : b.equals) !== null && R !== void 0 ? R : (W, ge) => W === ge, this.emitter = new y(), this.rawValue_ = p;
        }
        get constraint() {
          return this.constraint_;
        }
        get rawValue() {
          return this.rawValue_;
        }
        set rawValue(p) {
          this.setRawValue(p, {
            forceEmit: !1,
            last: !0
          });
        }
        setRawValue(p, b) {
          const R = b ?? {
            forceEmit: !1,
            last: !0
          }, W = this.constraint_ ? this.constraint_.constrain(p) : p, ge = this.rawValue_;
          this.equals_(ge, W) && !R.forceEmit || (this.emitter.emit("beforechange", {
            sender: this
          }), this.rawValue_ = W, this.emitter.emit("change", {
            options: R,
            previousRawValue: ge,
            rawValue: W,
            sender: this
          }));
        }
      }
      class B {
        constructor(p) {
          this.emitter = new y(), this.value_ = p;
        }
        get rawValue() {
          return this.value_;
        }
        set rawValue(p) {
          this.setRawValue(p, {
            forceEmit: !1,
            last: !0
          });
        }
        setRawValue(p, b) {
          const R = b ?? {
            forceEmit: !1,
            last: !0
          }, W = this.value_;
          W === p && !R.forceEmit || (this.emitter.emit("beforechange", {
            sender: this
          }), this.value_ = p, this.emitter.emit("change", {
            options: R,
            previousRawValue: W,
            rawValue: this.value_,
            sender: this
          }));
        }
      }
      function j(S, p) {
        const b = p == null ? void 0 : p.constraint, R = p == null ? void 0 : p.equals;
        return !b && !R ? new B(S) : new k(S, p);
      }
      class q {
        constructor(p) {
          this.emitter = new y(), this.valMap_ = p;
          for (const b in this.valMap_)
            this.valMap_[b].emitter.on("change", () => {
              this.emitter.emit("change", {
                key: b,
                sender: this
              });
            });
        }
        static createCore(p) {
          return Object.keys(p).reduce((R, W) => Object.assign(R, {
            [W]: j(p[W])
          }), {});
        }
        static fromObject(p) {
          const b = this.createCore(p);
          return new q(b);
        }
        get(p) {
          return this.valMap_[p].rawValue;
        }
        set(p, b) {
          this.valMap_[p].rawValue = b;
        }
        value(p) {
          return this.valMap_[p];
        }
      }
      function Z(S, p) {
        const R = Object.keys(p).reduce((W, ge) => {
          if (W === void 0)
            return;
          const ke = p[ge], lt = ke(S[ge]);
          return lt.succeeded ? Object.assign(Object.assign({}, W), { [ge]: lt.value }) : void 0;
        }, {});
        return R;
      }
      function N(S, p) {
        return S.reduce((b, R) => {
          if (b === void 0)
            return;
          const W = p(R);
          if (!(!W.succeeded || W.value === void 0))
            return [...b, W.value];
        }, []);
      }
      function z(S) {
        return S === null ? !1 : typeof S == "object";
      }
      function J(S) {
        return (p) => (b) => {
          if (!p && b === void 0)
            return {
              succeeded: !1,
              value: void 0
            };
          if (p && b === void 0)
            return {
              succeeded: !0,
              value: void 0
            };
          const R = S(b);
          return R !== void 0 ? {
            succeeded: !0,
            value: R
          } : {
            succeeded: !1,
            value: void 0
          };
        };
      }
      function se(S) {
        return {
          custom: (p) => J(p)(S),
          boolean: J((p) => typeof p == "boolean" ? p : void 0)(S),
          number: J((p) => typeof p == "number" ? p : void 0)(S),
          string: J((p) => typeof p == "string" ? p : void 0)(S),
          function: J((p) => typeof p == "function" ? p : void 0)(S),
          constant: (p) => J((b) => b === p ? p : void 0)(S),
          raw: J((p) => p)(S),
          object: (p) => J((b) => {
            if (z(b))
              return Z(b, p);
          })(S),
          array: (p) => J((b) => {
            if (Array.isArray(b))
              return N(b, p);
          })(S)
        };
      }
      const K = {
        optional: se(!0),
        required: se(!1)
      };
      function Q(S, p) {
        const b = K.required.object(p)(S);
        return b.succeeded ? b.value : void 0;
      }
      function de(S) {
        console.warn([
          `Missing '${S.key}' of ${S.target} in ${S.place}.`,
          "Please rebuild plugins with the latest core package."
        ].join(" "));
      }
      function ce(S) {
        return S && S.parentElement && S.parentElement.removeChild(S), null;
      }
      class _e {
        constructor(p) {
          this.value_ = p;
        }
        static create(p) {
          return [
            new _e(p),
            (b, R) => {
              p.setRawValue(b, R);
            }
          ];
        }
        get emitter() {
          return this.value_.emitter;
        }
        get rawValue() {
          return this.value_.rawValue;
        }
      }
      const Fe = x("");
      function Ie(S, p) {
        return T(S, Fe(void 0, p));
      }
      class Ee extends q {
        constructor(p) {
          var b;
          super(p), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = _e.create(j(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (b = this.get("parent")) === null || b === void 0 || b.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
        }
        static create(p) {
          var b, R, W;
          const ge = p ?? {};
          return new Ee(q.createCore({
            disabled: (b = ge.disabled) !== null && b !== void 0 ? b : !1,
            disposed: !1,
            hidden: (R = ge.hidden) !== null && R !== void 0 ? R : !1,
            parent: (W = ge.parent) !== null && W !== void 0 ? W : null
          }));
        }
        get globalDisabled() {
          return this.globalDisabled_;
        }
        bindClassModifiers(p) {
          E(this.globalDisabled_, Ie(p, "disabled")), C(this, "hidden", Ie(p, "hidden"));
        }
        bindDisabled(p) {
          E(this.globalDisabled_, (b) => {
            p.disabled = b;
          });
        }
        bindTabIndex(p) {
          E(this.globalDisabled_, (b) => {
            p.tabIndex = b ? -1 : 0;
          });
        }
        handleDispose(p) {
          this.value("disposed").emitter.on("change", (b) => {
            b && p();
          });
        }
        getGlobalDisabled_() {
          const p = this.get("parent");
          return (p ? p.globalDisabled.rawValue : !1) || this.get("disabled");
        }
        updateGlobalDisabled_() {
          this.setGlobalDisabled_(this.getGlobalDisabled_());
        }
        onDisabledChange_() {
          this.updateGlobalDisabled_();
        }
        onParentGlobalDisabledChange_() {
          this.updateGlobalDisabled_();
        }
        onParentChange_(p) {
          var b;
          const R = p.previousRawValue;
          R == null || R.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (b = this.get("parent")) === null || b === void 0 || b.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_();
        }
      }
      function me() {
        return ["veryfirst", "first", "last", "verylast"];
      }
      const xe = x(""), $ = {
        veryfirst: "vfst",
        first: "fst",
        last: "lst",
        verylast: "vlst"
      };
      class Ue {
        constructor(p) {
          this.parent_ = null, this.blade = p.blade, this.view = p.view, this.viewProps = p.viewProps;
          const b = this.view.element;
          this.blade.value("positions").emitter.on("change", () => {
            me().forEach((R) => {
              b.classList.remove(xe(void 0, $[R]));
            }), this.blade.get("positions").forEach((R) => {
              b.classList.add(xe(void 0, $[R]));
            });
          }), this.viewProps.handleDispose(() => {
            ce(b);
          });
        }
        get parent() {
          return this.parent_;
        }
        set parent(p) {
          if (this.parent_ = p, !("parent" in this.viewProps.valMap_)) {
            de({
              key: "parent",
              target: Ee.name,
              place: "BladeController.parent"
            });
            return;
          }
          this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
        }
      }
      const Me = "http://www.w3.org/2000/svg";
      function oe(S) {
        S.offsetHeight;
      }
      function Te(S, p) {
        const b = S.style.transition;
        S.style.transition = "none", p(), S.style.transition = b;
      }
      function Ye(S) {
        return S.ontouchstart !== void 0;
      }
      function Oe() {
        return globalThis;
      }
      function X() {
        return Oe().document;
      }
      function Y(S) {
        const p = S.ownerDocument.defaultView;
        return p && "document" in p ? S.getContext("2d", {
          willReadFrequently: !0
        }) : null;
      }
      const fe = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
      };
      function ue(S, p) {
        const b = S.createElementNS(Me, "svg");
        return b.innerHTML = fe[p], b;
      }
      function te(S, p, b) {
        S.insertBefore(p, S.children[b]);
      }
      function Se(S) {
        S.parentElement && S.parentElement.removeChild(S);
      }
      function ye(S) {
        for (; S.children.length > 0; )
          S.removeChild(S.children[0]);
      }
      function Ae(S) {
        for (; S.childNodes.length > 0; )
          S.removeChild(S.childNodes[0]);
      }
      function Ce(S) {
        return S.relatedTarget ? S.relatedTarget : "explicitOriginalTarget" in S ? S.explicitOriginalTarget : null;
      }
      const Ge = x("lbl");
      function De(S, p) {
        const b = S.createDocumentFragment();
        return p.split(`
`).map((W) => S.createTextNode(W)).forEach((W, ge) => {
          ge > 0 && b.appendChild(S.createElement("br")), b.appendChild(W);
        }), b;
      }
      class Ve {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(Ge()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("div");
          R.classList.add(Ge("l")), C(b.props, "label", (ge) => {
            h(ge) ? this.element.classList.add(Ge(void 0, "nol")) : (this.element.classList.remove(Ge(void 0, "nol")), Ae(R), R.appendChild(De(p, ge)));
          }), this.element.appendChild(R), this.labelElement = R;
          const W = p.createElement("div");
          W.classList.add(Ge("v")), this.element.appendChild(W), this.valueElement = W;
        }
      }
      class ze extends Ue {
        constructor(p, b) {
          const R = b.valueController.viewProps;
          super(Object.assign(Object.assign({}, b), { view: new Ve(p, {
            props: b.props,
            viewProps: R
          }), viewProps: R })), this.props = b.props, this.valueController = b.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      const Ze = {
        id: "button",
        type: "blade",
        accept(S) {
          const p = K, b = Q(S, {
            title: p.required.string,
            view: p.required.constant("button"),
            label: p.optional.string
          });
          return b ? { params: b } : null;
        },
        controller(S) {
          return new ze(S.document, {
            blade: S.blade,
            props: q.fromObject({
              label: S.params.label
            }),
            valueController: new L(S.document, {
              props: q.fromObject({
                title: S.params.title
              }),
              viewProps: S.viewProps
            })
          });
        },
        api(S) {
          return !(S.controller instanceof ze) || !(S.controller.valueController instanceof L) ? null : new _(S.controller);
        }
      };
      class Le extends Ue {
        constructor(p) {
          super(p), this.value = p.value;
        }
      }
      function ot() {
        return new q({
          positions: j([], {
            equals: d
          })
        });
      }
      class tt extends q {
        constructor(p) {
          super(p);
        }
        static create(p) {
          const b = {
            completed: !0,
            expanded: p,
            expandedHeight: null,
            shouldFixHeight: !1,
            temporaryExpanded: null
          }, R = q.createCore(b);
          return new tt(R);
        }
        get styleExpanded() {
          var p;
          return (p = this.get("temporaryExpanded")) !== null && p !== void 0 ? p : this.get("expanded");
        }
        get styleHeight() {
          if (!this.styleExpanded)
            return "0";
          const p = this.get("expandedHeight");
          return this.get("shouldFixHeight") && !h(p) ? `${p}px` : "auto";
        }
        bindExpandedClass(p, b) {
          const R = () => {
            this.styleExpanded ? p.classList.add(b) : p.classList.remove(b);
          };
          C(this, "expanded", R), C(this, "temporaryExpanded", R);
        }
        cleanUpTransition() {
          this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0);
        }
      }
      function mt(S, p) {
        let b = 0;
        return Te(p, () => {
          S.set("expandedHeight", null), S.set("temporaryExpanded", !0), oe(p), b = p.clientHeight, S.set("temporaryExpanded", null), oe(p);
        }), b;
      }
      function le(S, p) {
        p.style.height = S.styleHeight;
      }
      function ve(S, p) {
        S.value("expanded").emitter.on("beforechange", () => {
          if (S.set("completed", !1), h(S.get("expandedHeight"))) {
            const b = mt(S, p);
            b > 0 && S.set("expandedHeight", b);
          }
          S.set("shouldFixHeight", !0), oe(p);
        }), S.emitter.on("change", () => {
          le(S, p);
        }), le(S, p), p.addEventListener("transitionend", (b) => {
          b.propertyName === "height" && S.cleanUpTransition();
        });
      }
      class be extends n {
        constructor(p, b) {
          super(p), this.rackApi_ = b;
        }
      }
      function Xe(S, p) {
        return S.addBlade(Object.assign(Object.assign({}, p), { view: "button" }));
      }
      function We(S, p) {
        return S.addBlade(Object.assign(Object.assign({}, p), { view: "folder" }));
      }
      function Ne(S, p) {
        const b = p ?? {};
        return S.addBlade(Object.assign(Object.assign({}, b), { view: "separator" }));
      }
      function ct(S, p) {
        return S.addBlade(Object.assign(Object.assign({}, p), { view: "tab" }));
      }
      class gt {
        constructor(p) {
          this.emitter = new y(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = p;
        }
        get items() {
          return this.items_;
        }
        allItems() {
          return Array.from(this.cache_);
        }
        find(p) {
          for (const b of this.allItems())
            if (p(b))
              return b;
          return null;
        }
        includes(p) {
          return this.cache_.has(p);
        }
        add(p, b) {
          if (this.includes(p))
            throw g.shouldNeverHappen();
          const R = b !== void 0 ? b : this.items_.length;
          this.items_.splice(R, 0, p), this.cache_.add(p);
          const W = this.extract_(p);
          W && (W.emitter.on("add", this.onSubListAdd_), W.emitter.on("remove", this.onSubListRemove_), W.allItems().forEach((ge) => {
            this.cache_.add(ge);
          })), this.emitter.emit("add", {
            index: R,
            item: p,
            root: this,
            target: this
          });
        }
        remove(p) {
          const b = this.items_.indexOf(p);
          if (b < 0)
            return;
          this.items_.splice(b, 1), this.cache_.delete(p);
          const R = this.extract_(p);
          R && (R.emitter.off("add", this.onSubListAdd_), R.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
            index: b,
            item: p,
            root: this,
            target: this
          });
        }
        onSubListAdd_(p) {
          this.cache_.add(p.item), this.emitter.emit("add", {
            index: p.index,
            item: p.item,
            root: this,
            target: p.target
          });
        }
        onSubListRemove_(p) {
          this.cache_.delete(p.item), this.emitter.emit("remove", {
            index: p.index,
            item: p.item,
            root: this,
            target: p.target
          });
        }
      }
      class nt extends n {
        constructor(p) {
          super(p), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new y(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(p) {
          this.controller_.props.set("label", p);
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingChange_(p) {
          const b = p.sender.target.read();
          this.emitter_.emit("change", {
            event: new o(this, b, this.controller_.binding.target.presetKey, p.options.last)
          });
        }
      }
      class je extends ze {
        constructor(p, b) {
          super(p, b), this.binding = b.binding;
        }
      }
      class at extends n {
        constructor(p) {
          super(p), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new y(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(p) {
          this.controller_.props.set("label", p);
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingUpdate_(p) {
          const b = p.sender.target.read();
          this.emitter_.emit("update", {
            event: new a(this, b, this.controller_.binding.target.presetKey)
          });
        }
      }
      class ft extends ze {
        constructor(p, b) {
          super(p, b), this.binding = b.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
            this.binding.dispose();
          });
        }
      }
      function Qe(S) {
        return S instanceof Mt ? S.apiSet_ : S instanceof be ? S.rackApi_.apiSet_ : null;
      }
      function xt(S, p) {
        const b = S.find((R) => R.controller_ === p);
        if (!b)
          throw g.shouldNeverHappen();
        return b;
      }
      function yt(S, p, b) {
        if (!v.isBindable(S))
          throw g.notBindable();
        return new v(S, p, b);
      }
      class Mt extends n {
        constructor(p, b) {
          super(p), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new y(), this.apiSet_ = new gt(Qe), this.pool_ = b;
          const R = this.controller_.rack;
          R.emitter.on("add", this.onRackAdd_), R.emitter.on("remove", this.onRackRemove_), R.emitter.on("inputchange", this.onRackInputChange_), R.emitter.on("monitorupdate", this.onRackMonitorUpdate_), R.children.forEach((W) => {
            this.setUpApi_(W);
          });
        }
        get children() {
          return this.controller_.rack.children.map((p) => xt(this.apiSet_, p));
        }
        addInput(p, b, R) {
          const W = R ?? {}, ge = this.controller_.view.element.ownerDocument, ke = this.pool_.createInput(ge, yt(p, b, W.presetKey), W), lt = new nt(ke);
          return this.add(lt, W.index);
        }
        addMonitor(p, b, R) {
          const W = R ?? {}, ge = this.controller_.view.element.ownerDocument, ke = this.pool_.createMonitor(ge, yt(p, b), W), lt = new at(ke);
          return this.add(lt, W.index);
        }
        addFolder(p) {
          return We(this, p);
        }
        addButton(p) {
          return Xe(this, p);
        }
        addSeparator(p) {
          return Ne(this, p);
        }
        addTab(p) {
          return ct(this, p);
        }
        add(p, b) {
          this.controller_.rack.add(p.controller_, b);
          const R = this.apiSet_.find((W) => W.controller_ === p.controller_);
          return R && this.apiSet_.remove(R), this.apiSet_.add(p), p;
        }
        remove(p) {
          this.controller_.rack.remove(p.controller_);
        }
        addBlade(p) {
          const b = this.controller_.view.element.ownerDocument, R = this.pool_.createBlade(b, p), W = this.pool_.createBladeApi(R);
          return this.add(W, p.index);
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
        setUpApi_(p) {
          this.apiSet_.find((R) => R.controller_ === p) || this.apiSet_.add(this.pool_.createBladeApi(p));
        }
        onRackAdd_(p) {
          this.setUpApi_(p.bladeController);
        }
        onRackRemove_(p) {
          if (p.isRoot) {
            const b = xt(this.apiSet_, p.bladeController);
            this.apiSet_.remove(b);
          }
        }
        onRackInputChange_(p) {
          const b = p.bladeController;
          if (b instanceof je) {
            const R = xt(this.apiSet_, b), W = b.binding;
            this.emitter_.emit("change", {
              event: new o(R, W.target.read(), W.target.presetKey, p.options.last)
            });
          } else if (b instanceof Le) {
            const R = xt(this.apiSet_, b);
            this.emitter_.emit("change", {
              event: new o(R, b.value.rawValue, void 0, p.options.last)
            });
          }
        }
        onRackMonitorUpdate_(p) {
          if (!(p.bladeController instanceof ft))
            throw g.shouldNeverHappen();
          const b = xt(this.apiSet_, p.bladeController), R = p.bladeController.binding;
          this.emitter_.emit("update", {
            event: new a(b, R.target.read(), R.target.presetKey)
          });
        }
      }
      class nn extends be {
        constructor(p, b) {
          super(p, new Mt(p.rackController, b)), this.emitter_ = new y(), this.controller_.foldable.value("expanded").emitter.on("change", (R) => {
            this.emitter_.emit("fold", {
              event: new l(this, R.sender.rawValue)
            });
          }), this.rackApi_.on("change", (R) => {
            this.emitter_.emit("change", {
              event: R
            });
          }), this.rackApi_.on("update", (R) => {
            this.emitter_.emit("update", {
              event: R
            });
          });
        }
        get expanded() {
          return this.controller_.foldable.get("expanded");
        }
        set expanded(p) {
          this.controller_.foldable.set("expanded", p);
        }
        get title() {
          return this.controller_.props.get("title");
        }
        set title(p) {
          this.controller_.props.set("title", p);
        }
        get children() {
          return this.rackApi_.children;
        }
        addInput(p, b, R) {
          return this.rackApi_.addInput(p, b, R);
        }
        addMonitor(p, b, R) {
          return this.rackApi_.addMonitor(p, b, R);
        }
        addFolder(p) {
          return this.rackApi_.addFolder(p);
        }
        addButton(p) {
          return this.rackApi_.addButton(p);
        }
        addSeparator(p) {
          return this.rackApi_.addSeparator(p);
        }
        addTab(p) {
          return this.rackApi_.addTab(p);
        }
        add(p, b) {
          return this.rackApi_.add(p, b);
        }
        remove(p) {
          this.rackApi_.remove(p);
        }
        addBlade(p) {
          return this.rackApi_.addBlade(p);
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
      }
      class zt extends Ue {
        constructor(p) {
          super({
            blade: p.blade,
            view: p.view,
            viewProps: p.rackController.viewProps
          }), this.rackController = p.rackController;
        }
      }
      class $t {
        constructor(p, b) {
          const R = x(b.viewName);
          this.element = p.createElement("div"), this.element.classList.add(R()), b.viewProps.bindClassModifiers(this.element);
        }
      }
      function qt(S, p) {
        for (let b = 0; b < S.length; b++) {
          const R = S[b];
          if (R instanceof je && R.binding === p)
            return R;
        }
        return null;
      }
      function en(S, p) {
        for (let b = 0; b < S.length; b++) {
          const R = S[b];
          if (R instanceof ft && R.binding === p)
            return R;
        }
        return null;
      }
      function xn(S, p) {
        for (let b = 0; b < S.length; b++) {
          const R = S[b];
          if (R instanceof Le && R.value === p)
            return R;
        }
        return null;
      }
      function on(S) {
        return S instanceof An ? S.rack : S instanceof zt ? S.rackController.rack : null;
      }
      function zi(S) {
        const p = on(S);
        return p ? p.bcSet_ : null;
      }
      class un {
        constructor(p) {
          var b, R;
          this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new y(), this.blade_ = (b = p.blade) !== null && b !== void 0 ? b : null, (R = this.blade_) === null || R === void 0 || R.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = p.viewProps, this.bcSet_ = new gt(zi), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
        }
        get children() {
          return this.bcSet_.items;
        }
        add(p, b) {
          var R;
          (R = p.parent) === null || R === void 0 || R.remove(p), f(p, "parent") ? p.parent = this : (p.parent_ = this, de({
            key: "parent",
            target: "BladeController",
            place: "BladeRack.add"
          })), this.bcSet_.add(p, b);
        }
        remove(p) {
          f(p, "parent") ? p.parent = null : (p.parent_ = null, de({
            key: "parent",
            target: "BladeController",
            place: "BladeRack.remove"
          })), this.bcSet_.remove(p);
        }
        find(p) {
          return this.bcSet_.allItems().filter((b) => b instanceof p);
        }
        onSetAdd_(p) {
          this.updatePositions_();
          const b = p.target === p.root;
          if (this.emitter.emit("add", {
            bladeController: p.item,
            index: p.index,
            isRoot: b,
            sender: this
          }), !b)
            return;
          const R = p.item;
          if (R.viewProps.emitter.on("change", this.onChildViewPropsChange_), R.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), R.viewProps.handleDispose(this.onChildDispose_), R instanceof je)
            R.binding.emitter.on("change", this.onChildInputChange_);
          else if (R instanceof ft)
            R.binding.emitter.on("update", this.onChildMonitorUpdate_);
          else if (R instanceof Le)
            R.value.emitter.on("change", this.onChildValueChange_);
          else {
            const W = on(R);
            if (W) {
              const ge = W.emitter;
              ge.on("layout", this.onDescendantLayout_), ge.on("inputchange", this.onDescendantInputChange_), ge.on("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        onSetRemove_(p) {
          this.updatePositions_();
          const b = p.target === p.root;
          if (this.emitter.emit("remove", {
            bladeController: p.item,
            isRoot: b,
            sender: this
          }), !b)
            return;
          const R = p.item;
          if (R instanceof je)
            R.binding.emitter.off("change", this.onChildInputChange_);
          else if (R instanceof ft)
            R.binding.emitter.off("update", this.onChildMonitorUpdate_);
          else if (R instanceof Le)
            R.value.emitter.off("change", this.onChildValueChange_);
          else {
            const W = on(R);
            if (W) {
              const ge = W.emitter;
              ge.off("layout", this.onDescendantLayout_), ge.off("inputchange", this.onDescendantInputChange_), ge.off("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        updatePositions_() {
          const p = this.bcSet_.items.filter((W) => !W.viewProps.get("hidden")), b = p[0], R = p[p.length - 1];
          this.bcSet_.items.forEach((W) => {
            const ge = [];
            W === b && (ge.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && ge.push("veryfirst")), W === R && (ge.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && ge.push("verylast")), W.blade.set("positions", ge);
          });
        }
        onChildPositionsChange_() {
          this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildViewPropsChange_(p) {
          this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildDispose_() {
          this.bcSet_.items.filter((b) => b.viewProps.get("disposed")).forEach((b) => {
            this.bcSet_.remove(b);
          });
        }
        onChildInputChange_(p) {
          const b = qt(this.find(je), p.sender);
          if (!b)
            throw g.alreadyDisposed();
          this.emitter.emit("inputchange", {
            bladeController: b,
            options: p.options,
            sender: this
          });
        }
        onChildMonitorUpdate_(p) {
          const b = en(this.find(ft), p.sender);
          if (!b)
            throw g.alreadyDisposed();
          this.emitter.emit("monitorupdate", {
            bladeController: b,
            sender: this
          });
        }
        onChildValueChange_(p) {
          const b = xn(this.find(Le), p.sender);
          if (!b)
            throw g.alreadyDisposed();
          this.emitter.emit("inputchange", {
            bladeController: b,
            options: p.options,
            sender: this
          });
        }
        onDescendantLayout_(p) {
          this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
          });
        }
        onDescendantInputChange_(p) {
          this.emitter.emit("inputchange", {
            bladeController: p.bladeController,
            options: p.options,
            sender: this
          });
        }
        onDescendantMonitorUpdate_(p) {
          this.emitter.emit("monitorupdate", {
            bladeController: p.bladeController,
            sender: this
          });
        }
        onBladePositionsChange_() {
          this.updatePositions_();
        }
      }
      class An extends Ue {
        constructor(p, b) {
          super(Object.assign(Object.assign({}, b), { view: new $t(p, {
            viewName: "brk",
            viewProps: b.viewProps
          }) })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
          const R = new un({
            blade: b.root ? void 0 : b.blade,
            viewProps: b.viewProps
          });
          R.emitter.on("add", this.onRackAdd_), R.emitter.on("remove", this.onRackRemove_), this.rack = R, this.viewProps.handleDispose(() => {
            for (let W = this.rack.children.length - 1; W >= 0; W--)
              this.rack.children[W].viewProps.set("disposed", !0);
          });
        }
        onRackAdd_(p) {
          p.isRoot && te(this.view.element, p.bladeController.view.element, p.index);
        }
        onRackRemove_(p) {
          p.isRoot && Se(p.bladeController.view.element);
        }
      }
      const O = x("cnt");
      class ee {
        constructor(p, b) {
          var R;
          this.className_ = x((R = b.viewName) !== null && R !== void 0 ? R : "fld"), this.element = p.createElement("div"), this.element.classList.add(this.className_(), O()), b.viewProps.bindClassModifiers(this.element), this.foldable_ = b.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), C(this.foldable_, "completed", T(this.element, this.className_(void 0, "cpl")));
          const W = p.createElement("button");
          W.classList.add(this.className_("b")), C(b.props, "title", (Zt) => {
            h(Zt) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
          }), b.viewProps.bindDisabled(W), this.element.appendChild(W), this.buttonElement = W;
          const ge = p.createElement("div");
          ge.classList.add(this.className_("i")), this.element.appendChild(ge);
          const ke = p.createElement("div");
          ke.classList.add(this.className_("t")), I(b.props.value("title"), ke), this.buttonElement.appendChild(ke), this.titleElement = ke;
          const lt = p.createElement("div");
          lt.classList.add(this.className_("m")), this.buttonElement.appendChild(lt);
          const Xt = b.containerElement;
          Xt.classList.add(this.className_("c")), this.element.appendChild(Xt), this.containerElement = Xt;
        }
      }
      class he extends zt {
        constructor(p, b) {
          var R;
          const W = tt.create((R = b.expanded) !== null && R !== void 0 ? R : !0), ge = new An(p, {
            blade: b.blade,
            root: b.root,
            viewProps: b.viewProps
          });
          super(Object.assign(Object.assign({}, b), { rackController: ge, view: new ee(p, {
            containerElement: ge.view.element,
            foldable: W,
            props: b.props,
            viewName: b.root ? "rot" : void 0,
            viewProps: b.viewProps
          }) })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = b.props, this.foldable = W, ve(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition();
          }), this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition();
          }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
        }
        get document() {
          return this.view.element.ownerDocument;
        }
        onTitleClick_() {
          this.foldable.set("expanded", !this.foldable.get("expanded"));
        }
      }
      const F = {
        id: "folder",
        type: "blade",
        accept(S) {
          const p = K, b = Q(S, {
            title: p.required.string,
            view: p.required.constant("folder"),
            expanded: p.optional.boolean
          });
          return b ? { params: b } : null;
        },
        controller(S) {
          return new he(S.document, {
            blade: S.blade,
            expanded: S.params.expanded,
            props: q.fromObject({
              title: S.params.title
            }),
            viewProps: S.viewProps
          });
        },
        api(S) {
          return S.controller instanceof he ? new nn(S.controller, S.pool) : null;
        }
      };
      class ie extends Le {
        constructor(p, b) {
          const R = b.valueController.viewProps;
          super(Object.assign(Object.assign({}, b), { value: b.valueController.value, view: new Ve(p, {
            props: b.props,
            viewProps: R
          }), viewProps: R })), this.props = b.props, this.valueController = b.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      class re extends n {
      }
      const ne = x("spr");
      class ae {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(ne()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("hr");
          R.classList.add(ne("r")), this.element.appendChild(R);
        }
      }
      class we extends Ue {
        constructor(p, b) {
          super(Object.assign(Object.assign({}, b), { view: new ae(p, {
            viewProps: b.viewProps
          }) }));
        }
      }
      const Pe = {
        id: "separator",
        type: "blade",
        accept(S) {
          const b = Q(S, {
            view: K.required.constant("separator")
          });
          return b ? { params: b } : null;
        },
        controller(S) {
          return new we(S.document, {
            blade: S.blade,
            viewProps: S.viewProps
          });
        },
        api(S) {
          return S.controller instanceof we ? new re(S.controller) : null;
        }
      }, Re = x("tbi");
      class He {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(Re()), b.viewProps.bindClassModifiers(this.element), C(b.props, "selected", (ge) => {
            ge ? this.element.classList.add(Re(void 0, "sel")) : this.element.classList.remove(Re(void 0, "sel"));
          });
          const R = p.createElement("button");
          R.classList.add(Re("b")), b.viewProps.bindDisabled(R), this.element.appendChild(R), this.buttonElement = R;
          const W = p.createElement("div");
          W.classList.add(Re("t")), I(b.props.value("title"), W), this.buttonElement.appendChild(W), this.titleElement = W;
        }
      }
      class qe {
        constructor(p, b) {
          this.emitter = new y(), this.onClick_ = this.onClick_.bind(this), this.props = b.props, this.viewProps = b.viewProps, this.view = new He(p, {
            props: b.props,
            viewProps: b.viewProps
          }), this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class Ke {
        constructor(p, b) {
          this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new qe(p, {
            props: b.itemProps,
            viewProps: Ee.create()
          }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new An(p, {
            blade: ot(),
            viewProps: Ee.create()
          }), this.props = b.props, C(this.props, "selected", (R) => {
            this.itemController.props.set("selected", R), this.contentController.viewProps.set("hidden", !R);
          });
        }
        get itemController() {
          return this.ic_;
        }
        get contentController() {
          return this.cc_;
        }
        onItemClick_() {
          this.props.set("selected", !0);
        }
      }
      class Je {
        constructor(p, b) {
          this.controller_ = p, this.rackApi_ = b;
        }
        get title() {
          var p;
          return (p = this.controller_.itemController.props.get("title")) !== null && p !== void 0 ? p : "";
        }
        set title(p) {
          this.controller_.itemController.props.set("title", p);
        }
        get selected() {
          return this.controller_.props.get("selected");
        }
        set selected(p) {
          this.controller_.props.set("selected", p);
        }
        get children() {
          return this.rackApi_.children;
        }
        addButton(p) {
          return this.rackApi_.addButton(p);
        }
        addFolder(p) {
          return this.rackApi_.addFolder(p);
        }
        addSeparator(p) {
          return this.rackApi_.addSeparator(p);
        }
        addTab(p) {
          return this.rackApi_.addTab(p);
        }
        add(p, b) {
          this.rackApi_.add(p, b);
        }
        remove(p) {
          this.rackApi_.remove(p);
        }
        addInput(p, b, R) {
          return this.rackApi_.addInput(p, b, R);
        }
        addMonitor(p, b, R) {
          return this.rackApi_.addMonitor(p, b, R);
        }
        addBlade(p) {
          return this.rackApi_.addBlade(p);
        }
      }
      class et extends be {
        constructor(p, b) {
          super(p, new Mt(p.rackController, b)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new y(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (R) => {
            this.emitter_.emit("change", {
              event: R
            });
          }), this.rackApi_.on("update", (R) => {
            this.emitter_.emit("update", {
              event: R
            });
          }), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((R) => {
            this.setUpPageApi_(R);
          });
        }
        get pages() {
          return this.controller_.pageSet.items.map((p) => {
            const b = this.pageApiMap_.get(p);
            if (!b)
              throw g.shouldNeverHappen();
            return b;
          });
        }
        addPage(p) {
          const b = this.controller_.view.element.ownerDocument, R = new Ke(b, {
            itemProps: q.fromObject({
              selected: !1,
              title: p.title
            }),
            props: q.fromObject({
              selected: !1
            })
          });
          this.controller_.add(R, p.index);
          const W = this.pageApiMap_.get(R);
          if (!W)
            throw g.shouldNeverHappen();
          return W;
        }
        removePage(p) {
          this.controller_.remove(p);
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
        setUpPageApi_(p) {
          const b = this.rackApi_.apiSet_.find((W) => W.controller_ === p.contentController);
          if (!b)
            throw g.shouldNeverHappen();
          const R = new Je(p, b);
          this.pageApiMap_.set(p, R);
        }
        onPageAdd_(p) {
          this.setUpPageApi_(p.item);
        }
        onPageRemove_(p) {
          if (!this.pageApiMap_.get(p.item))
            throw g.shouldNeverHappen();
          this.pageApiMap_.delete(p.item);
        }
        onSelect_(p) {
          this.emitter_.emit("select", {
            event: new c(this, p.rawValue)
          });
        }
      }
      const st = -1;
      class Et {
        constructor() {
          this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = j(!0), this.selectedIndex = j(st), this.items_ = [];
        }
        add(p, b) {
          const R = b ?? this.items_.length;
          this.items_.splice(R, 0, p), p.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
        }
        remove(p) {
          const b = this.items_.indexOf(p);
          b < 0 || (this.items_.splice(b, 1), p.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
        }
        keepSelection_() {
          if (this.items_.length === 0) {
            this.selectedIndex.rawValue = st, this.empty.rawValue = !0;
            return;
          }
          const p = this.items_.findIndex((b) => b.rawValue);
          p < 0 ? (this.items_.forEach((b, R) => {
            b.rawValue = R === 0;
          }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((b, R) => {
            b.rawValue = R === p;
          }), this.selectedIndex.rawValue = p), this.empty.rawValue = !1;
        }
        onItemSelectedChange_(p) {
          if (p.rawValue) {
            const b = this.items_.findIndex((R) => R === p.sender);
            this.items_.forEach((R, W) => {
              R.rawValue = W === b;
            }), this.selectedIndex.rawValue = b;
          } else
            this.keepSelection_();
        }
      }
      const kt = x("tab");
      class Ot {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(kt(), O()), b.viewProps.bindClassModifiers(this.element), E(b.empty, T(this.element, kt(void 0, "nop")));
          const R = p.createElement("div");
          R.classList.add(kt("t")), this.element.appendChild(R), this.itemsElement = R;
          const W = p.createElement("div");
          W.classList.add(kt("i")), this.element.appendChild(W);
          const ge = b.contentsElement;
          ge.classList.add(kt("c")), this.element.appendChild(ge), this.contentsElement = ge;
        }
      }
      class bt extends zt {
        constructor(p, b) {
          const R = new An(p, {
            blade: b.blade,
            viewProps: b.viewProps
          }), W = new Et();
          super({
            blade: b.blade,
            rackController: R,
            view: new Ot(p, {
              contentsElement: R.view.element,
              empty: W.empty,
              viewProps: b.viewProps
            })
          }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new gt(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = W;
        }
        get pageSet() {
          return this.pageSet_;
        }
        add(p, b) {
          this.pageSet_.add(p, b);
        }
        remove(p) {
          this.pageSet_.remove(this.pageSet_.items[p]);
        }
        onPageAdd_(p) {
          const b = p.item;
          te(this.view.itemsElement, b.itemController.view.element, p.index), b.itemController.viewProps.set("parent", this.viewProps), this.rackController.rack.add(b.contentController, p.index), this.tab.add(b.props.value("selected"));
        }
        onPageRemove_(p) {
          const b = p.item;
          Se(b.itemController.view.element), b.itemController.viewProps.set("parent", null), this.rackController.rack.remove(b.contentController), this.tab.remove(b.props.value("selected"));
        }
      }
      const Yt = {
        id: "tab",
        type: "blade",
        accept(S) {
          const p = K, b = Q(S, {
            pages: p.required.array(p.required.object({ title: p.required.string })),
            view: p.required.constant("tab")
          });
          return !b || b.pages.length === 0 ? null : { params: b };
        },
        controller(S) {
          const p = new bt(S.document, {
            blade: S.blade,
            viewProps: S.viewProps
          });
          return S.params.pages.forEach((b) => {
            const R = new Ke(S.document, {
              itemProps: q.fromObject({
                selected: !1,
                title: b.title
              }),
              props: q.fromObject({
                selected: !1
              })
            });
            p.add(R);
          }), p;
        },
        api(S) {
          return S.controller instanceof bt ? new et(S.controller, S.pool) : null;
        }
      };
      function St(S, p) {
        const b = S.accept(p.params);
        if (!b)
          return null;
        const R = K.optional.boolean(p.params.disabled).value, W = K.optional.boolean(p.params.hidden).value;
        return S.controller({
          blade: ot(),
          document: p.document,
          params: Object.assign(Object.assign({}, b.params), { disabled: R, hidden: W }),
          viewProps: Ee.create({
            disabled: R,
            hidden: W
          })
        });
      }
      class mn {
        constructor() {
          this.disabled = !1, this.emitter = new y();
        }
        dispose() {
        }
        tick() {
          this.disabled || this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class ii {
        constructor(p, b) {
          this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = p, this.emitter = new y(), this.interval_ = b, this.setTimer_();
        }
        get disabled() {
          return this.disabled_;
        }
        set disabled(p) {
          this.disabled_ = p, this.disabled_ ? this.clearTimer_() : this.setTimer_();
        }
        dispose() {
          this.clearTimer_();
        }
        clearTimer_() {
          if (this.timerId_ === null)
            return;
          const p = this.doc_.defaultView;
          p && p.clearInterval(this.timerId_), this.timerId_ = null;
        }
        setTimer_() {
          if (this.clearTimer_(), this.interval_ <= 0)
            return;
          const p = this.doc_.defaultView;
          p && (this.timerId_ = p.setInterval(this.onTick_, this.interval_));
        }
        onTick_() {
          this.disabled_ || this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class hn {
        constructor(p) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.reader = p.reader, this.writer = p.writer, this.emitter = new y(), this.value = p.value, this.value.emitter.on("change", this.onValueChange_), this.target = p.target, this.read();
        }
        read() {
          const p = this.target.read();
          p !== void 0 && (this.value.rawValue = this.reader(p));
        }
        write_(p) {
          this.writer(this.target, p);
        }
        onValueChange_(p) {
          this.write_(p.rawValue), this.emitter.emit("change", {
            options: p.options,
            rawValue: p.rawValue,
            sender: this
          });
        }
      }
      function jt(S, p) {
        for (; S.length < p; )
          S.push(void 0);
      }
      function Vt(S) {
        const p = [];
        return jt(p, S), j(p);
      }
      function zn(S) {
        const p = S.indexOf(void 0);
        return p < 0 ? S : S.slice(0, p);
      }
      function Jn(S, p) {
        const b = [...zn(S), p];
        return b.length > S.length ? b.splice(0, b.length - S.length) : jt(b, S.length), b;
      }
      class Pn {
        constructor(p) {
          this.onTick_ = this.onTick_.bind(this), this.reader_ = p.reader, this.target = p.target, this.emitter = new y(), this.value = p.value, this.ticker = p.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
        }
        dispose() {
          this.ticker.dispose();
        }
        read() {
          const p = this.target.read();
          if (p === void 0)
            return;
          const b = this.value.rawValue, R = this.reader_(p);
          this.value.rawValue = Jn(b, R), this.emitter.emit("update", {
            rawValue: R,
            sender: this
          });
        }
        onTick_(p) {
          this.read();
        }
      }
      class kn {
        constructor(p) {
          this.constraints = p;
        }
        constrain(p) {
          return this.constraints.reduce((b, R) => R.constrain(b), p);
        }
      }
      function Ji(S, p) {
        if (S instanceof p)
          return S;
        if (S instanceof kn) {
          const b = S.constraints.reduce((R, W) => R || (W instanceof p ? W : null), null);
          if (b)
            return b;
        }
        return null;
      }
      class Qi {
        constructor(p) {
          this.values = q.fromObject({
            max: p.max,
            min: p.min
          });
        }
        constrain(p) {
          const b = this.values.get("max"), R = this.values.get("min");
          return Math.min(Math.max(p, R), b);
        }
      }
      class ka {
        constructor(p) {
          this.values = q.fromObject({
            options: p
          });
        }
        get options() {
          return this.values.get("options");
        }
        constrain(p) {
          const b = this.values.get("options");
          return b.length === 0 || b.filter((W) => W.value === p).length > 0 ? p : b[0].value;
        }
      }
      class Ud {
        constructor(p) {
          this.values = q.fromObject({
            max: p.max,
            min: p.min
          });
        }
        get maxValue() {
          return this.values.get("max");
        }
        get minValue() {
          return this.values.get("min");
        }
        constrain(p) {
          const b = this.values.get("max"), R = this.values.get("min");
          let W = p;
          return h(R) || (W = Math.max(W, R)), h(b) || (W = Math.min(W, b)), W;
        }
      }
      class Oa {
        constructor(p, b = 0) {
          this.step = p, this.origin = b;
        }
        constrain(p) {
          const b = this.origin % this.step, R = Math.round((p - b) / this.step);
          return b + R * this.step;
        }
      }
      const ea = x("lst");
      class vm {
        constructor(p, b) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = b.props, this.element = p.createElement("div"), this.element.classList.add(ea()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("select");
          R.classList.add(ea("s")), b.viewProps.bindDisabled(R), this.element.appendChild(R), this.selectElement = R;
          const W = p.createElement("div");
          W.classList.add(ea("m")), W.appendChild(ue(p, "dropdown")), this.element.appendChild(W), b.value.emitter.on("change", this.onValueChange_), this.value_ = b.value, C(this.props_, "options", (ge) => {
            ye(this.selectElement), ge.forEach((ke) => {
              const lt = p.createElement("option");
              lt.textContent = ke.text, this.selectElement.appendChild(lt);
            }), this.update_();
          });
        }
        update_() {
          const p = this.props_.get("options").map((b) => b.value);
          this.selectElement.selectedIndex = p.indexOf(this.value_.rawValue);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class Ao {
        constructor(p, b) {
          this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = b.props, this.value = b.value, this.viewProps = b.viewProps, this.view = new vm(p, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
        }
        onSelectChange_(p) {
          const b = p.currentTarget;
          this.value.rawValue = this.props.get("options")[b.selectedIndex].value;
        }
      }
      const ta = x("pop");
      class Fa {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(ta()), b.viewProps.bindClassModifiers(this.element), E(b.shows, T(this.element, ta(void 0, "v")));
        }
      }
      class Na {
        constructor(p, b) {
          this.shows = j(!1), this.viewProps = b.viewProps, this.view = new Fa(p, {
            shows: this.shows,
            viewProps: this.viewProps
          });
        }
      }
      const kd = x("txt");
      class Gl {
        constructor(p, b) {
          this.onChange_ = this.onChange_.bind(this), this.element = p.createElement("div"), this.element.classList.add(kd()), b.viewProps.bindClassModifiers(this.element), this.props_ = b.props, this.props_.emitter.on("change", this.onChange_);
          const R = p.createElement("input");
          R.classList.add(kd("i")), R.type = "text", b.viewProps.bindDisabled(R), this.element.appendChild(R), this.inputElement = R, b.value.emitter.on("change", this.onChange_), this.value_ = b.value, this.refresh();
        }
        refresh() {
          const p = this.props_.get("formatter");
          this.inputElement.value = p(this.value_.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class Ba {
        constructor(p, b) {
          this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = b.parser, this.props = b.props, this.value = b.value, this.viewProps = b.viewProps, this.view = new Gl(p, {
            props: b.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(p) {
          const R = p.currentTarget.value, W = this.parser_(R);
          h(W) || (this.value.rawValue = W), this.view.refresh();
        }
      }
      function Od(S) {
        return String(S);
      }
      function Fd(S) {
        return S === "false" ? !1 : !!S;
      }
      function Hl(S) {
        return Od(S);
      }
      class Nd {
        constructor(p) {
          this.text = p;
        }
        evaluate() {
          return Number(this.text);
        }
        toString() {
          return this.text;
        }
      }
      const _m = {
        "**": (S, p) => Math.pow(S, p),
        "*": (S, p) => S * p,
        "/": (S, p) => S / p,
        "%": (S, p) => S % p,
        "+": (S, p) => S + p,
        "-": (S, p) => S - p,
        "<<": (S, p) => S << p,
        ">>": (S, p) => S >> p,
        ">>>": (S, p) => S >>> p,
        "&": (S, p) => S & p,
        "^": (S, p) => S ^ p,
        "|": (S, p) => S | p
      };
      class ms {
        constructor(p, b, R) {
          this.left = b, this.operator = p, this.right = R;
        }
        evaluate() {
          const p = _m[this.operator];
          if (!p)
            throw new Error(`unexpected binary operator: '${this.operator}`);
          return p(this.left.evaluate(), this.right.evaluate());
        }
        toString() {
          return [
            "b(",
            this.left.toString(),
            this.operator,
            this.right.toString(),
            ")"
          ].join(" ");
        }
      }
      const Bd = {
        "+": (S) => S,
        "-": (S) => -S,
        "~": (S) => ~S
      };
      class ym {
        constructor(p, b) {
          this.operator = p, this.expression = b;
        }
        evaluate() {
          const p = Bd[this.operator];
          if (!p)
            throw new Error(`unexpected unary operator: '${this.operator}`);
          return p(this.expression.evaluate());
        }
        toString() {
          return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
        }
      }
      function Uu(S) {
        return (p, b) => {
          for (let R = 0; R < S.length; R++) {
            const W = S[R](p, b);
            if (W !== "")
              return W;
          }
          return "";
        };
      }
      function na(S, p) {
        var b;
        const R = S.substr(p).match(/^\s+/);
        return (b = R && R[0]) !== null && b !== void 0 ? b : "";
      }
      function xm(S, p) {
        const b = S.substr(p, 1);
        return b.match(/^[1-9]$/) ? b : "";
      }
      function za(S, p) {
        var b;
        const R = S.substr(p).match(/^[0-9]+/);
        return (b = R && R[0]) !== null && b !== void 0 ? b : "";
      }
      function Wl(S, p) {
        const b = za(S, p);
        if (b !== "")
          return b;
        const R = S.substr(p, 1);
        if (p += 1, R !== "-" && R !== "+")
          return "";
        const W = za(S, p);
        return W === "" ? "" : R + W;
      }
      function ia(S, p) {
        const b = S.substr(p, 1);
        if (p += 1, b.toLowerCase() !== "e")
          return "";
        const R = Wl(S, p);
        return R === "" ? "" : b + R;
      }
      function ao(S, p) {
        const b = S.substr(p, 1);
        if (b === "0")
          return b;
        const R = xm(S, p);
        return p += R.length, R === "" ? "" : R + za(S, p);
      }
      function bm(S, p) {
        const b = ao(S, p);
        if (p += b.length, b === "")
          return "";
        const R = S.substr(p, 1);
        if (p += R.length, R !== ".")
          return "";
        const W = za(S, p);
        return p += W.length, b + R + W + ia(S, p);
      }
      function zd(S, p) {
        const b = S.substr(p, 1);
        if (p += b.length, b !== ".")
          return "";
        const R = za(S, p);
        return p += R.length, R === "" ? "" : b + R + ia(S, p);
      }
      function Vd(S, p) {
        const b = ao(S, p);
        return p += b.length, b === "" ? "" : b + ia(S, p);
      }
      const Xl = Uu([
        bm,
        zd,
        Vd
      ]);
      function wm(S, p) {
        var b;
        const R = S.substr(p).match(/^[01]+/);
        return (b = R && R[0]) !== null && b !== void 0 ? b : "";
      }
      function Yl(S, p) {
        const b = S.substr(p, 2);
        if (p += b.length, b.toLowerCase() !== "0b")
          return "";
        const R = wm(S, p);
        return R === "" ? "" : b + R;
      }
      function Gd(S, p) {
        var b;
        const R = S.substr(p).match(/^[0-7]+/);
        return (b = R && R[0]) !== null && b !== void 0 ? b : "";
      }
      function Or(S, p) {
        const b = S.substr(p, 2);
        if (p += b.length, b.toLowerCase() !== "0o")
          return "";
        const R = Gd(S, p);
        return R === "" ? "" : b + R;
      }
      function py(S, p) {
        var b;
        const R = S.substr(p).match(/^[0-9a-f]+/i);
        return (b = R && R[0]) !== null && b !== void 0 ? b : "";
      }
      function ku(S, p) {
        const b = S.substr(p, 2);
        if (p += b.length, b.toLowerCase() !== "0x")
          return "";
        const R = py(S, p);
        return R === "" ? "" : b + R;
      }
      const Ou = Uu([
        Yl,
        Or,
        ku
      ]), Sm = Uu([
        Ou,
        Xl
      ]);
      function my(S, p) {
        const b = Sm(S, p);
        return p += b.length, b === "" ? null : {
          evaluable: new Nd(b),
          cursor: p
        };
      }
      function wr(S, p) {
        const b = S.substr(p, 1);
        if (p += b.length, b !== "(")
          return null;
        const R = cM(S, p);
        if (!R)
          return null;
        p = R.cursor, p += na(S, p).length;
        const W = S.substr(p, 1);
        return p += W.length, W !== ")" ? null : {
          evaluable: R.evaluable,
          cursor: p
        };
      }
      function gs(S, p) {
        var b;
        return (b = my(S, p)) !== null && b !== void 0 ? b : wr(S, p);
      }
      function or(S, p) {
        const b = gs(S, p);
        if (b)
          return b;
        const R = S.substr(p, 1);
        if (p += R.length, R !== "+" && R !== "-" && R !== "~")
          return null;
        const W = or(S, p);
        return W ? (p = W.cursor, {
          cursor: p,
          evaluable: new ym(R, W.evaluable)
        }) : null;
      }
      function Co(S, p, b) {
        b += na(p, b).length;
        const R = S.filter((W) => p.startsWith(W, b))[0];
        return R ? (b += R.length, b += na(p, b).length, {
          cursor: b,
          operator: R
        }) : null;
      }
      function Mm(S, p) {
        return (b, R) => {
          const W = S(b, R);
          if (!W)
            return null;
          R = W.cursor;
          let ge = W.evaluable;
          for (; ; ) {
            const ke = Co(p, b, R);
            if (!ke)
              break;
            R = ke.cursor;
            const lt = S(b, R);
            if (!lt)
              return null;
            R = lt.cursor, ge = new ms(ke.operator, ge, lt.evaluable);
          }
          return ge ? {
            cursor: R,
            evaluable: ge
          } : null;
        };
      }
      const nU = [
        ["**"],
        ["*", "/", "%"],
        ["+", "-"],
        ["<<", ">>>", ">>"],
        ["&"],
        ["^"],
        ["|"]
      ].reduce((S, p) => Mm(S, p), or);
      function cM(S, p) {
        return p += na(S, p).length, nU(S, p);
      }
      function iU(S) {
        const p = cM(S, 0);
        return !p || p.cursor + na(S, p.cursor).length !== S.length ? null : p.evaluable;
      }
      function ra(S) {
        var p;
        const b = iU(S);
        return (p = b == null ? void 0 : b.evaluate()) !== null && p !== void 0 ? p : null;
      }
      function uM(S) {
        if (typeof S == "number")
          return S;
        if (typeof S == "string") {
          const p = ra(S);
          if (!h(p))
            return p;
        }
        return 0;
      }
      function rU(S) {
        return String(S);
      }
      function ar(S) {
        return (p) => p.toFixed(Math.max(Math.min(S, 20), 0));
      }
      const sU = ar(0);
      function Em(S) {
        return sU(S) + "%";
      }
      function hM(S) {
        return String(S);
      }
      function gy(S) {
        return S;
      }
      function Hd({ primary: S, secondary: p, forward: b, backward: R }) {
        let W = !1;
        function ge(ke) {
          W || (W = !0, ke(), W = !1);
        }
        S.emitter.on("change", (ke) => {
          ge(() => {
            p.setRawValue(b(S, p), ke.options);
          });
        }), p.emitter.on("change", (ke) => {
          ge(() => {
            S.setRawValue(R(S, p), ke.options);
          }), ge(() => {
            p.setRawValue(b(S, p), ke.options);
          });
        }), ge(() => {
          p.setRawValue(b(S, p), {
            forceEmit: !1,
            last: !0
          });
        });
      }
      function Qr(S, p) {
        const b = S * (p.altKey ? 0.1 : 1) * (p.shiftKey ? 10 : 1);
        return p.upKey ? +b : p.downKey ? -b : 0;
      }
      function Wd(S) {
        return {
          altKey: S.altKey,
          downKey: S.key === "ArrowDown",
          shiftKey: S.shiftKey,
          upKey: S.key === "ArrowUp"
        };
      }
      function sa(S) {
        return {
          altKey: S.altKey,
          downKey: S.key === "ArrowLeft",
          shiftKey: S.shiftKey,
          upKey: S.key === "ArrowRight"
        };
      }
      function oU(S) {
        return S === "ArrowUp" || S === "ArrowDown";
      }
      function dM(S) {
        return oU(S) || S === "ArrowLeft" || S === "ArrowRight";
      }
      function vy(S, p) {
        var b, R;
        const W = p.ownerDocument.defaultView, ge = p.getBoundingClientRect();
        return {
          x: S.pageX - (((b = W && W.scrollX) !== null && b !== void 0 ? b : 0) + ge.left),
          y: S.pageY - (((R = W && W.scrollY) !== null && R !== void 0 ? R : 0) + ge.top)
        };
      }
      class jl {
        constructor(p) {
          this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = p, this.emitter = new y(), p.addEventListener("touchstart", this.onTouchStart_, {
            passive: !1
          }), p.addEventListener("touchmove", this.onTouchMove_, {
            passive: !0
          }), p.addEventListener("touchend", this.onTouchEnd_), p.addEventListener("mousedown", this.onMouseDown_);
        }
        computePosition_(p) {
          const b = this.elem_.getBoundingClientRect();
          return {
            bounds: {
              width: b.width,
              height: b.height
            },
            point: p ? {
              x: p.x,
              y: p.y
            } : null
          };
        }
        onMouseDown_(p) {
          var b;
          p.preventDefault(), (b = p.currentTarget) === null || b === void 0 || b.focus();
          const R = this.elem_.ownerDocument;
          R.addEventListener("mousemove", this.onDocumentMouseMove_), R.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
            altKey: p.altKey,
            data: this.computePosition_(vy(p, this.elem_)),
            sender: this,
            shiftKey: p.shiftKey
          });
        }
        onDocumentMouseMove_(p) {
          this.emitter.emit("move", {
            altKey: p.altKey,
            data: this.computePosition_(vy(p, this.elem_)),
            sender: this,
            shiftKey: p.shiftKey
          });
        }
        onDocumentMouseUp_(p) {
          const b = this.elem_.ownerDocument;
          b.removeEventListener("mousemove", this.onDocumentMouseMove_), b.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
            altKey: p.altKey,
            data: this.computePosition_(vy(p, this.elem_)),
            sender: this,
            shiftKey: p.shiftKey
          });
        }
        onTouchStart_(p) {
          p.preventDefault();
          const b = p.targetTouches.item(0), R = this.elem_.getBoundingClientRect();
          this.emitter.emit("down", {
            altKey: p.altKey,
            data: this.computePosition_(b ? {
              x: b.clientX - R.left,
              y: b.clientY - R.top
            } : void 0),
            sender: this,
            shiftKey: p.shiftKey
          }), this.lastTouch_ = b;
        }
        onTouchMove_(p) {
          const b = p.targetTouches.item(0), R = this.elem_.getBoundingClientRect();
          this.emitter.emit("move", {
            altKey: p.altKey,
            data: this.computePosition_(b ? {
              x: b.clientX - R.left,
              y: b.clientY - R.top
            } : void 0),
            sender: this,
            shiftKey: p.shiftKey
          }), this.lastTouch_ = b;
        }
        onTouchEnd_(p) {
          var b;
          const R = (b = p.targetTouches.item(0)) !== null && b !== void 0 ? b : this.lastTouch_, W = this.elem_.getBoundingClientRect();
          this.emitter.emit("up", {
            altKey: p.altKey,
            data: this.computePosition_(R ? {
              x: R.clientX - W.left,
              y: R.clientY - W.top
            } : void 0),
            sender: this,
            shiftKey: p.shiftKey
          });
        }
      }
      function li(S, p, b, R, W) {
        const ge = (S - p) / (b - p);
        return R + ge * (W - R);
      }
      function fM(S) {
        return String(S.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
      }
      function Vi(S, p, b) {
        return Math.min(Math.max(S, p), b);
      }
      function pM(S, p) {
        return (S % p + p) % p;
      }
      const Vs = x("txt");
      class aU {
        constructor(p, b) {
          this.onChange_ = this.onChange_.bind(this), this.props_ = b.props, this.props_.emitter.on("change", this.onChange_), this.element = p.createElement("div"), this.element.classList.add(Vs(), Vs(void 0, "num")), b.arrayPosition && this.element.classList.add(Vs(void 0, b.arrayPosition)), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("input");
          R.classList.add(Vs("i")), R.type = "text", b.viewProps.bindDisabled(R), this.element.appendChild(R), this.inputElement = R, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = b.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Vs()), this.inputElement.classList.add(Vs("i"));
          const W = p.createElement("div");
          W.classList.add(Vs("k")), this.element.appendChild(W), this.knobElement = W;
          const ge = p.createElementNS(Me, "svg");
          ge.classList.add(Vs("g")), this.knobElement.appendChild(ge);
          const ke = p.createElementNS(Me, "path");
          ke.classList.add(Vs("gb")), ge.appendChild(ke), this.guideBodyElem_ = ke;
          const lt = p.createElementNS(Me, "path");
          lt.classList.add(Vs("gh")), ge.appendChild(lt), this.guideHeadElem_ = lt;
          const Xt = p.createElement("div");
          Xt.classList.add(x("tt")()), this.knobElement.appendChild(Xt), this.tooltipElem_ = Xt, b.value.emitter.on("change", this.onChange_), this.value = b.value, this.refresh();
        }
        onDraggingChange_(p) {
          if (p.rawValue === null) {
            this.element.classList.remove(Vs(void 0, "drg"));
            return;
          }
          this.element.classList.add(Vs(void 0, "drg"));
          const b = p.rawValue / this.props_.get("draggingScale"), R = b + (b > 0 ? -1 : b < 0 ? 1 : 0), W = Vi(-R, -4, 4);
          this.guideHeadElem_.setAttributeNS(null, "d", [`M ${R + W},0 L${R},4 L${R + W},8`, `M ${b},-1 L${b},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${b},4`);
          const ge = this.props_.get("formatter");
          this.tooltipElem_.textContent = ge(this.value.rawValue), this.tooltipElem_.style.left = `${b}px`;
        }
        refresh() {
          const p = this.props_.get("formatter");
          this.inputElement.value = p(this.value.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class Xd {
        constructor(p, b) {
          var R;
          this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = b.baseStep, this.parser_ = b.parser, this.props = b.props, this.sliderProps_ = (R = b.sliderProps) !== null && R !== void 0 ? R : null, this.value = b.value, this.viewProps = b.viewProps, this.dragging_ = j(null), this.view = new aU(p, {
            arrayPosition: b.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
          const W = new jl(this.view.knobElement);
          W.emitter.on("down", this.onPointerDown_), W.emitter.on("move", this.onPointerMove_), W.emitter.on("up", this.onPointerUp_);
        }
        constrainValue_(p) {
          var b, R;
          const W = (b = this.sliderProps_) === null || b === void 0 ? void 0 : b.get("minValue"), ge = (R = this.sliderProps_) === null || R === void 0 ? void 0 : R.get("maxValue");
          let ke = p;
          return W !== void 0 && (ke = Math.max(ke, W)), ge !== void 0 && (ke = Math.min(ke, ge)), ke;
        }
        onInputChange_(p) {
          const R = p.currentTarget.value, W = this.parser_(R);
          h(W) || (this.value.rawValue = this.constrainValue_(W)), this.view.refresh();
        }
        onInputKeyDown_(p) {
          const b = Qr(this.baseStep_, Wd(p));
          b !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + b), {
            forceEmit: !1,
            last: !1
          });
        }
        onInputKeyUp_(p) {
          Qr(this.baseStep_, Wd(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }
        onPointerDown_() {
          this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
        }
        computeDraggingValue_(p) {
          if (!p.point)
            return null;
          const b = p.point.x - p.bounds.width / 2;
          return this.constrainValue_(this.originRawValue_ + b * this.props.get("draggingScale"));
        }
        onPointerMove_(p) {
          const b = this.computeDraggingValue_(p.data);
          b !== null && (this.value.setRawValue(b, {
            forceEmit: !1,
            last: !1
          }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
        }
        onPointerUp_(p) {
          const b = this.computeDraggingValue_(p.data);
          b !== null && (this.value.setRawValue(b, {
            forceEmit: !0,
            last: !0
          }), this.dragging_.rawValue = null);
        }
      }
      const _y = x("sld");
      class lU {
        constructor(p, b) {
          this.onChange_ = this.onChange_.bind(this), this.props_ = b.props, this.props_.emitter.on("change", this.onChange_), this.element = p.createElement("div"), this.element.classList.add(_y()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("div");
          R.classList.add(_y("t")), b.viewProps.bindTabIndex(R), this.element.appendChild(R), this.trackElement = R;
          const W = p.createElement("div");
          W.classList.add(_y("k")), this.trackElement.appendChild(W), this.knobElement = W, b.value.emitter.on("change", this.onChange_), this.value = b.value, this.update_();
        }
        update_() {
          const p = Vi(li(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
          this.knobElement.style.width = `${p}%`;
        }
        onChange_() {
          this.update_();
        }
      }
      class cU {
        constructor(p, b) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = b.baseStep, this.value = b.value, this.viewProps = b.viewProps, this.props = b.props, this.view = new lU(p, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new jl(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(p, b) {
          p.point && this.value.setRawValue(li(Vi(p.point.x, 0, p.bounds.width), 0, p.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), b);
        }
        onPointerDownOrMove_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerUp_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !0,
            last: !0
          });
        }
        onKeyDown_(p) {
          const b = Qr(this.baseStep_, sa(p));
          b !== 0 && this.value.setRawValue(this.value.rawValue + b, {
            forceEmit: !1,
            last: !1
          });
        }
        onKeyUp_(p) {
          Qr(this.baseStep_, sa(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }
      }
      const yy = x("sldtxt");
      class uU {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(yy());
          const R = p.createElement("div");
          R.classList.add(yy("s")), this.sliderView_ = b.sliderView, R.appendChild(this.sliderView_.element), this.element.appendChild(R);
          const W = p.createElement("div");
          W.classList.add(yy("t")), this.textView_ = b.textView, W.appendChild(this.textView_.element), this.element.appendChild(W);
        }
      }
      class xy {
        constructor(p, b) {
          this.value = b.value, this.viewProps = b.viewProps, this.sliderC_ = new cU(p, {
            baseStep: b.baseStep,
            props: b.sliderProps,
            value: b.value,
            viewProps: this.viewProps
          }), this.textC_ = new Xd(p, {
            baseStep: b.baseStep,
            parser: b.parser,
            props: b.textProps,
            sliderProps: b.sliderProps,
            value: b.value,
            viewProps: b.viewProps
          }), this.view = new uU(p, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
          });
        }
        get sliderController() {
          return this.sliderC_;
        }
        get textController() {
          return this.textC_;
        }
      }
      function Yd(S, p) {
        S.write(p);
      }
      function Tm(S) {
        const p = K;
        if (Array.isArray(S))
          return p.required.array(p.required.object({
            text: p.required.string,
            value: p.required.raw
          }))(S).value;
        if (typeof S == "object")
          return p.required.raw(S).value;
      }
      function mM(S) {
        if (S === "inline" || S === "popup")
          return S;
      }
      function Va(S) {
        const p = K;
        return p.required.object({
          max: p.optional.number,
          min: p.optional.number,
          step: p.optional.number
        })(S).value;
      }
      function gM(S) {
        if (Array.isArray(S))
          return S;
        const p = [];
        return Object.keys(S).forEach((b) => {
          p.push({ text: b, value: S[b] });
        }), p;
      }
      function by(S) {
        return h(S) ? null : new ka(gM(S));
      }
      function hU(S) {
        const p = S ? Ji(S, Oa) : null;
        return p ? p.step : null;
      }
      function Am(S, p) {
        const b = S && Ji(S, Oa);
        return b ? fM(b.step) : Math.max(fM(p), 2);
      }
      function Fu(S) {
        const p = hU(S);
        return p ?? 1;
      }
      function Nu(S, p) {
        var b;
        const R = S && Ji(S, Oa), W = Math.abs((b = R == null ? void 0 : R.step) !== null && b !== void 0 ? b : p);
        return W === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(W)) - 1);
      }
      const Cm = x("ckb");
      class dU {
        constructor(p, b) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.element = p.createElement("div"), this.element.classList.add(Cm()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("label");
          R.classList.add(Cm("l")), this.element.appendChild(R);
          const W = p.createElement("input");
          W.classList.add(Cm("i")), W.type = "checkbox", R.appendChild(W), this.inputElement = W, b.viewProps.bindDisabled(this.inputElement);
          const ge = p.createElement("div");
          ge.classList.add(Cm("w")), R.appendChild(ge);
          const ke = ue(p, "check");
          ge.appendChild(ke), b.value.emitter.on("change", this.onValueChange_), this.value = b.value, this.update_();
        }
        update_() {
          this.inputElement.checked = this.value.rawValue;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class fU {
        constructor(p, b) {
          this.onInputChange_ = this.onInputChange_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new dU(p, {
            value: this.value,
            viewProps: this.viewProps
          }), this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(p) {
          const b = p.currentTarget;
          this.value.rawValue = b.checked;
        }
      }
      function pU(S) {
        const p = [], b = by(S.options);
        return b && p.push(b), new kn(p);
      }
      const mU = {
        id: "input-bool",
        type: "input",
        accept: (S, p) => {
          if (typeof S != "boolean")
            return null;
          const R = Q(p, {
            options: K.optional.custom(Tm)
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => Fd,
          constraint: (S) => pU(S.params),
          writer: (S) => Yd
        },
        controller: (S) => {
          const p = S.document, b = S.value, R = S.constraint, W = R && Ji(R, ka);
          return W ? new Ao(p, {
            props: new q({
              options: W.values.value("options")
            }),
            value: b,
            viewProps: S.viewProps
          }) : new fU(p, {
            value: b,
            viewProps: S.viewProps
          });
        }
      }, ql = x("col");
      class gU {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(ql()), b.foldable.bindExpandedClass(this.element, ql(void 0, "expanded")), C(b.foldable, "completed", T(this.element, ql(void 0, "cpl")));
          const R = p.createElement("div");
          R.classList.add(ql("h")), this.element.appendChild(R);
          const W = p.createElement("div");
          W.classList.add(ql("s")), R.appendChild(W), this.swatchElement = W;
          const ge = p.createElement("div");
          if (ge.classList.add(ql("t")), R.appendChild(ge), this.textElement = ge, b.pickerLayout === "inline") {
            const ke = p.createElement("div");
            ke.classList.add(ql("p")), this.element.appendChild(ke), this.pickerElement = ke;
          } else
            this.pickerElement = null;
        }
      }
      function vU(S, p, b) {
        const R = Vi(S / 255, 0, 1), W = Vi(p / 255, 0, 1), ge = Vi(b / 255, 0, 1), ke = Math.max(R, W, ge), lt = Math.min(R, W, ge), Xt = ke - lt;
        let Zt = 0, Cn = 0;
        const Rn = (lt + ke) / 2;
        return Xt !== 0 && (Cn = Xt / (1 - Math.abs(ke + lt - 1)), R === ke ? Zt = (W - ge) / Xt : W === ke ? Zt = 2 + (ge - R) / Xt : Zt = 4 + (R - W) / Xt, Zt = Zt / 6 + (Zt < 0 ? 1 : 0)), [Zt * 360, Cn * 100, Rn * 100];
      }
      function _U(S, p, b) {
        const R = (S % 360 + 360) % 360, W = Vi(p / 100, 0, 1), ge = Vi(b / 100, 0, 1), ke = (1 - Math.abs(2 * ge - 1)) * W, lt = ke * (1 - Math.abs(R / 60 % 2 - 1)), Xt = ge - ke / 2;
        let Zt, Cn, Rn;
        return R >= 0 && R < 60 ? [Zt, Cn, Rn] = [ke, lt, 0] : R >= 60 && R < 120 ? [Zt, Cn, Rn] = [lt, ke, 0] : R >= 120 && R < 180 ? [Zt, Cn, Rn] = [0, ke, lt] : R >= 180 && R < 240 ? [Zt, Cn, Rn] = [0, lt, ke] : R >= 240 && R < 300 ? [Zt, Cn, Rn] = [lt, 0, ke] : [Zt, Cn, Rn] = [ke, 0, lt], [(Zt + Xt) * 255, (Cn + Xt) * 255, (Rn + Xt) * 255];
      }
      function yU(S, p, b) {
        const R = Vi(S / 255, 0, 1), W = Vi(p / 255, 0, 1), ge = Vi(b / 255, 0, 1), ke = Math.max(R, W, ge), lt = Math.min(R, W, ge), Xt = ke - lt;
        let Zt;
        Xt === 0 ? Zt = 0 : ke === R ? Zt = 60 * (((W - ge) / Xt % 6 + 6) % 6) : ke === W ? Zt = 60 * ((ge - R) / Xt + 2) : Zt = 60 * ((R - W) / Xt + 4);
        const Cn = ke === 0 ? 0 : Xt / ke, Rn = ke;
        return [Zt, Cn * 100, Rn * 100];
      }
      function vM(S, p, b) {
        const R = pM(S, 360), W = Vi(p / 100, 0, 1), ge = Vi(b / 100, 0, 1), ke = ge * W, lt = ke * (1 - Math.abs(R / 60 % 2 - 1)), Xt = ge - ke;
        let Zt, Cn, Rn;
        return R >= 0 && R < 60 ? [Zt, Cn, Rn] = [ke, lt, 0] : R >= 60 && R < 120 ? [Zt, Cn, Rn] = [lt, ke, 0] : R >= 120 && R < 180 ? [Zt, Cn, Rn] = [0, ke, lt] : R >= 180 && R < 240 ? [Zt, Cn, Rn] = [0, lt, ke] : R >= 240 && R < 300 ? [Zt, Cn, Rn] = [lt, 0, ke] : [Zt, Cn, Rn] = [ke, 0, lt], [(Zt + Xt) * 255, (Cn + Xt) * 255, (Rn + Xt) * 255];
      }
      function xU(S, p, b) {
        const R = b + p * (100 - Math.abs(2 * b - 100)) / 200;
        return [
          S,
          R !== 0 ? p * (100 - Math.abs(2 * b - 100)) / R : 0,
          b + p * (100 - Math.abs(2 * b - 100)) / (2 * 100)
        ];
      }
      function bU(S, p, b) {
        const R = 100 - Math.abs(b * (200 - p) / 100 - 100);
        return [S, R !== 0 ? p * b / R : 0, b * (200 - p) / (2 * 100)];
      }
      function Zl(S) {
        return [S[0], S[1], S[2]];
      }
      function _M(S, p) {
        return [S[0], S[1], S[2], p];
      }
      const wU = {
        hsl: {
          hsl: (S, p, b) => [S, p, b],
          hsv: xU,
          rgb: _U
        },
        hsv: {
          hsl: bU,
          hsv: (S, p, b) => [S, p, b],
          rgb: vM
        },
        rgb: {
          hsl: vU,
          hsv: yU,
          rgb: (S, p, b) => [S, p, b]
        }
      };
      function Pm(S, p) {
        return [
          p === "float" ? 1 : S === "rgb" ? 255 : 360,
          p === "float" ? 1 : S === "rgb" ? 255 : 100,
          p === "float" ? 1 : S === "rgb" ? 255 : 100
        ];
      }
      function SU(S, p) {
        return S === p ? p : pM(S, p);
      }
      function MU(S, p, b) {
        var R;
        const W = Pm(p, b);
        return [
          p === "rgb" ? Vi(S[0], 0, W[0]) : SU(S[0], W[0]),
          Vi(S[1], 0, W[1]),
          Vi(S[2], 0, W[2]),
          Vi((R = S[3]) !== null && R !== void 0 ? R : 1, 0, 1)
        ];
      }
      function yM(S, p, b, R) {
        const W = Pm(p, b), ge = Pm(p, R);
        return S.map((ke, lt) => ke / W[lt] * ge[lt]);
      }
      function EU(S, p, b) {
        const R = yM(S, p.mode, p.type, "int"), W = wU[p.mode][b.mode](...R);
        return yM(W, b.mode, "int", b.type);
      }
      function Rm(S, p) {
        return typeof S != "object" || h(S) ? !1 : p in S && typeof S[p] == "number";
      }
      class gn {
        static black(p = "int") {
          return new gn([0, 0, 0], "rgb", p);
        }
        static fromObject(p, b = "int") {
          const R = "a" in p ? [p.r, p.g, p.b, p.a] : [p.r, p.g, p.b];
          return new gn(R, "rgb", b);
        }
        static toRgbaObject(p, b = "int") {
          return p.toRgbaObject(b);
        }
        static isRgbColorObject(p) {
          return Rm(p, "r") && Rm(p, "g") && Rm(p, "b");
        }
        static isRgbaColorObject(p) {
          return this.isRgbColorObject(p) && Rm(p, "a");
        }
        static isColorObject(p) {
          return this.isRgbColorObject(p);
        }
        static equals(p, b) {
          if (p.mode !== b.mode)
            return !1;
          const R = p.comps_, W = b.comps_;
          for (let ge = 0; ge < R.length; ge++)
            if (R[ge] !== W[ge])
              return !1;
          return !0;
        }
        constructor(p, b, R = "int") {
          this.mode = b, this.type = R, this.comps_ = MU(p, b, R);
        }
        getComponents(p, b = "int") {
          return _M(EU(Zl(this.comps_), { mode: this.mode, type: this.type }, { mode: p ?? this.mode, type: b }), this.comps_[3]);
        }
        toRgbaObject(p = "int") {
          const b = this.getComponents("rgb", p);
          return {
            r: b[0],
            g: b[1],
            b: b[2],
            a: b[3]
          };
        }
      }
      const Ga = x("colp");
      class TU {
        constructor(p, b) {
          this.alphaViews_ = null, this.element = p.createElement("div"), this.element.classList.add(Ga()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("div");
          R.classList.add(Ga("hsv"));
          const W = p.createElement("div");
          W.classList.add(Ga("sv")), this.svPaletteView_ = b.svPaletteView, W.appendChild(this.svPaletteView_.element), R.appendChild(W);
          const ge = p.createElement("div");
          ge.classList.add(Ga("h")), this.hPaletteView_ = b.hPaletteView, ge.appendChild(this.hPaletteView_.element), R.appendChild(ge), this.element.appendChild(R);
          const ke = p.createElement("div");
          if (ke.classList.add(Ga("rgb")), this.textView_ = b.textView, ke.appendChild(this.textView_.element), this.element.appendChild(ke), b.alphaViews) {
            this.alphaViews_ = {
              palette: b.alphaViews.palette,
              text: b.alphaViews.text
            };
            const lt = p.createElement("div");
            lt.classList.add(Ga("a"));
            const Xt = p.createElement("div");
            Xt.classList.add(Ga("ap")), Xt.appendChild(this.alphaViews_.palette.element), lt.appendChild(Xt);
            const Zt = p.createElement("div");
            Zt.classList.add(Ga("at")), Zt.appendChild(this.alphaViews_.text.element), lt.appendChild(Zt), this.element.appendChild(lt);
          }
        }
        get allFocusableElements() {
          const p = [
            this.svPaletteView_.element,
            this.hPaletteView_.element,
            this.textView_.modeSelectElement,
            ...this.textView_.textViews.map((b) => b.inputElement)
          ];
          return this.alphaViews_ && p.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), p;
        }
      }
      function AU(S) {
        return S === "int" ? "int" : S === "float" ? "float" : void 0;
      }
      function wy(S) {
        const p = K;
        return Q(S, {
          alpha: p.optional.boolean,
          color: p.optional.object({
            alpha: p.optional.boolean,
            type: p.optional.custom(AU)
          }),
          expanded: p.optional.boolean,
          picker: p.optional.custom(mM)
        });
      }
      function Kl(S) {
        return S ? 0.1 : 1;
      }
      function $l(S) {
        var p;
        return (p = S.color) === null || p === void 0 ? void 0 : p.type;
      }
      function CU(S, p) {
        return S.alpha === p.alpha && S.mode === p.mode && S.notation === p.notation && S.type === p.type;
      }
      function Gs(S, p) {
        const b = S.match(/^(.+)%$/);
        return Math.min(b ? parseFloat(b[1]) * 0.01 * p : parseFloat(S), p);
      }
      const PU = {
        deg: (S) => S,
        grad: (S) => S * 360 / 400,
        rad: (S) => S * 360 / (2 * Math.PI),
        turn: (S) => S * 360
      };
      function xM(S) {
        const p = S.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
        if (!p)
          return parseFloat(S);
        const b = parseFloat(p[1]), R = p[2];
        return PU[R](b);
      }
      function bM(S) {
        const p = S.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!p)
          return null;
        const b = [
          Gs(p[1], 255),
          Gs(p[2], 255),
          Gs(p[3], 255)
        ];
        return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) ? null : b;
      }
      function wM(S) {
        return (p) => {
          const b = bM(p);
          return b ? new gn(b, "rgb", S) : null;
        };
      }
      function SM(S) {
        const p = S.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!p)
          return null;
        const b = [
          Gs(p[1], 255),
          Gs(p[2], 255),
          Gs(p[3], 255),
          Gs(p[4], 1)
        ];
        return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) || isNaN(b[3]) ? null : b;
      }
      function MM(S) {
        return (p) => {
          const b = SM(p);
          return b ? new gn(b, "rgb", S) : null;
        };
      }
      function EM(S) {
        const p = S.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!p)
          return null;
        const b = [
          xM(p[1]),
          Gs(p[2], 100),
          Gs(p[3], 100)
        ];
        return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) ? null : b;
      }
      function TM(S) {
        return (p) => {
          const b = EM(p);
          return b ? new gn(b, "hsl", S) : null;
        };
      }
      function AM(S) {
        const p = S.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!p)
          return null;
        const b = [
          xM(p[1]),
          Gs(p[2], 100),
          Gs(p[3], 100),
          Gs(p[4], 1)
        ];
        return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) || isNaN(b[3]) ? null : b;
      }
      function CM(S) {
        return (p) => {
          const b = AM(p);
          return b ? new gn(b, "hsl", S) : null;
        };
      }
      function PM(S) {
        const p = S.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (p)
          return [
            parseInt(p[1] + p[1], 16),
            parseInt(p[2] + p[2], 16),
            parseInt(p[3] + p[3], 16)
          ];
        const b = S.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        return b ? [
          parseInt(b[1], 16),
          parseInt(b[2], 16),
          parseInt(b[3], 16)
        ] : null;
      }
      function RU(S) {
        const p = PM(S);
        return p ? new gn(p, "rgb", "int") : null;
      }
      function RM(S) {
        const p = S.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (p)
          return [
            parseInt(p[1] + p[1], 16),
            parseInt(p[2] + p[2], 16),
            parseInt(p[3] + p[3], 16),
            li(parseInt(p[4] + p[4], 16), 0, 255, 0, 1)
          ];
        const b = S.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        return b ? [
          parseInt(b[1], 16),
          parseInt(b[2], 16),
          parseInt(b[3], 16),
          li(parseInt(b[4], 16), 0, 255, 0, 1)
        ] : null;
      }
      function DU(S) {
        const p = RM(S);
        return p ? new gn(p, "rgb", "int") : null;
      }
      function DM(S) {
        const p = S.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!p)
          return null;
        const b = [
          parseFloat(p[1]),
          parseFloat(p[2]),
          parseFloat(p[3])
        ];
        return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) ? null : b;
      }
      function IM(S) {
        return (p) => {
          const b = DM(p);
          return b ? new gn(b, "rgb", S) : null;
        };
      }
      function LM(S) {
        const p = S.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!p)
          return null;
        const b = [
          parseFloat(p[1]),
          parseFloat(p[2]),
          parseFloat(p[3]),
          parseFloat(p[4])
        ];
        return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) || isNaN(b[3]) ? null : b;
      }
      function UM(S) {
        return (p) => {
          const b = LM(p);
          return b ? new gn(b, "rgb", S) : null;
        };
      }
      const IU = [
        {
          parser: PM,
          result: {
            alpha: !1,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: RM,
          result: {
            alpha: !0,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: bM,
          result: {
            alpha: !1,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: SM,
          result: {
            alpha: !0,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: EM,
          result: {
            alpha: !1,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: AM,
          result: {
            alpha: !0,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: DM,
          result: {
            alpha: !1,
            mode: "rgb",
            notation: "object"
          }
        },
        {
          parser: LM,
          result: {
            alpha: !0,
            mode: "rgb",
            notation: "object"
          }
        }
      ];
      function LU(S) {
        return IU.reduce((p, { parser: b, result: R }) => p || (b(S) ? R : null), null);
      }
      function Sy(S, p = "int") {
        const b = LU(S);
        return b ? b.notation === "hex" && p !== "float" ? Object.assign(Object.assign({}, b), { type: "int" }) : b.notation === "func" ? Object.assign(Object.assign({}, b), { type: p }) : null : null;
      }
      const kM = {
        int: [
          RU,
          DU,
          wM("int"),
          MM("int"),
          TM("int"),
          CM("int"),
          IM("int"),
          UM("int")
        ],
        float: [
          wM("float"),
          MM("float"),
          TM("float"),
          CM("float"),
          IM("float"),
          UM("float")
        ]
      };
      function UU(S) {
        const p = kM[S];
        return (b) => {
          if (typeof b != "string")
            return gn.black(S);
          const R = p.reduce((W, ge) => W || ge(b), null);
          return R ?? gn.black(S);
        };
      }
      function My(S) {
        const p = kM[S];
        return (b) => p.reduce((R, W) => R || W(b), null);
      }
      function OM(S) {
        const p = Vi(Math.floor(S), 0, 255).toString(16);
        return p.length === 1 ? `0${p}` : p;
      }
      function FM(S, p = "#") {
        const b = Zl(S.getComponents("rgb")).map(OM).join("");
        return `${p}${b}`;
      }
      function Ey(S, p = "#") {
        const b = S.getComponents("rgb"), R = [b[0], b[1], b[2], b[3] * 255].map(OM).join("");
        return `${p}${R}`;
      }
      function NM(S, p) {
        const b = ar(p === "float" ? 2 : 0);
        return `rgb(${Zl(S.getComponents("rgb", p)).map((W) => b(W)).join(", ")})`;
      }
      function kU(S) {
        return (p) => NM(p, S);
      }
      function Dm(S, p) {
        const b = ar(2), R = ar(p === "float" ? 2 : 0);
        return `rgba(${S.getComponents("rgb", p).map((ge, ke) => (ke === 3 ? b : R)(ge)).join(", ")})`;
      }
      function OU(S) {
        return (p) => Dm(p, S);
      }
      function FU(S) {
        const p = [
          ar(0),
          Em,
          Em
        ];
        return `hsl(${Zl(S.getComponents("hsl")).map((R, W) => p[W](R)).join(", ")})`;
      }
      function NU(S) {
        const p = [
          ar(0),
          Em,
          Em,
          ar(2)
        ];
        return `hsla(${S.getComponents("hsl").map((R, W) => p[W](R)).join(", ")})`;
      }
      function BM(S, p) {
        const b = ar(p === "float" ? 2 : 0), R = ["r", "g", "b"];
        return `{${Zl(S.getComponents("rgb", p)).map((ge, ke) => `${R[ke]}: ${b(ge)}`).join(", ")}}`;
      }
      function BU(S) {
        return (p) => BM(p, S);
      }
      function zM(S, p) {
        const b = ar(2), R = ar(p === "float" ? 2 : 0), W = ["r", "g", "b", "a"];
        return `{${S.getComponents("rgb", p).map((ke, lt) => {
          const Xt = lt === 3 ? b : R;
          return `${W[lt]}: ${Xt(ke)}`;
        }).join(", ")}}`;
      }
      function zU(S) {
        return (p) => zM(p, S);
      }
      const VU = [
        {
          format: {
            alpha: !1,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: FM
        },
        {
          format: {
            alpha: !0,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: Ey
        },
        {
          format: {
            alpha: !1,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: FU
        },
        {
          format: {
            alpha: !0,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: NU
        },
        ...["int", "float"].reduce((S, p) => [
          ...S,
          {
            format: {
              alpha: !1,
              mode: "rgb",
              notation: "func",
              type: p
            },
            stringifier: kU(p)
          },
          {
            format: {
              alpha: !0,
              mode: "rgb",
              notation: "func",
              type: p
            },
            stringifier: OU(p)
          },
          {
            format: {
              alpha: !1,
              mode: "rgb",
              notation: "object",
              type: p
            },
            stringifier: BU(p)
          },
          {
            format: {
              alpha: !0,
              mode: "rgb",
              notation: "object",
              type: p
            },
            stringifier: zU(p)
          }
        ], [])
      ];
      function Ty(S) {
        return VU.reduce((p, b) => p || (CU(b.format, S) ? b.stringifier : null), null);
      }
      const jd = x("apl");
      class GU {
        constructor(p, b) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.value = b.value, this.value.emitter.on("change", this.onValueChange_), this.element = p.createElement("div"), this.element.classList.add(jd()), b.viewProps.bindClassModifiers(this.element), b.viewProps.bindTabIndex(this.element);
          const R = p.createElement("div");
          R.classList.add(jd("b")), this.element.appendChild(R);
          const W = p.createElement("div");
          W.classList.add(jd("c")), R.appendChild(W), this.colorElem_ = W;
          const ge = p.createElement("div");
          ge.classList.add(jd("m")), this.element.appendChild(ge), this.markerElem_ = ge;
          const ke = p.createElement("div");
          ke.classList.add(jd("p")), this.markerElem_.appendChild(ke), this.previewElem_ = ke, this.update_();
        }
        update_() {
          const p = this.value.rawValue, b = p.getComponents("rgb"), R = new gn([b[0], b[1], b[2], 0], "rgb"), W = new gn([b[0], b[1], b[2], 255], "rgb"), ge = [
            "to right",
            Dm(R),
            Dm(W)
          ];
          this.colorElem_.style.background = `linear-gradient(${ge.join(",")})`, this.previewElem_.style.backgroundColor = Dm(p);
          const ke = li(b[3], 0, 1, 0, 100);
          this.markerElem_.style.left = `${ke}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class HU {
        constructor(p, b) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new GU(p, {
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new jl(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(p, b) {
          if (!p.point)
            return;
          const R = p.point.x / p.bounds.width, W = this.value.rawValue, [ge, ke, lt] = W.getComponents("hsv");
          this.value.setRawValue(new gn([ge, ke, lt, R], "hsv"), b);
        }
        onPointerDown_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerMove_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerUp_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !0,
            last: !0
          });
        }
        onKeyDown_(p) {
          const b = Qr(Kl(!0), sa(p));
          if (b === 0)
            return;
          const R = this.value.rawValue, [W, ge, ke, lt] = R.getComponents("hsv");
          this.value.setRawValue(new gn([W, ge, ke, lt + b], "hsv"), {
            forceEmit: !1,
            last: !1
          });
        }
        onKeyUp_(p) {
          Qr(Kl(!0), sa(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }
      }
      const Bu = x("coltxt");
      function WU(S) {
        const p = S.createElement("select"), b = [
          { text: "RGB", value: "rgb" },
          { text: "HSL", value: "hsl" },
          { text: "HSV", value: "hsv" }
        ];
        return p.appendChild(b.reduce((R, W) => {
          const ge = S.createElement("option");
          return ge.textContent = W.text, ge.value = W.value, R.appendChild(ge), R;
        }, S.createDocumentFragment())), p;
      }
      class XU {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(Bu()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("div");
          R.classList.add(Bu("m")), this.modeElem_ = WU(p), this.modeElem_.classList.add(Bu("ms")), R.appendChild(this.modeSelectElement), b.viewProps.bindDisabled(this.modeElem_);
          const W = p.createElement("div");
          W.classList.add(Bu("mm")), W.appendChild(ue(p, "dropdown")), R.appendChild(W), this.element.appendChild(R);
          const ge = p.createElement("div");
          ge.classList.add(Bu("w")), this.element.appendChild(ge), this.textsElem_ = ge, this.textViews_ = b.textViews, this.applyTextViews_(), E(b.colorMode, (ke) => {
            this.modeElem_.value = ke;
          });
        }
        get modeSelectElement() {
          return this.modeElem_;
        }
        get textViews() {
          return this.textViews_;
        }
        set textViews(p) {
          this.textViews_ = p, this.applyTextViews_();
        }
        applyTextViews_() {
          ye(this.textsElem_);
          const p = this.element.ownerDocument;
          this.textViews_.forEach((b) => {
            const R = p.createElement("div");
            R.classList.add(Bu("c")), R.appendChild(b.element), this.textsElem_.appendChild(R);
          });
        }
      }
      function YU(S) {
        return ar(S === "float" ? 2 : 0);
      }
      function jU(S, p, b) {
        const R = Pm(S, p)[b];
        return new Qi({
          min: 0,
          max: R
        });
      }
      function Ay(S, p, b) {
        return new Xd(S, {
          arrayPosition: b === 0 ? "fst" : b === 2 ? "lst" : "mid",
          baseStep: Kl(!1),
          parser: p.parser,
          props: q.fromObject({
            draggingScale: p.colorType === "float" ? 0.01 : 1,
            formatter: YU(p.colorType)
          }),
          value: j(0, {
            constraint: jU(p.colorMode, p.colorType, b)
          }),
          viewProps: p.viewProps
        });
      }
      class qU {
        constructor(p, b) {
          this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = b.colorType, this.parser_ = b.parser, this.value = b.value, this.viewProps = b.viewProps, this.colorMode = j(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(p), this.view = new XU(p, {
            colorMode: this.colorMode,
            textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
            viewProps: this.viewProps
          }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
        }
        createComponentControllers_(p) {
          const b = {
            colorMode: this.colorMode.rawValue,
            colorType: this.colorType_,
            parser: this.parser_,
            viewProps: this.viewProps
          }, R = [
            Ay(p, b, 0),
            Ay(p, b, 1),
            Ay(p, b, 2)
          ];
          return R.forEach((W, ge) => {
            Hd({
              primary: this.value,
              secondary: W.value,
              forward: (ke) => ke.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[ge],
              backward: (ke, lt) => {
                const Xt = this.colorMode.rawValue, Zt = ke.rawValue.getComponents(Xt, this.colorType_);
                return Zt[ge] = lt.rawValue, new gn(_M(Zl(Zt), Zt[3]), Xt, this.colorType_);
              }
            });
          }), R;
        }
        onModeSelectChange_(p) {
          const b = p.currentTarget;
          this.colorMode.rawValue = b.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [
            this.ccs_[0].view,
            this.ccs_[1].view,
            this.ccs_[2].view
          ];
        }
      }
      const Cy = x("hpl");
      class ZU {
        constructor(p, b) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.value = b.value, this.value.emitter.on("change", this.onValueChange_), this.element = p.createElement("div"), this.element.classList.add(Cy()), b.viewProps.bindClassModifiers(this.element), b.viewProps.bindTabIndex(this.element);
          const R = p.createElement("div");
          R.classList.add(Cy("c")), this.element.appendChild(R);
          const W = p.createElement("div");
          W.classList.add(Cy("m")), this.element.appendChild(W), this.markerElem_ = W, this.update_();
        }
        update_() {
          const p = this.value.rawValue, [b] = p.getComponents("hsv");
          this.markerElem_.style.backgroundColor = NM(new gn([b, 100, 100], "hsv"));
          const R = li(b, 0, 360, 0, 100);
          this.markerElem_.style.left = `${R}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class KU {
        constructor(p, b) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new ZU(p, {
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new jl(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(p, b) {
          if (!p.point)
            return;
          const R = li(Vi(p.point.x, 0, p.bounds.width), 0, p.bounds.width, 0, 360), W = this.value.rawValue, [, ge, ke, lt] = W.getComponents("hsv");
          this.value.setRawValue(new gn([R, ge, ke, lt], "hsv"), b);
        }
        onPointerDown_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerMove_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerUp_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !0,
            last: !0
          });
        }
        onKeyDown_(p) {
          const b = Qr(Kl(!1), sa(p));
          if (b === 0)
            return;
          const R = this.value.rawValue, [W, ge, ke, lt] = R.getComponents("hsv");
          this.value.setRawValue(new gn([W + b, ge, ke, lt], "hsv"), {
            forceEmit: !1,
            last: !1
          });
        }
        onKeyUp_(p) {
          Qr(Kl(!1), sa(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }
      }
      const Py = x("svp"), VM = 64;
      class $U {
        constructor(p, b) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.value = b.value, this.value.emitter.on("change", this.onValueChange_), this.element = p.createElement("div"), this.element.classList.add(Py()), b.viewProps.bindClassModifiers(this.element), b.viewProps.bindTabIndex(this.element);
          const R = p.createElement("canvas");
          R.height = VM, R.width = VM, R.classList.add(Py("c")), this.element.appendChild(R), this.canvasElement = R;
          const W = p.createElement("div");
          W.classList.add(Py("m")), this.element.appendChild(W), this.markerElem_ = W, this.update_();
        }
        update_() {
          const p = Y(this.canvasElement);
          if (!p)
            return;
          const R = this.value.rawValue.getComponents("hsv"), W = this.canvasElement.width, ge = this.canvasElement.height, ke = p.getImageData(0, 0, W, ge), lt = ke.data;
          for (let Cn = 0; Cn < ge; Cn++)
            for (let Rn = 0; Rn < W; Rn++) {
              const Jl = li(Rn, 0, W, 0, 100), Zd = li(Cn, 0, ge, 100, 0), Kd = vM(R[0], Jl, Zd), Im = (Cn * W + Rn) * 4;
              lt[Im] = Kd[0], lt[Im + 1] = Kd[1], lt[Im + 2] = Kd[2], lt[Im + 3] = 255;
            }
          p.putImageData(ke, 0, 0);
          const Xt = li(R[1], 0, 100, 0, 100);
          this.markerElem_.style.left = `${Xt}%`;
          const Zt = li(R[2], 0, 100, 100, 0);
          this.markerElem_.style.top = `${Zt}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class JU {
        constructor(p, b) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new $U(p, {
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new jl(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(p, b) {
          if (!p.point)
            return;
          const R = li(p.point.x, 0, p.bounds.width, 0, 100), W = li(p.point.y, 0, p.bounds.height, 100, 0), [ge, , , ke] = this.value.rawValue.getComponents("hsv");
          this.value.setRawValue(new gn([ge, R, W, ke], "hsv"), b);
        }
        onPointerDown_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerMove_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerUp_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !0,
            last: !0
          });
        }
        onKeyDown_(p) {
          dM(p.key) && p.preventDefault();
          const [b, R, W, ge] = this.value.rawValue.getComponents("hsv"), ke = Kl(!1), lt = Qr(ke, sa(p)), Xt = Qr(ke, Wd(p));
          lt === 0 && Xt === 0 || this.value.setRawValue(new gn([b, R + lt, W + Xt, ge], "hsv"), {
            forceEmit: !1,
            last: !1
          });
        }
        onKeyUp_(p) {
          const b = Kl(!1), R = Qr(b, sa(p)), W = Qr(b, Wd(p));
          R === 0 && W === 0 || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }
      }
      class QU {
        constructor(p, b) {
          this.value = b.value, this.viewProps = b.viewProps, this.hPaletteC_ = new KU(p, {
            value: this.value,
            viewProps: this.viewProps
          }), this.svPaletteC_ = new JU(p, {
            value: this.value,
            viewProps: this.viewProps
          }), this.alphaIcs_ = b.supportsAlpha ? {
            palette: new HU(p, {
              value: this.value,
              viewProps: this.viewProps
            }),
            text: new Xd(p, {
              parser: ra,
              baseStep: 0.1,
              props: q.fromObject({
                draggingScale: 0.01,
                formatter: ar(2)
              }),
              value: j(0, {
                constraint: new Qi({ min: 0, max: 1 })
              }),
              viewProps: this.viewProps
            })
          } : null, this.alphaIcs_ && Hd({
            primary: this.value,
            secondary: this.alphaIcs_.text.value,
            forward: (R) => R.rawValue.getComponents()[3],
            backward: (R, W) => {
              const ge = R.rawValue.getComponents();
              return ge[3] = W.rawValue, new gn(ge, R.rawValue.mode);
            }
          }), this.textC_ = new qU(p, {
            colorType: b.colorType,
            parser: ra,
            value: this.value,
            viewProps: this.viewProps
          }), this.view = new TU(p, {
            alphaViews: this.alphaIcs_ ? {
              palette: this.alphaIcs_.palette.view,
              text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: b.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textView: this.textC_.view,
            viewProps: this.viewProps
          });
        }
        get textController() {
          return this.textC_;
        }
      }
      const Ry = x("colsw");
      class ek {
        constructor(p, b) {
          this.onValueChange_ = this.onValueChange_.bind(this), b.value.emitter.on("change", this.onValueChange_), this.value = b.value, this.element = p.createElement("div"), this.element.classList.add(Ry()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("div");
          R.classList.add(Ry("sw")), this.element.appendChild(R), this.swatchElem_ = R;
          const W = p.createElement("button");
          W.classList.add(Ry("b")), b.viewProps.bindDisabled(W), this.element.appendChild(W), this.buttonElement = W, this.update_();
        }
        update_() {
          const p = this.value.rawValue;
          this.swatchElem_.style.backgroundColor = Ey(p);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class tk {
        constructor(p, b) {
          this.value = b.value, this.viewProps = b.viewProps, this.view = new ek(p, {
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      class Dy {
        constructor(p, b) {
          this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.foldable_ = tt.create(b.expanded), this.swatchC_ = new tk(p, {
            value: this.value,
            viewProps: this.viewProps
          });
          const R = this.swatchC_.view.buttonElement;
          R.addEventListener("blur", this.onButtonBlur_), R.addEventListener("click", this.onButtonClick_), this.textC_ = new Ba(p, {
            parser: b.parser,
            props: q.fromObject({
              formatter: b.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
          }), this.view = new gU(p, {
            foldable: this.foldable_,
            pickerLayout: b.pickerLayout
          }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = b.pickerLayout === "popup" ? new Na(p, {
            viewProps: this.viewProps
          }) : null;
          const W = new QU(p, {
            colorType: b.colorType,
            supportsAlpha: b.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
          });
          W.view.allFocusableElements.forEach((ge) => {
            ge.addEventListener("blur", this.onPopupChildBlur_), ge.addEventListener("keydown", this.onPopupChildKeydown_);
          }), this.pickerC_ = W, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(W.view.element), Hd({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: (ge) => ge.rawValue,
            backward: (ge, ke) => ke.rawValue
          })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), ve(this.foldable_, this.view.pickerElement));
        }
        get textController() {
          return this.textC_;
        }
        onButtonBlur_(p) {
          if (!this.popC_)
            return;
          const b = this.view.element, R = p.relatedTarget;
          (!R || !b.contains(R)) && (this.popC_.shows.rawValue = !1);
        }
        onButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
        }
        onPopupChildBlur_(p) {
          if (!this.popC_)
            return;
          const b = this.popC_.view.element, R = Ce(p);
          R && b.contains(R) || R && R === this.swatchC_.view.buttonElement && !Ye(b.ownerDocument) || (this.popC_.shows.rawValue = !1);
        }
        onPopupChildKeydown_(p) {
          this.popC_ ? p.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && p.key === "Escape" && this.swatchC_.view.buttonElement.focus();
        }
      }
      function nk(S, p) {
        return gn.isColorObject(S) ? gn.fromObject(S, p) : gn.black(p);
      }
      function ik(S) {
        return Zl(S.getComponents("rgb")).reduce((p, b) => p << 8 | Math.floor(b) & 255, 0);
      }
      function rk(S) {
        return S.getComponents("rgb").reduce((p, b, R) => {
          const W = Math.floor(R === 3 ? b * 255 : b) & 255;
          return p << 8 | W;
        }, 0) >>> 0;
      }
      function sk(S) {
        return new gn([S >> 16 & 255, S >> 8 & 255, S & 255], "rgb");
      }
      function ok(S) {
        return new gn([
          S >> 24 & 255,
          S >> 16 & 255,
          S >> 8 & 255,
          li(S & 255, 0, 255, 0, 1)
        ], "rgb");
      }
      function ak(S) {
        return typeof S != "number" ? gn.black() : sk(S);
      }
      function lk(S) {
        return typeof S != "number" ? gn.black() : ok(S);
      }
      function ck(S) {
        const p = Ty(S);
        return p ? (b, R) => {
          Yd(b, p(R));
        } : null;
      }
      function uk(S) {
        const p = S ? rk : ik;
        return (b, R) => {
          Yd(b, p(R));
        };
      }
      function hk(S, p, b) {
        const R = p.toRgbaObject(b);
        S.writeProperty("r", R.r), S.writeProperty("g", R.g), S.writeProperty("b", R.b), S.writeProperty("a", R.a);
      }
      function dk(S, p, b) {
        const R = p.toRgbaObject(b);
        S.writeProperty("r", R.r), S.writeProperty("g", R.g), S.writeProperty("b", R.b);
      }
      function fk(S, p) {
        return (b, R) => {
          S ? hk(b, R, p) : dk(b, R, p);
        };
      }
      function Iy(S) {
        var p;
        return !!(S != null && S.alpha || !((p = S == null ? void 0 : S.color) === null || p === void 0) && p.alpha);
      }
      function pk(S) {
        return S ? (p) => Ey(p, "0x") : (p) => FM(p, "0x");
      }
      function mk(S) {
        return "color" in S || "view" in S && S.view === "color";
      }
      const gk = {
        id: "input-color-number",
        type: "input",
        accept: (S, p) => {
          if (typeof S != "number" || !mk(p))
            return null;
          const b = wy(p);
          return b ? {
            initialValue: S,
            params: b
          } : null;
        },
        binding: {
          reader: (S) => Iy(S.params) ? lk : ak,
          equals: gn.equals,
          writer: (S) => uk(Iy(S.params))
        },
        controller: (S) => {
          const p = Iy(S.params), b = "expanded" in S.params ? S.params.expanded : void 0, R = "picker" in S.params ? S.params.picker : void 0;
          return new Dy(S.document, {
            colorType: "int",
            expanded: b ?? !1,
            formatter: pk(p),
            parser: My("int"),
            pickerLayout: R ?? "popup",
            supportsAlpha: p,
            value: S.value,
            viewProps: S.viewProps
          });
        }
      };
      function vk(S) {
        return gn.isRgbaColorObject(S);
      }
      function _k(S) {
        return (p) => nk(p, S);
      }
      function yk(S, p) {
        return (b) => S ? zM(b, p) : BM(b, p);
      }
      const xk = {
        id: "input-color-object",
        type: "input",
        accept: (S, p) => {
          if (!gn.isColorObject(S))
            return null;
          const b = wy(p);
          return b ? {
            initialValue: S,
            params: b
          } : null;
        },
        binding: {
          reader: (S) => _k($l(S.params)),
          equals: gn.equals,
          writer: (S) => fk(vk(S.initialValue), $l(S.params))
        },
        controller: (S) => {
          var p;
          const b = gn.isRgbaColorObject(S.initialValue), R = "expanded" in S.params ? S.params.expanded : void 0, W = "picker" in S.params ? S.params.picker : void 0, ge = (p = $l(S.params)) !== null && p !== void 0 ? p : "int";
          return new Dy(S.document, {
            colorType: ge,
            expanded: R ?? !1,
            formatter: yk(b, ge),
            parser: My(ge),
            pickerLayout: W ?? "popup",
            supportsAlpha: b,
            value: S.value,
            viewProps: S.viewProps
          });
        }
      }, bk = {
        id: "input-color-string",
        type: "input",
        accept: (S, p) => {
          if (typeof S != "string" || "view" in p && p.view === "text")
            return null;
          const b = Sy(S, $l(p));
          if (!b || !Ty(b))
            return null;
          const W = wy(p);
          return W ? {
            initialValue: S,
            params: W
          } : null;
        },
        binding: {
          reader: (S) => {
            var p;
            return UU((p = $l(S.params)) !== null && p !== void 0 ? p : "int");
          },
          equals: gn.equals,
          writer: (S) => {
            const p = Sy(S.initialValue, $l(S.params));
            if (!p)
              throw g.shouldNeverHappen();
            const b = ck(p);
            if (!b)
              throw g.notBindable();
            return b;
          }
        },
        controller: (S) => {
          const p = Sy(S.initialValue, $l(S.params));
          if (!p)
            throw g.shouldNeverHappen();
          const b = Ty(p);
          if (!b)
            throw g.shouldNeverHappen();
          const R = "expanded" in S.params ? S.params.expanded : void 0, W = "picker" in S.params ? S.params.picker : void 0;
          return new Dy(S.document, {
            colorType: p.type,
            expanded: R ?? !1,
            formatter: b,
            parser: My(p.type),
            pickerLayout: W ?? "popup",
            supportsAlpha: p.alpha,
            value: S.value,
            viewProps: S.viewProps
          });
        }
      };
      class Ha {
        constructor(p) {
          this.components = p.components, this.asm_ = p.assembly;
        }
        constrain(p) {
          const b = this.asm_.toComponents(p).map((R, W) => {
            var ge, ke;
            return (ke = (ge = this.components[W]) === null || ge === void 0 ? void 0 : ge.constrain(R)) !== null && ke !== void 0 ? ke : R;
          });
          return this.asm_.fromComponents(b);
        }
      }
      const GM = x("pndtxt");
      class wk {
        constructor(p, b) {
          this.textViews = b.textViews, this.element = p.createElement("div"), this.element.classList.add(GM()), this.textViews.forEach((R) => {
            const W = p.createElement("div");
            W.classList.add(GM("a")), W.appendChild(R.element), this.element.appendChild(W);
          });
        }
      }
      function Sk(S, p, b) {
        return new Xd(S, {
          arrayPosition: b === 0 ? "fst" : b === p.axes.length - 1 ? "lst" : "mid",
          baseStep: p.axes[b].baseStep,
          parser: p.parser,
          props: p.axes[b].textProps,
          value: j(0, {
            constraint: p.axes[b].constraint
          }),
          viewProps: p.viewProps
        });
      }
      class Ly {
        constructor(p, b) {
          this.value = b.value, this.viewProps = b.viewProps, this.acs_ = b.axes.map((R, W) => Sk(p, b, W)), this.acs_.forEach((R, W) => {
            Hd({
              primary: this.value,
              secondary: R.value,
              forward: (ge) => b.assembly.toComponents(ge.rawValue)[W],
              backward: (ge, ke) => {
                const lt = b.assembly.toComponents(ge.rawValue);
                return lt[W] = ke.rawValue, b.assembly.fromComponents(lt);
              }
            });
          }), this.view = new wk(p, {
            textViews: this.acs_.map((R) => R.view)
          });
        }
      }
      function HM(S, p) {
        return "step" in S && !h(S.step) ? new Oa(S.step, p) : null;
      }
      function WM(S) {
        return !h(S.max) && !h(S.min) ? new Qi({
          max: S.max,
          min: S.min
        }) : !h(S.max) || !h(S.min) ? new Ud({
          max: S.max,
          min: S.min
        }) : null;
      }
      function Mk(S) {
        const p = Ji(S, Qi);
        if (p)
          return [p.values.get("min"), p.values.get("max")];
        const b = Ji(S, Ud);
        return b ? [b.minValue, b.maxValue] : [void 0, void 0];
      }
      function Ek(S, p) {
        const b = [], R = HM(S, p);
        R && b.push(R);
        const W = WM(S);
        W && b.push(W);
        const ge = by(S.options);
        return ge && b.push(ge), new kn(b);
      }
      const Tk = {
        id: "input-number",
        type: "input",
        accept: (S, p) => {
          if (typeof S != "number")
            return null;
          const b = K, R = Q(p, {
            format: b.optional.function,
            max: b.optional.number,
            min: b.optional.number,
            options: b.optional.custom(Tm),
            step: b.optional.number
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => uM,
          constraint: (S) => Ek(S.params, S.initialValue),
          writer: (S) => Yd
        },
        controller: (S) => {
          var p;
          const b = S.value, R = S.constraint, W = R && Ji(R, ka);
          if (W)
            return new Ao(S.document, {
              props: new q({
                options: W.values.value("options")
              }),
              value: b,
              viewProps: S.viewProps
            });
          const ge = (p = "format" in S.params ? S.params.format : void 0) !== null && p !== void 0 ? p : ar(Am(R, b.rawValue)), ke = R && Ji(R, Qi);
          return ke ? new xy(S.document, {
            baseStep: Fu(R),
            parser: ra,
            sliderProps: new q({
              maxValue: ke.values.value("max"),
              minValue: ke.values.value("min")
            }),
            textProps: q.fromObject({
              draggingScale: Nu(R, b.rawValue),
              formatter: ge
            }),
            value: b,
            viewProps: S.viewProps
          }) : new Xd(S.document, {
            baseStep: Fu(R),
            parser: ra,
            props: q.fromObject({
              draggingScale: Nu(R, b.rawValue),
              formatter: ge
            }),
            value: b,
            viewProps: S.viewProps
          });
        }
      };
      class Wa {
        constructor(p = 0, b = 0) {
          this.x = p, this.y = b;
        }
        getComponents() {
          return [this.x, this.y];
        }
        static isObject(p) {
          if (h(p))
            return !1;
          const b = p.x, R = p.y;
          return !(typeof b != "number" || typeof R != "number");
        }
        static equals(p, b) {
          return p.x === b.x && p.y === b.y;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y
          };
        }
      }
      const XM = {
        toComponents: (S) => S.getComponents(),
        fromComponents: (S) => new Wa(...S)
      }, zu = x("p2d");
      class Ak {
        constructor(p, b) {
          this.element = p.createElement("div"), this.element.classList.add(zu()), b.viewProps.bindClassModifiers(this.element), E(b.expanded, T(this.element, zu(void 0, "expanded")));
          const R = p.createElement("div");
          R.classList.add(zu("h")), this.element.appendChild(R);
          const W = p.createElement("button");
          W.classList.add(zu("b")), W.appendChild(ue(p, "p2dpad")), b.viewProps.bindDisabled(W), R.appendChild(W), this.buttonElement = W;
          const ge = p.createElement("div");
          if (ge.classList.add(zu("t")), R.appendChild(ge), this.textElement = ge, b.pickerLayout === "inline") {
            const ke = p.createElement("div");
            ke.classList.add(zu("p")), this.element.appendChild(ke), this.pickerElement = ke;
          } else
            this.pickerElement = null;
        }
      }
      const Xa = x("p2dp");
      class Ck {
        constructor(p, b) {
          this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = b.invertsY, this.maxValue_ = b.maxValue, this.element = p.createElement("div"), this.element.classList.add(Xa()), b.layout === "popup" && this.element.classList.add(Xa(void 0, "p")), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("div");
          R.classList.add(Xa("p")), b.viewProps.bindTabIndex(R), this.element.appendChild(R), this.padElement = R;
          const W = p.createElementNS(Me, "svg");
          W.classList.add(Xa("g")), this.padElement.appendChild(W), this.svgElem_ = W;
          const ge = p.createElementNS(Me, "line");
          ge.classList.add(Xa("ax")), ge.setAttributeNS(null, "x1", "0"), ge.setAttributeNS(null, "y1", "50%"), ge.setAttributeNS(null, "x2", "100%"), ge.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(ge);
          const ke = p.createElementNS(Me, "line");
          ke.classList.add(Xa("ax")), ke.setAttributeNS(null, "x1", "50%"), ke.setAttributeNS(null, "y1", "0"), ke.setAttributeNS(null, "x2", "50%"), ke.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(ke);
          const lt = p.createElementNS(Me, "line");
          lt.classList.add(Xa("l")), lt.setAttributeNS(null, "x1", "50%"), lt.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(lt), this.lineElem_ = lt;
          const Xt = p.createElement("div");
          Xt.classList.add(Xa("m")), this.padElement.appendChild(Xt), this.markerElem_ = Xt, b.value.emitter.on("change", this.onValueChange_), this.value = b.value, this.update_();
        }
        get allFocusableElements() {
          return [this.padElement];
        }
        update_() {
          const [p, b] = this.value.rawValue.getComponents(), R = this.maxValue_, W = li(p, -R, +R, 0, 100), ge = li(b, -R, +R, 0, 100), ke = this.invertsY_ ? 100 - ge : ge;
          this.lineElem_.setAttributeNS(null, "x2", `${W}%`), this.lineElem_.setAttributeNS(null, "y2", `${ke}%`), this.markerElem_.style.left = `${W}%`, this.markerElem_.style.top = `${ke}%`;
        }
        onValueChange_() {
          this.update_();
        }
        onFoldableChange_() {
          this.update_();
        }
      }
      function YM(S, p, b) {
        return [
          Qr(p[0], sa(S)),
          Qr(p[1], Wd(S)) * (b ? 1 : -1)
        ];
      }
      class Pk {
        constructor(p, b) {
          this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.baseSteps_ = b.baseSteps, this.maxValue_ = b.maxValue, this.invertsY_ = b.invertsY, this.view = new Ck(p, {
            invertsY: this.invertsY_,
            layout: b.layout,
            maxValue: this.maxValue_,
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new jl(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
        }
        handlePointerEvent_(p, b) {
          if (!p.point)
            return;
          const R = this.maxValue_, W = li(p.point.x, 0, p.bounds.width, -R, +R), ge = li(this.invertsY_ ? p.bounds.height - p.point.y : p.point.y, 0, p.bounds.height, -R, +R);
          this.value.setRawValue(new Wa(W, ge), b);
        }
        onPointerDown_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerMove_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !1,
            last: !1
          });
        }
        onPointerUp_(p) {
          this.handlePointerEvent_(p.data, {
            forceEmit: !0,
            last: !0
          });
        }
        onPadKeyDown_(p) {
          dM(p.key) && p.preventDefault();
          const [b, R] = YM(p, this.baseSteps_, this.invertsY_);
          b === 0 && R === 0 || this.value.setRawValue(new Wa(this.value.rawValue.x + b, this.value.rawValue.y + R), {
            forceEmit: !1,
            last: !1
          });
        }
        onPadKeyUp_(p) {
          const [b, R] = YM(p, this.baseSteps_, this.invertsY_);
          b === 0 && R === 0 || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }
      }
      class Rk {
        constructor(p, b) {
          var R, W;
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.foldable_ = tt.create(b.expanded), this.popC_ = b.pickerLayout === "popup" ? new Na(p, {
            viewProps: this.viewProps
          }) : null;
          const ge = new Pk(p, {
            baseSteps: [b.axes[0].baseStep, b.axes[1].baseStep],
            invertsY: b.invertsY,
            layout: b.pickerLayout,
            maxValue: b.maxValue,
            value: this.value,
            viewProps: this.viewProps
          });
          ge.view.allFocusableElements.forEach((ke) => {
            ke.addEventListener("blur", this.onPopupChildBlur_), ke.addEventListener("keydown", this.onPopupChildKeydown_);
          }), this.pickerC_ = ge, this.textC_ = new Ly(p, {
            assembly: XM,
            axes: b.axes,
            parser: b.parser,
            value: this.value,
            viewProps: this.viewProps
          }), this.view = new Ak(p, {
            expanded: this.foldable_.value("expanded"),
            pickerLayout: b.pickerLayout,
            viewProps: this.viewProps
          }), this.view.textElement.appendChild(this.textC_.view.element), (R = this.view.buttonElement) === null || R === void 0 || R.addEventListener("blur", this.onPadButtonBlur_), (W = this.view.buttonElement) === null || W === void 0 || W.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Hd({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: (ke) => ke.rawValue,
            backward: (ke, lt) => lt.rawValue
          })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), ve(this.foldable_, this.view.pickerElement));
        }
        onPadButtonBlur_(p) {
          if (!this.popC_)
            return;
          const b = this.view.element, R = p.relatedTarget;
          (!R || !b.contains(R)) && (this.popC_.shows.rawValue = !1);
        }
        onPadButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
        }
        onPopupChildBlur_(p) {
          if (!this.popC_)
            return;
          const b = this.popC_.view.element, R = Ce(p);
          R && b.contains(R) || R && R === this.view.buttonElement && !Ye(b.ownerDocument) || (this.popC_.shows.rawValue = !1);
        }
        onPopupChildKeydown_(p) {
          this.popC_ ? p.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && p.key === "Escape" && this.view.buttonElement.focus();
        }
      }
      class Vu {
        constructor(p = 0, b = 0, R = 0) {
          this.x = p, this.y = b, this.z = R;
        }
        getComponents() {
          return [this.x, this.y, this.z];
        }
        static isObject(p) {
          if (h(p))
            return !1;
          const b = p.x, R = p.y, W = p.z;
          return !(typeof b != "number" || typeof R != "number" || typeof W != "number");
        }
        static equals(p, b) {
          return p.x === b.x && p.y === b.y && p.z === b.z;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z
          };
        }
      }
      const jM = {
        toComponents: (S) => S.getComponents(),
        fromComponents: (S) => new Vu(...S)
      };
      function Dk(S) {
        return Vu.isObject(S) ? new Vu(S.x, S.y, S.z) : new Vu();
      }
      function Ik(S, p) {
        S.writeProperty("x", p.x), S.writeProperty("y", p.y), S.writeProperty("z", p.z);
      }
      function Lk(S, p) {
        return new Ha({
          assembly: jM,
          components: [
            oa("x" in S ? S.x : void 0, p.x),
            oa("y" in S ? S.y : void 0, p.y),
            oa("z" in S ? S.z : void 0, p.z)
          ]
        });
      }
      function Uy(S, p) {
        return {
          baseStep: Fu(p),
          constraint: p,
          textProps: q.fromObject({
            draggingScale: Nu(p, S),
            formatter: ar(Am(p, S))
          })
        };
      }
      const Uk = {
        id: "input-point3d",
        type: "input",
        accept: (S, p) => {
          if (!Vu.isObject(S))
            return null;
          const b = K, R = Q(p, {
            x: b.optional.custom(Va),
            y: b.optional.custom(Va),
            z: b.optional.custom(Va)
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => Dk,
          constraint: (S) => Lk(S.params, S.initialValue),
          equals: Vu.equals,
          writer: (S) => Ik
        },
        controller: (S) => {
          const p = S.value, b = S.constraint;
          if (!(b instanceof Ha))
            throw g.shouldNeverHappen();
          return new Ly(S.document, {
            assembly: jM,
            axes: [
              Uy(p.rawValue.x, b.components[0]),
              Uy(p.rawValue.y, b.components[1]),
              Uy(p.rawValue.z, b.components[2])
            ],
            parser: ra,
            value: p,
            viewProps: S.viewProps
          });
        }
      };
      class Gu {
        constructor(p = 0, b = 0, R = 0, W = 0) {
          this.x = p, this.y = b, this.z = R, this.w = W;
        }
        getComponents() {
          return [this.x, this.y, this.z, this.w];
        }
        static isObject(p) {
          if (h(p))
            return !1;
          const b = p.x, R = p.y, W = p.z, ge = p.w;
          return !(typeof b != "number" || typeof R != "number" || typeof W != "number" || typeof ge != "number");
        }
        static equals(p, b) {
          return p.x === b.x && p.y === b.y && p.z === b.z && p.w === b.w;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
          };
        }
      }
      const qM = {
        toComponents: (S) => S.getComponents(),
        fromComponents: (S) => new Gu(...S)
      };
      function kk(S) {
        return Gu.isObject(S) ? new Gu(S.x, S.y, S.z, S.w) : new Gu();
      }
      function Ok(S, p) {
        S.writeProperty("x", p.x), S.writeProperty("y", p.y), S.writeProperty("z", p.z), S.writeProperty("w", p.w);
      }
      function Fk(S, p) {
        return new Ha({
          assembly: qM,
          components: [
            oa("x" in S ? S.x : void 0, p.x),
            oa("y" in S ? S.y : void 0, p.y),
            oa("z" in S ? S.z : void 0, p.z),
            oa("w" in S ? S.w : void 0, p.w)
          ]
        });
      }
      function Nk(S, p) {
        return {
          baseStep: Fu(p),
          constraint: p,
          textProps: q.fromObject({
            draggingScale: Nu(p, S),
            formatter: ar(Am(p, S))
          })
        };
      }
      const Bk = {
        id: "input-point4d",
        type: "input",
        accept: (S, p) => {
          if (!Gu.isObject(S))
            return null;
          const b = K, R = Q(p, {
            x: b.optional.custom(Va),
            y: b.optional.custom(Va),
            z: b.optional.custom(Va),
            w: b.optional.custom(Va)
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => kk,
          constraint: (S) => Fk(S.params, S.initialValue),
          equals: Gu.equals,
          writer: (S) => Ok
        },
        controller: (S) => {
          const p = S.value, b = S.constraint;
          if (!(b instanceof Ha))
            throw g.shouldNeverHappen();
          return new Ly(S.document, {
            assembly: qM,
            axes: p.rawValue.getComponents().map((R, W) => Nk(R, b.components[W])),
            parser: ra,
            value: p,
            viewProps: S.viewProps
          });
        }
      };
      function zk(S) {
        const p = [], b = by(S.options);
        return b && p.push(b), new kn(p);
      }
      const Vk = {
        id: "input-string",
        type: "input",
        accept: (S, p) => {
          if (typeof S != "string")
            return null;
          const R = Q(p, {
            options: K.optional.custom(Tm)
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => hM,
          constraint: (S) => zk(S.params),
          writer: (S) => Yd
        },
        controller: (S) => {
          const p = S.document, b = S.value, R = S.constraint, W = R && Ji(R, ka);
          return W ? new Ao(p, {
            props: new q({
              options: W.values.value("options")
            }),
            value: b,
            viewProps: S.viewProps
          }) : new Ba(p, {
            parser: (ge) => ge,
            props: q.fromObject({
              formatter: gy
            }),
            value: b,
            viewProps: S.viewProps
          });
        }
      }, qd = {
        monitor: {
          defaultInterval: 200,
          defaultLineCount: 3
        }
      }, ZM = x("mll");
      class Gk {
        constructor(p, b) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = b.formatter, this.element = p.createElement("div"), this.element.classList.add(ZM()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("textarea");
          R.classList.add(ZM("i")), R.style.height = `calc(var(--bld-us) * ${b.lineCount})`, R.readOnly = !0, b.viewProps.bindDisabled(R), this.element.appendChild(R), this.textareaElem_ = R, b.value.emitter.on("change", this.onValueUpdate_), this.value = b.value, this.update_();
        }
        update_() {
          const p = this.textareaElem_, b = p.scrollTop === p.scrollHeight - p.clientHeight, R = [];
          this.value.rawValue.forEach((W) => {
            W !== void 0 && R.push(this.formatter_(W));
          }), p.textContent = R.join(`
`), b && (p.scrollTop = p.scrollHeight);
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class ky {
        constructor(p, b) {
          this.value = b.value, this.viewProps = b.viewProps, this.view = new Gk(p, {
            formatter: b.formatter,
            lineCount: b.lineCount,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const KM = x("sgl");
      class Hk {
        constructor(p, b) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = b.formatter, this.element = p.createElement("div"), this.element.classList.add(KM()), b.viewProps.bindClassModifiers(this.element);
          const R = p.createElement("input");
          R.classList.add(KM("i")), R.readOnly = !0, R.type = "text", b.viewProps.bindDisabled(R), this.element.appendChild(R), this.inputElement = R, b.value.emitter.on("change", this.onValueUpdate_), this.value = b.value, this.update_();
        }
        update_() {
          const p = this.value.rawValue, b = p[p.length - 1];
          this.inputElement.value = b !== void 0 ? this.formatter_(b) : "";
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class Oy {
        constructor(p, b) {
          this.value = b.value, this.viewProps = b.viewProps, this.view = new Hk(p, {
            formatter: b.formatter,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const Wk = {
        id: "monitor-bool",
        type: "monitor",
        accept: (S, p) => {
          if (typeof S != "boolean")
            return null;
          const R = Q(p, {
            lineCount: K.optional.number
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => Fd
        },
        controller: (S) => {
          var p;
          return S.value.rawValue.length === 1 ? new Oy(S.document, {
            formatter: Hl,
            value: S.value,
            viewProps: S.viewProps
          }) : new ky(S.document, {
            formatter: Hl,
            lineCount: (p = S.params.lineCount) !== null && p !== void 0 ? p : qd.monitor.defaultLineCount,
            value: S.value,
            viewProps: S.viewProps
          });
        }
      }, Ya = x("grl");
      class Xk {
        constructor(p, b) {
          this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = p.createElement("div"), this.element.classList.add(Ya()), b.viewProps.bindClassModifiers(this.element), this.formatter_ = b.formatter, this.props_ = b.props, this.cursor_ = b.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
          const R = p.createElementNS(Me, "svg");
          R.classList.add(Ya("g")), R.style.height = `calc(var(--bld-us) * ${b.lineCount})`, this.element.appendChild(R), this.svgElem_ = R;
          const W = p.createElementNS(Me, "polyline");
          this.svgElem_.appendChild(W), this.lineElem_ = W;
          const ge = p.createElement("div");
          ge.classList.add(Ya("t"), x("tt")()), this.element.appendChild(ge), this.tooltipElem_ = ge, b.value.emitter.on("change", this.onValueUpdate_), this.value = b.value, this.update_();
        }
        get graphElement() {
          return this.svgElem_;
        }
        update_() {
          const p = this.svgElem_.getBoundingClientRect(), b = this.value.rawValue.length - 1, R = this.props_.get("minValue"), W = this.props_.get("maxValue"), ge = [];
          this.value.rawValue.forEach((Cn, Rn) => {
            if (Cn === void 0)
              return;
            const Jl = li(Rn, 0, b, 0, p.width), Zd = li(Cn, R, W, p.height, 0);
            ge.push([Jl, Zd].join(","));
          }), this.lineElem_.setAttributeNS(null, "points", ge.join(" "));
          const ke = this.tooltipElem_, lt = this.value.rawValue[this.cursor_.rawValue];
          if (lt === void 0) {
            ke.classList.remove(Ya("t", "a"));
            return;
          }
          const Xt = li(this.cursor_.rawValue, 0, b, 0, p.width), Zt = li(lt, R, W, p.height, 0);
          ke.style.left = `${Xt}px`, ke.style.top = `${Zt}px`, ke.textContent = `${this.formatter_(lt)}`, ke.classList.contains(Ya("t", "a")) || (ke.classList.add(Ya("t", "a"), Ya("t", "in")), oe(ke), ke.classList.remove(Ya("t", "in")));
        }
        onValueUpdate_() {
          this.update_();
        }
        onCursorChange_() {
          this.update_();
        }
      }
      class Yk {
        constructor(p, b) {
          if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = b.props, this.value = b.value, this.viewProps = b.viewProps, this.cursor_ = j(-1), this.view = new Xk(p, {
            cursor: this.cursor_,
            formatter: b.formatter,
            lineCount: b.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps
          }), !Ye(p))
            this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
          else {
            const R = new jl(this.view.element);
            R.emitter.on("down", this.onGraphPointerDown_), R.emitter.on("move", this.onGraphPointerMove_), R.emitter.on("up", this.onGraphPointerUp_);
          }
        }
        onGraphMouseLeave_() {
          this.cursor_.rawValue = -1;
        }
        onGraphMouseMove_(p) {
          const b = this.view.element.getBoundingClientRect();
          this.cursor_.rawValue = Math.floor(li(p.offsetX, 0, b.width, 0, this.value.rawValue.length));
        }
        onGraphPointerDown_(p) {
          this.onGraphPointerMove_(p);
        }
        onGraphPointerMove_(p) {
          if (!p.data.point) {
            this.cursor_.rawValue = -1;
            return;
          }
          this.cursor_.rawValue = Math.floor(li(p.data.point.x, 0, p.data.bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerUp_() {
          this.cursor_.rawValue = -1;
        }
      }
      function Fy(S) {
        return "format" in S && !h(S.format) ? S.format : ar(2);
      }
      function jk(S) {
        var p;
        return S.value.rawValue.length === 1 ? new Oy(S.document, {
          formatter: Fy(S.params),
          value: S.value,
          viewProps: S.viewProps
        }) : new ky(S.document, {
          formatter: Fy(S.params),
          lineCount: (p = S.params.lineCount) !== null && p !== void 0 ? p : qd.monitor.defaultLineCount,
          value: S.value,
          viewProps: S.viewProps
        });
      }
      function qk(S) {
        var p, b, R;
        return new Yk(S.document, {
          formatter: Fy(S.params),
          lineCount: (p = S.params.lineCount) !== null && p !== void 0 ? p : qd.monitor.defaultLineCount,
          props: q.fromObject({
            maxValue: (b = "max" in S.params ? S.params.max : null) !== null && b !== void 0 ? b : 100,
            minValue: (R = "min" in S.params ? S.params.min : null) !== null && R !== void 0 ? R : 0
          }),
          value: S.value,
          viewProps: S.viewProps
        });
      }
      function $M(S) {
        return "view" in S && S.view === "graph";
      }
      const Zk = {
        id: "monitor-number",
        type: "monitor",
        accept: (S, p) => {
          if (typeof S != "number")
            return null;
          const b = K, R = Q(p, {
            format: b.optional.function,
            lineCount: b.optional.number,
            max: b.optional.number,
            min: b.optional.number,
            view: b.optional.string
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          defaultBufferSize: (S) => $M(S) ? 64 : 1,
          reader: (S) => uM
        },
        controller: (S) => $M(S.params) ? qk(S) : jk(S)
      }, Kk = {
        id: "monitor-string",
        type: "monitor",
        accept: (S, p) => {
          if (typeof S != "string")
            return null;
          const b = K, R = Q(p, {
            lineCount: b.optional.number,
            multiline: b.optional.boolean
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => hM
        },
        controller: (S) => {
          var p;
          const b = S.value;
          return b.rawValue.length > 1 || "multiline" in S.params && S.params.multiline ? new ky(S.document, {
            formatter: gy,
            lineCount: (p = S.params.lineCount) !== null && p !== void 0 ? p : qd.monitor.defaultLineCount,
            value: b,
            viewProps: S.viewProps
          }) : new Oy(S.document, {
            formatter: gy,
            value: b,
            viewProps: S.viewProps
          });
        }
      };
      function $k(S, p) {
        var b;
        const R = S.accept(p.target.read(), p.params);
        if (h(R))
          return null;
        const W = K, ge = {
          target: p.target,
          initialValue: R.initialValue,
          params: R.params
        }, ke = S.binding.reader(ge), lt = S.binding.constraint ? S.binding.constraint(ge) : void 0, Xt = j(ke(R.initialValue), {
          constraint: lt,
          equals: S.binding.equals
        }), Zt = new hn({
          reader: ke,
          target: p.target,
          value: Xt,
          writer: S.binding.writer(ge)
        }), Cn = W.optional.boolean(p.params.disabled).value, Rn = W.optional.boolean(p.params.hidden).value, Jl = S.controller({
          constraint: lt,
          document: p.document,
          initialValue: R.initialValue,
          params: R.params,
          value: Zt.value,
          viewProps: Ee.create({
            disabled: Cn,
            hidden: Rn
          })
        });
        return new je(p.document, {
          binding: Zt,
          blade: ot(),
          props: q.fromObject({
            label: "label" in p.params ? (b = W.optional.string(p.params.label).value) !== null && b !== void 0 ? b : null : p.target.key
          }),
          valueController: Jl
        });
      }
      function Jk(S, p) {
        return p === 0 ? new mn() : new ii(S, p ?? qd.monitor.defaultInterval);
      }
      function Qk(S, p) {
        var b, R, W;
        const ge = K, ke = S.accept(p.target.read(), p.params);
        if (h(ke))
          return null;
        const lt = {
          target: p.target,
          initialValue: ke.initialValue,
          params: ke.params
        }, Xt = S.binding.reader(lt), Zt = (R = (b = ge.optional.number(p.params.bufferSize).value) !== null && b !== void 0 ? b : S.binding.defaultBufferSize && S.binding.defaultBufferSize(ke.params)) !== null && R !== void 0 ? R : 1, Cn = ge.optional.number(p.params.interval).value, Rn = new Pn({
          reader: Xt,
          target: p.target,
          ticker: Jk(p.document, Cn),
          value: Vt(Zt)
        }), Jl = ge.optional.boolean(p.params.disabled).value, Zd = ge.optional.boolean(p.params.hidden).value, Kd = S.controller({
          document: p.document,
          params: ke.params,
          value: Rn.value,
          viewProps: Ee.create({
            disabled: Jl,
            hidden: Zd
          })
        });
        return new ft(p.document, {
          binding: Rn,
          blade: ot(),
          props: q.fromObject({
            label: "label" in p.params ? (W = ge.optional.string(p.params.label).value) !== null && W !== void 0 ? W : null : p.target.key
          }),
          valueController: Kd
        });
      }
      class eO {
        constructor() {
          this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
          };
        }
        getAll() {
          return [
            ...this.pluginsMap_.blades,
            ...this.pluginsMap_.inputs,
            ...this.pluginsMap_.monitors
          ];
        }
        register(p) {
          p.type === "blade" ? this.pluginsMap_.blades.unshift(p) : p.type === "input" ? this.pluginsMap_.inputs.unshift(p) : p.type === "monitor" && this.pluginsMap_.monitors.unshift(p);
        }
        createInput(p, b, R) {
          const W = b.read();
          if (h(W))
            throw new g({
              context: {
                key: b.key
              },
              type: "nomatchingcontroller"
            });
          const ge = this.pluginsMap_.inputs.reduce((ke, lt) => ke ?? $k(lt, {
            document: p,
            target: b,
            params: R
          }), null);
          if (ge)
            return ge;
          throw new g({
            context: {
              key: b.key
            },
            type: "nomatchingcontroller"
          });
        }
        createMonitor(p, b, R) {
          const W = this.pluginsMap_.monitors.reduce((ge, ke) => ge ?? Qk(ke, {
            document: p,
            params: R,
            target: b
          }), null);
          if (W)
            return W;
          throw new g({
            context: {
              key: b.key
            },
            type: "nomatchingcontroller"
          });
        }
        createBlade(p, b) {
          const R = this.pluginsMap_.blades.reduce((W, ge) => W ?? St(ge, {
            document: p,
            params: b
          }), null);
          if (!R)
            throw new g({
              type: "nomatchingview",
              context: {
                params: b
              }
            });
          return R;
        }
        createBladeApi(p) {
          if (p instanceof je)
            return new nt(p);
          if (p instanceof ft)
            return new at(p);
          if (p instanceof An)
            return new Mt(p, this);
          const b = this.pluginsMap_.blades.reduce((R, W) => R ?? W.api({
            controller: p,
            pool: this
          }), null);
          if (!b)
            throw g.shouldNeverHappen();
          return b;
        }
      }
      function tO() {
        const S = new eO();
        return [
          aO,
          Uk,
          Bk,
          Vk,
          Tk,
          bk,
          xk,
          gk,
          mU,
          Wk,
          Kk,
          Zk,
          Ze,
          F,
          Pe,
          Yt
        ].forEach((p) => {
          S.register(p);
        }), S;
      }
      function nO(S) {
        return Wa.isObject(S) ? new Wa(S.x, S.y) : new Wa();
      }
      function iO(S, p) {
        S.writeProperty("x", p.x), S.writeProperty("y", p.y);
      }
      function oa(S, p) {
        if (!S)
          return;
        const b = [], R = HM(S, p);
        R && b.push(R);
        const W = WM(S);
        return W && b.push(W), new kn(b);
      }
      function rO(S, p) {
        return new Ha({
          assembly: XM,
          components: [
            oa("x" in S ? S.x : void 0, p.x),
            oa("y" in S ? S.y : void 0, p.y)
          ]
        });
      }
      function JM(S, p) {
        const [b, R] = S ? Mk(S) : [];
        if (!h(b) || !h(R))
          return Math.max(Math.abs(b ?? 0), Math.abs(R ?? 0));
        const W = Fu(S);
        return Math.max(Math.abs(W) * 10, Math.abs(p) * 10);
      }
      function sO(S, p) {
        const b = p instanceof Ha ? p.components[0] : void 0, R = p instanceof Ha ? p.components[1] : void 0, W = JM(b, S.x), ge = JM(R, S.y);
        return Math.max(W, ge);
      }
      function QM(S, p) {
        return {
          baseStep: Fu(p),
          constraint: p,
          textProps: q.fromObject({
            draggingScale: Nu(p, S),
            formatter: ar(Am(p, S))
          })
        };
      }
      function oO(S) {
        if (!("y" in S))
          return !1;
        const p = S.y;
        return p && "inverted" in p ? !!p.inverted : !1;
      }
      const aO = {
        id: "input-point2d",
        type: "input",
        accept: (S, p) => {
          if (!Wa.isObject(S))
            return null;
          const b = K, R = Q(p, {
            expanded: b.optional.boolean,
            picker: b.optional.custom(mM),
            x: b.optional.custom(Va),
            y: b.optional.object({
              inverted: b.optional.boolean,
              max: b.optional.number,
              min: b.optional.number,
              step: b.optional.number
            })
          });
          return R ? {
            initialValue: S,
            params: R
          } : null;
        },
        binding: {
          reader: (S) => nO,
          constraint: (S) => rO(S.params, S.initialValue),
          equals: Wa.equals,
          writer: (S) => iO
        },
        controller: (S) => {
          const p = S.document, b = S.value, R = S.constraint;
          if (!(R instanceof Ha))
            throw g.shouldNeverHappen();
          const W = "expanded" in S.params ? S.params.expanded : void 0, ge = "picker" in S.params ? S.params.picker : void 0;
          return new Rk(p, {
            axes: [
              QM(b.rawValue.x, R.components[0]),
              QM(b.rawValue.y, R.components[1])
            ],
            expanded: W ?? !1,
            invertsY: oO(S.params),
            maxValue: sO(b.rawValue, R),
            parser: ra,
            pickerLayout: ge ?? "popup",
            value: b,
            viewProps: S.viewProps
          });
        }
      };
      class eE extends n {
        constructor(p) {
          super(p), this.emitter_ = new y(), this.controller_.valueController.value.emitter.on("change", (b) => {
            this.emitter_.emit("change", {
              event: new o(this, b.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(p) {
          this.controller_.props.set("label", p);
        }
        get options() {
          return this.controller_.valueController.props.get("options");
        }
        set options(p) {
          this.controller_.valueController.props.set("options", p);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(p) {
          this.controller_.valueController.value.rawValue = p;
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
      }
      class tE extends n {
        constructor(p) {
          super(p), this.emitter_ = new y(), this.controller_.valueController.value.emitter.on("change", (b) => {
            this.emitter_.emit("change", {
              event: new o(this, b.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(p) {
          this.controller_.props.set("label", p);
        }
        get maxValue() {
          return this.controller_.valueController.sliderController.props.get("maxValue");
        }
        set maxValue(p) {
          this.controller_.valueController.sliderController.props.set("maxValue", p);
        }
        get minValue() {
          return this.controller_.valueController.sliderController.props.get("minValue");
        }
        set minValue(p) {
          this.controller_.valueController.sliderController.props.set("minValue", p);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(p) {
          this.controller_.valueController.value.rawValue = p;
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
      }
      class nE extends n {
        constructor(p) {
          super(p), this.emitter_ = new y(), this.controller_.valueController.value.emitter.on("change", (b) => {
            this.emitter_.emit("change", {
              event: new o(this, b.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(p) {
          this.controller_.props.set("label", p);
        }
        get formatter() {
          return this.controller_.valueController.props.get("formatter");
        }
        set formatter(p) {
          this.controller_.valueController.props.set("formatter", p);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(p) {
          this.controller_.valueController.value.rawValue = p;
        }
        on(p, b) {
          const R = b.bind(this);
          return this.emitter_.on(p, (W) => {
            R(W.event);
          }), this;
        }
      }
      const lO = /* @__PURE__ */ function() {
        return {
          id: "list",
          type: "blade",
          accept(S) {
            const p = K, b = Q(S, {
              options: p.required.custom(Tm),
              value: p.required.raw,
              view: p.required.constant("list"),
              label: p.optional.string
            });
            return b ? { params: b } : null;
          },
          controller(S) {
            const p = new ka(gM(S.params.options)), b = j(S.params.value, {
              constraint: p
            }), R = new Ao(S.document, {
              props: new q({
                options: p.values.value("options")
              }),
              value: b,
              viewProps: S.viewProps
            });
            return new ie(S.document, {
              blade: S.blade,
              props: q.fromObject({
                label: S.params.label
              }),
              valueController: R
            });
          },
          api(S) {
            return !(S.controller instanceof ie) || !(S.controller.valueController instanceof Ao) ? null : new eE(S.controller);
          }
        };
      }();
      function cO(S) {
        return S.reduce((p, b) => Object.assign(p, {
          [b.presetKey]: b.read()
        }), {});
      }
      function uO(S, p) {
        S.forEach((b) => {
          const R = p[b.target.presetKey];
          R !== void 0 && b.writer(b.target, b.reader(R));
        });
      }
      class hO extends nn {
        /**
         * @hidden
         */
        constructor(p, b) {
          super(p, b);
        }
        get element() {
          return this.controller_.view.element;
        }
        /**
         * Imports a preset of all inputs.
         * @param preset The preset object to import.
         */
        importPreset(p) {
          const b = this.controller_.rackController.rack.find(je).map((R) => R.binding);
          uO(b, p), this.refresh();
        }
        /**
         * Exports a preset of all inputs.
         * @return An exported preset object.
         */
        exportPreset() {
          const p = this.controller_.rackController.rack.find(je).map((b) => b.binding.target);
          return cO(p);
        }
        /**
         * Refreshes all bindings of the pane.
         */
        refresh() {
          this.controller_.rackController.rack.find(je).forEach((p) => {
            p.binding.read();
          }), this.controller_.rackController.rack.find(ft).forEach((p) => {
            p.binding.read();
          });
        }
      }
      class dO extends he {
        constructor(p, b) {
          super(p, {
            expanded: b.expanded,
            blade: b.blade,
            props: b.props,
            root: !0,
            viewProps: b.viewProps
          });
        }
      }
      const fO = {
        id: "slider",
        type: "blade",
        accept(S) {
          const p = K, b = Q(S, {
            max: p.required.number,
            min: p.required.number,
            view: p.required.constant("slider"),
            format: p.optional.function,
            label: p.optional.string,
            value: p.optional.number
          });
          return b ? { params: b } : null;
        },
        controller(S) {
          var p, b;
          const R = (p = S.params.value) !== null && p !== void 0 ? p : 0, W = new Qi({
            max: S.params.max,
            min: S.params.min
          }), ge = new xy(S.document, {
            baseStep: 1,
            parser: ra,
            sliderProps: new q({
              maxValue: W.values.value("max"),
              minValue: W.values.value("min")
            }),
            textProps: q.fromObject({
              draggingScale: Nu(void 0, R),
              formatter: (b = S.params.format) !== null && b !== void 0 ? b : rU
            }),
            value: j(R, {
              constraint: W
            }),
            viewProps: S.viewProps
          });
          return new ie(S.document, {
            blade: S.blade,
            props: q.fromObject({
              label: S.params.label
            }),
            valueController: ge
          });
        },
        api(S) {
          return !(S.controller instanceof ie) || !(S.controller.valueController instanceof xy) ? null : new tE(S.controller);
        }
      }, pO = /* @__PURE__ */ function() {
        return {
          id: "text",
          type: "blade",
          accept(S) {
            const p = K, b = Q(S, {
              parse: p.required.function,
              value: p.required.raw,
              view: p.required.constant("text"),
              format: p.optional.function,
              label: p.optional.string
            });
            return b ? { params: b } : null;
          },
          controller(S) {
            var p;
            const b = new Ba(S.document, {
              parser: S.params.parse,
              props: q.fromObject({
                formatter: (p = S.params.format) !== null && p !== void 0 ? p : (R) => String(R)
              }),
              value: j(S.params.value),
              viewProps: S.viewProps
            });
            return new ie(S.document, {
              blade: S.blade,
              props: q.fromObject({
                label: S.params.label
              }),
              valueController: b
            });
          },
          api(S) {
            return !(S.controller instanceof ie) || !(S.controller.valueController instanceof Ba) ? null : new nE(S.controller);
          }
        };
      }();
      function mO(S) {
        const p = S.createElement("div");
        return p.classList.add(x("dfw")()), S.body && S.body.appendChild(p), p;
      }
      function iE(S, p, b) {
        if (S.querySelector(`style[data-tp-style=${p}]`))
          return;
        const R = S.createElement("style");
        R.dataset.tpStyle = p, R.textContent = b, S.head.appendChild(R);
      }
      class gO extends hO {
        constructor(p) {
          var b, R;
          const W = p ?? {}, ge = (b = W.document) !== null && b !== void 0 ? b : X(), ke = tO(), lt = new dO(ge, {
            expanded: W.expanded,
            blade: ot(),
            props: q.fromObject({
              title: W.title
            }),
            viewProps: Ee.create()
          });
          super(lt, ke), this.pool_ = ke, this.containerElem_ = (R = W.container) !== null && R !== void 0 ? R : mO(ge), this.containerElem_.appendChild(this.element), this.doc_ = ge, this.usesDefaultWrapper_ = !W.container, this.setUpDefaultPlugins_();
        }
        get document() {
          if (!this.doc_)
            throw g.alreadyDisposed();
          return this.doc_;
        }
        dispose() {
          const p = this.containerElem_;
          if (!p)
            throw g.alreadyDisposed();
          if (this.usesDefaultWrapper_) {
            const b = p.parentElement;
            b && b.removeChild(p);
          }
          this.containerElem_ = null, this.doc_ = null, super.dispose();
        }
        registerPlugin(p) {
          ("plugin" in p ? [p.plugin] : "plugins" in p ? p.plugins : []).forEach((R) => {
            this.pool_.register(R), this.embedPluginStyle_(R);
          });
        }
        embedPluginStyle_(p) {
          p.css && iE(this.document, `plugin-${p.id}`, p.css);
        }
        setUpDefaultPlugins_() {
          iE(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((p) => {
            this.embedPluginStyle_(p);
          }), this.registerPlugin({
            plugins: [
              fO,
              lO,
              Yt,
              pO
            ]
          });
        }
      }
      const vO = new i("3.1.10");
      t.BladeApi = n, t.ButtonApi = _, t.FolderApi = nn, t.InputBindingApi = nt, t.ListApi = eE, t.MonitorBindingApi = at, t.Pane = gO, t.SeparatorApi = re, t.SliderApi = tE, t.TabApi = et, t.TabPageApi = Je, t.TextApi = nE, t.TpChangeEvent = o, t.VERSION = vO, Object.defineProperty(t, "__esModule", { value: !0 });
    });
  }(Vf, Vf.exports)), Vf.exports;
}
var oj = sj();
function aj() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(n, r) {
    var o = n.id, a = n.name, l = n.dependencies;
    l === void 0 && (l = []);
    var c = n.init;
    c === void 0 && (c = function() {
    });
    var u = n.getTransferables;
    if (u === void 0 && (u = null), !s[o])
      try {
        l = l.map(function(d) {
          return d && d.isWorkerModule && (e(d, function(f) {
            if (f instanceof Error)
              throw f;
          }), d = s[d.id].value), d;
        }), c = i("<" + a + ">.init", c), u && (u = i("<" + a + ">.getTransferables", u));
        var h = null;
        typeof c == "function" ? h = c.apply(void 0, l) : console.error("worker module init function failed to rehydrate"), s[o] = {
          id: o,
          value: h,
          getTransferables: u
        }, r(h);
      } catch (d) {
        d && d.noLog || console.error(d), r(d);
      }
  }
  function t(n, r) {
    var o, a = n.id, l = n.args;
    (!s[a] || typeof s[a].value != "function") && r(new Error("Worker module " + a + ": not found or its 'init' did not return a function"));
    try {
      var c = (o = s[a]).value.apply(o, l);
      c && typeof c.then == "function" ? c.then(u, function(h) {
        return r(h instanceof Error ? h : new Error("" + h));
      }) : u(c);
    } catch (h) {
      r(h);
    }
    function u(h) {
      try {
        var d = s[a].getTransferables && s[a].getTransferables(h);
        (!d || !Array.isArray(d) || !d.length) && (d = void 0), r(h, d);
      } catch (f) {
        console.error(f), r(f);
      }
    }
  }
  function i(n, r) {
    var o = void 0;
    self.troikaDefine = function(l) {
      return o = l;
    };
    var a = URL.createObjectURL(
      new Blob(
        ["/** " + n.replace(/\*/g, "") + ` **/

troikaDefine(
` + r + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(a);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(a), delete self.troikaDefine, o;
  }
  self.addEventListener("message", function(n) {
    var r = n.data, o = r.messageId, a = r.action, l = r.data;
    try {
      a === "registerModule" && e(l, function(c) {
        c instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: { isCallable: typeof c == "function" }
        });
      }), a === "callModule" && t(l, function(c, u) {
        c instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: c
        }, u || void 0);
      });
    } catch (c) {
      postMessage({
        messageId: o,
        success: !1,
        error: c.stack
      });
    }
  });
}
function lj(s) {
  var e = function() {
    for (var t = [], i = arguments.length; i--; ) t[i] = arguments[i];
    return e._getInitResult().then(function(n) {
      if (typeof n == "function")
        return n.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = s.dependencies, i = s.init;
    t = Array.isArray(t) ? t.map(function(r) {
      return r && (r = r.onMainThread || r, r._getInitResult && (r = r._getInitResult())), r;
    }) : [];
    var n = Promise.all(t).then(function(r) {
      return i.apply(null, r);
    });
    return e._getInitResult = function() {
      return n;
    }, n;
  }, e;
}
var o3 = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return o3 = function() {
    return s;
  }, s;
}, cj = 0, uj = 0, Sb = !1, _p = /* @__PURE__ */ Object.create(null), yp = /* @__PURE__ */ Object.create(null), H1 = /* @__PURE__ */ Object.create(null);
function Id(s) {
  if ((!s || typeof s.init != "function") && !Sb)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, t = s.init, i = s.getTransferables, n = s.workerId, r = lj(s);
  n == null && (n = "#default");
  var o = "workerModule" + ++cj, a = s.name || o, l = null;
  e = e && e.map(function(u) {
    return typeof u == "function" && !u.workerModuleData && (Sb = !0, u = Id({
      workerId: n,
      name: "<" + a + "> function dependency: " + u.name,
      init: `function(){return (
` + Vv(u) + `
)}`
    }), Sb = !1), u && u.workerModuleData && (u = u.workerModuleData), u;
  });
  function c() {
    for (var u = [], h = arguments.length; h--; ) u[h] = arguments[h];
    if (!o3())
      return r.apply(void 0, u);
    if (!l) {
      l = Y2(n, "registerModule", c.workerModuleData);
      var d = function() {
        l = null, yp[n].delete(d);
      };
      (yp[n] || (yp[n] = /* @__PURE__ */ new Set())).add(d);
    }
    return l.then(function(f) {
      var m = f.isCallable;
      if (m)
        return Y2(n, "callModule", { id: o, args: u });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return c.workerModuleData = {
    isWorkerModule: !0,
    id: o,
    name: a,
    dependencies: e,
    init: Vv(t),
    getTransferables: i && Vv(i)
  }, c.onMainThread = r, c;
}
function hj(s) {
  yp[s] && yp[s].forEach(function(e) {
    e();
  }), _p[s] && (_p[s].terminate(), delete _p[s]);
}
function Vv(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function dj(s) {
  var e = _p[s];
  if (!e) {
    var t = Vv(aj);
    e = _p[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var n = i.data, r = n.messageId, o = H1[r];
      if (!o)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete H1[r], o(n);
    };
  }
  return e;
}
function Y2(s, e, t) {
  return new Promise(function(i, n) {
    var r = ++uj;
    H1[r] = function(o) {
      o.success ? i(o.result) : n(new Error("Error in worker " + e + " call: " + o.error));
    }, dj(s).postMessage({
      messageId: r,
      action: e,
      data: t
    });
  });
}
function cy() {
  var s = function(e) {
    function t(Z, N, z, J, se, K, Q, de) {
      var ce = 1 - Q;
      de.x = ce * ce * Z + 2 * ce * Q * z + Q * Q * se, de.y = ce * ce * N + 2 * ce * Q * J + Q * Q * K;
    }
    function i(Z, N, z, J, se, K, Q, de, ce, _e) {
      var Fe = 1 - ce;
      _e.x = Fe * Fe * Fe * Z + 3 * Fe * Fe * ce * z + 3 * Fe * ce * ce * se + ce * ce * ce * Q, _e.y = Fe * Fe * Fe * N + 3 * Fe * Fe * ce * J + 3 * Fe * ce * ce * K + ce * ce * ce * de;
    }
    function n(Z, N) {
      for (var z = /([MLQCZ])([^MLQCZ]*)/g, J, se, K, Q, de; J = z.exec(Z); ) {
        var ce = J[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(_e) {
          return parseFloat(_e);
        });
        switch (J[1]) {
          case "M":
            Q = se = ce[0], de = K = ce[1];
            break;
          case "L":
            (ce[0] !== Q || ce[1] !== de) && N("L", Q, de, Q = ce[0], de = ce[1]);
            break;
          case "Q": {
            N("Q", Q, de, Q = ce[2], de = ce[3], ce[0], ce[1]);
            break;
          }
          case "C": {
            N("C", Q, de, Q = ce[4], de = ce[5], ce[0], ce[1], ce[2], ce[3]);
            break;
          }
          case "Z":
            (Q !== se || de !== K) && N("L", Q, de, se, K);
            break;
        }
      }
    }
    function r(Z, N, z) {
      z === void 0 && (z = 16);
      var J = { x: 0, y: 0 };
      n(Z, function(se, K, Q, de, ce, _e, Fe, Ie, Ee) {
        switch (se) {
          case "L":
            N(K, Q, de, ce);
            break;
          case "Q": {
            for (var me = K, xe = Q, $ = 1; $ < z; $++)
              t(
                K,
                Q,
                _e,
                Fe,
                de,
                ce,
                $ / (z - 1),
                J
              ), N(me, xe, J.x, J.y), me = J.x, xe = J.y;
            break;
          }
          case "C": {
            for (var Ue = K, Me = Q, oe = 1; oe < z; oe++)
              i(
                K,
                Q,
                _e,
                Fe,
                Ie,
                Ee,
                de,
                ce,
                oe / (z - 1),
                J
              ), N(Ue, Me, J.x, J.y), Ue = J.x, Me = J.y;
            break;
          }
        }
      });
    }
    var o = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", a = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", l = /* @__PURE__ */ new WeakMap(), c = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(Z, N) {
      var z = Z.getContext ? Z.getContext("webgl", c) : Z, J = l.get(z);
      if (!J) {
        let Fe = function(Ue) {
          var Me = K[Ue];
          if (!Me && (Me = K[Ue] = z.getExtension(Ue), !Me))
            throw new Error(Ue + " not supported");
          return Me;
        }, Ie = function(Ue, Me) {
          var oe = z.createShader(Me);
          return z.shaderSource(oe, Ue), z.compileShader(oe), oe;
        }, Ee = function(Ue, Me, oe, Te) {
          if (!Q[Ue]) {
            var Ye = {}, Oe = {}, X = z.createProgram();
            z.attachShader(X, Ie(Me, z.VERTEX_SHADER)), z.attachShader(X, Ie(oe, z.FRAGMENT_SHADER)), z.linkProgram(X), Q[Ue] = {
              program: X,
              transaction: function(fe) {
                z.useProgram(X), fe({
                  setUniform: function(te, Se) {
                    for (var ye = [], Ae = arguments.length - 2; Ae-- > 0; ) ye[Ae] = arguments[Ae + 2];
                    var Ce = Oe[Se] || (Oe[Se] = z.getUniformLocation(X, Se));
                    z["uniform" + te].apply(z, [Ce].concat(ye));
                  },
                  setAttribute: function(te, Se, ye, Ae, Ce) {
                    var Ge = Ye[te];
                    Ge || (Ge = Ye[te] = {
                      buf: z.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: z.getAttribLocation(X, te),
                      data: null
                    }), z.bindBuffer(z.ARRAY_BUFFER, Ge.buf), z.vertexAttribPointer(Ge.loc, Se, z.FLOAT, !1, 0, 0), z.enableVertexAttribArray(Ge.loc), se ? z.vertexAttribDivisor(Ge.loc, Ae) : Fe("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Ge.loc, Ae), Ce !== Ge.data && (z.bufferData(z.ARRAY_BUFFER, Ce, ye), Ge.data = Ce);
                  }
                });
              }
            };
          }
          Q[Ue].transaction(Te);
        }, me = function(Ue, Me) {
          ce++;
          try {
            z.activeTexture(z.TEXTURE0 + ce);
            var oe = de[Ue];
            oe || (oe = de[Ue] = z.createTexture(), z.bindTexture(z.TEXTURE_2D, oe), z.texParameteri(z.TEXTURE_2D, z.TEXTURE_MIN_FILTER, z.NEAREST), z.texParameteri(z.TEXTURE_2D, z.TEXTURE_MAG_FILTER, z.NEAREST)), z.bindTexture(z.TEXTURE_2D, oe), Me(oe, ce);
          } finally {
            ce--;
          }
        }, xe = function(Ue, Me, oe) {
          var Te = z.createFramebuffer();
          _e.push(Te), z.bindFramebuffer(z.FRAMEBUFFER, Te), z.activeTexture(z.TEXTURE0 + Me), z.bindTexture(z.TEXTURE_2D, Ue), z.framebufferTexture2D(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0, z.TEXTURE_2D, Ue, 0);
          try {
            oe(Te);
          } finally {
            z.deleteFramebuffer(Te), z.bindFramebuffer(z.FRAMEBUFFER, _e[--_e.length - 1] || null);
          }
        }, $ = function() {
          K = {}, Q = {}, de = {}, ce = -1, _e.length = 0;
        };
        var se = typeof WebGL2RenderingContext < "u" && z instanceof WebGL2RenderingContext, K = {}, Q = {}, de = {}, ce = -1, _e = [];
        z.canvas.addEventListener("webglcontextlost", function(Ue) {
          $(), Ue.preventDefault();
        }, !1), l.set(z, J = {
          gl: z,
          isWebGL2: se,
          getExtension: Fe,
          withProgram: Ee,
          withTexture: me,
          withTextureFramebuffer: xe,
          handleContextLoss: $
        });
      }
      N(J);
    }
    function h(Z, N, z, J, se, K, Q, de) {
      Q === void 0 && (Q = 15), de === void 0 && (de = null), u(Z, function(ce) {
        var _e = ce.gl, Fe = ce.withProgram, Ie = ce.withTexture;
        Ie("copy", function(Ee, me) {
          _e.texImage2D(_e.TEXTURE_2D, 0, _e.RGBA, se, K, 0, _e.RGBA, _e.UNSIGNED_BYTE, N), Fe("copy", o, a, function(xe) {
            var $ = xe.setUniform, Ue = xe.setAttribute;
            Ue("aUV", 2, _e.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), $("1i", "image", me), _e.bindFramebuffer(_e.FRAMEBUFFER, de || null), _e.disable(_e.BLEND), _e.colorMask(Q & 8, Q & 4, Q & 2, Q & 1), _e.viewport(z, J, se, K), _e.scissor(z, J, se, K), _e.drawArrays(_e.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function d(Z, N, z) {
      var J = Z.width, se = Z.height;
      u(Z, function(K) {
        var Q = K.gl, de = new Uint8Array(J * se * 4);
        Q.readPixels(0, 0, J, se, Q.RGBA, Q.UNSIGNED_BYTE, de), Z.width = N, Z.height = z, h(Q, de, 0, 0, J, se);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: d
    });
    function m(Z, N, z, J, se, K) {
      K === void 0 && (K = 1);
      var Q = new Uint8Array(Z * N), de = J[2] - J[0], ce = J[3] - J[1], _e = [];
      r(z, function(Ue, Me, oe, Te) {
        _e.push({
          x1: Ue,
          y1: Me,
          x2: oe,
          y2: Te,
          minX: Math.min(Ue, oe),
          minY: Math.min(Me, Te),
          maxX: Math.max(Ue, oe),
          maxY: Math.max(Me, Te)
        });
      }), _e.sort(function(Ue, Me) {
        return Ue.maxX - Me.maxX;
      });
      for (var Fe = 0; Fe < Z; Fe++)
        for (var Ie = 0; Ie < N; Ie++) {
          var Ee = xe(
            J[0] + de * (Fe + 0.5) / Z,
            J[1] + ce * (Ie + 0.5) / N
          ), me = Math.pow(1 - Math.abs(Ee) / se, K) / 2;
          Ee < 0 && (me = 1 - me), me = Math.max(0, Math.min(255, Math.round(me * 255))), Q[Ie * Z + Fe] = me;
        }
      return Q;
      function xe(Ue, Me) {
        for (var oe = 1 / 0, Te = 1 / 0, Ye = _e.length; Ye--; ) {
          var Oe = _e[Ye];
          if (Oe.maxX + Te <= Ue)
            break;
          if (Ue + Te > Oe.minX && Me - Te < Oe.maxY && Me + Te > Oe.minY) {
            var X = _(Ue, Me, Oe.x1, Oe.y1, Oe.x2, Oe.y2);
            X < oe && (oe = X, Te = Math.sqrt(oe));
          }
        }
        return $(Ue, Me) && (Te = -Te), Te;
      }
      function $(Ue, Me) {
        for (var oe = 0, Te = _e.length; Te--; ) {
          var Ye = _e[Te];
          if (Ye.maxX <= Ue)
            break;
          var Oe = Ye.y1 > Me != Ye.y2 > Me && Ue < (Ye.x2 - Ye.x1) * (Me - Ye.y1) / (Ye.y2 - Ye.y1) + Ye.x1;
          Oe && (oe += Ye.y1 < Ye.y2 ? 1 : -1);
        }
        return oe !== 0;
      }
    }
    function g(Z, N, z, J, se, K, Q, de, ce, _e) {
      K === void 0 && (K = 1), de === void 0 && (de = 0), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), v(Z, N, z, J, se, K, Q, null, de, ce, _e);
    }
    function v(Z, N, z, J, se, K, Q, de, ce, _e, Fe) {
      K === void 0 && (K = 1), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), Fe === void 0 && (Fe = 0);
      for (var Ie = m(Z, N, z, J, se, K), Ee = new Uint8Array(Ie.length * 4), me = 0; me < Ie.length; me++)
        Ee[me * 4 + Fe] = Ie[me];
      h(Q, Ee, ce, _e, Z, N, 1 << 3 - Fe, de);
    }
    function _(Z, N, z, J, se, K) {
      var Q = se - z, de = K - J, ce = Q * Q + de * de, _e = ce ? Math.max(0, Math.min(1, ((Z - z) * Q + (N - J) * de) / ce)) : 0, Fe = Z - (z + _e * Q), Ie = N - (J + _e * de);
      return Fe * Fe + Ie * Ie;
    }
    var y = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: m,
      generateIntoCanvas: g,
      generateIntoFramebuffer: v
    }), w = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", x = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", M = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", A = new Float32Array([0, 0, 2, 0, 0, 2]), E = null, C = !1, P = {}, T = /* @__PURE__ */ new WeakMap();
    function I(Z) {
      if (!C && !k(Z))
        throw new Error("WebGL generation not supported");
    }
    function D(Z, N, z, J, se, K, Q) {
      if (K === void 0 && (K = 1), Q === void 0 && (Q = null), !Q && (Q = E, !Q)) {
        var de = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!de)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        Q = E = de.getContext("webgl", { depth: !1 });
      }
      I(Q);
      var ce = new Uint8Array(Z * N * 4);
      u(Q, function(Ee) {
        var me = Ee.gl, xe = Ee.withTexture, $ = Ee.withTextureFramebuffer;
        xe("readable", function(Ue, Me) {
          me.texImage2D(me.TEXTURE_2D, 0, me.RGBA, Z, N, 0, me.RGBA, me.UNSIGNED_BYTE, null), $(Ue, Me, function(oe) {
            L(
              Z,
              N,
              z,
              J,
              se,
              K,
              me,
              oe,
              0,
              0,
              0
              // red channel
            ), me.readPixels(0, 0, Z, N, me.RGBA, me.UNSIGNED_BYTE, ce);
          });
        });
      });
      for (var _e = new Uint8Array(Z * N), Fe = 0, Ie = 0; Fe < ce.length; Fe += 4)
        _e[Ie++] = ce[Fe];
      return _e;
    }
    function U(Z, N, z, J, se, K, Q, de, ce, _e) {
      K === void 0 && (K = 1), de === void 0 && (de = 0), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), L(Z, N, z, J, se, K, Q, null, de, ce, _e);
    }
    function L(Z, N, z, J, se, K, Q, de, ce, _e, Fe) {
      K === void 0 && (K = 1), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), Fe === void 0 && (Fe = 0), I(Q);
      var Ie = [];
      r(z, function(Ee, me, xe, $) {
        Ie.push(Ee, me, xe, $);
      }), Ie = new Float32Array(Ie), u(Q, function(Ee) {
        var me = Ee.gl, xe = Ee.isWebGL2, $ = Ee.getExtension, Ue = Ee.withProgram, Me = Ee.withTexture, oe = Ee.withTextureFramebuffer, Te = Ee.handleContextLoss;
        if (Me("rawDistances", function(Ye, Oe) {
          (Z !== Ye._lastWidth || N !== Ye._lastHeight) && me.texImage2D(
            me.TEXTURE_2D,
            0,
            me.RGBA,
            Ye._lastWidth = Z,
            Ye._lastHeight = N,
            0,
            me.RGBA,
            me.UNSIGNED_BYTE,
            null
          ), Ue("main", w, x, function(X) {
            var Y = X.setAttribute, fe = X.setUniform, ue = !xe && $("ANGLE_instanced_arrays"), te = !xe && $("EXT_blend_minmax");
            Y("aUV", 2, me.STATIC_DRAW, 0, A), Y("aLineSegment", 4, me.DYNAMIC_DRAW, 1, Ie), fe.apply(void 0, ["4f", "uGlyphBounds"].concat(J)), fe("1f", "uMaxDistance", se), fe("1f", "uExponent", K), oe(Ye, Oe, function(Se) {
              me.enable(me.BLEND), me.colorMask(!0, !0, !0, !0), me.viewport(0, 0, Z, N), me.scissor(0, 0, Z, N), me.blendFunc(me.ONE, me.ONE), me.blendEquationSeparate(me.FUNC_ADD, xe ? me.MAX : te.MAX_EXT), me.clear(me.COLOR_BUFFER_BIT), xe ? me.drawArraysInstanced(me.TRIANGLES, 0, 3, Ie.length / 4) : ue.drawArraysInstancedANGLE(me.TRIANGLES, 0, 3, Ie.length / 4);
            });
          }), Ue("post", o, M, function(X) {
            X.setAttribute("aUV", 2, me.STATIC_DRAW, 0, A), X.setUniform("1i", "tex", Oe), me.bindFramebuffer(me.FRAMEBUFFER, de), me.disable(me.BLEND), me.colorMask(Fe === 0, Fe === 1, Fe === 2, Fe === 3), me.viewport(ce, _e, Z, N), me.scissor(ce, _e, Z, N), me.drawArrays(me.TRIANGLES, 0, 3);
          });
        }), me.isContextLost())
          throw Te(), new Error("webgl context lost");
      });
    }
    function k(Z) {
      var N = !Z || Z === E ? P : Z.canvas || Z, z = T.get(N);
      if (z === void 0) {
        C = !0;
        var J = null;
        try {
          var se = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], K = D(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            Z
          );
          z = K && se.length === K.length && K.every(function(Q, de) {
            return Q === se[de];
          }), z || (J = "bad trial run results", console.info(se, K));
        } catch (Q) {
          z = !1, J = Q.message;
        }
        J && console.warn("WebGL SDF generation not supported:", J), C = !1, T.set(N, z);
      }
      return z;
    }
    var B = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: D,
      generateIntoCanvas: U,
      generateIntoFramebuffer: L,
      isSupported: k
    });
    function j(Z, N, z, J, se, K) {
      se === void 0 && (se = Math.max(J[2] - J[0], J[3] - J[1]) / 2), K === void 0 && (K = 1);
      try {
        return D.apply(B, arguments);
      } catch (Q) {
        return console.info("WebGL SDF generation failed, falling back to JS", Q), m.apply(y, arguments);
      }
    }
    function q(Z, N, z, J, se, K, Q, de, ce, _e) {
      se === void 0 && (se = Math.max(J[2] - J[0], J[3] - J[1]) / 2), K === void 0 && (K = 1), de === void 0 && (de = 0), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0);
      try {
        return U.apply(B, arguments);
      } catch (Fe) {
        return console.info("WebGL SDF generation failed, falling back to JS", Fe), g.apply(y, arguments);
      }
    }
    return e.forEachPathCommand = n, e.generate = j, e.generateIntoCanvas = q, e.javascript = y, e.pathToLineSegments = r, e.webgl = B, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
function a3() {
  var s = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, i = {}, n = {};
    i.L = 1, n[1] = "L", Object.keys(t).forEach(function(Te, Ye) {
      i[Te] = 1 << Ye + 1, n[i[Te]] = Te;
    }), Object.freeze(i);
    var r = i.LRI | i.RLI | i.FSI, o = i.L | i.R | i.AL, a = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, l = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, c = i.S | i.WS | i.B | r | i.PDI | l, u = null;
    function h() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var Te = function(Oe) {
          if (t.hasOwnProperty(Oe)) {
            var X = 0;
            t[Oe].split(",").forEach(function(Y) {
              var fe = Y.split("+"), ue = fe[0], te = fe[1];
              ue = parseInt(ue, 36), te = te ? parseInt(te, 36) : 0, u.set(X += ue, i[Oe]);
              for (var Se = 0; Se < te; Se++)
                u.set(++X, i[Oe]);
            });
          }
        };
        for (var Ye in t) Te(Ye);
      }
    }
    function d(Te) {
      return h(), u.get(Te.codePointAt(0)) || i.L;
    }
    function f(Te) {
      return n[d(Te)];
    }
    var m = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function g(Te, Ye) {
      var Oe = 36, X = 0, Y = /* @__PURE__ */ new Map(), fe = Ye && /* @__PURE__ */ new Map(), ue;
      return Te.split(",").forEach(function te(Se) {
        if (Se.indexOf("+") !== -1)
          for (var ye = +Se; ye--; )
            te(ue);
        else {
          ue = Se;
          var Ae = Se.split(">"), Ce = Ae[0], Ge = Ae[1];
          Ce = String.fromCodePoint(X += parseInt(Ce, Oe)), Ge = String.fromCodePoint(X += parseInt(Ge, Oe)), Y.set(Ce, Ge), Ye && fe.set(Ge, Ce);
        }
      }), { map: Y, reverseMap: fe };
    }
    var v, _, y;
    function w() {
      if (!v) {
        var Te = g(m.pairs, !0), Ye = Te.map, Oe = Te.reverseMap;
        v = Ye, _ = Oe, y = g(m.canonical, !1).map;
      }
    }
    function x(Te) {
      return w(), v.get(Te) || null;
    }
    function M(Te) {
      return w(), _.get(Te) || null;
    }
    function A(Te) {
      return w(), y.get(Te) || null;
    }
    var E = i.L, C = i.R, P = i.EN, T = i.ES, I = i.ET, D = i.AN, U = i.CS, L = i.B, k = i.S, B = i.ON, j = i.BN, q = i.NSM, Z = i.AL, N = i.LRO, z = i.RLO, J = i.LRE, se = i.RLE, K = i.PDF, Q = i.LRI, de = i.RLI, ce = i.FSI, _e = i.PDI;
    function Fe(Te, Ye) {
      for (var Oe = 125, X = new Uint32Array(Te.length), Y = 0; Y < Te.length; Y++)
        X[Y] = d(Te[Y]);
      var fe = /* @__PURE__ */ new Map();
      function ue(wr, gs) {
        var or = X[wr];
        X[wr] = gs, fe.set(or, fe.get(or) - 1), or & a && fe.set(a, fe.get(a) - 1), fe.set(gs, (fe.get(gs) || 0) + 1), gs & a && fe.set(a, (fe.get(a) || 0) + 1);
      }
      for (var te = new Uint8Array(Te.length), Se = /* @__PURE__ */ new Map(), ye = [], Ae = null, Ce = 0; Ce < Te.length; Ce++)
        Ae || ye.push(Ae = {
          start: Ce,
          end: Te.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: Ye === "rtl" ? 1 : Ye === "ltr" ? 0 : Sm(Ce, !1)
        }), X[Ce] & L && (Ae.end = Ce, Ae = null);
      for (var Ge = se | J | z | N | r | _e | K | L, De = function(wr) {
        return wr + (wr & 1 ? 1 : 2);
      }, Ve = function(wr) {
        return wr + (wr & 1 ? 2 : 1);
      }, ze = 0; ze < ye.length; ze++) {
        Ae = ye[ze];
        var Ze = [{
          _level: Ae.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Le = void 0, ot = 0, tt = 0, mt = 0;
        fe.clear();
        for (var le = Ae.start; le <= Ae.end; le++) {
          var ve = X[le];
          if (Le = Ze[Ze.length - 1], fe.set(ve, (fe.get(ve) || 0) + 1), ve & a && fe.set(a, (fe.get(a) || 0) + 1), ve & Ge)
            if (ve & (se | J)) {
              te[le] = Le._level;
              var be = (ve === se ? Ve : De)(Le._level);
              be <= Oe && !ot && !tt ? Ze.push({
                _level: be,
                _override: 0,
                _isolate: 0
              }) : ot || tt++;
            } else if (ve & (z | N)) {
              te[le] = Le._level;
              var Xe = (ve === z ? Ve : De)(Le._level);
              Xe <= Oe && !ot && !tt ? Ze.push({
                _level: Xe,
                _override: ve & z ? C : E,
                _isolate: 0
              }) : ot || tt++;
            } else if (ve & r) {
              ve & ce && (ve = Sm(le + 1, !0) === 1 ? de : Q), te[le] = Le._level, Le._override && ue(le, Le._override);
              var We = (ve === de ? Ve : De)(Le._level);
              We <= Oe && ot === 0 && tt === 0 ? (mt++, Ze.push({
                _level: We,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: le
              })) : ot++;
            } else if (ve & _e) {
              if (ot > 0)
                ot--;
              else if (mt > 0) {
                for (tt = 0; !Ze[Ze.length - 1]._isolate; )
                  Ze.pop();
                var Ne = Ze[Ze.length - 1]._isolInitIndex;
                Ne != null && (Se.set(Ne, le), Se.set(le, Ne)), Ze.pop(), mt--;
              }
              Le = Ze[Ze.length - 1], te[le] = Le._level, Le._override && ue(le, Le._override);
            } else ve & K ? (ot === 0 && (tt > 0 ? tt-- : !Le._isolate && Ze.length > 1 && (Ze.pop(), Le = Ze[Ze.length - 1])), te[le] = Le._level) : ve & L && (te[le] = Ae.level);
          else
            te[le] = Le._level, Le._override && ve !== j && ue(le, Le._override);
        }
        for (var ct = [], gt = null, nt = Ae.start; nt <= Ae.end; nt++) {
          var je = X[nt];
          if (!(je & l)) {
            var at = te[nt], ft = je & r, Qe = je === _e;
            gt && at === gt._level ? (gt._end = nt, gt._endsWithIsolInit = ft) : ct.push(gt = {
              _start: nt,
              _end: nt,
              _level: at,
              _startsWithPDI: Qe,
              _endsWithIsolInit: ft
            });
          }
        }
        for (var xt = [], yt = 0; yt < ct.length; yt++) {
          var Mt = ct[yt];
          if (!Mt._startsWithPDI || Mt._startsWithPDI && !Se.has(Mt._start)) {
            for (var nn = [gt = Mt], zt = void 0; gt && gt._endsWithIsolInit && (zt = Se.get(gt._end)) != null; )
              for (var $t = yt + 1; $t < ct.length; $t++)
                if (ct[$t]._start === zt) {
                  nn.push(gt = ct[$t]);
                  break;
                }
            for (var qt = [], en = 0; en < nn.length; en++)
              for (var xn = nn[en], on = xn._start; on <= xn._end; on++)
                qt.push(on);
            for (var zi = te[qt[0]], un = Ae.level, An = qt[0] - 1; An >= 0; An--)
              if (!(X[An] & l)) {
                un = te[An];
                break;
              }
            var O = qt[qt.length - 1], ee = te[O], he = Ae.level;
            if (!(X[O] & r)) {
              for (var F = O + 1; F <= Ae.end; F++)
                if (!(X[F] & l)) {
                  he = te[F];
                  break;
                }
            }
            xt.push({
              _seqIndices: qt,
              _sosType: Math.max(un, zi) % 2 ? C : E,
              _eosType: Math.max(he, ee) % 2 ? C : E
            });
          }
        }
        for (var ie = 0; ie < xt.length; ie++) {
          var re = xt[ie], ne = re._seqIndices, ae = re._sosType, we = re._eosType, Pe = te[ne[0]] & 1 ? C : E;
          if (fe.get(q))
            for (var Re = 0; Re < ne.length; Re++) {
              var He = ne[Re];
              if (X[He] & q) {
                for (var qe = ae, Ke = Re - 1; Ke >= 0; Ke--)
                  if (!(X[ne[Ke]] & l)) {
                    qe = X[ne[Ke]];
                    break;
                  }
                ue(He, qe & (r | _e) ? B : qe);
              }
            }
          if (fe.get(P))
            for (var Je = 0; Je < ne.length; Je++) {
              var et = ne[Je];
              if (X[et] & P)
                for (var st = Je - 1; st >= -1; st--) {
                  var Et = st === -1 ? ae : X[ne[st]];
                  if (Et & o) {
                    Et === Z && ue(et, D);
                    break;
                  }
                }
            }
          if (fe.get(Z))
            for (var kt = 0; kt < ne.length; kt++) {
              var Ot = ne[kt];
              X[Ot] & Z && ue(Ot, C);
            }
          if (fe.get(T) || fe.get(U))
            for (var bt = 1; bt < ne.length - 1; bt++) {
              var Yt = ne[bt];
              if (X[Yt] & (T | U)) {
                for (var St = 0, mn = 0, ii = bt - 1; ii >= 0 && (St = X[ne[ii]], !!(St & l)); ii--)
                  ;
                for (var hn = bt + 1; hn < ne.length && (mn = X[ne[hn]], !!(mn & l)); hn++)
                  ;
                St === mn && (X[Yt] === T ? St === P : St & (P | D)) && ue(Yt, St);
              }
            }
          if (fe.get(P))
            for (var jt = 0; jt < ne.length; jt++) {
              var Vt = ne[jt];
              if (X[Vt] & P) {
                for (var zn = jt - 1; zn >= 0 && X[ne[zn]] & (I | l); zn--)
                  ue(ne[zn], P);
                for (jt++; jt < ne.length && X[ne[jt]] & (I | l | P); jt++)
                  X[ne[jt]] !== P && ue(ne[jt], P);
              }
            }
          if (fe.get(I) || fe.get(T) || fe.get(U))
            for (var Jn = 0; Jn < ne.length; Jn++) {
              var Pn = ne[Jn];
              if (X[Pn] & (I | T | U)) {
                ue(Pn, B);
                for (var kn = Jn - 1; kn >= 0 && X[ne[kn]] & l; kn--)
                  ue(ne[kn], B);
                for (var Ji = Jn + 1; Ji < ne.length && X[ne[Ji]] & l; Ji++)
                  ue(ne[Ji], B);
              }
            }
          if (fe.get(P))
            for (var Qi = 0, ka = ae; Qi < ne.length; Qi++) {
              var Ud = ne[Qi], Oa = X[Ud];
              Oa & P ? ka === E && ue(Ud, E) : Oa & o && (ka = Oa);
            }
          if (fe.get(a)) {
            var ea = C | P | D, vm = ea | E, Ao = [];
            {
              for (var ta = [], Fa = 0; Fa < ne.length; Fa++)
                if (X[ne[Fa]] & a) {
                  var Na = Te[ne[Fa]], kd = void 0;
                  if (x(Na) !== null)
                    if (ta.length < 63)
                      ta.push({ char: Na, seqIndex: Fa });
                    else
                      break;
                  else if ((kd = M(Na)) !== null)
                    for (var Gl = ta.length - 1; Gl >= 0; Gl--) {
                      var Ba = ta[Gl].char;
                      if (Ba === kd || Ba === M(A(Na)) || x(A(Ba)) === Na) {
                        Ao.push([ta[Gl].seqIndex, Fa]), ta.length = Gl;
                        break;
                      }
                    }
                }
              Ao.sort(function(wr, gs) {
                return wr[0] - gs[0];
              });
            }
            for (var Od = 0; Od < Ao.length; Od++) {
              for (var Fd = Ao[Od], Hl = Fd[0], Nd = Fd[1], _m = !1, ms = 0, Bd = Hl + 1; Bd < Nd; Bd++) {
                var ym = ne[Bd];
                if (X[ym] & vm) {
                  _m = !0;
                  var Uu = X[ym] & ea ? C : E;
                  if (Uu === Pe) {
                    ms = Uu;
                    break;
                  }
                }
              }
              if (_m && !ms) {
                ms = ae;
                for (var na = Hl - 1; na >= 0; na--) {
                  var xm = ne[na];
                  if (X[xm] & vm) {
                    var za = X[xm] & ea ? C : E;
                    za !== Pe ? ms = za : ms = Pe;
                    break;
                  }
                }
              }
              if (ms) {
                if (X[ne[Hl]] = X[ne[Nd]] = ms, ms !== Pe) {
                  for (var Wl = Hl + 1; Wl < ne.length; Wl++)
                    if (!(X[ne[Wl]] & l)) {
                      d(Te[ne[Wl]]) & q && (X[ne[Wl]] = ms);
                      break;
                    }
                }
                if (ms !== Pe) {
                  for (var ia = Nd + 1; ia < ne.length; ia++)
                    if (!(X[ne[ia]] & l)) {
                      d(Te[ne[ia]]) & q && (X[ne[ia]] = ms);
                      break;
                    }
                }
              }
            }
            for (var ao = 0; ao < ne.length; ao++)
              if (X[ne[ao]] & a) {
                for (var bm = ao, zd = ao, Vd = ae, Xl = ao - 1; Xl >= 0; Xl--)
                  if (X[ne[Xl]] & l)
                    bm = Xl;
                  else {
                    Vd = X[ne[Xl]] & ea ? C : E;
                    break;
                  }
                for (var wm = we, Yl = ao + 1; Yl < ne.length; Yl++)
                  if (X[ne[Yl]] & (a | l))
                    zd = Yl;
                  else {
                    wm = X[ne[Yl]] & ea ? C : E;
                    break;
                  }
                for (var Gd = bm; Gd <= zd; Gd++)
                  X[ne[Gd]] = Vd === wm ? Vd : Pe;
                ao = zd;
              }
          }
        }
        for (var Or = Ae.start; Or <= Ae.end; Or++) {
          var py = te[Or], ku = X[Or];
          if (py & 1 ? ku & (E | P | D) && te[Or]++ : ku & C ? te[Or]++ : ku & (D | P) && (te[Or] += 2), ku & l && (te[Or] = Or === 0 ? Ae.level : te[Or - 1]), Or === Ae.end || d(Te[Or]) & (k | L))
            for (var Ou = Or; Ou >= 0 && d(Te[Ou]) & c; Ou--)
              te[Ou] = Ae.level;
        }
      }
      return {
        levels: te,
        paragraphs: ye
      };
      function Sm(wr, gs) {
        for (var or = wr; or < Te.length; or++) {
          var Co = X[or];
          if (Co & (C | Z))
            return 1;
          if (Co & (L | E) || gs && Co === _e)
            return 0;
          if (Co & r) {
            var Mm = my(or);
            or = Mm === -1 ? Te.length : Mm;
          }
        }
        return 0;
      }
      function my(wr) {
        for (var gs = 1, or = wr + 1; or < Te.length; or++) {
          var Co = X[or];
          if (Co & L)
            break;
          if (Co & _e) {
            if (--gs === 0)
              return or;
          } else Co & r && gs++;
        }
        return -1;
      }
    }
    var Ie = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", Ee;
    function me() {
      if (!Ee) {
        var Te = g(Ie, !0), Ye = Te.map, Oe = Te.reverseMap;
        Oe.forEach(function(X, Y) {
          Ye.set(Y, X);
        }), Ee = Ye;
      }
    }
    function xe(Te) {
      return me(), Ee.get(Te) || null;
    }
    function $(Te, Ye, Oe, X) {
      var Y = Te.length;
      Oe = Math.max(0, Oe == null ? 0 : +Oe), X = Math.min(Y - 1, X == null ? Y - 1 : +X);
      for (var fe = /* @__PURE__ */ new Map(), ue = Oe; ue <= X; ue++)
        if (Ye[ue] & 1) {
          var te = xe(Te[ue]);
          te !== null && fe.set(ue, te);
        }
      return fe;
    }
    function Ue(Te, Ye, Oe, X) {
      var Y = Te.length;
      Oe = Math.max(0, Oe == null ? 0 : +Oe), X = Math.min(Y - 1, X == null ? Y - 1 : +X);
      var fe = [];
      return Ye.paragraphs.forEach(function(ue) {
        var te = Math.max(Oe, ue.start), Se = Math.min(X, ue.end);
        if (te < Se) {
          for (var ye = Ye.levels.slice(te, Se + 1), Ae = Se; Ae >= te && d(Te[Ae]) & c; Ae--)
            ye[Ae] = ue.level;
          for (var Ce = ue.level, Ge = 1 / 0, De = 0; De < ye.length; De++) {
            var Ve = ye[De];
            Ve > Ce && (Ce = Ve), Ve < Ge && (Ge = Ve | 1);
          }
          for (var ze = Ce; ze >= Ge; ze--)
            for (var Ze = 0; Ze < ye.length; Ze++)
              if (ye[Ze] >= ze) {
                for (var Le = Ze; Ze + 1 < ye.length && ye[Ze + 1] >= ze; )
                  Ze++;
                Ze > Le && fe.push([Le + te, Ze + te]);
              }
        }
      }), fe;
    }
    function Me(Te, Ye, Oe, X) {
      var Y = oe(Te, Ye, Oe, X), fe = [].concat(Te);
      return Y.forEach(function(ue, te) {
        fe[te] = (Ye.levels[ue] & 1 ? xe(Te[ue]) : null) || Te[ue];
      }), fe.join("");
    }
    function oe(Te, Ye, Oe, X) {
      for (var Y = Ue(Te, Ye, Oe, X), fe = [], ue = 0; ue < Te.length; ue++)
        fe[ue] = ue;
      return Y.forEach(function(te) {
        for (var Se = te[0], ye = te[1], Ae = fe.slice(Se, ye + 1), Ce = Ae.length; Ce--; )
          fe[ye - Ce] = Ae[Ce];
      }), fe;
    }
    return e.closingToOpeningBracket = M, e.getBidiCharType = d, e.getBidiCharTypeName = f, e.getCanonicalBracket = A, e.getEmbeddingLevels = Fe, e.getMirroredCharacter = xe, e.getMirroredCharactersMap = $, e.getReorderSegments = Ue, e.getReorderedIndices = oe, e.getReorderedString = Me, e.openingToClosingBracket = x, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
const l3 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function W1(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(i, n) {
    let r = Ft[n];
    return r ? W1(r) : i;
  }
  return s.replace(e, t);
}
const ur = [];
for (let s = 0; s < 256; s++)
  ur[s] = (s < 16 ? "0" : "") + s.toString(16);
function fj() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (ur[s & 255] + ur[s >> 8 & 255] + ur[s >> 16 & 255] + ur[s >> 24 & 255] + "-" + ur[e & 255] + ur[e >> 8 & 255] + "-" + ur[e >> 16 & 15 | 64] + ur[e >> 24 & 255] + "-" + ur[t & 63 | 128] + ur[t >> 8 & 255] + "-" + ur[t >> 16 & 255] + ur[t >> 24 & 255] + ur[i & 255] + ur[i >> 8 & 255] + ur[i >> 16 & 255] + ur[i >> 24 & 255]).toUpperCase();
}
const yc = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let i = arguments[e];
    if (i)
      for (let n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (s[n] = i[n]);
  }
  return s;
}, pj = Date.now(), j2 = /* @__PURE__ */ new WeakMap(), q2 = /* @__PURE__ */ new Map();
let mj = 1e10;
function X1(s, e) {
  const t = yj(e);
  let i = j2.get(s);
  if (i || j2.set(s, i = /* @__PURE__ */ Object.create(null)), i[t])
    return new i[t]();
  const n = `_onBeforeCompile${t}`, r = function(c, u) {
    s.onBeforeCompile.call(this, c, u);
    const h = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
    let d = q2[h];
    if (!d) {
      const f = gj(this, c, e, t);
      d = q2[h] = f;
    }
    c.vertexShader = d.vertexShader, c.fragmentShader = d.fragmentShader, yc(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - pj;
      }
    }), this[n] && this[n](c);
  }, o = function() {
    return a(e.chained ? s : s.clone());
  }, a = function(c) {
    const u = Object.create(c, l);
    return Object.defineProperty(u, "baseMaterial", { value: s }), Object.defineProperty(u, "id", { value: mj++ }), u.uuid = fj(), u.uniforms = yc({}, c.uniforms, e.uniforms), u.defines = yc({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = yc({}, c.extensions, e.extensions), u._listeners = void 0, u;
  }, l = {
    constructor: { value: o },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => s.type,
      set: (c) => {
        s.type = c;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        const u = this.baseMaterial;
        return c === u || u.isDerivedMaterial && u.isDerivedFrom(c) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(c) {
        this[n] = c;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        return s.copy.call(this, c), !s.isShaderMaterial && !s.isDerivedMaterial && (yc(this.extensions, c.extensions), yc(this.defines, c.defines), yc(this.uniforms, Fl.clone(c.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const c = new s.constructor();
        return a(c).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._depthMaterial;
        return c || (c = this._depthMaterial = X1(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Ru({ depthPacking: Md }),
          e
        ), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._distanceMaterial;
        return c || (c = this._distanceMaterial = X1(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new Cd(),
          e
        ), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: c, _distanceMaterial: u } = this;
        c && c.dispose(), u && u.dispose(), s.dispose.call(this);
      }
    }
  };
  return i[t] = o, new o();
}
function gj(s, { vertexShader: e, fragmentShader: t }, i, n) {
  let {
    vertexDefs: r,
    vertexMainIntro: o,
    vertexMainOutro: a,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: m
  } = i;
  if (r = r || "", o = o || "", a = a || "", c = c || "", u = u || "", h = h || "", (l || f) && (e = W1(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = W1(t)), f) {
    let g = f({ vertexShader: e, fragmentShader: t });
    e = g.vertexShader, t = g.fragmentShader;
  }
  if (d) {
    let g = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (v) => (g.push(v), "")
    ), h = `${d}
${g.join(`
`)}
${h}`;
  }
  if (m) {
    const g = `
uniform float ${m};
`;
    r = g + r, c = g + c;
  }
  return l && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, r = `${r}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, o = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (g, v, _, y) => /\battribute\s+vec[23]\s+$/.test(y.substr(0, _)) ? v : `troika_${v}_${n}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = Z2(e, n, r, o, a), t = Z2(t, n, c, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function Z2(s, e, t, i, n) {
  return (i || n || t) && (s = s.replace(
    l3,
    `
${t}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${n}
}`), s;
}
function vj(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let _j = 0;
const K2 = /* @__PURE__ */ new Map();
function yj(s) {
  const e = JSON.stringify(s, vj);
  let t = K2.get(e);
  return t == null && K2.set(e, t = ++_j), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function xj() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(n) {
      var r = e._bin, o = new Uint8Array(n);
      if (r.readASCII(o, 0, 4) == "ttcf") {
        var a = 4;
        r.readUshort(o, a), a += 2, r.readUshort(o, a), a += 2;
        var l = r.readUint(o, a);
        a += 4;
        for (var c = [], u = 0; u < l; u++) {
          var h = r.readUint(o, a);
          a += 4, c.push(e._readFont(o, h));
        }
        return c;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, r) {
      var o = e._bin, a = r;
      o.readFixed(n, r), r += 4;
      var l = o.readUshort(n, r);
      r += 2, o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2;
      for (var c = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: a }, h = {}, d = 0; d < l; d++) {
        var f = o.readASCII(n, r, 4);
        r += 4, o.readUint(n, r), r += 4;
        var m = o.readUint(n, r);
        r += 4;
        var g = o.readUint(n, r);
        r += 4, h[f] = { offset: m, length: g };
      }
      for (d = 0; d < c.length; d++) {
        var v = c[d];
        h[v] && (u[v.trim()] = e[v.trim()].parse(n, h[v].offset, h[v].length, u));
      }
      return u;
    }, _tabOffset: function(n, r, o) {
      for (var a = e._bin, l = a.readUshort(n, o + 4), c = o + 12, u = 0; u < l; u++) {
        var h = a.readASCII(n, c, 4);
        c += 4, a.readUint(n, c), c += 4;
        var d = a.readUint(n, c);
        if (c += 4, a.readUint(n, c), c += 4, h == r) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, r) {
      return (n[r] << 8 | n[r + 1]) + (n[r + 2] << 8 | n[r + 3]) / 65540;
    }, readF2dot14: function(n, r) {
      return e._bin.readShort(n, r) / 16384;
    }, readInt: function(n, r) {
      return e._bin._view(n).getInt32(r);
    }, readInt8: function(n, r) {
      return e._bin._view(n).getInt8(r);
    }, readShort: function(n, r) {
      return e._bin._view(n).getInt16(r);
    }, readUshort: function(n, r) {
      return e._bin._view(n).getUint16(r);
    }, readUshorts: function(n, r, o) {
      for (var a = [], l = 0; l < o; l++) a.push(e._bin.readUshort(n, r + 2 * l));
      return a;
    }, readUint: function(n, r) {
      return e._bin._view(n).getUint32(r);
    }, readUint64: function(n, r) {
      return 4294967296 * e._bin.readUint(n, r) + e._bin.readUint(n, r + 4);
    }, readASCII: function(n, r, o) {
      for (var a = "", l = 0; l < o; l++) a += String.fromCharCode(n[r + l]);
      return a;
    }, readUnicode: function(n, r, o) {
      for (var a = "", l = 0; l < o; l++) {
        var c = n[r++] << 8 | n[r++];
        a += String.fromCharCode(c);
      }
      return a;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, r, o) {
      var a = e._bin._tdec;
      return a && r == 0 && o == n.length ? a.decode(n) : e._bin.readASCII(n, r, o);
    }, readBytes: function(n, r, o) {
      for (var a = [], l = 0; l < o; l++) a.push(n[r + l]);
      return a;
    }, readASCIIArray: function(n, r, o) {
      for (var a = [], l = 0; l < o; l++) a.push(String.fromCharCode(n[r + l]));
      return a;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, r, o, a, l) {
      var c = e._bin, u = {}, h = r;
      c.readFixed(n, r), r += 4;
      var d = c.readUshort(n, r);
      r += 2;
      var f = c.readUshort(n, r);
      r += 2;
      var m = c.readUshort(n, r);
      return r += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + m, l), u;
    }, e._lctf.readLookupList = function(n, r, o) {
      var a = e._bin, l = r, c = [], u = a.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var d = a.readUshort(n, r);
        r += 2;
        var f = e._lctf.readLookupTable(n, l + d, o);
        c.push(f);
      }
      return c;
    }, e._lctf.readLookupTable = function(n, r, o) {
      var a = e._bin, l = r, c = { tabs: [] };
      c.ltype = a.readUshort(n, r), r += 2, c.flag = a.readUshort(n, r), r += 2;
      var u = a.readUshort(n, r);
      r += 2;
      for (var h = c.ltype, d = 0; d < u; d++) {
        var f = a.readUshort(n, r);
        r += 2;
        var m = o(n, h, l + f, c);
        c.tabs.push(m);
      }
      return c;
    }, e._lctf.numOfOnes = function(n) {
      for (var r = 0, o = 0; o < 32; o++) n >>> o & 1 && r++;
      return r;
    }, e._lctf.readClassDef = function(n, r) {
      var o = e._bin, a = [], l = o.readUshort(n, r);
      if (r += 2, l == 1) {
        var c = o.readUshort(n, r);
        r += 2;
        var u = o.readUshort(n, r);
        r += 2;
        for (var h = 0; h < u; h++) a.push(c + h), a.push(c + h), a.push(o.readUshort(n, r)), r += 2;
      }
      if (l == 2) {
        var d = o.readUshort(n, r);
        for (r += 2, h = 0; h < d; h++) a.push(o.readUshort(n, r)), r += 2, a.push(o.readUshort(n, r)), r += 2, a.push(o.readUshort(n, r)), r += 2;
      }
      return a;
    }, e._lctf.getInterval = function(n, r) {
      for (var o = 0; o < n.length; o += 3) {
        var a = n[o], l = n[o + 1];
        if (n[o + 2], a <= r && r <= l) return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, r) {
      var o = e._bin, a = {};
      a.fmt = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      return r += 2, a.fmt == 1 && (a.tab = o.readUshorts(n, r, l)), a.fmt == 2 && (a.tab = o.readUshorts(n, r, 3 * l)), a;
    }, e._lctf.coverageIndex = function(n, r) {
      var o = n.tab;
      if (n.fmt == 1) return o.indexOf(r);
      if (n.fmt == 2) {
        var a = e._lctf.getInterval(o, r);
        if (a != -1) return o[a + 2] + (r - o[a]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, r) {
      var o = e._bin, a = r, l = [], c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readASCII(n, r, 4);
        r += 4;
        var d = o.readUshort(n, r);
        r += 2;
        var f = e._lctf.readFeatureTable(n, a + d);
        f.tag = h.trim(), l.push(f);
      }
      return l;
    }, e._lctf.readFeatureTable = function(n, r) {
      var o = e._bin, a = r, l = {}, c = o.readUshort(n, r);
      r += 2, c > 0 && (l.featureParams = a + c);
      var u = o.readUshort(n, r);
      r += 2, l.tab = [];
      for (var h = 0; h < u; h++) l.tab.push(o.readUshort(n, r + 2 * h));
      return l;
    }, e._lctf.readScriptList = function(n, r) {
      var o = e._bin, a = r, l = {}, c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readASCII(n, r, 4);
        r += 4;
        var d = o.readUshort(n, r);
        r += 2, l[h.trim()] = e._lctf.readScriptTable(n, a + d);
      }
      return l;
    }, e._lctf.readScriptTable = function(n, r) {
      var o = e._bin, a = r, l = {}, c = o.readUshort(n, r);
      r += 2, c > 0 && (l.default = e._lctf.readLangSysTable(n, a + c));
      var u = o.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, r, 4);
        r += 4;
        var f = o.readUshort(n, r);
        r += 2, l[d.trim()] = e._lctf.readLangSysTable(n, a + f);
      }
      return l;
    }, e._lctf.readLangSysTable = function(n, r) {
      var o = e._bin, a = {};
      o.readUshort(n, r), r += 2, a.reqFeature = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      return r += 2, a.features = o.readUshorts(n, r, l), a;
    }, e.CFF = {}, e.CFF.parse = function(n, r, o) {
      var a = e._bin;
      (n = new Uint8Array(n.buffer, r, o))[r = 0], n[++r], n[++r], n[++r], r++;
      var l = [];
      r = e.CFF.readIndex(n, r, l);
      for (var c = [], u = 0; u < l.length - 1; u++) c.push(a.readASCII(n, r + l[u], l[u + 1] - l[u]));
      r += l[l.length - 1];
      var h = [];
      r = e.CFF.readIndex(n, r, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++) d.push(e.CFF.readDict(n, r + h[u], r + h[u + 1]));
      r += h[h.length - 1];
      var f = d[0], m = [];
      r = e.CFF.readIndex(n, r, m);
      var g = [];
      for (u = 0; u < m.length - 1; u++) g.push(a.readASCII(n, r + m[u], m[u + 1] - m[u]));
      if (r += m[m.length - 1], e.CFF.readSubrs(n, r, f), f.CharStrings) {
        r = f.CharStrings, m = [], r = e.CFF.readIndex(n, r, m);
        var v = [];
        for (u = 0; u < m.length - 1; u++) v.push(a.readBytes(n, r + m[u], m[u + 1] - m[u]));
        f.CharStrings = v;
      }
      if (f.ROS) {
        r = f.FDArray;
        var _ = [];
        for (r = e.CFF.readIndex(n, r, _), f.FDArray = [], u = 0; u < _.length - 1; u++) {
          var y = e.CFF.readDict(n, r + _[u], r + _[u + 1]);
          e.CFF._readFDict(n, y, g), f.FDArray.push(y);
        }
        r += _[_.length - 1], r = f.FDSelect, f.FDSelect = [];
        var w = n[r];
        if (r++, w != 3) throw w;
        var x = a.readUshort(n, r);
        for (r += 2, u = 0; u < x + 1; u++) f.FDSelect.push(a.readUshort(n, r), n[r + 2]), r += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, g), f;
    }, e.CFF._readFDict = function(n, r, o) {
      var a;
      for (var l in r.Private && (a = r.Private[1], r.Private = e.CFF.readDict(n, a, a + r.Private[0]), r.Private.Subrs && e.CFF.readSubrs(n, a + r.Private.Subrs, r.Private)), r) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(l) != -1 && (r[l] = o[r[l] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, r, o) {
      var a = e._bin, l = [];
      r = e.CFF.readIndex(n, r, l);
      var c, u = l.length;
      c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = c, o.Subrs = [];
      for (var h = 0; h < l.length - 1; h++) o.Subrs.push(a.readBytes(n, r + l[h], l[h + 1] - l[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, r) {
      for (var o = 0; o < n.charset.length; o++) if (n.charset[o] == r) return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, r) {
      return r < 0 || r > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[r]);
    }, e.CFF.readEncoding = function(n, r, o) {
      e._bin;
      var a = [".notdef"], l = n[r];
      if (r++, l != 0) throw "error: unknown encoding format: " + l;
      var c = n[r];
      r++;
      for (var u = 0; u < c; u++) a.push(n[r + u]);
      return a;
    }, e.CFF.readCharset = function(n, r, o) {
      var a = e._bin, l = [".notdef"], c = n[r];
      if (r++, c == 0) for (var u = 0; u < o; u++) {
        var h = a.readUshort(n, r);
        r += 2, l.push(h);
      }
      else {
        if (c != 1 && c != 2) throw "error: format: " + c;
        for (; l.length < o; ) {
          h = a.readUshort(n, r), r += 2;
          var d = 0;
          for (c == 1 ? (d = n[r], r++) : (d = a.readUshort(n, r), r += 2), u = 0; u <= d; u++) l.push(h), h++;
        }
      }
      return l;
    }, e.CFF.readIndex = function(n, r, o) {
      var a = e._bin, l = a.readUshort(n, r) + 1, c = n[r += 2];
      if (r++, c == 1) for (var u = 0; u < l; u++) o.push(n[r + u]);
      else if (c == 2) for (u = 0; u < l; u++) o.push(a.readUshort(n, r + 2 * u));
      else if (c == 3) for (u = 0; u < l; u++) o.push(16777215 & a.readUint(n, r + 3 * u - 1));
      else if (l != 1) throw "unsupported offset size: " + c + ", count: " + l;
      return (r += l * c) - 1;
    }, e.CFF.getCharString = function(n, r, o) {
      var a = e._bin, l = n[r], c = n[r + 1];
      n[r + 2], n[r + 3], n[r + 4];
      var u = 1, h = null, d = null;
      l <= 20 && (h = l, u = 1), l == 12 && (h = 100 * l + c, u = 2), 21 <= l && l <= 27 && (h = l, u = 1), l == 28 && (d = a.readShort(n, r + 1), u = 3), 29 <= l && l <= 31 && (h = l, u = 1), 32 <= l && l <= 246 && (d = l - 139, u = 1), 247 <= l && l <= 250 && (d = 256 * (l - 247) + c + 108, u = 2), 251 <= l && l <= 254 && (d = 256 * -(l - 251) - c - 108, u = 2), l == 255 && (d = a.readInt(n, r + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, r, o) {
      for (var a = r + o, l = e._bin, c = []; r < a; ) {
        var u = n[r], h = n[r + 1];
        n[r + 2], n[r + 3], n[r + 4];
        var d = 1, f = null, m = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (m = l.readShort(n, r + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (m = u - 139, d = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (m = l.readInt(n, r + 1) / 65535, d = 5), c.push(m ?? "o" + f), r += d;
      }
      return c;
    }, e.CFF.readDict = function(n, r, o) {
      for (var a = e._bin, l = {}, c = []; r < o; ) {
        var u = n[r], h = n[r + 1];
        n[r + 2], n[r + 3], n[r + 4];
        var d = 1, f = null, m = null;
        if (u == 28 && (m = a.readShort(n, r + 1), d = 3), u == 29 && (m = a.readInt(n, r + 1), d = 5), 32 <= u && u <= 246 && (m = u - 139, d = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - h - 108, d = 2), u == 255) throw m = a.readInt(n, r + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var g = [];
          for (d = 1; ; ) {
            var v = n[r + d];
            d++;
            var _ = v >> 4, y = 15 & v;
            if (_ != 15 && g.push(_), y != 15 && g.push(y), y == 15) break;
          }
          for (var w = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], M = 0; M < g.length; M++) w += x[g[M]];
          m = parseFloat(w);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (l[f] = c.length == 1 ? c[0] : c, c = []) : c.push(m), r += d;
      }
      return l;
    }, e.cmap = {}, e.cmap.parse = function(n, r, o) {
      n = new Uint8Array(n.buffer, r, o), r = 0;
      var a = e._bin, l = {};
      a.readUshort(n, r), r += 2;
      var c = a.readUshort(n, r);
      r += 2;
      var u = [];
      l.tables = [];
      for (var h = 0; h < c; h++) {
        var d = a.readUshort(n, r);
        r += 2;
        var f = a.readUshort(n, r);
        r += 2;
        var m = a.readUint(n, r);
        r += 4;
        var g = "p" + d + "e" + f, v = u.indexOf(m);
        if (v == -1) {
          var _;
          v = l.tables.length, u.push(m);
          var y = a.readUshort(n, m);
          y == 0 ? _ = e.cmap.parse0(n, m) : y == 4 ? _ = e.cmap.parse4(n, m) : y == 6 ? _ = e.cmap.parse6(n, m) : y == 12 ? _ = e.cmap.parse12(n, m) : console.debug("unknown format: " + y, d, f, m), l.tables.push(_);
        }
        if (l[g] != null) throw "multiple tables for one platform+encoding";
        l[g] = v;
      }
      return l;
    }, e.cmap.parse0 = function(n, r) {
      var o = e._bin, a = {};
      a.format = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      r += 2, o.readUshort(n, r), r += 2, a.map = [];
      for (var c = 0; c < l - 6; c++) a.map.push(n[r + c]);
      return a;
    }, e.cmap.parse4 = function(n, r) {
      var o = e._bin, a = r, l = {};
      l.format = o.readUshort(n, r), r += 2;
      var c = o.readUshort(n, r);
      r += 2, o.readUshort(n, r), r += 2;
      var u = o.readUshort(n, r);
      r += 2;
      var h = u / 2;
      l.searchRange = o.readUshort(n, r), r += 2, l.entrySelector = o.readUshort(n, r), r += 2, l.rangeShift = o.readUshort(n, r), r += 2, l.endCount = o.readUshorts(n, r, h), r += 2 * h, r += 2, l.startCount = o.readUshorts(n, r, h), r += 2 * h, l.idDelta = [];
      for (var d = 0; d < h; d++) l.idDelta.push(o.readShort(n, r)), r += 2;
      for (l.idRangeOffset = o.readUshorts(n, r, h), r += 2 * h, l.glyphIdArray = []; r < a + c; ) l.glyphIdArray.push(o.readUshort(n, r)), r += 2;
      return l;
    }, e.cmap.parse6 = function(n, r) {
      var o = e._bin, a = {};
      a.format = o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2, a.firstCode = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      r += 2, a.glyphIdArray = [];
      for (var c = 0; c < l; c++) a.glyphIdArray.push(o.readUshort(n, r)), r += 2;
      return a;
    }, e.cmap.parse12 = function(n, r) {
      var o = e._bin, a = {};
      a.format = o.readUshort(n, r), r += 2, r += 2, o.readUint(n, r), r += 4, o.readUint(n, r), r += 4;
      var l = o.readUint(n, r);
      r += 4, a.groups = [];
      for (var c = 0; c < l; c++) {
        var u = r + 12 * c, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        a.groups.push([h, d, f]);
      }
      return a;
    }, e.glyf = {}, e.glyf.parse = function(n, r, o, a) {
      for (var l = [], c = 0; c < a.maxp.numGlyphs; c++) l.push(null);
      return l;
    }, e.glyf._parseGlyf = function(n, r) {
      var o = e._bin, a = n._data, l = e._tabOffset(a, "glyf", n._offset) + n.loca[r];
      if (n.loca[r] == n.loca[r + 1]) return null;
      var c = {};
      if (c.noc = o.readShort(a, l), l += 2, c.xMin = o.readShort(a, l), l += 2, c.yMin = o.readShort(a, l), l += 2, c.xMax = o.readShort(a, l), l += 2, c.yMax = o.readShort(a, l), l += 2, c.xMin >= c.xMax || c.yMin >= c.yMax) return null;
      if (c.noc > 0) {
        c.endPts = [];
        for (var u = 0; u < c.noc; u++) c.endPts.push(o.readUshort(a, l)), l += 2;
        var h = o.readUshort(a, l);
        if (l += 2, a.length - l < h) return null;
        c.instructions = o.readBytes(a, l, h), l += h;
        var d = c.endPts[c.noc - 1] + 1;
        for (c.flags = [], u = 0; u < d; u++) {
          var f = a[l];
          if (l++, c.flags.push(f), (8 & f) != 0) {
            var m = a[l];
            l++;
            for (var g = 0; g < m; g++) c.flags.push(f), u++;
          }
        }
        for (c.xs = [], u = 0; u < d; u++) {
          var v = (2 & c.flags[u]) != 0, _ = (16 & c.flags[u]) != 0;
          v ? (c.xs.push(_ ? a[l] : -a[l]), l++) : _ ? c.xs.push(0) : (c.xs.push(o.readShort(a, l)), l += 2);
        }
        for (c.ys = [], u = 0; u < d; u++)
          v = (4 & c.flags[u]) != 0, _ = (32 & c.flags[u]) != 0, v ? (c.ys.push(_ ? a[l] : -a[l]), l++) : _ ? c.ys.push(0) : (c.ys.push(o.readShort(a, l)), l += 2);
        var y = 0, w = 0;
        for (u = 0; u < d; u++) y += c.xs[u], w += c.ys[u], c.xs[u] = y, c.ys[u] = w;
      } else {
        var x;
        c.parts = [];
        do {
          x = o.readUshort(a, l), l += 2;
          var M = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (c.parts.push(M), M.glyphIndex = o.readUshort(a, l), l += 2, 1 & x) {
            var A = o.readShort(a, l);
            l += 2;
            var E = o.readShort(a, l);
            l += 2;
          } else
            A = o.readInt8(a, l), l++, E = o.readInt8(a, l), l++;
          2 & x ? (M.m.tx = A, M.m.ty = E) : (M.p1 = A, M.p2 = E), 8 & x ? (M.m.a = M.m.d = o.readF2dot14(a, l), l += 2) : 64 & x ? (M.m.a = o.readF2dot14(a, l), l += 2, M.m.d = o.readF2dot14(a, l), l += 2) : 128 & x && (M.m.a = o.readF2dot14(a, l), l += 2, M.m.b = o.readF2dot14(a, l), l += 2, M.m.c = o.readF2dot14(a, l), l += 2, M.m.d = o.readF2dot14(a, l), l += 2);
        } while (32 & x);
        if (256 & x) {
          var C = o.readUshort(a, l);
          for (l += 2, c.instr = [], u = 0; u < C; u++) c.instr.push(a[l]), l++;
        }
      }
      return c;
    }, e.GDEF = {}, e.GDEF.parse = function(n, r, o, a) {
      var l = r;
      r += 4;
      var c = e._bin.readUshort(n, r);
      return { glyphClassDef: c === 0 ? null : e._lctf.readClassDef(n, l + c) };
    }, e.GPOS = {}, e.GPOS.parse = function(n, r, o, a) {
      return e._lctf.parse(n, r, o, a, e.GPOS.subt);
    }, e.GPOS.subt = function(n, r, o, a) {
      var l = e._bin, c = o, u = {};
      if (u.fmt = l.readUshort(n, o), o += 2, r == 1 || r == 2 || r == 3 || r == 7 || r == 8 && u.fmt <= 2) {
        var h = l.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + c);
      }
      if (r == 1 && u.fmt == 1) {
        var d = l.readUshort(n, o);
        o += 2, d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (r == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = l.readUshort(n, o), o += 2;
        var f = l.readUshort(n, o);
        o += 2;
        var m = e._lctf.numOfOnes(d), g = e._lctf.numOfOnes(f);
        if (u.fmt == 1) {
          u.pairsets = [];
          var v = l.readUshort(n, o);
          o += 2;
          for (var _ = 0; _ < v; _++) {
            var y = c + l.readUshort(n, o);
            o += 2;
            var w = l.readUshort(n, y);
            y += 2;
            for (var x = [], M = 0; M < w; M++) {
              var A = l.readUshort(n, y);
              y += 2, d != 0 && (D = e.GPOS.readValueRecord(n, y, d), y += 2 * m), f != 0 && (U = e.GPOS.readValueRecord(n, y, f), y += 2 * g), x.push({ gid2: A, val1: D, val2: U });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var E = l.readUshort(n, o);
          o += 2;
          var C = l.readUshort(n, o);
          o += 2;
          var P = l.readUshort(n, o);
          o += 2;
          var T = l.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, c + E), u.classDef2 = e._lctf.readClassDef(n, c + C), u.matrix = [], _ = 0; _ < P; _++) {
            var I = [];
            for (M = 0; M < T; M++) {
              var D = null, U = null;
              d != 0 && (D = e.GPOS.readValueRecord(n, o, d), o += 2 * m), f != 0 && (U = e.GPOS.readValueRecord(n, o, f), o += 2 * g), I.push({ val1: D, val2: U });
            }
            u.matrix.push(I);
          }
        }
      } else if (r == 4 && u.fmt == 1) u.markCoverage = e._lctf.readCoverage(n, l.readUshort(n, o) + c), u.baseCoverage = e._lctf.readCoverage(n, l.readUshort(n, o + 2) + c), u.markClassCount = l.readUshort(n, o + 4), u.markArray = e.GPOS.readMarkArray(n, l.readUshort(n, o + 6) + c), u.baseArray = e.GPOS.readBaseArray(n, l.readUshort(n, o + 8) + c, u.markClassCount);
      else if (r == 6 && u.fmt == 1) u.mark1Coverage = e._lctf.readCoverage(n, l.readUshort(n, o) + c), u.mark2Coverage = e._lctf.readCoverage(n, l.readUshort(n, o + 2) + c), u.markClassCount = l.readUshort(n, o + 4), u.mark1Array = e.GPOS.readMarkArray(n, l.readUshort(n, o + 6) + c), u.mark2Array = e.GPOS.readBaseArray(n, l.readUshort(n, o + 8) + c, u.markClassCount);
      else {
        if (r == 9 && u.fmt == 1) {
          var L = l.readUshort(n, o);
          o += 2;
          var k = l.readUint(n, o);
          if (o += 4, a.ltype == 9) a.ltype = L;
          else if (a.ltype != L) throw "invalid extension substitution";
          return e.GPOS.subt(n, a.ltype, c + k);
        }
        console.debug("unsupported GPOS table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, r, o) {
      var a = e._bin, l = [];
      return l.push(1 & o ? a.readShort(n, r) : 0), r += 1 & o ? 2 : 0, l.push(2 & o ? a.readShort(n, r) : 0), r += 2 & o ? 2 : 0, l.push(4 & o ? a.readShort(n, r) : 0), r += 4 & o ? 2 : 0, l.push(8 & o ? a.readShort(n, r) : 0), r += 8 & o ? 2 : 0, l;
    }, e.GPOS.readBaseArray = function(n, r, o) {
      var a = e._bin, l = [], c = r, u = a.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        for (var d = [], f = 0; f < o; f++) d.push(e.GPOS.readAnchorRecord(n, c + a.readUshort(n, r))), r += 2;
        l.push(d);
      }
      return l;
    }, e.GPOS.readMarkArray = function(n, r) {
      var o = e._bin, a = [], l = r, c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = e.GPOS.readAnchorRecord(n, o.readUshort(n, r + 2) + l);
        h.markClass = o.readUshort(n, r), a.push(h), r += 4;
      }
      return a;
    }, e.GPOS.readAnchorRecord = function(n, r) {
      var o = e._bin, a = {};
      return a.fmt = o.readUshort(n, r), a.x = o.readShort(n, r + 2), a.y = o.readShort(n, r + 4), a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, r, o, a) {
      return e._lctf.parse(n, r, o, a, e.GSUB.subt);
    }, e.GSUB.subt = function(n, r, o, a) {
      var l = e._bin, c = o, u = {};
      if (u.fmt = l.readUshort(n, o), o += 2, r != 1 && r != 2 && r != 4 && r != 5 && r != 6) return null;
      if (r == 1 || r == 2 || r == 4 || r == 5 && u.fmt <= 2 || r == 6 && u.fmt <= 2) {
        var h = l.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, c + h);
      }
      if (r == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1) u.delta = l.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = l.readUshort(n, o);
          o += 2, u.newg = l.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (r == 2 && u.fmt == 1) {
        d = l.readUshort(n, o), o += 2, u.seqs = [];
        for (var f = 0; f < d; f++) {
          var m = l.readUshort(n, o) + c;
          o += 2;
          var g = l.readUshort(n, m);
          u.seqs.push(l.readUshorts(n, m + 2, g));
        }
      } else if (r == 4)
        for (u.vals = [], d = l.readUshort(n, o), o += 2, f = 0; f < d; f++) {
          var v = l.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, c + v));
        }
      else if (r == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var _ = l.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, c + _), u.scset = [];
          var y = l.readUshort(n, o);
          for (o += 2, f = 0; f < y; f++) {
            var w = l.readUshort(n, o);
            o += 2, u.scset.push(w == 0 ? null : e.GSUB.readSubClassSet(n, c + w));
          }
        }
      } else if (r == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = l.readUshort(n, o), o += 2;
            for (var x = [], M = 0; M < d; M++) x.push(e._lctf.readCoverage(n, c + l.readUshort(n, o + 2 * M)));
            o += 2 * d, f == 0 && (u.backCvg = x), f == 1 && (u.inptCvg = x), f == 2 && (u.ahedCvg = x);
          }
          d = l.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (r == 7 && u.fmt == 1) {
          var A = l.readUshort(n, o);
          o += 2;
          var E = l.readUint(n, o);
          if (o += 4, a.ltype == 9) a.ltype = A;
          else if (a.ltype != A) throw "invalid extension substitution";
          return e.GSUB.subt(n, a.ltype, c + E);
        }
        console.debug("unsupported GSUB table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, r) {
      var o = e._bin.readUshort, a = r, l = [], c = o(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o(n, r);
        r += 2, l.push(e.GSUB.readSubClassRule(n, a + h));
      }
      return l;
    }, e.GSUB.readSubClassRule = function(n, r) {
      var o = e._bin.readUshort, a = {}, l = o(n, r), c = o(n, r += 2);
      r += 2, a.input = [];
      for (var u = 0; u < l - 1; u++) a.input.push(o(n, r)), r += 2;
      return a.substLookupRecords = e.GSUB.readSubstLookupRecords(n, r, c), a;
    }, e.GSUB.readSubstLookupRecords = function(n, r, o) {
      for (var a = e._bin.readUshort, l = [], c = 0; c < o; c++) l.push(a(n, r), a(n, r + 2)), r += 4;
      return l;
    }, e.GSUB.readChainSubClassSet = function(n, r) {
      var o = e._bin, a = r, l = [], c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readUshort(n, r);
        r += 2, l.push(e.GSUB.readChainSubClassRule(n, a + h));
      }
      return l;
    }, e.GSUB.readChainSubClassRule = function(n, r) {
      for (var o = e._bin, a = {}, l = ["backtrack", "input", "lookahead"], c = 0; c < l.length; c++) {
        var u = o.readUshort(n, r);
        r += 2, c == 1 && u--, a[l[c]] = o.readUshorts(n, r, u), r += 2 * a[l[c]].length;
      }
      return u = o.readUshort(n, r), r += 2, a.subst = o.readUshorts(n, r, 2 * u), r += 2 * a.subst.length, a;
    }, e.GSUB.readLigatureSet = function(n, r) {
      var o = e._bin, a = r, l = [], c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readUshort(n, r);
        r += 2, l.push(e.GSUB.readLigature(n, a + h));
      }
      return l;
    }, e.GSUB.readLigature = function(n, r) {
      var o = e._bin, a = { chain: [] };
      a.nglyph = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      r += 2;
      for (var c = 0; c < l - 1; c++) a.chain.push(o.readUshort(n, r)), r += 2;
      return a;
    }, e.head = {}, e.head.parse = function(n, r, o) {
      var a = e._bin, l = {};
      return a.readFixed(n, r), r += 4, l.fontRevision = a.readFixed(n, r), r += 4, a.readUint(n, r), r += 4, a.readUint(n, r), r += 4, l.flags = a.readUshort(n, r), r += 2, l.unitsPerEm = a.readUshort(n, r), r += 2, l.created = a.readUint64(n, r), r += 8, l.modified = a.readUint64(n, r), r += 8, l.xMin = a.readShort(n, r), r += 2, l.yMin = a.readShort(n, r), r += 2, l.xMax = a.readShort(n, r), r += 2, l.yMax = a.readShort(n, r), r += 2, l.macStyle = a.readUshort(n, r), r += 2, l.lowestRecPPEM = a.readUshort(n, r), r += 2, l.fontDirectionHint = a.readShort(n, r), r += 2, l.indexToLocFormat = a.readShort(n, r), r += 2, l.glyphDataFormat = a.readShort(n, r), r += 2, l;
    }, e.hhea = {}, e.hhea.parse = function(n, r, o) {
      var a = e._bin, l = {};
      return a.readFixed(n, r), r += 4, l.ascender = a.readShort(n, r), r += 2, l.descender = a.readShort(n, r), r += 2, l.lineGap = a.readShort(n, r), r += 2, l.advanceWidthMax = a.readUshort(n, r), r += 2, l.minLeftSideBearing = a.readShort(n, r), r += 2, l.minRightSideBearing = a.readShort(n, r), r += 2, l.xMaxExtent = a.readShort(n, r), r += 2, l.caretSlopeRise = a.readShort(n, r), r += 2, l.caretSlopeRun = a.readShort(n, r), r += 2, l.caretOffset = a.readShort(n, r), r += 2, r += 8, l.metricDataFormat = a.readShort(n, r), r += 2, l.numberOfHMetrics = a.readUshort(n, r), r += 2, l;
    }, e.hmtx = {}, e.hmtx.parse = function(n, r, o, a) {
      for (var l = e._bin, c = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < a.maxp.numGlyphs; d++) d < a.hhea.numberOfHMetrics && (u = l.readUshort(n, r), r += 2, h = l.readShort(n, r), r += 2), c.aWidth.push(u), c.lsBearing.push(h);
      return c;
    }, e.kern = {}, e.kern.parse = function(n, r, o, a) {
      var l = e._bin, c = l.readUshort(n, r);
      if (r += 2, c == 1) return e.kern.parseV1(n, r - 2, o, a);
      var u = l.readUshort(n, r);
      r += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        r += 2, o = l.readUshort(n, r), r += 2;
        var f = l.readUshort(n, r);
        r += 2;
        var m = f >>> 8;
        if ((m &= 15) != 0) throw "unknown kern table format: " + m;
        r = e.kern.readFormat0(n, r, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, r, o, a) {
      var l = e._bin;
      l.readFixed(n, r), r += 4;
      var c = l.readUint(n, r);
      r += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < c; h++) {
        l.readUint(n, r), r += 4;
        var d = l.readUshort(n, r);
        r += 2, l.readUshort(n, r), r += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0) throw "unknown kern table format: " + f;
        r = e.kern.readFormat0(n, r, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, r, o) {
      var a = e._bin, l = -1, c = a.readUshort(n, r);
      r += 2, a.readUshort(n, r), r += 2, a.readUshort(n, r), r += 2, a.readUshort(n, r), r += 2;
      for (var u = 0; u < c; u++) {
        var h = a.readUshort(n, r);
        r += 2;
        var d = a.readUshort(n, r);
        r += 2;
        var f = a.readShort(n, r);
        r += 2, h != l && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var m = o.rval[o.rval.length - 1];
        m.glyph2.push(d), m.vals.push(f), l = h;
      }
      return r;
    }, e.loca = {}, e.loca.parse = function(n, r, o, a) {
      var l = e._bin, c = [], u = a.head.indexToLocFormat, h = a.maxp.numGlyphs + 1;
      if (u == 0) for (var d = 0; d < h; d++) c.push(l.readUshort(n, r + (d << 1)) << 1);
      if (u == 1) for (d = 0; d < h; d++) c.push(l.readUint(n, r + (d << 2)));
      return c;
    }, e.maxp = {}, e.maxp.parse = function(n, r, o) {
      var a = e._bin, l = {}, c = a.readUint(n, r);
      return r += 4, l.numGlyphs = a.readUshort(n, r), r += 2, c == 65536 && (l.maxPoints = a.readUshort(n, r), r += 2, l.maxContours = a.readUshort(n, r), r += 2, l.maxCompositePoints = a.readUshort(n, r), r += 2, l.maxCompositeContours = a.readUshort(n, r), r += 2, l.maxZones = a.readUshort(n, r), r += 2, l.maxTwilightPoints = a.readUshort(n, r), r += 2, l.maxStorage = a.readUshort(n, r), r += 2, l.maxFunctionDefs = a.readUshort(n, r), r += 2, l.maxInstructionDefs = a.readUshort(n, r), r += 2, l.maxStackElements = a.readUshort(n, r), r += 2, l.maxSizeOfInstructions = a.readUshort(n, r), r += 2, l.maxComponentElements = a.readUshort(n, r), r += 2, l.maxComponentDepth = a.readUshort(n, r), r += 2), l;
    }, e.name = {}, e.name.parse = function(n, r, o) {
      var a = e._bin, l = {};
      a.readUshort(n, r), r += 2;
      var c = a.readUshort(n, r);
      r += 2, a.readUshort(n, r);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = r += 2, f = 0; f < c; f++) {
        var m = a.readUshort(n, r);
        r += 2;
        var g = a.readUshort(n, r);
        r += 2;
        var v = a.readUshort(n, r);
        r += 2;
        var _ = a.readUshort(n, r);
        r += 2;
        var y = a.readUshort(n, r);
        r += 2;
        var w = a.readUshort(n, r);
        r += 2;
        var x, M = h[_], A = d + 12 * c + w;
        if (m == 0) x = a.readUnicode(n, A, y / 2);
        else if (m == 3 && g == 0) x = a.readUnicode(n, A, y / 2);
        else if (g == 0) x = a.readASCII(n, A, y);
        else if (g == 1) x = a.readUnicode(n, A, y / 2);
        else if (g == 3) x = a.readUnicode(n, A, y / 2);
        else {
          if (m != 1) throw "unknown encoding " + g + ", platformID: " + m;
          x = a.readASCII(n, A, y), console.debug("reading unknown MAC encoding " + g + " as ASCII");
        }
        var E = "p" + m + "," + v.toString(16);
        l[E] == null && (l[E] = {}), l[E][M !== void 0 ? M : _] = x, l[E]._lang = v;
      }
      for (var C in l) if (l[C].postScriptName != null && l[C]._lang == 1033) return l[C];
      for (var C in l) if (l[C].postScriptName != null && l[C]._lang == 0) return l[C];
      for (var C in l) if (l[C].postScriptName != null && l[C]._lang == 3084) return l[C];
      for (var C in l) if (l[C].postScriptName != null) return l[C];
      for (var C in l) {
        u = C;
        break;
      }
      return console.debug("returning name table with languageID " + l[u]._lang), l[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, r, o) {
      var a = e._bin.readUshort(n, r);
      r += 2;
      var l = {};
      if (a == 0) e["OS/2"].version0(n, r, l);
      else if (a == 1) e["OS/2"].version1(n, r, l);
      else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(n, r, l);
      else {
        if (a != 5) throw "unknown OS/2 table version: " + a;
        e["OS/2"].version5(n, r, l);
      }
      return l;
    }, e["OS/2"].version0 = function(n, r, o) {
      var a = e._bin;
      return o.xAvgCharWidth = a.readShort(n, r), r += 2, o.usWeightClass = a.readUshort(n, r), r += 2, o.usWidthClass = a.readUshort(n, r), r += 2, o.fsType = a.readUshort(n, r), r += 2, o.ySubscriptXSize = a.readShort(n, r), r += 2, o.ySubscriptYSize = a.readShort(n, r), r += 2, o.ySubscriptXOffset = a.readShort(n, r), r += 2, o.ySubscriptYOffset = a.readShort(n, r), r += 2, o.ySuperscriptXSize = a.readShort(n, r), r += 2, o.ySuperscriptYSize = a.readShort(n, r), r += 2, o.ySuperscriptXOffset = a.readShort(n, r), r += 2, o.ySuperscriptYOffset = a.readShort(n, r), r += 2, o.yStrikeoutSize = a.readShort(n, r), r += 2, o.yStrikeoutPosition = a.readShort(n, r), r += 2, o.sFamilyClass = a.readShort(n, r), r += 2, o.panose = a.readBytes(n, r, 10), r += 10, o.ulUnicodeRange1 = a.readUint(n, r), r += 4, o.ulUnicodeRange2 = a.readUint(n, r), r += 4, o.ulUnicodeRange3 = a.readUint(n, r), r += 4, o.ulUnicodeRange4 = a.readUint(n, r), r += 4, o.achVendID = [a.readInt8(n, r), a.readInt8(n, r + 1), a.readInt8(n, r + 2), a.readInt8(n, r + 3)], r += 4, o.fsSelection = a.readUshort(n, r), r += 2, o.usFirstCharIndex = a.readUshort(n, r), r += 2, o.usLastCharIndex = a.readUshort(n, r), r += 2, o.sTypoAscender = a.readShort(n, r), r += 2, o.sTypoDescender = a.readShort(n, r), r += 2, o.sTypoLineGap = a.readShort(n, r), r += 2, o.usWinAscent = a.readUshort(n, r), r += 2, o.usWinDescent = a.readUshort(n, r), r += 2;
    }, e["OS/2"].version1 = function(n, r, o) {
      var a = e._bin;
      return r = e["OS/2"].version0(n, r, o), o.ulCodePageRange1 = a.readUint(n, r), r += 4, o.ulCodePageRange2 = a.readUint(n, r), r += 4;
    }, e["OS/2"].version2 = function(n, r, o) {
      var a = e._bin;
      return r = e["OS/2"].version1(n, r, o), o.sxHeight = a.readShort(n, r), r += 2, o.sCapHeight = a.readShort(n, r), r += 2, o.usDefault = a.readUshort(n, r), r += 2, o.usBreak = a.readUshort(n, r), r += 2, o.usMaxContext = a.readUshort(n, r), r += 2;
    }, e["OS/2"].version5 = function(n, r, o) {
      var a = e._bin;
      return r = e["OS/2"].version2(n, r, o), o.usLowerOpticalPointSize = a.readUshort(n, r), r += 2, o.usUpperOpticalPointSize = a.readUshort(n, r), r += 2;
    }, e.post = {}, e.post.parse = function(n, r, o) {
      var a = e._bin, l = {};
      return l.version = a.readFixed(n, r), r += 4, l.italicAngle = a.readFixed(n, r), r += 4, l.underlinePosition = a.readShort(n, r), r += 2, l.underlineThickness = a.readShort(n, r), r += 2, l;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, r) {
      var o = n.cmap, a = -1;
      if (o.p0e4 != null ? a = o.p0e4 : o.p3e1 != null ? a = o.p3e1 : o.p1e0 != null ? a = o.p1e0 : o.p0e3 != null && (a = o.p0e3), a == -1) throw "no familiar platform and encoding!";
      var l = o.tables[a];
      if (l.format == 0) return r >= l.map.length ? 0 : l.map[r];
      if (l.format == 4) {
        for (var c = -1, u = 0; u < l.endCount.length; u++) if (r <= l.endCount[u]) {
          c = u;
          break;
        }
        return c == -1 || l.startCount[c] > r ? 0 : 65535 & (l.idRangeOffset[c] != 0 ? l.glyphIdArray[r - l.startCount[c] + (l.idRangeOffset[c] >> 1) - (l.idRangeOffset.length - c)] : r + l.idDelta[c]);
      }
      if (l.format == 12) {
        if (r > l.groups[l.groups.length - 1][1]) return 0;
        for (u = 0; u < l.groups.length; u++) {
          var h = l.groups[u];
          if (h[0] <= r && r <= h[1]) return h[2] + (r - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + l.format;
    }, e.U.glyphToPath = function(n, r) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[r]) {
        var a = n.SVG.entries[r];
        return a == null ? o : (typeof a == "string" && (a = e.SVG.toPath(a), n.SVG.entries[r] = a), a);
      }
      if (n.CFF) {
        var l = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, c = n.CFF, u = n.CFF.Private;
        if (c.ROS) {
          for (var h = 0; c.FDSelect[h + 2] <= r; ) h += 2;
          u = c.FDArray[c.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[r], l, c, u, o);
      } else n.glyf && e.U._drawGlyf(r, n, o);
      return o;
    }, e.U._drawGlyf = function(n, r, o) {
      var a = r.glyf[n];
      a == null && (a = r.glyf[n] = e.glyf._parseGlyf(r, n)), a != null && (a.noc > -1 ? e.U._simpleGlyph(a, o) : e.U._compoGlyph(a, r, o));
    }, e.U._simpleGlyph = function(n, r) {
      for (var o = 0; o < n.noc; o++) {
        for (var a = o == 0 ? 0 : n.endPts[o - 1] + 1, l = n.endPts[o], c = a; c <= l; c++) {
          var u = c == a ? l : c - 1, h = c == l ? a : c + 1, d = 1 & n.flags[c], f = 1 & n.flags[u], m = 1 & n.flags[h], g = n.xs[c], v = n.ys[c];
          if (c == a) if (d) {
            if (!f) {
              e.U.P.moveTo(r, g, v);
              continue;
            }
            e.U.P.moveTo(r, n.xs[u], n.ys[u]);
          } else f ? e.U.P.moveTo(r, n.xs[u], n.ys[u]) : e.U.P.moveTo(r, (n.xs[u] + g) / 2, (n.ys[u] + v) / 2);
          d ? f && e.U.P.lineTo(r, g, v) : m ? e.U.P.qcurveTo(r, g, v, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(r, g, v, (g + n.xs[h]) / 2, (v + n.ys[h]) / 2);
        }
        e.U.P.closePath(r);
      }
    }, e.U._compoGlyph = function(n, r, o) {
      for (var a = 0; a < n.parts.length; a++) {
        var l = { cmds: [], crds: [] }, c = n.parts[a];
        e.U._drawGlyf(c.glyphIndex, r, l);
        for (var u = c.m, h = 0; h < l.crds.length; h += 2) {
          var d = l.crds[h], f = l.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < l.cmds.length; h++) o.cmds.push(l.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, r) {
      var o = e._lctf.getInterval(r, n);
      return o == -1 ? 0 : r[o + 2];
    }, e.U._applySubs = function(n, r, o, a) {
      for (var l = n.length - r - 1, c = 0; c < o.tabs.length; c++) if (o.tabs[c] != null) {
        var u, h = o.tabs[c];
        if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[r])) != -1) {
          if (o.ltype == 1) n[r], h.fmt == 1 ? n[r] = n[r] + h.delta : n[r] = h.newg[u];
          else if (o.ltype == 4) for (var d = h.vals[u], f = 0; f < d.length; f++) {
            var m = d[f], g = m.chain.length;
            if (!(g > l)) {
              for (var v = !0, _ = 0, y = 0; y < g; y++) {
                for (; n[r + _ + (1 + y)] == -1; ) _++;
                m.chain[y] != n[r + _ + (1 + y)] && (v = !1);
              }
              if (v) {
                for (n[r] = m.nglyph, y = 0; y < g + _; y++) n[r + y + 1] = -1;
                break;
              }
            }
          }
          else if (o.ltype == 5 && h.fmt == 2) for (var w = e._lctf.getInterval(h.cDef, n[r]), x = h.cDef[w + 2], M = h.scset[x], A = 0; A < M.length; A++) {
            var E = M[A], C = E.input;
            if (!(C.length > l)) {
              for (v = !0, y = 0; y < C.length; y++) {
                var P = e._lctf.getInterval(h.cDef, n[r + 1 + y]);
                if (w == -1 && h.cDef[P + 2] != C[y]) {
                  v = !1;
                  break;
                }
              }
              if (v) {
                var T = E.substLookupRecords;
                for (f = 0; f < T.length; f += 2) T[f], T[f + 1];
              }
            }
          }
          else if (o.ltype == 6 && h.fmt == 3) {
            if (!e.U._glsCovered(n, h.backCvg, r - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, r) || !e.U._glsCovered(n, h.ahedCvg, r + h.inptCvg.length)) continue;
            var I = h.lookupRec;
            for (A = 0; A < I.length; A += 2) {
              w = I[A];
              var D = a[I[A + 1]];
              e.U._applySubs(n, r + w, D, a);
            }
          }
        }
      }
    }, e.U._glsCovered = function(n, r, o) {
      for (var a = 0; a < r.length; a++)
        if (e._lctf.coverageIndex(r[a], n[o + a]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, r, o) {
      for (var a = { cmds: [], crds: [] }, l = 0, c = 0; c < r.length; c++) {
        var u = r[c];
        if (u != -1) {
          for (var h = c < r.length - 1 && r[c + 1] != -1 ? r[c + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2) a.crds.push(d.crds[f] + l), a.crds.push(d.crds[f + 1]);
          for (o && a.cmds.push(o), f = 0; f < d.cmds.length; f++) a.cmds.push(d.cmds[f]);
          o && a.cmds.push("X"), l += n.hmtx.aWidth[u], c < r.length - 1 && (l += e.U.getPairAdjustment(n, u, h));
        }
      }
      return a;
    }, e.U.P = {}, e.U.P.moveTo = function(n, r, o) {
      n.cmds.push("M"), n.crds.push(r, o);
    }, e.U.P.lineTo = function(n, r, o) {
      n.cmds.push("L"), n.crds.push(r, o);
    }, e.U.P.curveTo = function(n, r, o, a, l, c, u) {
      n.cmds.push("C"), n.crds.push(r, o, a, l, c, u);
    }, e.U.P.qcurveTo = function(n, r, o, a, l) {
      n.cmds.push("Q"), n.crds.push(r, o, a, l);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, r, o, a, l) {
      for (var c = r.stack, u = r.nStems, h = r.haveWidth, d = r.width, f = r.open, m = 0, g = r.x, v = r.y, _ = 0, y = 0, w = 0, x = 0, M = 0, A = 0, E = 0, C = 0, P = 0, T = 0, I = { val: 0, size: 0 }; m < n.length; ) {
        e.CFF.getCharString(n, m, I);
        var D = I.val;
        if (m += I.size, D == "o1" || D == "o18") c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0;
        else if (D == "o3" || D == "o23")
          c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0;
        else if (D == "o4") c.length > 1 && !h && (d = c.shift() + a.nominalWidthX, h = !0), f && e.U.P.closePath(l), v += c.pop(), e.U.P.moveTo(l, g, v), f = !0;
        else if (D == "o5") for (; c.length > 0; ) g += c.shift(), v += c.shift(), e.U.P.lineTo(l, g, v);
        else if (D == "o6" || D == "o7") for (var U = c.length, L = D == "o6", k = 0; k < U; k++) {
          var B = c.shift();
          L ? g += B : v += B, L = !L, e.U.P.lineTo(l, g, v);
        }
        else if (D == "o8" || D == "o24") {
          U = c.length;
          for (var j = 0; j + 6 <= U; ) _ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), g = w + c.shift(), v = x + c.shift(), e.U.P.curveTo(l, _, y, w, x, g, v), j += 6;
          D == "o24" && (g += c.shift(), v += c.shift(), e.U.P.lineTo(l, g, v));
        } else {
          if (D == "o11") break;
          if (D == "o1234" || D == "o1235" || D == "o1236" || D == "o1237") D == "o1234" && (y = v, w = (_ = g + c.shift()) + c.shift(), T = x = y + c.shift(), A = x, C = v, g = (E = (M = (P = w + c.shift()) + c.shift()) + c.shift()) + c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v)), D == "o1235" && (_ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), P = w + c.shift(), T = x + c.shift(), M = P + c.shift(), A = T + c.shift(), E = M + c.shift(), C = A + c.shift(), g = E + c.shift(), v = C + c.shift(), c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v)), D == "o1236" && (_ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), T = x = y + c.shift(), A = x, E = (M = (P = w + c.shift()) + c.shift()) + c.shift(), C = A + c.shift(), g = E + c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v)), D == "o1237" && (_ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), P = w + c.shift(), T = x + c.shift(), M = P + c.shift(), A = T + c.shift(), E = M + c.shift(), C = A + c.shift(), Math.abs(E - g) > Math.abs(C - v) ? g = E + c.shift() : v = C + c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v));
          else if (D == "o14") {
            if (c.length > 0 && !h && (d = c.shift() + o.nominalWidthX, h = !0), c.length == 4) {
              var q = c.shift(), Z = c.shift(), N = c.shift(), z = c.shift(), J = e.CFF.glyphBySE(o, N), se = e.CFF.glyphBySE(o, z);
              e.U._drawCFF(o.CharStrings[J], r, o, a, l), r.x = q, r.y = Z, e.U._drawCFF(o.CharStrings[se], r, o, a, l);
            }
            f && (e.U.P.closePath(l), f = !1);
          } else if (D == "o19" || D == "o20")
            c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0, m += u + 7 >> 3;
          else if (D == "o21") c.length > 2 && !h && (d = c.shift() + a.nominalWidthX, h = !0), v += c.pop(), g += c.pop(), f && e.U.P.closePath(l), e.U.P.moveTo(l, g, v), f = !0;
          else if (D == "o22") c.length > 1 && !h && (d = c.shift() + a.nominalWidthX, h = !0), g += c.pop(), f && e.U.P.closePath(l), e.U.P.moveTo(l, g, v), f = !0;
          else if (D == "o25") {
            for (; c.length > 6; ) g += c.shift(), v += c.shift(), e.U.P.lineTo(l, g, v);
            _ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), g = w + c.shift(), v = x + c.shift(), e.U.P.curveTo(l, _, y, w, x, g, v);
          } else if (D == "o26") for (c.length % 2 && (g += c.shift()); c.length > 0; ) _ = g, y = v + c.shift(), g = w = _ + c.shift(), v = (x = y + c.shift()) + c.shift(), e.U.P.curveTo(l, _, y, w, x, g, v);
          else if (D == "o27") for (c.length % 2 && (v += c.shift()); c.length > 0; ) y = v, w = (_ = g + c.shift()) + c.shift(), x = y + c.shift(), g = w + c.shift(), v = x, e.U.P.curveTo(l, _, y, w, x, g, v);
          else if (D == "o10" || D == "o29") {
            var K = D == "o10" ? a : o;
            if (c.length == 0) console.debug("error: empty stack");
            else {
              var Q = c.pop(), de = K.Subrs[Q + K.Bias];
              r.x = g, r.y = v, r.nStems = u, r.haveWidth = h, r.width = d, r.open = f, e.U._drawCFF(de, r, o, a, l), g = r.x, v = r.y, u = r.nStems, h = r.haveWidth, d = r.width, f = r.open;
            }
          } else if (D == "o30" || D == "o31") {
            var ce = c.length, _e = (j = 0, D == "o31");
            for (j += ce - (U = -3 & ce); j < U; ) _e ? (y = v, w = (_ = g + c.shift()) + c.shift(), v = (x = y + c.shift()) + c.shift(), U - j == 5 ? (g = w + c.shift(), j++) : g = w, _e = !1) : (_ = g, y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), g = w + c.shift(), U - j == 5 ? (v = x + c.shift(), j++) : v = x, _e = !0), e.U.P.curveTo(l, _, y, w, x, g, v), j += 4;
          } else {
            if ((D + "").charAt(0) == "o") throw console.debug("Unknown operation: " + D, n), D;
            c.push(D);
          }
        }
      }
      r.x = g, r.y = v, r.nStems = u, r.haveWidth = h, r.width = d, r.open = f;
    };
    var t = e, i = { Typr: t };
    return s.Typr = t, s.default = i, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function bj() {
  return function(s) {
    var e = Uint8Array, t = Uint16Array, i = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), r = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), a = function(D, U) {
      for (var L = new t(31), k = 0; k < 31; ++k) L[k] = U += 1 << D[k - 1];
      var B = new i(L[30]);
      for (k = 1; k < 30; ++k) for (var j = L[k]; j < L[k + 1]; ++j) B[j] = j - L[k] << 5 | k;
      return [L, B];
    }, l = a(n, 2), c = l[0], u = l[1];
    c[28] = 258, u[258] = 28;
    for (var h = a(r, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var m = (43690 & f) >>> 1 | (21845 & f) << 1;
      m = (61680 & (m = (52428 & m) >>> 2 | (13107 & m) << 2)) >>> 4 | (3855 & m) << 4, d[f] = ((65280 & m) >>> 8 | (255 & m) << 8) >>> 1;
    }
    var g = function(D, U, L) {
      for (var k = D.length, B = 0, j = new t(U); B < k; ++B) ++j[D[B] - 1];
      var q, Z = new t(U);
      for (B = 0; B < U; ++B) Z[B] = Z[B - 1] + j[B - 1] << 1;
      {
        q = new t(1 << U);
        var N = 15 - U;
        for (B = 0; B < k; ++B) if (D[B]) for (var z = B << 4 | D[B], J = U - D[B], se = Z[D[B] - 1]++ << J, K = se | (1 << J) - 1; se <= K; ++se) q[d[se] >>> N] = z;
      }
      return q;
    }, v = new e(288);
    for (f = 0; f < 144; ++f) v[f] = 8;
    for (f = 144; f < 256; ++f) v[f] = 9;
    for (f = 256; f < 280; ++f) v[f] = 7;
    for (f = 280; f < 288; ++f) v[f] = 8;
    var _ = new e(32);
    for (f = 0; f < 32; ++f) _[f] = 5;
    var y = g(v, 9), w = g(_, 5), x = function(D) {
      for (var U = D[0], L = 1; L < D.length; ++L) D[L] > U && (U = D[L]);
      return U;
    }, M = function(D, U, L) {
      var k = U / 8 | 0;
      return (D[k] | D[k + 1] << 8) >> (7 & U) & L;
    }, A = function(D, U) {
      var L = U / 8 | 0;
      return (D[L] | D[L + 1] << 8 | D[L + 2] << 16) >> (7 & U);
    }, E = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], C = function(D, U, L) {
      var k = new Error(U || E[D]);
      if (k.code = D, Error.captureStackTrace && Error.captureStackTrace(k, C), !L) throw k;
      return k;
    }, P = function(D, U, L) {
      var k = D.length;
      if (!k || L && !L.l && k < 5) return U || new e(0);
      var B = !U || L, j = !L || L.i;
      L || (L = {}), U || (U = new e(3 * k));
      var q, Z = function(Le) {
        var ot = U.length;
        if (Le > ot) {
          var tt = new e(Math.max(2 * ot, Le));
          tt.set(U), U = tt;
        }
      }, N = L.f || 0, z = L.p || 0, J = L.b || 0, se = L.l, K = L.d, Q = L.m, de = L.n, ce = 8 * k;
      do {
        if (!se) {
          L.f = N = M(D, z, 1);
          var _e = M(D, z + 1, 3);
          if (z += 3, !_e) {
            var Fe = D[(Oe = ((q = z) / 8 | 0) + (7 & q && 1) + 4) - 4] | D[Oe - 3] << 8, Ie = Oe + Fe;
            if (Ie > k) {
              j && C(0);
              break;
            }
            B && Z(J + Fe), U.set(D.subarray(Oe, Ie), J), L.b = J += Fe, L.p = z = 8 * Ie;
            continue;
          }
          if (_e == 1) se = y, K = w, Q = 9, de = 5;
          else if (_e == 2) {
            var Ee = M(D, z, 31) + 257, me = M(D, z + 10, 15) + 4, xe = Ee + M(D, z + 5, 31) + 1;
            z += 14;
            for (var $ = new e(xe), Ue = new e(19), Me = 0; Me < me; ++Me) Ue[o[Me]] = M(D, z + 3 * Me, 7);
            z += 3 * me;
            var oe = x(Ue), Te = (1 << oe) - 1, Ye = g(Ue, oe);
            for (Me = 0; Me < xe; ) {
              var Oe, X = Ye[M(D, z, Te)];
              if (z += 15 & X, (Oe = X >>> 4) < 16) $[Me++] = Oe;
              else {
                var Y = 0, fe = 0;
                for (Oe == 16 ? (fe = 3 + M(D, z, 3), z += 2, Y = $[Me - 1]) : Oe == 17 ? (fe = 3 + M(D, z, 7), z += 3) : Oe == 18 && (fe = 11 + M(D, z, 127), z += 7); fe--; ) $[Me++] = Y;
              }
            }
            var ue = $.subarray(0, Ee), te = $.subarray(Ee);
            Q = x(ue), de = x(te), se = g(ue, Q), K = g(te, de);
          } else C(1);
          if (z > ce) {
            j && C(0);
            break;
          }
        }
        B && Z(J + 131072);
        for (var Se = (1 << Q) - 1, ye = (1 << de) - 1, Ae = z; ; Ae = z) {
          var Ce = (Y = se[A(D, z) & Se]) >>> 4;
          if ((z += 15 & Y) > ce) {
            j && C(0);
            break;
          }
          if (Y || C(2), Ce < 256) U[J++] = Ce;
          else {
            if (Ce == 256) {
              Ae = z, se = null;
              break;
            }
            var Ge = Ce - 254;
            if (Ce > 264) {
              var De = n[Me = Ce - 257];
              Ge = M(D, z, (1 << De) - 1) + c[Me], z += De;
            }
            var Ve = K[A(D, z) & ye], ze = Ve >>> 4;
            if (Ve || C(3), z += 15 & Ve, te = h[ze], ze > 3 && (De = r[ze], te += A(D, z) & (1 << De) - 1, z += De), z > ce) {
              j && C(0);
              break;
            }
            B && Z(J + 131072);
            for (var Ze = J + Ge; J < Ze; J += 4) U[J] = U[J - te], U[J + 1] = U[J + 1 - te], U[J + 2] = U[J + 2 - te], U[J + 3] = U[J + 3 - te];
            J = Ze;
          }
        }
        L.l = se, L.p = Ae, L.b = J, se && (N = 1, L.m = Q, L.d = K, L.n = de);
      } while (!N);
      return J == U.length ? U : function(Le, ot, tt) {
        (tt == null || tt > Le.length) && (tt = Le.length);
        var mt = new (Le instanceof t ? t : Le instanceof i ? i : e)(tt - ot);
        return mt.set(Le.subarray(ot, tt)), mt;
      }(U, 0, J);
    }, T = new e(0), I = typeof TextDecoder < "u" && new TextDecoder();
    try {
      I.decode(T, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(D) {
      var U = new DataView(D), L = 0;
      function k() {
        var Ee = U.getUint16(L);
        return L += 2, Ee;
      }
      function B() {
        var Ee = U.getUint32(L);
        return L += 4, Ee;
      }
      function j(Ee) {
        Fe.setUint16(Ie, Ee), Ie += 2;
      }
      function q(Ee) {
        Fe.setUint32(Ie, Ee), Ie += 4;
      }
      for (var Z = { signature: B(), flavor: B(), length: B(), numTables: k(), reserved: k(), totalSfntSize: B(), majorVersion: k(), minorVersion: k(), metaOffset: B(), metaLength: B(), metaOrigLength: B(), privOffset: B(), privLength: B() }, N = 0; Math.pow(2, N) <= Z.numTables; ) N++;
      N--;
      for (var z = 16 * Math.pow(2, N), J = 16 * Z.numTables - z, se = 12, K = [], Q = 0; Q < Z.numTables; Q++) K.push({ tag: B(), offset: B(), compLength: B(), origLength: B(), origChecksum: B() }), se += 16;
      var de, ce = new Uint8Array(12 + 16 * K.length + K.reduce(function(Ee, me) {
        return Ee + me.origLength + 4;
      }, 0)), _e = ce.buffer, Fe = new DataView(_e), Ie = 0;
      return q(Z.flavor), j(Z.numTables), j(z), j(N), j(J), K.forEach(function(Ee) {
        q(Ee.tag), q(Ee.origChecksum), q(se), q(Ee.origLength), Ee.outOffset = se, (se += Ee.origLength) % 4 != 0 && (se += 4 - se % 4);
      }), K.forEach(function(Ee) {
        var me, xe = D.slice(Ee.offset, Ee.offset + Ee.compLength);
        if (Ee.compLength != Ee.origLength) {
          var $ = new Uint8Array(Ee.origLength);
          me = new Uint8Array(xe, 2), P(me, $);
        } else $ = new Uint8Array(xe);
        ce.set($, Ee.outOffset);
        var Ue = 0;
        (se = Ee.outOffset + Ee.origLength) % 4 != 0 && (Ue = 4 - se % 4), ce.set(new Uint8Array(Ue).buffer, Ee.outOffset + Ee.origLength), de = se + Ue;
      }), _e.slice(0, de);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function wj(s, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, r = 2, o = 4, a = 8, l = 16, c = 32;
  let u;
  function h(E) {
    if (!u) {
      const C = {
        R: r,
        L: n,
        D: o,
        C: l,
        U: c,
        T: a
      };
      u = /* @__PURE__ */ new Map();
      for (let P in i) {
        let T = 0;
        i[P].split(",").forEach((I) => {
          let [D, U] = I.split("+");
          D = parseInt(D, 36), U = U ? parseInt(U, 36) : 0, u.set(T += D, C[P]);
          for (let L = U; L--; )
            u.set(++T, C[P]);
        });
      }
    }
    return u.get(E) || c;
  }
  const d = 1, f = 2, m = 3, g = 4, v = [null, "isol", "init", "fina", "medi"];
  function _(E) {
    const C = new Uint8Array(E.length);
    let P = c, T = d, I = -1;
    for (let D = 0; D < E.length; D++) {
      const U = E.codePointAt(D);
      let L = h(U) | 0, k = d;
      L & a || (P & (n | o | l) ? L & (r | o | l) ? (k = m, (T === d || T === m) && C[I]++) : L & (n | c) && (T === f || T === g) && C[I]-- : P & (r | c) && (T === f || T === g) && C[I]--, T = C[D] = k, P = L, I = D, U > 65535 && D++);
    }
    return C;
  }
  function y(E, C) {
    const P = [];
    for (let I = 0; I < C.length; I++) {
      const D = C.codePointAt(I);
      D > 65535 && I++, P.push(s.U.codeToGlyph(E, D));
    }
    const T = E.GSUB;
    if (T) {
      const { lookupList: I, featureList: D } = T;
      let U;
      const L = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, k = [];
      D.forEach((B) => {
        if (L.test(B.tag))
          for (let j = 0; j < B.tab.length; j++) {
            if (k[B.tab[j]]) continue;
            k[B.tab[j]] = !0;
            const q = I[B.tab[j]], Z = /^(isol|init|fina|medi)$/.test(B.tag);
            Z && !U && (U = _(C));
            for (let N = 0; N < P.length; N++)
              (!U || !Z || v[U[N]] === B.tag) && s.U._applySubs(P, N, q, I);
          }
      });
    }
    return P;
  }
  function w(E, C) {
    const P = new Int16Array(C.length * 3);
    let T = 0;
    for (; T < C.length; T++) {
      const L = C[T];
      if (L === -1) continue;
      P[T * 3 + 2] = E.hmtx.aWidth[L];
      const k = E.GPOS;
      if (k) {
        const B = k.lookupList;
        for (let j = 0; j < B.length; j++) {
          const q = B[j];
          for (let Z = 0; Z < q.tabs.length; Z++) {
            const N = q.tabs[Z];
            if (q.ltype === 1) {
              if (s._lctf.coverageIndex(N.coverage, L) !== -1 && N.pos) {
                U(N.pos, T);
                break;
              }
            } else if (q.ltype === 2) {
              let z = null, J = I();
              if (J !== -1) {
                const se = s._lctf.coverageIndex(N.coverage, C[J]);
                if (se !== -1) {
                  if (N.fmt === 1) {
                    const K = N.pairsets[se];
                    for (let Q = 0; Q < K.length; Q++)
                      K[Q].gid2 === L && (z = K[Q]);
                  } else if (N.fmt === 2) {
                    const K = s.U._getGlyphClass(C[J], N.classDef1), Q = s.U._getGlyphClass(L, N.classDef2);
                    z = N.matrix[K][Q];
                  }
                  if (z) {
                    z.val1 && U(z.val1, J), z.val2 && U(z.val2, T);
                    break;
                  }
                }
              }
            } else if (q.ltype === 4) {
              const z = s._lctf.coverageIndex(N.markCoverage, L);
              if (z !== -1) {
                const J = I(D), se = J === -1 ? -1 : s._lctf.coverageIndex(N.baseCoverage, C[J]);
                if (se !== -1) {
                  const K = N.markArray[z], Q = N.baseArray[se][K.markClass];
                  P[T * 3] = Q.x - K.x + P[J * 3] - P[J * 3 + 2], P[T * 3 + 1] = Q.y - K.y + P[J * 3 + 1];
                  break;
                }
              }
            } else if (q.ltype === 6) {
              const z = s._lctf.coverageIndex(N.mark1Coverage, L);
              if (z !== -1) {
                const J = I();
                if (J !== -1) {
                  const se = C[J];
                  if (x(E, se) === 3) {
                    const K = s._lctf.coverageIndex(N.mark2Coverage, se);
                    if (K !== -1) {
                      const Q = N.mark1Array[z], de = N.mark2Array[K][Q.markClass];
                      P[T * 3] = de.x - Q.x + P[J * 3] - P[J * 3 + 2], P[T * 3 + 1] = de.y - Q.y + P[J * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (E.kern && !E.cff) {
        const B = I();
        if (B !== -1) {
          const j = E.kern.glyph1.indexOf(C[B]);
          if (j !== -1) {
            const q = E.kern.rval[j].glyph2.indexOf(L);
            q !== -1 && (P[B * 3 + 2] += E.kern.rval[j].vals[q]);
          }
        }
      }
    }
    return P;
    function I(L) {
      for (let k = T - 1; k >= 0; k--)
        if (C[k] !== -1 && (!L || L(C[k])))
          return k;
      return -1;
    }
    function D(L) {
      return x(E, L) === 1;
    }
    function U(L, k) {
      for (let B = 0; B < 3; B++)
        P[k * 3 + B] += L[B] || 0;
    }
  }
  function x(E, C) {
    const P = E.GDEF && E.GDEF.glyphClassDef;
    return P ? s.U._getGlyphClass(C, P) : 0;
  }
  function M(...E) {
    for (let C = 0; C < E.length; C++)
      if (typeof E[C] == "number")
        return E[C];
  }
  function A(E) {
    const C = /* @__PURE__ */ Object.create(null), P = E["OS/2"], T = E.hhea, I = E.head.unitsPerEm, D = M(P && P.sTypoAscender, T && T.ascender, I), U = {
      unitsPerEm: I,
      ascender: D,
      descender: M(P && P.sTypoDescender, T && T.descender, 0),
      capHeight: M(P && P.sCapHeight, D),
      xHeight: M(P && P.sxHeight, D),
      lineGap: M(P && P.sTypoLineGap, T && T.lineGap),
      supportsCodePoint(L) {
        return s.U.codeToGlyph(E, L) > 0;
      },
      forEachGlyph(L, k, B, j) {
        let q = 0;
        const Z = 1 / U.unitsPerEm * k, N = y(E, L);
        let z = 0;
        const J = w(E, N);
        return N.forEach((se, K) => {
          if (se !== -1) {
            let Q = C[se];
            if (!Q) {
              const { cmds: de, crds: ce } = s.U.glyphToPath(E, se);
              let _e = "", Fe = 0;
              for (let $ = 0, Ue = de.length; $ < Ue; $++) {
                const Me = t[de[$]];
                _e += de[$];
                for (let oe = 1; oe <= Me; oe++)
                  _e += (oe > 1 ? "," : "") + ce[Fe++];
              }
              let Ie, Ee, me, xe;
              if (ce.length) {
                Ie = Ee = 1 / 0, me = xe = -1 / 0;
                for (let $ = 0, Ue = ce.length; $ < Ue; $ += 2) {
                  let Me = ce[$], oe = ce[$ + 1];
                  Me < Ie && (Ie = Me), oe < Ee && (Ee = oe), Me > me && (me = Me), oe > xe && (xe = oe);
                }
              } else
                Ie = me = Ee = xe = 0;
              Q = C[se] = {
                index: se,
                advanceWidth: E.hmtx.aWidth[se],
                xMin: Ie,
                yMin: Ee,
                xMax: me,
                yMax: xe,
                path: _e
              };
            }
            j.call(
              null,
              Q,
              q + J[K * 3] * Z,
              J[K * 3 + 1] * Z,
              z
            ), q += J[K * 3 + 2] * Z, B && (q += B * k);
          }
          z += L.codePointAt(z) > 65535 ? 2 : 1;
        }), q;
      }
    };
    return U;
  }
  return function(C) {
    const P = new Uint8Array(C, 0, 4), T = s._bin.readASCII(P, 0, 4);
    if (T === "wOFF")
      C = e(C);
    else if (T === "wOF2")
      throw new Error("woff2 fonts not supported");
    return A(s.parse(C)[0]);
  };
}
const Sj = /* @__PURE__ */ Id({
  name: "Typr Font Parser",
  dependencies: [xj, bj, wj],
  init(s, e, t) {
    const i = s(), n = e();
    return t(i, n);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function Mj() {
  return function(s) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(w) {
      var x = w >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & w));
    }, e.prototype.has = function(w) {
      var x = this.buckets.get(w >> 5);
      return x !== void 0 && (x & 1 << (31 & w)) != 0;
    }, e.prototype.serialize = function() {
      var w = [];
      return this.buckets.forEach(function(x, M) {
        w.push((+M).toString(36) + ":" + x.toString(36));
      }), w.join(",");
    }, e.prototype.deserialize = function(w) {
      var x = this;
      this.buckets.clear(), w.split(",").forEach(function(M) {
        var A = M.split(":");
        x.buckets.set(parseInt(A[0], 36), parseInt(A[1], 36));
      });
    };
    var t = Math.pow(2, 8), i = t - 1, n = ~i;
    function r(w) {
      var x = function(A) {
        return A & n;
      }(w).toString(16), M = function(A) {
        return (A & n) + t - 1;
      }(w).toString(16);
      return "codepoint-index/plane" + (w >> 16) + "/" + x + "-" + M + ".json";
    }
    function o(w, x) {
      var M = w & i, A = x.codePointAt(M / 6 | 0);
      return ((A = (A || 48) - 48) & 1 << M % 6) != 0;
    }
    function a(w, x) {
      var M;
      (M = w, M.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(A) {
        return A.split("-").map(function(E) {
          return parseInt(E.trim(), 16);
        });
      })).forEach(function(A) {
        var E = A[0], C = A[1];
        C === void 0 && (C = E), x(E, C);
      });
    }
    function l(w, x) {
      a(w, function(M, A) {
        for (var E = M; E <= A; E++) x(E);
      });
    }
    var c = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(w) {
      var x = h.get(w);
      return x || (x = new e(), l(w.ranges, function(M) {
        return x.add(M);
      }), h.set(w, x)), x;
    }
    var m, g = /* @__PURE__ */ new Map();
    function v(w, x, M) {
      return w[x] ? x : w[M] ? M : function(A) {
        for (var E in A) return E;
      }(w);
    }
    function _(w, x) {
      var M = x;
      if (!w.includes(M)) {
        M = 1 / 0;
        for (var A = 0; A < w.length; A++) Math.abs(w[A] - x) < Math.abs(M - x) && (M = w[A]);
      }
      return M;
    }
    function y(w) {
      return m || (m = /* @__PURE__ */ new Set(), l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        m.add(x);
      })), m.has(w);
    }
    return s.CodePointSet = e, s.clearCache = function() {
      c = {}, u = {};
    }, s.getFontsForString = function(w, x) {
      x === void 0 && (x = {});
      var M, A = x.lang;
      A === void 0 && (A = new RegExp("\\p{Script=Hangul}", "u").test(M = w) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(M) ? "ja" : "en");
      var E = x.category;
      E === void 0 && (E = "sans-serif");
      var C = x.style;
      C === void 0 && (C = "normal");
      var P = x.weight;
      P === void 0 && (P = 400);
      var T = (x.dataUrl || d).replace(/\/$/g, ""), I = /* @__PURE__ */ new Map(), D = new Uint8Array(w.length), U = {}, L = {}, k = new Array(w.length), B = /* @__PURE__ */ new Map(), j = !1;
      function q(z) {
        var J = g.get(z);
        return J || (J = fetch(T + "/" + z).then(function(se) {
          if (!se.ok) throw new Error(se.statusText);
          return se.json().then(function(K) {
            if (!Array.isArray(K) || K[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + K[0]);
            return K[1];
          });
        }).catch(function(se) {
          if (T !== d) return j || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + T + '", trying default CDN. ' + se.message), j = !0), T = d, g.delete(z), q(z);
          throw se;
        }), g.set(z, J)), J;
      }
      for (var Z = function(z) {
        var J = w.codePointAt(z), se = r(J);
        k[z] = se, c[se] || B.has(se) || B.set(se, q(se).then(function(K) {
          c[se] = K;
        })), J > 65535 && (z++, N = z);
      }, N = 0; N < w.length; N++) Z(N);
      return Promise.all(B.values()).then(function() {
        B.clear();
        for (var z = function(se) {
          var K = w.codePointAt(se), Q = null, de = c[k[se]], ce = void 0;
          for (var _e in de) {
            var Fe = L[_e];
            if (Fe === void 0 && (Fe = L[_e] = new RegExp(_e).test(A || "en")), Fe) {
              for (var Ie in ce = _e, de[_e]) if (o(K, de[_e][Ie])) {
                Q = Ie;
                break;
              }
              break;
            }
          }
          if (!Q) {
            e: for (var Ee in de) if (Ee !== ce) {
              for (var me in de[Ee]) if (o(K, de[Ee][me])) {
                Q = me;
                break e;
              }
            }
          }
          Q || (console.debug("No font coverage for U+" + K.toString(16)), Q = "latin"), k[se] = Q, u[Q] || B.has(Q) || B.set(Q, q("font-meta/" + Q + ".json").then(function(xe) {
            u[Q] = xe;
          })), K > 65535 && (se++, J = se);
        }, J = 0; J < w.length; J++) z(J);
        return Promise.all(B.values());
      }).then(function() {
        for (var z, J = null, se = 0; se < w.length; se++) {
          var K = w.codePointAt(se);
          if (J && (y(K) || f(J).has(K))) D[se] = D[se - 1];
          else {
            J = u[k[se]];
            var Q = U[J.id];
            if (!Q) {
              var de = J.typeforms, ce = v(de, E, "sans-serif"), _e = v(de[ce], C, "normal"), Fe = _((z = de[ce]) === null || z === void 0 ? void 0 : z[_e], P);
              Q = U[J.id] = T + "/font-files/" + J.id + "/" + ce + "." + _e + "." + Fe + ".woff";
            }
            var Ie = I.get(Q);
            Ie == null && (Ie = I.size, I.set(Q, Ie)), D[se] = Ie;
          }
          K > 65535 && (se++, D[se] = D[se - 1]);
        }
        return { fontUrls: Array.from(I.keys()), chars: D };
      });
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({});
}
function Ej(s, e) {
  const t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function n(o, a) {
    const l = (c) => {
      console.error(`Failure loading font ${o}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", o, !0), c.responseType = "arraybuffer", c.onload = function() {
        if (c.status >= 400)
          l(new Error(c.statusText));
        else if (c.status > 0)
          try {
            const u = s(c.response);
            u.src = o, a(u);
          } catch (u) {
            l(u);
          }
      }, c.onerror = l, c.send();
    } catch (c) {
      l(c);
    }
  }
  function r(o, a) {
    let l = t[o];
    l ? a(l) : i[o] ? i[o].push(a) : (i[o] = [a], n(o, (c) => {
      c.src = o, t[o] = c, i[o].forEach((u) => u(c)), delete i[o];
    }));
  }
  return function(o, a, {
    lang: l,
    fonts: c = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), m = [];
    o.length || y();
    const g = /* @__PURE__ */ new Map(), v = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), c && !Array.isArray(c) && (c = [c]), c = c.slice().filter((x) => !x.lang || x.lang.test(l)).reverse(), c.length) {
      let E = 0;
      (function C(P = 0) {
        for (let T = P, I = o.length; T < I; T++) {
          const D = o.codePointAt(T);
          if (E === 1 && m[f[T - 1]].supportsCodePoint(D) || T > 0 && /\s/.test(o[T]))
            f[T] = f[T - 1], E === 2 && (v[v.length - 1][1] = T);
          else
            for (let U = f[T], L = c.length; U <= L; U++)
              if (U === L) {
                const k = E === 2 ? v[v.length - 1] : v[v.length] = [T, T];
                k[1] = T, E = 2;
              } else {
                f[T] = U;
                const { src: k, unicodeRange: B } = c[U];
                if (!B || w(D, B)) {
                  const j = t[k];
                  if (!j) {
                    r(k, () => {
                      C(T);
                    });
                    return;
                  }
                  if (j.supportsCodePoint(D)) {
                    let q = g.get(j);
                    typeof q != "number" && (q = m.length, m.push(j), g.set(j, q)), f[T] = q, E = 1;
                    break;
                  }
                }
              }
          D > 65535 && T + 1 < I && (f[T + 1] = f[T], T++, E === 2 && (v[v.length - 1][1] = T));
        }
        _();
      })();
    } else
      v.push([0, o.length - 1]), _();
    function _() {
      if (v.length) {
        const x = v.map((M) => o.substring(M[0], M[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: l || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: M, chars: A }) => {
          const E = m.length;
          let C = 0;
          v.forEach((T) => {
            for (let I = 0, D = T[1] - T[0]; I <= D; I++)
              f[T[0] + I] = A[C++] + E;
            C++;
          });
          let P = 0;
          M.forEach((T, I) => {
            r(T, (D) => {
              m[I + E] = D, ++P === M.length && y();
            });
          });
        });
      } else
        y();
    }
    function y() {
      a({
        chars: f,
        fonts: m
      });
    }
    function w(x, M) {
      for (let A = 0; A < M.length; A++) {
        const [E, C = E] = M[A];
        if (E <= x && x <= C)
          return !0;
      }
      return !1;
    }
  };
}
const Tj = /* @__PURE__ */ Id({
  name: "FontResolver",
  dependencies: [
    Ej,
    Sj,
    Mj
  ],
  init(s, e, t) {
    return s(e, t());
  }
});
function Aj(s, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", r = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: m, lang: g, fonts: v, style: _, weight: y, preResolvedFonts: w, unicodeFontsURL: x }, M) {
    const A = ({ chars: E, fonts: C }) => {
      let P, T;
      const I = [];
      for (let D = 0; D < E.length; D++)
        E[D] !== T ? (T = E[D], I.push(P = { start: D, end: D, fontObj: C[E[D]] })) : P.end = D;
      M(I);
    };
    w ? A(w) : s(
      m,
      A,
      { lang: g, fonts: v, style: _, weight: y, unicodeFontsURL: x }
    );
  }
  function a({
    text: m = "",
    font: g,
    lang: v,
    sdfGlyphSize: _ = 64,
    fontSize: y = 400,
    fontWeight: w = 1,
    fontStyle: x = "normal",
    letterSpacing: M = 0,
    lineHeight: A = "normal",
    maxWidth: E = 1 / 0,
    direction: C,
    textAlign: P = "left",
    textIndent: T = 0,
    whiteSpace: I = "normal",
    overflowWrap: D = "normal",
    anchorX: U = 0,
    anchorY: L = 0,
    metricsOnly: k = !1,
    unicodeFontsURL: B,
    preResolvedFonts: j = null,
    includeCaretPositions: q = !1,
    chunkedBoundsSize: Z = 8192,
    colorRanges: N = null
  }, z) {
    const J = h(), se = { fontLoad: 0, typesetting: 0 };
    m.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), m = m.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), y = +y, M = +M, E = +E, A = A || "normal", T = +T, o({
      text: m,
      lang: v,
      style: x,
      weight: w,
      fonts: typeof g == "string" ? [{ src: g }] : g,
      unicodeFontsURL: B,
      preResolvedFonts: j
    }, (K) => {
      se.fontLoad = h() - J;
      const Q = isFinite(E);
      let de = null, ce = null, _e = null, Fe = null, Ie = null, Ee = null, me = null, xe = null, $ = 0, Ue = 0, Me = I !== "nowrap";
      const oe = /* @__PURE__ */ new Map(), Te = h();
      let Ye = T, Oe = 0, X = new d();
      const Y = [X];
      K.forEach((ye) => {
        const { fontObj: Ae } = ye, { ascender: Ce, descender: Ge, unitsPerEm: De, lineGap: Ve, capHeight: ze, xHeight: Ze } = Ae;
        let Le = oe.get(Ae);
        if (!Le) {
          const ve = y / De, be = A === "normal" ? (Ce - Ge + Ve) * ve : A * y, Xe = (be - (Ce - Ge) * ve) / 2, We = Math.min(be, (Ce - Ge) * ve), Ne = (Ce + Ge) / 2 * ve + We / 2;
          Le = {
            index: oe.size,
            src: Ae.src,
            fontObj: Ae,
            fontSizeMult: ve,
            unitsPerEm: De,
            ascender: Ce * ve,
            descender: Ge * ve,
            capHeight: ze * ve,
            xHeight: Ze * ve,
            lineHeight: be,
            baseline: -Xe - Ce * ve,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: Ne,
            caretBottom: Ne - We
          }, oe.set(Ae, Le);
        }
        const { fontSizeMult: ot } = Le, tt = m.slice(ye.start, ye.end + 1);
        let mt, le;
        Ae.forEachGlyph(tt, y, M, (ve, be, Xe, We) => {
          be += Oe, We += ye.start, mt = be, le = ve;
          const Ne = m.charAt(We), ct = ve.advanceWidth * ot, gt = X.count;
          let nt;
          if ("isEmpty" in ve || (ve.isWhitespace = !!Ne && new RegExp(n).test(Ne), ve.canBreakAfter = !!Ne && r.test(Ne), ve.isEmpty = ve.xMin === ve.xMax || ve.yMin === ve.yMax || i.test(Ne)), !ve.isWhitespace && !ve.isEmpty && Ue++, Me && Q && !ve.isWhitespace && be + ct + Ye > E && gt) {
            if (X.glyphAt(gt - 1).glyphObj.canBreakAfter)
              nt = new d(), Ye = -be;
            else
              for (let at = gt; at--; )
                if (at === 0 && D === "break-word") {
                  nt = new d(), Ye = -be;
                  break;
                } else if (X.glyphAt(at).glyphObj.canBreakAfter) {
                  nt = X.splitAt(at + 1);
                  const ft = nt.glyphAt(0).x;
                  Ye -= ft;
                  for (let Qe = nt.count; Qe--; )
                    nt.glyphAt(Qe).x -= ft;
                  break;
                }
            nt && (X.isSoftWrapped = !0, X = nt, Y.push(X), $ = E);
          }
          let je = X.glyphAt(X.count);
          je.glyphObj = ve, je.x = be + Ye, je.y = Xe, je.width = ct, je.charIndex = We, je.fontData = Le, Ne === `
` && (X = new d(), Y.push(X), Ye = -(be + ct + M * y) + T);
        }), Oe = mt + le.advanceWidth * ot + M * y;
      });
      let fe = 0;
      Y.forEach((ye) => {
        let Ae = !0;
        for (let Ce = ye.count; Ce--; ) {
          const Ge = ye.glyphAt(Ce);
          Ae && !Ge.glyphObj.isWhitespace && (ye.width = Ge.x + Ge.width, ye.width > $ && ($ = ye.width), Ae = !1);
          let { lineHeight: De, capHeight: Ve, xHeight: ze, baseline: Ze } = Ge.fontData;
          De > ye.lineHeight && (ye.lineHeight = De);
          const Le = Ze - ye.baseline;
          Le < 0 && (ye.baseline += Le, ye.cap += Le, ye.ex += Le), ye.cap = Math.max(ye.cap, ye.baseline + Ve), ye.ex = Math.max(ye.ex, ye.baseline + ze);
        }
        ye.baseline -= fe, ye.cap -= fe, ye.ex -= fe, fe += ye.lineHeight;
      });
      let ue = 0, te = 0;
      if (U && (typeof U == "number" ? ue = -U : typeof U == "string" && (ue = -$ * (U === "left" ? 0 : U === "center" ? 0.5 : U === "right" ? 1 : c(U)))), L && (typeof L == "number" ? te = -L : typeof L == "string" && (te = L === "top" ? 0 : L === "top-baseline" ? -Y[0].baseline : L === "top-cap" ? -Y[0].cap : L === "top-ex" ? -Y[0].ex : L === "middle" ? fe / 2 : L === "bottom" ? fe : L === "bottom-baseline" ? -Y[Y.length - 1].baseline : c(L) * fe)), !k) {
        const ye = e.getEmbeddingLevels(m, C);
        de = new Uint16Array(Ue), ce = new Uint8Array(Ue), _e = new Float32Array(Ue * 2), Fe = {}, me = [1 / 0, 1 / 0, -1 / 0, -1 / 0], xe = [], q && (Ee = new Float32Array(m.length * 4)), N && (Ie = new Uint8Array(Ue * 3));
        let Ae = 0, Ce = -1, Ge = -1, De, Ve;
        if (Y.forEach((ze, Ze) => {
          let { count: Le, width: ot } = ze;
          if (Le > 0) {
            let tt = 0;
            for (let We = Le; We-- && ze.glyphAt(We).glyphObj.isWhitespace; )
              tt++;
            let mt = 0, le = 0;
            if (P === "center")
              mt = ($ - ot) / 2;
            else if (P === "right")
              mt = $ - ot;
            else if (P === "justify" && ze.isSoftWrapped) {
              let We = 0;
              for (let Ne = Le - tt; Ne--; )
                ze.glyphAt(Ne).glyphObj.isWhitespace && We++;
              le = ($ - ot) / We;
            }
            if (le || mt) {
              let We = 0;
              for (let Ne = 0; Ne < Le; Ne++) {
                let ct = ze.glyphAt(Ne);
                const gt = ct.glyphObj;
                ct.x += mt + We, le !== 0 && gt.isWhitespace && Ne < Le - tt && (We += le, ct.width += le);
              }
            }
            const ve = e.getReorderSegments(
              m,
              ye,
              ze.glyphAt(0).charIndex,
              ze.glyphAt(ze.count - 1).charIndex
            );
            for (let We = 0; We < ve.length; We++) {
              const [Ne, ct] = ve[We];
              let gt = 1 / 0, nt = -1 / 0;
              for (let je = 0; je < Le; je++)
                if (ze.glyphAt(je).charIndex >= Ne) {
                  let at = je, ft = je;
                  for (; ft < Le; ft++) {
                    let Qe = ze.glyphAt(ft);
                    if (Qe.charIndex > ct)
                      break;
                    ft < Le - tt && (gt = Math.min(gt, Qe.x), nt = Math.max(nt, Qe.x + Qe.width));
                  }
                  for (let Qe = at; Qe < ft; Qe++) {
                    const xt = ze.glyphAt(Qe);
                    xt.x = nt - (xt.x + xt.width - gt);
                  }
                  break;
                }
            }
            let be;
            const Xe = (We) => be = We;
            for (let We = 0; We < Le; We++) {
              const Ne = ze.glyphAt(We);
              be = Ne.glyphObj;
              const ct = be.index, gt = ye.levels[Ne.charIndex] & 1;
              if (gt) {
                const nt = e.getMirroredCharacter(m[Ne.charIndex]);
                nt && Ne.fontData.fontObj.forEachGlyph(nt, 0, 0, Xe);
              }
              if (q) {
                const { charIndex: nt, fontData: je } = Ne, at = Ne.x + ue, ft = Ne.x + Ne.width + ue;
                Ee[nt * 4] = gt ? ft : at, Ee[nt * 4 + 1] = gt ? at : ft, Ee[nt * 4 + 2] = ze.baseline + je.caretBottom + te, Ee[nt * 4 + 3] = ze.baseline + je.caretTop + te;
                const Qe = nt - Ce;
                Qe > 1 && u(Ee, Ce, Qe), Ce = nt;
              }
              if (N) {
                const { charIndex: nt } = Ne;
                for (; nt > Ge; )
                  Ge++, N.hasOwnProperty(Ge) && (Ve = N[Ge]);
              }
              if (!be.isWhitespace && !be.isEmpty) {
                const nt = Ae++, { fontSizeMult: je, src: at, index: ft } = Ne.fontData, Qe = Fe[at] || (Fe[at] = {});
                Qe[ct] || (Qe[ct] = {
                  path: be.path,
                  pathBounds: [be.xMin, be.yMin, be.xMax, be.yMax]
                });
                const xt = Ne.x + ue, yt = Ne.y + ze.baseline + te;
                _e[nt * 2] = xt, _e[nt * 2 + 1] = yt;
                const Mt = xt + be.xMin * je, nn = yt + be.yMin * je, zt = xt + be.xMax * je, $t = yt + be.yMax * je;
                Mt < me[0] && (me[0] = Mt), nn < me[1] && (me[1] = nn), zt > me[2] && (me[2] = zt), $t > me[3] && (me[3] = $t), nt % Z === 0 && (De = { start: nt, end: nt, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, xe.push(De)), De.end++;
                const qt = De.rect;
                if (Mt < qt[0] && (qt[0] = Mt), nn < qt[1] && (qt[1] = nn), zt > qt[2] && (qt[2] = zt), $t > qt[3] && (qt[3] = $t), de[nt] = ct, ce[nt] = ft, N) {
                  const en = nt * 3;
                  Ie[en] = Ve >> 16 & 255, Ie[en + 1] = Ve >> 8 & 255, Ie[en + 2] = Ve & 255;
                }
              }
            }
          }
        }), Ee) {
          const ze = m.length - Ce;
          ze > 1 && u(Ee, Ce, ze);
        }
      }
      const Se = [];
      oe.forEach(({ index: ye, src: Ae, unitsPerEm: Ce, ascender: Ge, descender: De, lineHeight: Ve, capHeight: ze, xHeight: Ze }) => {
        Se[ye] = { src: Ae, unitsPerEm: Ce, ascender: Ge, descender: De, lineHeight: Ve, capHeight: ze, xHeight: Ze };
      }), se.typesetting = h() - Te, z({
        glyphIds: de,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: ce,
        //index into fontData for each glyph
        glyphPositions: _e,
        //x,y of each glyph's origin in layout
        glyphData: Fe,
        //dict holding data about each glyph appearing in the text
        fontData: Se,
        //data about each font used in the text
        caretPositions: Ee,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: Ie,
        //color for each glyph, if color ranges supplied
        chunkedBounds: xe,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: y,
        //calculated em height
        topBaseline: te + Y[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          ue,
          te - fe,
          ue + $,
          te
        ],
        visibleBounds: me,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: se
      });
    });
  }
  function l(m, g) {
    a({ ...m, metricsOnly: !0 }, (v) => {
      const [_, y, w, x] = v.blockBounds;
      g({
        width: w - _,
        height: x - y
      });
    });
  }
  function c(m) {
    let g = m.match(/^([\d.]+)%$/), v = g ? parseFloat(g[1]) : NaN;
    return isNaN(v) ? 0 : v / 100;
  }
  function u(m, g, v) {
    const _ = m[g * 4], y = m[g * 4 + 1], w = m[g * 4 + 2], x = m[g * 4 + 3], M = (y - _) / v;
    for (let A = 0; A < v; A++) {
      const E = (g + A) * 4;
      m[E] = _ + M * A, m[E + 1] = _ + M * (A + 1), m[E + 2] = w, m[E + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(m) {
      let g = d.flyweight;
      return g.data = this.data, g.index = m, g;
    },
    splitAt(m) {
      let g = new d();
      return g.data = this.data.splice(m * f.length), g;
    }
  }, d.flyweight = f.reduce((m, g, v, _) => (Object.defineProperty(m, g, {
    get() {
      return this.data[this.index * f.length + v];
    },
    set(y) {
      this.data[this.index * f.length + v] = y;
    }
  }), m), { data: null, index: 0 }), {
    typeset: a,
    measure: l
  };
}
const ru = () => (self.performance || Date).now(), uy = /* @__PURE__ */ cy();
let $2;
function Cj(s, e, t, i, n, r, o, a, l, c, u = !0) {
  return u ? Rj(s, e, t, i, n, r, o, a, l, c).then(
    null,
    (h) => ($2 || (console.warn("WebGL SDF generation failed, falling back to JS", h), $2 = !0), Q2(s, e, t, i, n, r, o, a, l, c))
  ) : Q2(s, e, t, i, n, r, o, a, l, c);
}
const Gv = [], Pj = 5;
let Y1 = 0;
function c3() {
  const s = ru();
  for (; Gv.length && ru() - s < Pj; )
    Gv.shift()();
  Y1 = Gv.length ? setTimeout(c3, 0) : 0;
}
const Rj = (...s) => new Promise((e, t) => {
  Gv.push(() => {
    const i = ru();
    try {
      uy.webgl.generateIntoCanvas(...s), e({ timing: ru() - i });
    } catch (n) {
      t(n);
    }
  }), Y1 || (Y1 = setTimeout(c3, 0));
}), Dj = 4, Ij = 2e3, J2 = {};
let Lj = 0;
function Q2(s, e, t, i, n, r, o, a, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + Lj++ % Dj;
  let h = J2[u];
  return h || (h = J2[u] = {
    workerModule: Id({
      name: u,
      workerId: u,
      dependencies: [
        cy,
        ru
      ],
      init(d, f) {
        const m = d().javascript.generate;
        return function(...g) {
          const v = f();
          return {
            textureData: m(...g),
            timing: f() - v
          };
        };
      },
      getTransferables(d) {
        return [d.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(s, e, t, i, n, r).then(({ textureData: d, timing: f }) => {
    const m = ru(), g = new Uint8Array(d.length * 4);
    for (let v = 0; v < d.length; v++)
      g[v * 4 + c] = d[v];
    return uy.webglUtils.renderImageData(o, g, a, l, s, e, 1 << 3 - c), f += ru() - m, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      hj(u);
    }, Ij)), { timing: f };
  });
}
function Uj(s) {
  s._warm || (uy.webgl.isSupported(s), s._warm = !0);
}
const kj = uy.webglUtils.resizeWebGLCanvasWithoutClearing, Gf = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, Oj = /* @__PURE__ */ new rt();
function Eh() {
  return (self.performance || Date).now();
}
const eC = /* @__PURE__ */ Object.create(null);
function Fj(s, e) {
  s = Bj({}, s);
  const t = Eh(), i = [];
  if (s.font && i.push({ label: "user", src: zj(s.font) }), s.font = i, s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || Gf.sdfGlyphSize, s.unicodeFontsURL = s.unicodeFontsURL || Gf.unicodeFontsURL, s.colorRanges != null) {
    let d = {};
    for (let f in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(f)) {
        let m = s.colorRanges[f];
        typeof m != "number" && (m = Oj.set(m).getHex()), d[f] = m;
      }
    s.colorRanges = d;
  }
  Object.freeze(s);
  const { textureWidth: n, sdfExponent: r } = Gf, { sdfGlyphSize: o } = s, a = n / o * 4;
  let l = eC[o];
  if (!l) {
    const d = document.createElement("canvas");
    d.width = n, d.height = o * 256 / a, l = eC[o] = {
      glyphCount: 0,
      sdfGlyphSize: o,
      sdfCanvas: d,
      sdfTexture: new ei(
        d,
        void 0,
        void 0,
        void 0,
        Sn,
        Sn
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, l.sdfTexture.generateMipmaps = !1, Nj(l);
  }
  const { sdfTexture: c, sdfCanvas: u } = l;
  d3(s).then((d) => {
    const { glyphIds: f, glyphFontIndices: m, fontData: g, glyphPositions: v, fontSize: _, timings: y } = d, w = [], x = new Float32Array(f.length * 4);
    let M = 0, A = 0;
    const E = Eh(), C = g.map((U) => {
      let L = l.glyphsByFont.get(U.src);
      return L || l.glyphsByFont.set(U.src, L = /* @__PURE__ */ new Map()), L;
    });
    f.forEach((U, L) => {
      const k = m[L], { src: B, unitsPerEm: j } = g[k];
      let q = C[k].get(U);
      if (!q) {
        const { path: se, pathBounds: K } = d.glyphData[B][U], Q = Math.max(K[2] - K[0], K[3] - K[1]) / o * (Gf.sdfMargin * o + 0.5), de = l.glyphCount++, ce = [
          K[0] - Q,
          K[1] - Q,
          K[2] + Q,
          K[3] + Q
        ];
        C[k].set(U, q = { path: se, atlasIndex: de, sdfViewBox: ce }), w.push(q);
      }
      const { sdfViewBox: Z } = q, N = v[A++], z = v[A++], J = _ / j;
      x[M++] = N + Z[0] * J, x[M++] = z + Z[1] * J, x[M++] = N + Z[2] * J, x[M++] = z + Z[3] * J, f[L] = q.atlasIndex;
    }), y.quads = (y.quads || 0) + (Eh() - E);
    const P = Eh();
    y.sdf = {};
    const T = u.height, I = Math.ceil(l.glyphCount / a), D = Math.pow(2, Math.ceil(Math.log2(I * o)));
    D > T && (console.info(`Increasing SDF texture size ${T}->${D}`), kj(u, n, D), c.dispose()), Promise.all(w.map(
      (U) => u3(U, l, s.gpuAccelerateSDF).then(({ timing: L }) => {
        y.sdf[U.atlasIndex] = L;
      })
    )).then(() => {
      w.length && !l.contextLost && (h3(l), c.needsUpdate = !0), y.sdfTotal = Eh() - P, y.total = Eh() - t, e(Object.freeze({
        parameters: s,
        sdfTexture: c,
        sdfGlyphSize: o,
        sdfExponent: r,
        glyphBounds: x,
        glyphAtlasIndices: f,
        glyphColors: d.glyphColors,
        caretPositions: d.caretPositions,
        chunkedBounds: d.chunkedBounds,
        ascender: d.ascender,
        descender: d.descender,
        lineHeight: d.lineHeight,
        capHeight: d.capHeight,
        xHeight: d.xHeight,
        topBaseline: d.topBaseline,
        blockBounds: d.blockBounds,
        visibleBounds: d.visibleBounds,
        timings: d.timings
      }));
    });
  }), Promise.resolve().then(() => {
    l.contextLost || Uj(u);
  });
}
function u3({ path: s, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: i, sdfCanvas: n, contextLost: r }, o) {
  if (r)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: a, sdfExponent: l } = Gf, c = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (a / i) * i, d = Math.floor(u / (a / i)) * i, f = e % 4;
  return Cj(i, i, s, t, c, l, n, h, d, f, o);
}
function Nj(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), s.contextLost = !1;
    const i = [];
    s.glyphsByFont.forEach((n) => {
      n.forEach((r) => {
        i.push(u3(r, s, !0));
      });
    }), Promise.all(i).then(() => {
      h3(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function Bj(s, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (s[t] = e[t]);
  return s;
}
let mv;
function zj(s) {
  return mv || (mv = typeof document > "u" ? {} : document.createElement("a")), mv.href = s, mv.href;
}
function h3(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = s, { width: i, height: n } = e, r = s.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    (!o || o.length !== i * n * 4) && (o = new Uint8Array(i * n * 4), t.image = { width: i, height: n, data: o }, t.flipY = !1, t.isDataTexture = !0), r.readPixels(0, 0, i, n, r.RGBA, r.UNSIGNED_BYTE, o);
  }
}
const Vj = /* @__PURE__ */ Id({
  name: "Typesetter",
  dependencies: [
    Aj,
    Tj,
    a3
  ],
  init(s, e, t) {
    return s(e, t());
  }
}), d3 = /* @__PURE__ */ Id({
  name: "Typesetter",
  dependencies: [
    Vj
  ],
  init(s) {
    return function(e) {
      return new Promise((t) => {
        s.typeset(e, t);
      });
    };
  },
  getTransferables(s) {
    const e = [];
    for (let t in s)
      s[t] && s[t].buffer && e.push(s[t].buffer);
    return e;
  }
});
d3.onMainThread;
const tC = {};
function Gj(s) {
  let e = tC[s];
  return e || (e = tC[s] = new $r(1, 1, s, s).translate(0.5, 0.5, 0)), e;
}
const Hj = "aTroikaGlyphBounds", nC = "aTroikaGlyphIndex", Wj = "aTroikaGlyphColor";
let Xj = class extends pm {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new fi(), this.boundingBox = new yn();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = Gj(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = t.attributes[i].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, i, n, r) {
    this.updateAttributeData(Hj, e, 4), this.updateAttributeData(nC, t, 1), this.updateAttributeData(Wj, r, 3), this._blockBounds = i, this._chunkedBounds = n, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: i } = this;
      if (t) {
        const { PI: n, floor: r, min: o, max: a, sin: l, cos: c } = Math, u = n / 2, h = n * 2, d = Math.abs(t), f = e[0] / d, m = e[2] / d, g = r((f + u) / h) !== r((m + u) / h) ? -d : o(l(f) * d, l(m) * d), v = r((f - u) / h) !== r((m - u) / h) ? d : a(l(f) * d, l(m) * d), _ = r((f + n) / h) !== r((m + n) / h) ? d * 2 : a(d - c(f) * d, d - c(m) * d);
        i.min.set(g, e[1], t < 0 ? -_ : 0), i.max.set(v, e[3], t < 0 ? 0 : _);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(nC).count, i = this._chunkedBounds;
    if (i)
      for (let n = i.length; n--; ) {
        t = i[n].end;
        let r = i[n].rect;
        if (r[1] < e.w && r[3] > e.y && r[0] < e.z && r[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(e, t, i) {
    const n = this.getAttribute(e);
    t ? n && n.array.length === t.length ? (n.array.set(t), n.needsUpdate = !0) : (this.setAttribute(e, new Jo(t, i)), delete this._maxInstanceCount, this.dispose()) : n && this.deleteAttribute(e);
  }
};
const Yj = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, jj = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, qj = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, Zj = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function Kj(s) {
  const e = X1(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Be() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Kt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Kt(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Be() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new rt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Jt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: Yj,
    vertexTransform: jj,
    fragmentDefs: qj,
    fragmentColorTransform: Zj,
    customRewriter({ vertexShader: t, fragmentShader: i }) {
      let n = /\buniform\s+vec3\s+diffuse\b/;
      return n.test(i) && (i = i.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(t) || (t = t.replace(
        l3,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: i };
    }
  });
  return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const rM = /* @__PURE__ */ new qn({
  color: 16777215,
  side: wi,
  transparent: !0
}), iC = 8421504, rC = /* @__PURE__ */ new _t(), gv = /* @__PURE__ */ new H(), Mb = /* @__PURE__ */ new H(), Tf = [], $j = /* @__PURE__ */ new H(), Eb = "+x+y";
function sC(s) {
  return Array.isArray(s) ? s[0] : s;
}
let f3 = () => {
  const s = new it(
    new $r(1, 1),
    rM
  );
  return f3 = () => s, s;
}, p3 = () => {
  const s = new it(
    new $r(1, 1, 32, 1),
    rM
  );
  return p3 = () => s, s;
};
const Jj = { type: "syncstart" }, Qj = { type: "synccomplete" }, m3 = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], eq = m3.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
let ri = class extends it {
  constructor() {
    const e = new Xj();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = iC, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = Eb, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(Jj), Fj({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((n) => n && n());
      })), this.dispatchEvent(Qj), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, i, n, r, o) {
    this.sync(), r.isTroikaTextMaterial && this._prepareForRender(r);
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(e) {
    return Kj(e);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = rM.clone());
    if ((!e || !e.isDerivedFrom(t)) && (e = this._derivedMaterial = this.createDerivedMaterial(t), t.addEventListener("dispose", function i() {
      t.removeEventListener("dispose", i), e.dispose();
    })), this.hasOutline()) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function n() {
        e.removeEventListener("dispose", n), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return sC(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return sC(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, i = e.uniforms, n = this.textRenderInfo;
    if (n) {
      const { sdfTexture: a, blockBounds: l } = n;
      i.uTroikaSDFTexture.value = a, i.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height), i.uTroikaSDFGlyphSize.value = n.sdfGlyphSize, i.uTroikaSDFExponent.value = n.sdfExponent, i.uTroikaTotalBounds.value.fromArray(l), i.uTroikaUseGlyphColors.value = !t && !!n.glyphColors;
      let c = 0, u = 0, h = 0, d, f, m, g = 0, v = 0;
      if (t) {
        let { outlineWidth: y, outlineOffsetX: w, outlineOffsetY: x, outlineBlur: M, outlineOpacity: A } = this;
        c = this._parsePercent(y) || 0, u = Math.max(0, this._parsePercent(M) || 0), d = A, g = this._parsePercent(w) || 0, v = this._parsePercent(x) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (m = this.strokeColor, i.uTroikaStrokeColor.value.set(m ?? iC), f = this.strokeOpacity, f == null && (f = 1)), d = this.fillOpacity;
      i.uTroikaEdgeOffset.value = c, i.uTroikaPositionOffset.value.set(g, v), i.uTroikaBlurRadius.value = u, i.uTroikaStrokeWidth.value = h, i.uTroikaStrokeOpacity.value = f, i.uTroikaFillOpacity.value = d ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let _ = this.clipRect;
      if (_ && Array.isArray(_) && _.length === 4)
        i.uTroikaClipRect.value.fromArray(_);
      else {
        const y = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          l[0] - y,
          l[1] - y,
          l[2] + y,
          l[3] + y
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const r = t ? this.outlineColor || 0 : this.color;
    if (r == null)
      delete e.color;
    else {
      const a = e.hasOwnProperty("color") ? e.color : e.color = new rt();
      (r !== a._input || typeof r == "object") && a.set(a._input = r);
    }
    let o = this.orientation || Eb;
    if (o !== e._orientation) {
      let a = i.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let l = o !== Eb && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, h, d] = l;
        gv.set(0, 0, 0)[u] = c === "-" ? 1 : -1, Mb.set(0, 0, 0)[d] = h === "-" ? -1 : 1, rC.lookAt($j, gv.cross(Mb), Mb), a.setFromMatrix4(rC);
      } else
        a.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), i = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new Be()) {
    t.copy(e);
    const i = this.curveRadius;
    return i && (t.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new Be()) {
    return gv.copy(e), this.localPositionToTextCoords(this.worldToLocal(gv), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: i, curveRadius: n } = this;
    if (i) {
      const r = i.blockBounds, o = n ? p3() : f3(), a = o.geometry, { position: l, uv: c } = a.attributes;
      for (let u = 0; u < c.count; u++) {
        let h = r[0] + c.getX(u) * (r[2] - r[0]);
        const d = r[1] + c.getY(u) * (r[3] - r[1]);
        let f = 0;
        n && (f = n - Math.cos(h / n) * n, h = Math.sin(h / n) * n), l.setXYZ(u, h, d, f);
      }
      a.boundingSphere = this.geometry.boundingSphere, a.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, Tf.length = 0, o.raycast(e, Tf);
      for (let u = 0; u < Tf.length; u++)
        Tf[u].object = this, t.push(Tf[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, eq.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
m3.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(ri.prototype, s, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
new yn();
new rt();
class tq {
  //
  constructor(e) {
    var t;
    this._charts = /* @__PURE__ */ new Map(), this._width = 400, this._height = 110, this._backgroundOpacity = 0.7, this._perf = e.perf, this._backgroundOpacity = (t = e.backgroundOpacity) != null ? t : this._backgroundOpacity, this.wrapper = document.createElement("div"), this.wrapper.id = "three-perf-ui", this.wrapper.style.position = "fixed", this.wrapper.style.bottom = "0", this.wrapper.style.left = "0", this.wrapper.style.width = this._width + "px", this.wrapper.style.height = this._height + "px", e.domElement.appendChild(this.wrapper), this.canvas = document.createElement("canvas"), this.canvas.width = this._width, this.canvas.height = this._height, this.canvas.style.position = "absolute", this.wrapper.appendChild(this.canvas), this.initCanvas();
  }
  setScale(e) {
    this.wrapper.style.width = e * this.width + "px", this.wrapper.style.height = e * this.height + "px", this._renderer.setSize(this._width * e, this._height * e, !0);
  }
  initCanvas() {
    this._renderer = new CS({
      canvas: this.canvas,
      antialias: !0,
      alpha: !0
    }), this._renderer.setClearColor(0, this._backgroundOpacity), this._renderer.setPixelRatio(window.devicePixelRatio), this._scene = new am(), this._camera = new Ua(
      0,
      this._width,
      0,
      -this._height,
      0.1,
      100
    ), this._camera.position.set(0, 0, 10), this._camera.lookAt(0, 0, 0), this._camera.updateProjectionMatrix(), this._scene.add(this._camera), this._scene.userData.useStats = !1;
    const e = new ri();
    e.anchorX = "right", e.position.set(45, -8, 0), e.text = "0.000", e.fontSize = 15, e.color = "rgb(253, 151, 31)", e.sync(), this._scene.add(e);
    const t = new ri();
    t.anchorX = "right", t.position.set(65, -7, 0), t.text = "ms", t.fontSize = 9, t.color = "rgb(255, 255, 255)", t.sync(), this._scene.add(t);
    const i = new ri();
    i.anchorX = "right", i.position.set(65, -22, 0), i.text = "GPU", i.fontSize = 9, i.color = "rgb(253, 151, 31)", i.sync(), this._scene.add(i);
    const n = new ri();
    n.anchorX = "right", n.position.set(115, -8, 0), n.text = "0.000", n.fontSize = 15, n.color = "rgb(66, 226, 46)", n.sync(), this._scene.add(n);
    const r = new ri();
    r.anchorX = "right", r.position.set(135, -7, 0), r.text = "ms", r.fontSize = 9, r.color = "rgb(255, 255, 255)", r.sync(), this._scene.add(r);
    const o = new ri();
    o.anchorX = "right", o.position.set(135, -22, 0), o.text = "CPU", o.fontSize = 9, o.color = "rgb(66, 226, 46)", o.sync(), this._scene.add(o);
    const a = new ri();
    a.anchorX = "center", a.position.set(165, -8, 0), a.text = "0", a.fontSize = 15, a.color = "rgb(238, 38, 110)", a.sync(), this._scene.add(a);
    const l = new ri();
    l.anchorX = "center", l.position.set(175, -22, 0), l.text = "FPS", l.fontSize = 9, l.color = "rgb(238, 38, 110)", l.sync(), this._scene.add(l);
    const c = new ri();
    c.anchorX = "right", c.position.set(235, -8, 0), c.text = "0", c.fontSize = 15, c.color = "#ffffff", c.sync(), this._scene.add(c);
    const u = new ri();
    u.anchorX = "right", u.position.set(235, -22, 0), u.text = "calls", u.fontSize = 9, u.color = "rgb(101, 197, 188)", u.sync(), this._scene.add(u);
    const h = new ri();
    h.anchorX = "right", h.position.set(315, -8, 0), h.text = "0", h.fontSize = 15, h.color = "#ffffff", h.sync(), this._scene.add(h);
    const d = new ri();
    d.anchorX = "right", d.position.set(315, -22, 0), d.text = "triangles", d.fontSize = 9, d.color = "rgb(101, 197, 188)", d.sync(), this._scene.add(d);
    const f = new ri();
    f.anchorX = "right", f.position.set(365, -8, 0), f.text = "0", f.fontSize = 15, f.color = "#ffffff", f.sync(), this._scene.add(f);
    const m = new ri();
    m.anchorX = "right", m.position.set(365, -22, 0), m.text = "passes", m.fontSize = 9, m.color = "rgb(101, 197, 188)", m.sync(), this._scene.add(m), this._basicInfoElements = {
      gpuValue: e,
      cpuValue: n,
      fpsValue: a,
      callsValue: c,
      trianglesValue: h,
      renderpassesValue: f
    };
    const g = new ri();
    g.anchorX = "right", g.position.set(65, -39, 0), g.text = "0", g.fontSize = 15, g.color = "#ffffff", g.sync(), this._scene.add(g);
    const v = new ri();
    v.anchorX = "right", v.position.set(65, -53, 0), v.text = "geometries", v.fontSize = 9, v.color = "rgb(101, 197, 188)", v.sync(), this._scene.add(v);
    const _ = new ri();
    _.anchorX = "right", _.position.set(135, -39, 0), _.text = "0", _.fontSize = 15, _.color = "#ffffff", _.sync(), this._scene.add(_);
    const y = new ri();
    y.anchorX = "right", y.position.set(135, -53, 0), y.text = "textures", y.fontSize = 9, y.color = "rgb(101, 197, 188)", y.sync(), this._scene.add(y);
    const w = new ri();
    w.anchorX = "right", w.position.set(205, -39, 0), w.text = "0", w.fontSize = 15, w.color = "#ffffff", w.sync(), this._scene.add(w);
    const x = new ri();
    x.anchorX = "right", x.position.set(205, -53, 0), x.text = "shaders", x.fontSize = 9, x.color = "rgb(101, 197, 188)", x.sync(), this._scene.add(x);
    const M = new ri();
    M.anchorX = "right", M.position.set(275, -39, 0), M.text = "0", M.fontSize = 15, M.color = "#ffffff", M.sync(), this._scene.add(M);
    const A = new ri();
    A.anchorX = "right", A.position.set(275, -53, 0), A.text = "lines", A.fontSize = 9, A.color = "rgb(101, 197, 188)", A.sync(), this._scene.add(A);
    const E = new ri();
    E.anchorX = "right", E.position.set(345, -39, 0), E.text = "0", E.fontSize = 15, E.color = "#ffffff", E.sync(), this._scene.add(E);
    const C = new ri();
    C.anchorX = "right", C.position.set(345, -53, 0), C.text = "points", C.fontSize = 9, C.color = "rgb(101, 197, 188)", C.sync(), this._scene.add(C), this._memInfoElements = {
      geometriesValue: g,
      geometriesLabel: v,
      texturesValue: _,
      texturesLabel: y,
      shadersValue: w,
      shadersLabel: x,
      linesValue: M,
      linesLabel: A,
      pointsValue: E,
      pointsLabel: C
    };
    const P = new Gt();
    let T = new Float32Array(60 * 3);
    for (let j = 0; j < 60; j++)
      T[3 * j + 0] = this._width / 59 * j, T[3 * j + 1] = -110, T[3 * j + 2] = 0;
    let I = new Nt(T, 3);
    I.usage = Zh, P.setAttribute("position", I);
    const D = new Ui(
      P,
      new Bi({ color: "rgb(253, 151, 31)" })
    );
    this._scene.add(D), this._charts.set("gpu", D);
    const U = new Gt();
    T = new Float32Array(60 * 3);
    for (let j = 0; j < 60; j++)
      T[3 * j + 0] = this._width / 59 * j, T[3 * j + 1] = -110, T[3 * j + 2] = 0;
    I = new Nt(T, 3), I.usage = Zh, U.setAttribute("position", I);
    const L = new Ui(
      U,
      new Bi({ color: "rgb(66, 226, 46)" })
    );
    this._scene.add(L), this._charts.set("cpu", L);
    const k = new Gt();
    T = new Float32Array(60 * 3);
    for (let j = 0; j < 60; j++)
      T[3 * j + 0] = this._width / 59 * j, T[3 * j + 1] = -110, T[3 * j + 2] = 0;
    I = new Nt(T, 3), I.usage = Zh, k.setAttribute("position", I);
    const B = new Ui(
      k,
      new Bi({ color: "rgb(238, 38, 110)" })
    );
    this._scene.add(B), this._charts.set("fps", B);
  }
  update() {
    var e, t;
    if (this._perf.chart && this._perf.showGraph)
      for (const i in this._perf.chart.data) {
        const n = this._perf.chart.data[i];
        if (!this._charts.get(i) || !n)
          continue;
        const o = this._charts.get(i).geometry.attributes.position;
        let a = 0;
        for (let l = 0; l < n.length; l++)
          n[l] > a && (a = n[l]);
        a = Math.max(a, 20);
        for (let l = 0; l < n.length; l++) {
          let c = (this._perf.chart.circularId + l + 1) % 60;
          o.setY(
            l,
            (n[c] / a * 90 - 110) * this.height / 110
          );
        }
        o.needsUpdate = !0;
      }
    this._basicInfoElements.gpuValue.text = this._perf.log.gpu.toFixed(3), this._basicInfoElements.cpuValue.text = this._perf.log.cpu.toFixed(3), this._basicInfoElements.fpsValue.text = this._perf.log.fps.toFixed(0), this._basicInfoElements.callsValue.text = this._perf.threeRenderer.info.render.calls.toString(), this._basicInfoElements.trianglesValue.text = this._perf.threeRenderer.info.render.triangles.toString(), this._basicInfoElements.renderpassesValue.text = this._perf.renderPassesNumber.toString(), this._memInfoElements.geometriesValue.text = this._perf.threeRenderer.info.memory.geometries.toString(), this._memInfoElements.texturesValue.text = this._perf.threeRenderer.info.memory.textures.toString(), this._memInfoElements.shadersValue.text = (t = (e = this._perf.threeRenderer.info.programs) == null ? void 0 : e.length.toString()) != null ? t : "", this._memInfoElements.linesValue.text = this._perf.threeRenderer.info.render.lines.toString(), this._memInfoElements.pointsValue.text = this._perf.threeRenderer.info.render.points.toString(), this.render();
  }
  render() {
    this._renderer.render(this._scene, this._camera);
  }
  dispose() {
    this.wrapper.remove();
  }
  //
  toggleVisibility(e) {
    this.wrapper.style.display = e ? "block" : "none";
  }
  toggleCharts(e) {
    this._charts.forEach((t) => {
      t.visible = e;
    }), this._perf.showGraph ? this.height = this._perf.memory ? 110 : 70 : this.height = this._perf.memory ? 70 : 40, this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  toggleMemoryInfo(e) {
    for (const t in this._memInfoElements)
      this._memInfoElements[t].visible = e;
    this.width = 380, this._perf.showGraph ? this.height = this._perf.memory ? 110 : 70 : this.height = this._perf.memory ? 70 : 40, this.wrapper.style.width = this._perf.scale * this.width + "px", this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  setBackgroundOpacity(e) {
    this._backgroundOpacity = e, this._renderer.setClearColor(0, this._backgroundOpacity), this.render();
  }
  //
  get width() {
    return this._width;
  }
  set width(e) {
    this._width = e, this._camera.right = e, this._camera.updateProjectionMatrix(), this._renderer.setSize(
      this._perf.scale * this._width,
      this._perf.scale * this._height
    ), this.render();
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this._height = e, this._camera.bottom = -e, this._camera.updateProjectionMatrix(), this._renderer.setSize(
      this._perf.scale * this._width,
      this._perf.scale * this._height
    ), this.render();
  }
}
const Io = {
  value: 0,
  fpsLimit: 60,
  isOverLimit: 0
}, Af = (s) => (s == null ? void 0 : s.reduce((e, t) => e + t, 0)) / s.length;
class nq {
  //
  constructor(e) {
    this.names = [""], this.finished = [], this.paused = !1, this.overClock = !1, this.queryHasResult = !1, this.queryCreated = !1, this.isWebGL2 = !0, this.memAccums = [], this.gpuAccums = [], this.activeAccums = [], this.logsAccums = {
      mem: [],
      gpu: [],
      cpu: [],
      fps: [],
      fpsFixed: []
    }, this.fpsChart = [], this.gpuChart = [], this.cpuChart = [], this.memChart = [], this.paramLogger = () => {
    }, this.glFinish = () => {
    }, this.chartLogger = () => {
    }, this.chartLen = 60, this.logsPerSecond = 10, this.maxMemory = 1500, this.chartHz = 10, this.startCpuProfiling = !1, this.lastCalculateFixed = 0, this.chartFrame = 0, this.gpuTimeProcess = 0, this.chartTime = 0, this.activeQueries = 0, this.circularId = 0, this.detected = 0, this.frameId = 0, this.rafId = 0, this.idleCbId = 0, this.checkQueryId = 0, this.uuid = void 0, this.currentCpu = 0, this.currentMem = 0, this.paramFrame = 0, this.paramTime = 0, this.now = () => {
    }, this.t0 = 0, this.nextFps = (t) => {
      const i = 16.666666666666668, n = i - t.timeRemaining(), r = i * Io.fpsLimit / 10 / n;
      r < 0 || (Io.value = r, Io.isOverLimit < 25 ? Io.isOverLimit++ : this.perf.overclockingFps = !0);
    }, this.nextFrame = (t) => {
      this.frameId++;
      const i = t || this.now();
      let n = i - this.paramTime, r = 0;
      if (this.frameId <= 1)
        this.paramFrame = this.frameId, this.paramTime = i;
      else if (i >= this.paramTime) {
        this.maxMemory = window.performance.memory ? window.performance.memory.jsHeapSizeLimit / 1048576 : 0;
        const o = this.frameId - this.paramFrame, a = o * 1e3 / n, l = this.perf.overclockingFps ? Io.value : a;
        if (r = this.isWebGL2 ? this.gpuAccums[0] : this.gpuAccums[0] / n, this.isWebGL2 ? this.gpuAccums[0] = 0 : Promise.all(this.finished).then(() => {
          this.gpuAccums[0] = 0, this.finished = [];
        }), this.currentMem = Math.round(window.performance && window.performance.memory ? window.performance.memory.usedJSHeapSize / 1048576 : 0), window.performance && this.startCpuProfiling) {
          window.performance.mark("cpu-finished");
          const c = performance.measure("cpu-duration", "cpu-started", "cpu-finished");
          this.currentCpu = c.duration, this.logsAccums.cpu.push(this.currentCpu), this.startCpuProfiling = !1;
        }
        this.logsAccums.mem.push(this.currentMem), this.logsAccums.fpsFixed.push(a), this.logsAccums.fps.push(l), this.logsAccums.gpu.push(r), this.overClock && typeof window.requestIdleCallback < "u" && (Io.isOverLimit > 0 && l > a ? Io.isOverLimit-- : this.perf.overclockingFps && (this.perf.overclockingFps = !1)), i >= this.paramTime + 1e3 / this.logsPerSecond && (this.paramLogger({
          cpu: Af(this.logsAccums.cpu),
          gpu: Af(this.logsAccums.gpu),
          mem: Af(this.logsAccums.mem),
          fps: Af(this.logsAccums.fps),
          duration: Math.round(n),
          maxMemory: this.maxMemory,
          frameCount: o
        }), this.logsAccums.mem = [], this.logsAccums.fps = [], this.logsAccums.gpu = [], this.logsAccums.cpu = [], this.paramFrame = this.frameId, this.paramTime = i), this.overClock && i - this.lastCalculateFixed >= 2 * 1e3 && (this.lastCalculateFixed = t, Io.fpsLimit = Math.round(Af(this.logsAccums.fpsFixed) / 10) * 100, this.perf.fpsLimit = Io.fpsLimit / 10, this.logsAccums.fpsFixed = [], this.paramFrame = this.frameId, this.paramTime = i);
      }
      if (!this.detected || !this.chartFrame)
        this.chartFrame = this.frameId, this.chartTime = i, this.circularId = 0;
      else {
        const o = i - this.chartTime;
        let a = this.chartHz * o / 1e3;
        for (; --a > 0 && this.detected; ) {
          const c = (this.frameId - this.chartFrame) / o * 1e3, u = this.perf.overclockingFps ? Io.value : c;
          this.fpsChart[this.circularId % this.chartLen] = u;
          const h = 1e3 / this.currentMem, d = this.currentCpu, f = (this.isWebGL2 ? this.gpuAccums[1] * 2 : Math.round(this.gpuAccums[1] / n * 100)) + 4;
          f > 0 && (this.gpuChart[this.circularId % this.chartLen] = f), d > 0 && (this.cpuChart[this.circularId % this.chartLen] = d), h > 0 && (this.memChart[this.circularId % this.chartLen] = h);
          for (let m = 0; m < this.names.length; m++)
            this.chartLogger({
              i: m,
              data: {
                fps: this.fpsChart,
                gpu: this.gpuChart,
                cpu: this.cpuChart,
                mem: this.memChart
              },
              circularId: this.circularId
            });
          this.circularId++, this.chartFrame = this.frameId, this.chartTime = i;
        }
      }
    }, this.perf = e.perf, this.trackGPU = e.trackGPU, this.overClock = e.overClock, this.logsPerSecond = e.logsPerSecond, this.gl = e.gl, this.paramLogger = e.paramLogger, this.chartLogger = e.chartLogger, window.GLPerf = window.GLPerf || {}, this.fpsChart = new Array(this.chartLen).fill(0), this.gpuChart = new Array(this.chartLen).fill(0), this.cpuChart = new Array(this.chartLen).fill(0), this.memChart = new Array(this.chartLen).fill(0), this.now = () => window.performance && window.performance.now ? window.performance.now() : Date.now(), this.initGpu(), this.is120hz();
  }
  initGpu() {
    this.uuid = Kr.generateUUID(), this.gl && (this.isWebGL2 = !0, this.extension || (this.extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")), this.extension === null && (this.isWebGL2 = !1));
  }
  /**
   * 120hz device detection
   */
  is120hz() {
    let e = 0;
    const t = (i) => {
      ++e < 20 ? this.rafId = window.requestAnimationFrame(t) : (this.detected = Math.ceil(1e3 * e / (i - this.t0) / 70), window.cancelAnimationFrame(this.rafId)), this.t0 || (this.t0 = i);
    };
    this.rafId = window.requestAnimationFrame(t);
  }
  /**
   * Explicit UI add
   * @param { string | undefined } name
   */
  addUI(e) {
    this.names.indexOf(e) === -1 && (this.names.push(e), this.gpuAccums.push(0), this.activeAccums.push(!1));
  }
  startGpu() {
    const e = this.gl, t = this.extension;
    if (!(!e || !t) && this.isWebGL2) {
      let i = !1, n, r;
      if (this.query) {
        this.queryHasResult = !1;
        let o = this.query;
        if (i = e.getQueryParameter(o, e.QUERY_RESULT_AVAILABLE), n = e.getParameter(t.GPU_DISJOINT_EXT), i && !n) {
          r = e.getQueryParameter(this.query, e.QUERY_RESULT);
          const a = r * 1e-6;
          (i || n) && (e.deleteQuery(this.query), o = null), i && a > 0 && (n || this.activeAccums.forEach((l, c) => {
            this.gpuAccums[c] = a;
          }));
        }
      }
      (i || !this.query) && (this.queryCreated = !0, this.query = e.createQuery(), e.beginQuery(t.TIME_ELAPSED_EXT, this.query));
    }
  }
  endGpu() {
    const e = this.extension, t = this.gl;
    this.isWebGL2 && this.queryCreated && t.getQuery(e.TIME_ELAPSED_EXT, t.CURRENT_QUERY) && t.endQuery(e.TIME_ELAPSED_EXT);
  }
  /**
   * Begin named measurement
   * @param { string | undefined } name
   */
  begin(e) {
    this.startGpu(), this.updateAccums(e);
  }
  /**
   * End named measure
   * @param { string | undefined } name
   */
  end(e) {
    this.endGpu(), this.updateAccums(e);
  }
  updateAccums(e) {
    let t = this.names.indexOf(e);
    t === -1 && (t = this.names.length, this.addUI(e));
    const i = this.now();
    this.activeAccums[t] = !this.activeAccums[t], this.t0 = i;
  }
}
tn.prototype.updateMatrixWorld;
tn.prototype.updateWorldMatrix;
tn.prototype.updateMatrix;
const oC = ["calls", "triangles", "points", "lines"], aC = ["gpu", "cpu", "mem", "fps"];
class iq {
  //
  constructor(e) {
    var t, i, n, r, o, a, l, c, u, h, d, f;
    this.gui = new oj.Pane(), this.accumulated = {
      totalFrames: 0,
      log: {
        i: 0,
        maxMemory: 0,
        gpu: 0,
        mem: 0,
        cpu: 0,
        fps: 0,
        duration: 0,
        frameCount: 0
      },
      gl: {
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
        counts: 0
      },
      max: {
        log: {
          i: 0,
          maxMemory: 0,
          gpu: 0,
          mem: 0,
          cpu: 0,
          fps: 0,
          duration: 0,
          frameCount: 0
        },
        gl: {
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0,
          counts: 0
        }
      }
    }, this.renderPassesNumber = 0, this._keypressed = "", this._guiVisible = !0, this.actionToCallUI = "dev", this.keypressHandler = (M) => {
      if (!this.actionToCallUI)
        return;
      this._keypressed += M.key;
      const A = this._keypressed.split("");
      for (; A.length > this.actionToCallUI.length; )
        A.shift();
      A.join("") === this.actionToCallUI && (this._keypressed = "", this.guiVisible = !this.guiVisible);
    }, this.afterRender = () => {
      this._enabled && (this.perfEngine.paused || (this.perfEngine.nextFrame(window.performance.now()), this.perfEngine.overClock && typeof window.requestIdleCallback < "u" && (this.perfEngine.idleCbId = requestIdleCallback(this.perfEngine.nextFps))), this.perfEngine && this.perfEngine.end("profiler"), window.performance && (window.performance.mark("cpu-started"), this.perfEngine.startCpuProfiling = !0), this.deepAnalyze);
    }, this.deepAnalyze = (t = e.deepAnalyze) != null ? t : !1, this.threeRenderer = e.renderer, this.ui = new tq({
      perf: this,
      domElement: e.domElement,
      backgroundOpacity: e.backgroundOpacity
    }), this._visible = (i = e.visible) != null ? i : !0, this._enabled = (n = e.enabled) != null ? n : !0, this.scale = (r = e.scale) != null ? r : 1, this.anchorX = (o = e.anchorX) != null ? o : "left", this.anchorY = (a = e.anchorY) != null ? a : "top", this.showGraph = (l = e.showGraph) != null ? l : !0, this.memory = (c = e.memory) != null ? c : !0, this.actionToCallUI = (u = e.actionToCallUI) != null ? u : "", this.guiVisible = (h = e.guiVisible) != null ? h : !1, this.gui.element.parentElement.style.width = "300px", window.addEventListener("keypress", this.keypressHandler);
    const m = (d = e.overClock) != null ? d : !0;
    this.perfEngine = new nq({
      perf: this,
      trackGPU: !0,
      overClock: m,
      chartLen: 120,
      // chart ? chart.length : 120,
      chartHz: 60,
      // chart ? chart.hz : 60,
      logsPerSecond: (f = e.logsPerSecond) != null ? f : 10,
      gl: e.renderer.getContext(),
      chartLogger: (M) => {
        this.chart = M;
      },
      paramLogger: (M) => {
        if (!this._enabled)
          return;
        const A = {
          maxMemory: M.maxMemory,
          gpu: M.gpu,
          cpu: M.cpu,
          mem: M.mem,
          fps: M.fps,
          totalTime: M.duration,
          frameCount: M.frameCount
        };
        this.log = A;
        const E = this.accumulated, C = this.threeRenderer.info.render;
        E.totalFrames++, E.gl.calls += C.calls, E.gl.triangles += C.triangles, E.gl.points += C.points, E.gl.lines += C.lines, E.log.gpu += M.gpu, E.log.cpu += M.cpu, E.log.mem += M.mem, E.log.fps += M.fps;
        for (let P = 0; P < oC.length; P++) {
          const T = oC[P], I = C[T];
          I > E.max.gl[T] && (E.max.gl[T] = I);
        }
        for (let P = 0; P < aC.length; P++) {
          const T = aC[P], I = M[T];
          I > E.max.log[T] && (E.max.log[T] = I);
        }
        this.accumulated = E, this.ui.update();
      }
    });
    const g = e.renderer.getContext();
    let v = null, _ = null;
    const y = g.getExtension("WEBGL_debug_renderer_info"), w = g.getParameter(g.VERSION);
    y != null && (v = g.getParameter(y.UNMASKED_RENDERER_WEBGL), _ = g.getParameter(y.UNMASKED_VENDOR_WEBGL)), _ || (_ = "Unknown vendor"), v || (v = g.getParameter(g.RENDERER)), this.startTime = performance.now(), this.infos = {
      version: w,
      renderer: v,
      vendor: _
    }, this.rendererRender = this.threeRenderer.render, this.threeRenderer.info.autoReset = !1, this.threeRenderer.render = (M, A) => {
      this.renderPassesNumber++, this.rendererRender.call(this.threeRenderer, M, A);
    }, this.guiFolder = this.gui.addFolder({ title: "Settings" });
    const x = this.guiFolder.addFolder({ title: "ThreePerf" });
    x.addInput(this, "visible", { label: "Visible" }), x.addInput(this, "enabled", { label: "Enabled" }), x.addInput(this, "anchorX", {
      label: "xAnchor",
      options: { left: "left", right: "right" }
    }), x.addInput(this, "anchorY", {
      label: "yAnchor",
      options: { top: "top", bottom: "bottom" }
    }), x.addInput(this, "backgroundOpacity", {
      label: "Background opacity",
      min: 0,
      max: 1,
      step: 0.1
    }), x.addInput(this, "memory", { label: "Memory" }), x.addInput(this, "showGraph", { label: "Charts" }), x.addInput(this, "scale", {
      label: "Scale",
      min: 0.1,
      max: 2,
      step: 0.1
    }), x.addInput(this, "logsPerSecond", {
      label: "LogsPerSecond",
      min: 1,
      max: 60,
      step: 1
    }), console.log("ThreePerf inited.");
  }
  begin() {
    this.perfEngine.begin("profiler");
  }
  end() {
    this.afterRender(), this.renderPassesNumber = 0, this.threeRenderer.info.reset();
  }
  dispose() {
    var e;
    this.ui.dispose(), (e = this.gui.element.parentElement) == null || e.remove(), window.removeEventListener("keypress", this.keypressHandler);
  }
  //
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e;
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    this._visible = e, this.ui.toggleVisibility(e);
  }
  get guiVisible() {
    return this._guiVisible;
  }
  set guiVisible(e) {
    this._guiVisible = e, this.gui.element.parentElement.style.display = e ? "block" : "none";
  }
  get anchorX() {
    return this._anchorX;
  }
  set anchorX(e) {
    this._anchorX = e, this._anchorX === "left" ? (this.ui.wrapper.style.left = "0", this.ui.wrapper.style.right = "") : (this.ui.wrapper.style.left = "", this.ui.wrapper.style.right = "0");
  }
  get anchorY() {
    return this._anchorY;
  }
  set anchorY(e) {
    this._anchorY = e, this._anchorY === "top" ? (this.ui.wrapper.style.top = "0", this.ui.wrapper.style.bottom = "") : (this.ui.wrapper.style.top = "", this.ui.wrapper.style.bottom = "0");
  }
  get showGraph() {
    return this._showGraph;
  }
  set showGraph(e) {
    this._showGraph = e, this.ui.toggleCharts(e);
  }
  get memory() {
    return this._memory;
  }
  set memory(e) {
    this._memory = e, this.ui.toggleMemoryInfo(e);
  }
  get scale() {
    return this._scale;
  }
  set scale(e) {
    this._scale = e, this.ui.setScale(e);
  }
  get logsPerSecond() {
    return this.perfEngine.logsPerSecond;
  }
  set logsPerSecond(e) {
    this.perfEngine.logsPerSecond = e;
  }
  get backgroundOpacity() {
    return this.ui._backgroundOpacity;
  }
  set backgroundOpacity(e) {
    this.ui.setBackgroundOpacity(e);
  }
}
function g3(s, e) {
  if (new.target) return Rt({ component: g3, ...s });
  Ct(e, !0);
  let t = G(e, "domElement", 23, () => document.body), i = G(e, "logsPerSecond", 7, 10), n = G(e, "showGraph", 7, !0), r = G(e, "memory", 7, !0), o = G(e, "enabled", 7, !0), a = G(e, "visible", 7, !0), l = G(e, "actionToCallUI", 7, ""), c = G(e, "guiVisible", 7, !1), u = G(e, "backgroundOpacity", 7, 0.7), h = G(e, "scale", 7, 1), d = G(e, "anchorX", 7, "left"), f = G(e, "anchorY", 7, "top");
  const { renderer: m, renderStage: g, mainStage: v } = cn();
  let _;
  return $e(() => {
    t(), _ == null || _.dispose(), _ = new iq({ domElement: t(), renderer: m });
  }), $e(() => {
    _.logsPerSecond = i(), _.showGraph = n(), _.memory = r(), _.enabled = o(), _.visible = a(), _.actionToCallUI = l(), _.guiVisible = c(), _.backgroundOpacity = u(), _.scale = h(), _.anchorX = d(), _.anchorY = f();
  }), ti(
    () => {
      _.begin();
    },
    {
      stage: wu("monitor-begin", { before: v })
    }
  ), ti(
    () => {
      _.end();
    },
    {
      stage: wu("monitor-end", { after: g })
    }
  ), Ki(() => {
    _ && _.dispose();
  }), Pt({
    get domElement() {
      return t();
    },
    set domElement(y = document.body) {
      t(y), V();
    },
    get logsPerSecond() {
      return i();
    },
    set logsPerSecond(y = 10) {
      i(y), V();
    },
    get showGraph() {
      return n();
    },
    set showGraph(y = !0) {
      n(y), V();
    },
    get memory() {
      return r();
    },
    set memory(y = !0) {
      r(y), V();
    },
    get enabled() {
      return o();
    },
    set enabled(y = !0) {
      o(y), V();
    },
    get visible() {
      return a();
    },
    set visible(y = !0) {
      a(y), V();
    },
    get actionToCallUI() {
      return l();
    },
    set actionToCallUI(y = "") {
      l(y), V();
    },
    get guiVisible() {
      return c();
    },
    set guiVisible(y = !1) {
      c(y), V();
    },
    get backgroundOpacity() {
      return u();
    },
    set backgroundOpacity(y = 0.7) {
      u(y), V();
    },
    get scale() {
      return h();
    },
    set scale(y = 1) {
      h(y), V();
    },
    get anchorX() {
      return d();
    },
    set anchorX(y = "left") {
      d(y), V();
    },
    get anchorY() {
      return f();
    },
    set anchorY(y = "top") {
      f(y), V();
    },
    $set: Lt,
    $on: (y, w) => It(e, y, w)
  });
}
Ut(
  g3,
  {
    domElement: {},
    logsPerSecond: {},
    showGraph: {},
    memory: {},
    enabled: {},
    visible: {},
    actionToCallUI: {},
    guiVisible: {},
    backgroundOpacity: {},
    scale: {},
    anchorX: {},
    anchorY: {}
  },
  [],
  [],
  !0
);
const rq = `
#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

uniform float thickness;
uniform bool screenspace;
uniform vec2 size;

void main() {
  #if defined (USE_SKINNING)
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
  #endif
  #include <begin_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  vec4 tNormal = vec4(normal, 0.0);
  vec4 tPosition = vec4(transformed, 1.0);
  #ifdef USE_INSTANCING
    tNormal = instanceMatrix * tNormal;
    tPosition = instanceMatrix * tPosition;
  #endif
  if (!screenspace) {
    vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  } else {
    vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
    vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
    vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
    clipPosition.xy += offset;
    gl_Position = clipPosition;
  }
}`, sq = `
uniform vec3 color;
uniform float opacity;
void main(){
  gl_FragColor = vec4(color, opacity);
  #include <tonemapping_fragment>
  #include <${iy >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
}
`;
var oq = /* @__PURE__ */ ni("<!> <!>", 1), aq = /* @__PURE__ */ ni("<!> <!>", 1);
function v3(s, e) {
  if (new.target) return Rt({ component: v3, ...s });
  Ct(e, !0);
  let t = G(e, "color", 7, "black"), i = G(e, "screenspace", 7, !1), n = G(e, "opacity", 7, 1), r = G(e, "transparent", 7, !1), o = G(e, "thickness", 7, 0.05), a = G(e, "toneMapped", 7, !0), l = G(e, "angle", 23, () => Math.PI), c = G(e, "polygonOffset", 7, !1), u = G(e, "polygonOffsetFactor", 7, 0), h = G(e, "renderOrder", 7, 0), d = G(e, "children", 7), f = G(e, "ref", 15), m = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "color",
    "screenspace",
    "opacity",
    "transparent",
    "thickness",
    "toneMapped",
    "angle",
    "polygonOffset",
    "polygonOffsetFactor",
    "renderOrder",
    "children",
    "ref"
  ]);
  const { renderer: g } = cn(), v = {
    screenspace: { value: i() },
    color: { value: new rt(t()) },
    opacity: { value: n() },
    thickness: { value: o() },
    size: { value: new Be() }
  }, _ = new Zn(), y = new Mi({
    side: Yi,
    uniforms: v,
    vertexShader: rq,
    fragmentShader: sq
  }), w = To();
  let x = rm(w), M = /* @__PURE__ */ wt(() => {
    if (bn(x.current, "Mesh"))
      return FS(x.current.geometry, l());
  }), A = /* @__PURE__ */ wt(() => {
    if (bn(x.current, "Mesh")) {
      if (bn(x.current, "SkinnedMesh")) {
        const E = new P_();
        return E.bind(x.current.skeleton, x.current.bindMatrix), E;
      } else if (bn(x.current, "InstancedMesh")) {
        const E = new Td(void 0, void 0, x.current.count);
        return E.instanceMatrix = x.current.instanceMatrix, E;
      }
      return new it();
    }
  });
  return $e(() => {
    pe(A) && (pe(A).renderOrder = h());
  }), $e(() => {
    y.transparent = r();
  }), $e(() => {
    y.toneMapped = a();
  }), $e(() => {
    y.polygonOffset = c();
  }), $e(() => {
    y.polygonOffsetFactor = u();
  }), $e(() => {
    y.uniforms.screenspace.value = i();
  }), $e(() => {
    y.uniforms.color.value.set(t());
  }), $e(() => {
    y.uniforms.opacity.value = n();
  }), $e(() => {
    y.uniforms.thickness.value = o();
  }), $e(() => {
    g.getDrawingBufferSize(y.uniforms.size.value);
  }), pt(s, sn({ is: _ }, () => m, {
    get ref() {
      return f();
    },
    set ref(E) {
      f(E);
    },
    children: (E, C) => {
      var P = aq(), T = dt(P);
      pt(T, {
        get is() {
          return pe(A);
        },
        children: (D, U) => {
          var L = oq(), k = dt(L);
          pt(k, {
            get is() {
              return pe(M);
            }
          });
          var B = Wn(k, 2);
          pt(B, { is: y }), ut(D, L);
        },
        $$slots: { default: !0 }
      });
      var I = Wn(T, 2);
      Wt(I, () => d() ?? Bt, () => ({ ref: _ })), ut(E, P);
    },
    $$slots: { default: !0 }
  })), Pt({
    get color() {
      return t();
    },
    set color(E = "black") {
      t(E), V();
    },
    get screenspace() {
      return i();
    },
    set screenspace(E = !1) {
      i(E), V();
    },
    get opacity() {
      return n();
    },
    set opacity(E = 1) {
      n(E), V();
    },
    get transparent() {
      return r();
    },
    set transparent(E = !1) {
      r(E), V();
    },
    get thickness() {
      return o();
    },
    set thickness(E = 0.05) {
      o(E), V();
    },
    get toneMapped() {
      return a();
    },
    set toneMapped(E = !0) {
      a(E), V();
    },
    get angle() {
      return l();
    },
    set angle(E = Math.PI) {
      l(E), V();
    },
    get polygonOffset() {
      return c();
    },
    set polygonOffset(E = !1) {
      c(E), V();
    },
    get polygonOffsetFactor() {
      return u();
    },
    set polygonOffsetFactor(E = 0) {
      u(E), V();
    },
    get renderOrder() {
      return h();
    },
    set renderOrder(E = 0) {
      h(E), V();
    },
    get children() {
      return d();
    },
    set children(E) {
      d(E), V();
    },
    get ref() {
      return f();
    },
    set ref(E) {
      f(E), V();
    },
    $set: Lt,
    $on: (E, C) => It(e, E, C)
  });
}
Ut(
  v3,
  {
    color: {},
    screenspace: {},
    opacity: {},
    transparent: {},
    thickness: {},
    toneMapped: {},
    angle: {},
    polygonOffset: {},
    polygonOffsetFactor: {},
    renderOrder: {},
    children: {},
    ref: {}
  },
  [],
  [],
  !0
);
function _3(s, e) {
  if (new.target) return Rt({ component: _3, ...s });
  Ct(e, !0);
  let t = G(e, "id", 7, 1), i = G(e, "colorWrite", 7, !1), n = G(e, "depthWrite", 7, !1), r = G(e, "ref", 15), o = G(e, "children", 7), a = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "colorWrite",
    "depthWrite",
    "ref",
    "children"
  ]);
  const l = new it();
  Ht(() => {
    const { material: u } = l;
    Array.isArray(u) || (u.colorWrite = i(), u.depthWrite = n(), u.stencilWrite = !0, u.stencilRef = t(), u.stencilFunc = j0, u.stencilFail = Ov, u.stencilZFail = Ov, u.stencilZPass = Ov);
  });
  const c = /* @__PURE__ */ wt(() => -t());
  return pt(s, sn(
    {
      is: l,
      get renderOrder() {
        return pe(c);
      }
    },
    () => a,
    {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      },
      children: (u, h) => {
        var d = At(), f = dt(d);
        Wt(f, () => o() ?? Bt, () => ({ ref: l })), ut(u, d);
      },
      $$slots: { default: !0 }
    }
  )), Pt({
    get id() {
      return t();
    },
    set id(u = 1) {
      t(u), V();
    },
    get colorWrite() {
      return i();
    },
    set colorWrite(u = !1) {
      i(u), V();
    },
    get depthWrite() {
      return n();
    },
    set depthWrite(u = !1) {
      n(u), V();
    },
    get ref() {
      return r();
    },
    set ref(u) {
      r(u), V();
    },
    get children() {
      return o();
    },
    set children(u) {
      o(u), V();
    },
    $set: Lt,
    $on: (u, h) => It(e, u, h)
  });
}
Ut(
  _3,
  {
    id: {},
    colorWrite: {},
    depthWrite: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
function y3(s, e) {
  if (new.target) return Rt({ component: y3, ...s });
  Ct(e, !0);
  const t = rm(Vl().suspended), { renderer: i } = cn();
  return Ht(() => (t.current || (i.shadowMap.autoUpdate = !1, i.shadowMap.needsUpdate = !0), () => {
    i.shadowMap.autoUpdate = !0, i.shadowMap.needsUpdate = !0;
  })), Pt({
    $set: Lt,
    $on: (n, r) => It(e, n, r)
  });
}
Ut(y3, {}, [], [], !0);
function x3(s, e) {
  if (new.target) return Rt({ component: x3, ...s });
  Ct(e, !0);
  let t = G(e, "ref", 15), i = G(e, "children", 7), n = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "children"
  ]);
  const r = new nS();
  return kS("detailed", (o) => {
    if (To().current !== r) return;
    let l, c = o.props.distance, u = o.props.hysteresis;
    const h = /* @__PURE__ */ wt(() => bn(o.ref, "Object3D") ? o.ref : void 0), d = /* @__PURE__ */ wt(() => o.props.distance ?? 0), f = /* @__PURE__ */ wt(() => o.props.hysteresis ?? 0), m = (_, y, w) => {
      r.addLevel(_, y, w);
    }, g = (_) => {
      const y = r.levels.findIndex((w) => w.object === _);
      y > -1 && r.levels.splice(y, 1);
    }, v = (_, y, w) => {
      io(() => {
        const x = r.levels.find((M) => M.object === _);
        x && (x.distance = y, x.hysteresis = w);
      });
    };
    return zs.pre(
      () => [
        pe(h),
        pe(d),
        pe(f)
      ],
      ([_, y, w]) => {
        _ !== l && (l && g(l), _ && m(_, y, w), l = _), _ && (y !== c || w !== u) && (v(_, y, w), c = y, u = w);
      }
    ), Ki(() => {
      pe(h) && g(pe(h));
    }), { pluginProps: ["distance", "hysteresis"] };
  }), pt(s, sn({ is: r }, () => n, {
    get ref() {
      return t();
    },
    set ref(o) {
      t(o);
    },
    children: (o, a) => {
      var l = At(), c = dt(l);
      Wt(c, () => i() ?? Bt, () => ({ ref: r })), ut(o, l);
    },
    $$slots: { default: !0 }
  })), Pt({
    get ref() {
      return t();
    },
    set ref(o) {
      t(o), V();
    },
    get children() {
      return i();
    },
    set children(o) {
      i(o), V();
    },
    $set: Lt,
    $on: (o, a) => It(e, o, a)
  });
}
Ut(x3, { ref: {}, children: {} }, [], [], !0);
const lq = `void main() {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	discard;
}
`, cq = "void main() {}";
function b3(s, e) {
  if (new.target) return Rt({ component: b3, ...s });
  Ct(e, !0);
  let t = G(e, "children", 7), i = G(e, "ref", 15), n = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "ref"
  ]);
  var r = At(), o = dt(r);
  return Rs(o, () => pt.ShaderMaterial, (a, l) => {
    l(a, sn({ fragmentShader: lq, vertexShader: cq }, () => n, {
      get ref() {
        return i();
      },
      set ref(c) {
        i(c);
      },
      children: (c, u) => {
        var h = At(), d = dt(h);
        Wt(d, () => t() ?? Bt, i), ut(c, h);
      },
      $$slots: { default: !0 }
    }));
  }), ut(s, r), Pt({
    get children() {
      return t();
    },
    set children(a) {
      t(a), V();
    },
    get ref() {
      return i();
    },
    set ref(a) {
      i(a), V();
    },
    $set: Lt,
    $on: (a, l) => It(e, a, l)
  });
}
Ut(b3, { children: {}, ref: {} }, [], [], !0);
const lC = new yn();
function w3(s, e) {
  if (new.target) return Rt({ component: w3, ...s });
  Ct(e, !0);
  const { renderStage: t } = cn();
  let i = G(e, "axis", 7), n = G(e, "auto", 7, !1), r = G(e, "box", 7, lC), o = G(e, "precise", 7), a = G(e, "onresize", 7), l = G(e, "stage", 23, () => wu("<Resize>", { before: t })), c = G(e, "ref", 15), u = G(e, "children", 7), h = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "axis",
    "auto",
    "box",
    "precise",
    "onresize",
    "stage",
    "ref",
    "children"
  ]);
  c(new Zn());
  const d = new Zn(), f = new Zn(), m = () => {
    var P;
    f.matrixWorld.identity();
    const { max: w, min: x } = r().setFromObject(d, o()), M = w.x - x.x, A = w.y - x.y, E = w.z - x.z, C = i() === "x" ? M : i() === "y" ? A : i() === "z" ? E : Math.max(M, A, E);
    f.scale.setScalar(1 / C), (P = a()) == null || P();
  }, { start: g, stop: v } = ti(
    () => {
      m(), v();
    },
    { autoStart: !1, stage: l() }
  ), _ = g;
  zs(() => [i(), o()], g);
  const y = (w) => {
    bn(w.ref, "Object3D") && zs.pre(() => [w.ref], () => (n() && g(), () => {
      n() && g();
    }));
  };
  return pt(s, sn(
    {
      get is() {
        return c();
      }
    },
    () => h,
    {
      children: (w, x) => {
        pt(w, {
          is: f,
          children: (M, A) => {
            pt(M, {
              is: d,
              children: (E, C) => {
                sy(E, {
                  name: "resize",
                  plugin: y,
                  children: (P, T) => {
                    var I = At(), D = dt(I);
                    Wt(D, () => u() ?? Bt, () => ({ ref: c(), resize: g })), ut(P, I);
                  },
                  $$slots: { default: !0 }
                });
              },
              $$slots: { default: !0 }
            });
          },
          $$slots: { default: !0 }
        });
      },
      $$slots: { default: !0 }
    }
  )), Pt({
    resize: _,
    get axis() {
      return i();
    },
    set axis(w) {
      i(w), V();
    },
    get auto() {
      return n();
    },
    set auto(w = !1) {
      n(w), V();
    },
    get box() {
      return r();
    },
    set box(w = lC) {
      r(w), V();
    },
    get precise() {
      return o();
    },
    set precise(w) {
      o(w), V();
    },
    get onresize() {
      return a();
    },
    set onresize(w) {
      a(w), V();
    },
    get stage() {
      return l();
    },
    set stage(w = wu("<Resize>", { before: t })) {
      l(w), V();
    },
    get ref() {
      return c();
    },
    set ref(w) {
      c(w), V();
    },
    get children() {
      return u();
    },
    set children(w) {
      u(w), V();
    },
    $set: Lt,
    $on: (w, x) => It(e, w, x)
  });
}
Ut(
  w3,
  {
    axis: {},
    auto: {},
    box: {},
    precise: {},
    onresize: {},
    stage: {},
    ref: {},
    children: {}
  },
  [],
  ["resize"],
  !0
);
var uq = /* @__PURE__ */ ni("<!> <!>", 1);
function S3(s, e) {
  if (new.target) return Rt({ component: S3, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(T, "$started", t);
  let r = G(e, "background", 7, "auto"), o = G(e, "far", 7, 1e3), a = G(e, "fog", 7, "auto"), l = G(e, "frames", 7, 1 / 0), c = G(e, "near", 7, 0.1), u = G(e, "onupdatestart", 7), h = G(e, "onupdatestop", 7), d = G(e, "resolution", 7, 256), f = G(e, "children", 7), m = G(e, "ref", 15), g = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "background",
    "far",
    "fog",
    "frames",
    "near",
    "onupdatestart",
    "onupdatestop",
    "resolution",
    "children",
    "ref"
  ]);
  const { camera: v, renderTarget: _ } = RL(() => c(), () => o(), () => d()), { renderer: y, scene: w } = cn(), x = new Zn(), M = new Zn();
  let A = 0;
  const E = () => {
    var U;
    if (A < l()) {
      M.visible = !1;
      const L = w.fog, k = w.background;
      w.background = r() === "auto" ? k : r(), w.fog = a() === "auto" ? L : a(), v.update(y, w), w.background = k, w.fog = L, M.visible = !0, A += 1;
    } else
      P(), (U = h()) == null || U();
  }, { start: C, stop: P, started: T } = ti(E, { autoStart: !1 }), I = () => {
    var U, L;
    n() && (P(), (U = h()) == null || U()), A = 0, C(), (L = u()) == null || L();
  };
  zs(
    () => [
      r(),
      o(),
      c(),
      a(),
      l(),
      d()
    ],
    I
  ), pt(s, sn({ is: x }, () => g, {
    get ref() {
      return m();
    },
    set ref(U) {
      m(U);
    },
    children: (U, L) => {
      var k = uq(), B = dt(k);
      pt(B, { is: v });
      var j = Wn(B, 2);
      pt(j, {
        is: M,
        children: (q, Z) => {
          var N = At(), z = dt(N);
          Wt(z, () => f() ?? Bt, () => ({
            camera: v,
            ref: x,
            renderTarget: _,
            restart: I,
            update: E
          })), ut(q, N);
        },
        $$slots: { default: !0 }
      }), ut(U, k);
    },
    $$slots: { default: !0 }
  }));
  var D = Pt({
    camera: v,
    renderTarget: _,
    update: E,
    restart: I,
    get background() {
      return r();
    },
    set background(U = "auto") {
      r(U), V();
    },
    get far() {
      return o();
    },
    set far(U = 1e3) {
      o(U), V();
    },
    get fog() {
      return a();
    },
    set fog(U = "auto") {
      a(U), V();
    },
    get frames() {
      return l();
    },
    set frames(U = 1 / 0) {
      l(U), V();
    },
    get near() {
      return c();
    },
    set near(U = 0.1) {
      c(U), V();
    },
    get onupdatestart() {
      return u();
    },
    set onupdatestart(U) {
      u(U), V();
    },
    get onupdatestop() {
      return h();
    },
    set onupdatestop(U) {
      h(U), V();
    },
    get resolution() {
      return d();
    },
    set resolution(U = 256) {
      d(U), V();
    },
    get children() {
      return f();
    },
    set children(U) {
      f(U), V();
    },
    get ref() {
      return m();
    },
    set ref(U) {
      m(U), V();
    },
    $set: Lt,
    $on: (U, L) => It(e, U, L)
  });
  return i(), D;
}
Ut(
  S3,
  {
    background: {},
    far: {},
    fog: {},
    frames: {},
    near: {},
    onupdatestart: {},
    onupdatestop: {},
    resolution: {},
    children: {},
    ref: {}
  },
  [],
  [
    "camera",
    "renderTarget",
    "update",
    "restart"
  ],
  !0
);
const M3 = (s, e) => {
  s.save();
  let t = s.fillStyle;
  s.fillStyle = e, s.fillRect(0, 0, s.canvas.width, s.canvas.height), s.fillStyle = t, s.restore();
}, hq = new rt(), E3 = (s, e = []) => {
  for (const t of e)
    s.addColorStop(t.offset, hq.set(t.color).getStyle());
  return s;
};
function T3(s, e) {
  if (new.target) return Rt({ component: T3, ...s });
  Ct(e, !0);
  let t = G(e, "width", 7, 1024), i = G(e, "height", 7, 1024), n = G(e, "startX", 7, 0), r = G(e, "startY", 7, 0), o = G(e, "endX", 7, 0), a = G(e, "endY", 23, i), l = G(e, "stops", 23, () => [
    { offset: 0, color: "black" },
    { offset: 1, color: "white" }
  ]), c = G(e, "attach", 7, "map"), u = G(e, "children", 7), h = G(e, "ref", 15), d = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "width",
    "height",
    "startX",
    "startY",
    "endX",
    "endY",
    "stops",
    "attach",
    "children",
    "ref"
  ]);
  const f = new OffscreenCanvas(0, 0), m = f.getContext("2d"), g = new U_(f);
  $e(() => {
    f.width = t();
  }), $e(() => {
    f.height = i();
  }), zs(() => [e.wrapS, e.wrapT], () => {
    g.needsUpdate = !0, _();
  });
  const v = /* @__PURE__ */ wt(() => {
    const y = m == null ? void 0 : m.createLinearGradient(n(), r(), o(), a());
    return y !== void 0 && E3(y, l()), y;
  }), { invalidate: _ } = cn();
  return Ht(() => {
    pe(v) !== void 0 && m !== null && (M3(m, pe(v)), g.needsUpdate = !0, _());
  }), pt(s, sn(
    {
      is: g,
      get attach() {
        return c();
      }
    },
    () => d,
    {
      get ref() {
        return h();
      },
      set ref(y) {
        h(y);
      },
      children: (y, w) => {
        var x = At(), M = dt(x);
        Wt(M, () => u() ?? Bt, () => ({ ref: g })), ut(y, x);
      },
      $$slots: { default: !0 }
    }
  )), Pt({
    get width() {
      return t();
    },
    set width(y = 1024) {
      t(y), V();
    },
    get height() {
      return i();
    },
    set height(y = 1024) {
      i(y), V();
    },
    get startX() {
      return n();
    },
    set startX(y = 0) {
      n(y), V();
    },
    get startY() {
      return r();
    },
    set startY(y = 0) {
      r(y), V();
    },
    get endX() {
      return o();
    },
    set endX(y = 0) {
      o(y), V();
    },
    get endY() {
      return a();
    },
    set endY(y = i) {
      a(y), V();
    },
    get stops() {
      return l();
    },
    set stops(y = [
      { offset: 0, color: "black" },
      { offset: 1, color: "white" }
    ]) {
      l(y), V();
    },
    get attach() {
      return c();
    },
    set attach(y = "map") {
      c(y), V();
    },
    get children() {
      return u();
    },
    set children(y) {
      u(y), V();
    },
    get ref() {
      return h();
    },
    set ref(y) {
      h(y), V();
    },
    $set: Lt,
    $on: (y, w) => It(e, y, w)
  });
}
Ut(
  T3,
  {
    width: {},
    height: {},
    startX: {},
    startY: {},
    endX: {},
    endY: {},
    stops: {},
    attach: {},
    children: {},
    ref: {}
  },
  [],
  [],
  !0
);
function A3(s, e) {
  if (new.target) return Rt({ component: A3, ...s });
  Ct(e, !0);
  let t = G(e, "width", 7, 1024), i = G(e, "height", 7, 1024), n = G(e, "innerRadius", 7, 0), r = G(e, "outerRadius", 7, "auto"), o = G(e, "stops", 23, () => [
    { offset: 0, color: "black" },
    { offset: 1, color: "white" }
  ]), a = G(e, "attach", 7, "map"), l = G(e, "children", 7), c = G(e, "ref", 15), u = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "width",
    "height",
    "innerRadius",
    "outerRadius",
    "stops",
    "attach",
    "children",
    "ref"
  ]);
  const h = new OffscreenCanvas(0, 0), d = h.getContext("2d"), f = new U_(h);
  $e(() => {
    h.width = t();
  }), $e(() => {
    h.height = i();
  }), zs(() => [e.wrapS, e.wrapT], () => {
    f.needsUpdate = !0, _();
  });
  let m = /* @__PURE__ */ wt(() => 0.5 * t()), g = /* @__PURE__ */ wt(() => 0.5 * i());
  const v = /* @__PURE__ */ wt(() => {
    const y = d == null ? void 0 : d.createRadialGradient(pe(m), pe(g), n(), pe(m), pe(g), r() === "auto" ? Math.hypot(pe(m), pe(g)) : r());
    return y !== void 0 && E3(y, o()), y;
  }), { invalidate: _ } = cn();
  return Ht(() => {
    pe(v) !== void 0 && d !== null && (M3(d, pe(v)), f.needsUpdate = !0, _());
  }), pt(s, sn({ is: f }, () => u, {
    get attach() {
      return a();
    },
    get ref() {
      return c();
    },
    set ref(y) {
      c(y);
    },
    children: (y, w) => {
      var x = At(), M = dt(x);
      Wt(M, () => l() ?? Bt, () => ({ ref: f })), ut(y, x);
    },
    $$slots: { default: !0 }
  })), Pt({
    get width() {
      return t();
    },
    set width(y = 1024) {
      t(y), V();
    },
    get height() {
      return i();
    },
    set height(y = 1024) {
      i(y), V();
    },
    get innerRadius() {
      return n();
    },
    set innerRadius(y = 0) {
      n(y), V();
    },
    get outerRadius() {
      return r();
    },
    set outerRadius(y = "auto") {
      r(y), V();
    },
    get stops() {
      return o();
    },
    set stops(y = [
      { offset: 0, color: "black" },
      { offset: 1, color: "white" }
    ]) {
      o(y), V();
    },
    get attach() {
      return a();
    },
    set attach(y = "map") {
      a(y), V();
    },
    get children() {
      return l();
    },
    set children(y) {
      l(y), V();
    },
    get ref() {
      return c();
    },
    set ref(y) {
      c(y), V();
    },
    $set: Lt,
    $on: (y, w) => It(e, y, w)
  });
}
Ut(
  A3,
  {
    width: {},
    height: {},
    innerRadius: {},
    outerRadius: {},
    stops: {},
    attach: {},
    children: {},
    ref: {}
  },
  [],
  [],
  !0
);
var Jp;
class dq {
  constructor(e) {
    Lm(this, Jp, Us(!1));
    zs(() => [e()], ([t]) => {
      const i = new IntersectionObserver((n) => {
        for (const r of n)
          this.isOffscreen = !r.isIntersecting;
      });
      return i.observe(t), () => {
        i.disconnect();
      };
    });
  }
  get isOffscreen() {
    return pe(Sr(this, Jp));
  }
  set isOffscreen(e) {
    In(Sr(this, Jp), pr(e));
  }
}
Jp = new WeakMap();
function sM(s, e) {
  if (new.target) return Rt({ component: sM, ...s });
  Ct(e, !0);
  let t = G(e, "dom", 7), i = G(e, "children", 7);
  const n = new dq(() => t()), r = cn();
  XI({ dom: t(), canvas: r.canvas }), GI();
  const { scene: o } = ey();
  IS(o), ZI(o);
  const { camera: a } = DS();
  JI();
  const { renderer: l, renderStage: c, canvas: u } = cn(), h = new Kt(), d = new Kt();
  let f;
  const { start: m, stop: g } = ti(
    Symbol("<View>"),
    () => {
      if (n.isOffscreen) return;
      const {
        left: y,
        bottom: w,
        width: x,
        height: M
      } = t().getBoundingClientRect(), { bottom: A, left: E } = u.getBoundingClientRect(), C = A - w, P = y - E;
      l.getScissor(d), l.getViewport(h), f = l.getScissorTest(), l.setViewport(P, C, x, M), l.setScissor(P, C, x, M), l.setScissorTest(!0), l.render(o, a.current), l.setViewport(h), l.setScissor(d), l.setScissorTest(f);
    },
    { stage: c, autoStart: !1 }
  );
  Ht(() => {
    n.isOffscreen ? g() : m();
  });
  var v = At(), _ = dt(v);
  return Wt(_, () => i() ?? Bt), ut(s, v), Pt({
    get dom() {
      return t();
    },
    set dom(y) {
      t(y), V();
    },
    get children() {
      return i();
    },
    set children(y) {
      i(y), V();
    },
    $set: Lt,
    $on: (y, w) => It(e, y, w)
  });
}
Ut(sM, { dom: {}, children: {} }, [], [], !0);
function C3(s, e) {
  if (new.target) return Rt({ component: C3, ...s });
  Ct(e, !0);
  let t = G(e, "dom", 7), i = G(e, "children", 7);
  var n = At(), r = dt(n);
  {
    var o = (a) => {
      sM(a, {
        get dom() {
          return t();
        },
        children: (l, c) => {
          var u = At(), h = dt(u);
          Wt(h, () => i() ?? Bt), ut(l, u);
        },
        $$slots: { default: !0 }
      });
    };
    Ai(r, (a) => {
      t() && a(o);
    });
  }
  return ut(s, n), Pt({
    get dom() {
      return t();
    },
    set dom(a) {
      t(a), V();
    },
    get children() {
      return i();
    },
    set children(a) {
      i(a), V();
    },
    $set: Lt,
    $on: (a, l) => It(e, a, l)
  });
}
Ut(C3, { dom: {}, children: {} }, [], [], !0);
class fq {
  constructor(e, t = " .:-=+*#%@", i = {}) {
    const n = i.resolution || 0.15, r = i.scale || 1, o = i.color || !1, a = i.alpha || !1, l = i.block || !1, c = i.invert || !1, u = i.strResolution || "low";
    let h, d;
    const f = document.createElement("div");
    f.style.cursor = "default";
    const m = document.createElement("table");
    f.appendChild(m);
    let g, v, _;
    this.setSize = function(L, k) {
      h = L, d = k, e.setSize(L, k), y();
    }, this.render = function(L, k) {
      e.render(L, k), U(m);
    }, this.domElement = f;
    function y() {
      g = Math.floor(h * n), v = Math.floor(d * n), E.width = g, E.height = v, _ = e.domElement, _.style.backgroundColor && (m.rows[0].cells[0].style.backgroundColor = _.style.backgroundColor, m.rows[0].cells[0].style.color = _.style.color), m.cellSpacing = 0, m.cellPadding = 0;
      const L = m.style;
      L.whiteSpace = "pre", L.margin = "0px", L.padding = "0px", L.letterSpacing = D + "px", L.fontFamily = M, L.fontSize = T + "px", L.lineHeight = I + "px", L.textAlign = "left", L.textDecoration = "none";
    }
    const w = " .,:;i1tfLCG08@".split(""), x = " CGO08@".split(""), M = "courier new, monospace", A = e.domElement, E = document.createElement("canvas");
    if (!E.getContext)
      return;
    const C = E.getContext("2d");
    if (!C.getImageData)
      return;
    let P = o ? x : w;
    t && (P = t);
    const T = 2 / n * r, I = 2 / n * r;
    let D = 0;
    if (u == "low")
      switch (r) {
        case 1:
          D = -1;
          break;
        case 2:
        case 3:
          D = -2.1;
          break;
        case 4:
          D = -3.1;
          break;
        case 5:
          D = -4.15;
          break;
      }
    if (u == "medium")
      switch (r) {
        case 1:
          D = 0;
          break;
        case 2:
          D = -1;
          break;
        case 3:
          D = -1.04;
          break;
        case 4:
        case 5:
          D = -2.1;
          break;
      }
    if (u == "high")
      switch (r) {
        case 1:
        case 2:
          D = 0;
          break;
        case 3:
        case 4:
        case 5:
          D = -1;
          break;
      }
    function U(L) {
      C.clearRect(0, 0, g, v), C.drawImage(A, 0, 0, g, v);
      const k = C.getImageData(0, 0, g, v).data;
      let B = "";
      for (let j = 0; j < v; j += 2) {
        for (let q = 0; q < g; q++) {
          const Z = (j * g + q) * 4, N = k[Z], z = k[Z + 1], J = k[Z + 2], se = k[Z + 3];
          let K, Q;
          Q = (0.3 * N + 0.59 * z + 0.11 * J) / 255, se == 0 && (Q = 1), K = Math.floor((1 - Q) * (P.length - 1)), c && (K = P.length - K - 1);
          let de = P[K];
          (de === void 0 || de == " ") && (de = "&nbsp;"), o ? B += "<span style='color:rgb(" + N + "," + z + "," + J + ");" + (l ? "background-color:rgb(" + N + "," + z + "," + J + ");" : "") + (a ? "opacity:" + se / 255 + ";" : "") + "'>" + de + "</span>" : B += de;
        }
        B += "<br/>";
      }
      L.innerHTML = `<tr><td style="display:block;width:${h}px;height:${d}px;overflow:hidden">${B}</td></tr>`;
    }
  }
}
function P3(s, e) {
  if (new.target) return Rt({ component: P3, ...s });
  Ct(e, !0);
  const t = " .:-+*=%@#";
  let i = G(e, "autoRender", 7, !0), n = G(e, "bgColor", 7, "#000000"), r = G(e, "camera", 7), o = G(e, "characters", 7, t), a = G(e, "fgColor", 7, "#ffffff"), l = G(e, "onstart", 7), c = G(e, "onstop", 7), u = G(e, "options", 23, () => ({})), h = G(e, "scene", 7), d = G(e, "children", 7);
  const {
    autoRender: f,
    camera: m,
    renderStage: g,
    renderer: v,
    canvas: _,
    dom: y,
    scene: w,
    size: x
  } = cn(), M = /* @__PURE__ */ wt(() => o() || t), A = /* @__PURE__ */ wt(() => {
    const k = new fq(v, pe(M), u());
    return k.domElement.style.position = "absolute", k.domElement.style.top = "0px", k.domElement.style.left = "0px", k.domElement.style.pointerEvents = "none", k;
  }), E = () => pe(A), C = rm(x);
  $e(() => {
    pe(A).setSize(C.current.width, C.current.height);
  }), $e(() => {
    pe(A).domElement.style.color = a();
  }), $e(() => {
    pe(A).domElement.style.backgroundColor = n();
  }), Ht(() => {
    _.style.opacity = "0";
    const k = pe(A).domElement;
    return y.appendChild(k), () => {
      _.style.opacity = "1", y.removeChild(k);
    };
  });
  const { start: P, stop: T } = ti(
    () => {
      pe(A).render(h() ?? w, r() ?? m.current);
    },
    {
      autoInvalidate: !1,
      autoStart: !1,
      stage: g
    }
  ), I = () => {
    var k;
    P(), (k = l()) == null || k();
  }, D = () => {
    var k;
    T(), (k = c()) == null || k();
  };
  Ht(() => {
    if (i())
      return I(), () => {
        D();
      };
  }), Ht(() => {
    const k = f.current;
    return f.set(!i()), () => {
      f.set(k);
    };
  });
  var U = At(), L = dt(U);
  return Wt(L, () => d() ?? Bt, () => ({ asciiEffect: pe(A) })), ut(s, U), Pt({
    getEffect: E,
    start: I,
    stop: D,
    get autoRender() {
      return i();
    },
    set autoRender(k = !0) {
      i(k), V();
    },
    get bgColor() {
      return n();
    },
    set bgColor(k = "#000000") {
      n(k), V();
    },
    get camera() {
      return r();
    },
    set camera(k) {
      r(k), V();
    },
    get characters() {
      return o();
    },
    set characters(k = t) {
      o(k), V();
    },
    get fgColor() {
      return a();
    },
    set fgColor(k = "#ffffff") {
      a(k), V();
    },
    get onstart() {
      return l();
    },
    set onstart(k) {
      l(k), V();
    },
    get onstop() {
      return c();
    },
    set onstop(k) {
      c(k), V();
    },
    get options() {
      return u();
    },
    set options(k = {}) {
      u(k), V();
    },
    get scene() {
      return h();
    },
    set scene(k) {
      h(k), V();
    },
    get children() {
      return d();
    },
    set children(k) {
      d(k), V();
    },
    $set: Lt,
    $on: (k, B) => It(e, k, B)
  });
}
Ut(
  P3,
  {
    autoRender: {},
    bgColor: {},
    camera: {},
    characters: {},
    fgColor: {},
    onstart: {},
    onstop: {},
    options: {},
    scene: {},
    children: {}
  },
  [],
  ["getEffect", "start", "stop"],
  !0
);
typeof window < "u" && document.createElement("div");
var pq = /* @__PURE__ */ ni("<!> <!>", 1);
function R3(s, e) {
  if (new.target) return Rt({ component: R3, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(f, "$suspended", t), r = () => Bn(m, "$errors", t);
  let o = G(e, "final", 7, !1), a = G(e, "onload", 7), l = G(e, "onsuspend", 7), c = G(e, "onerror", 7), u = G(e, "error", 7), h = G(e, "fallback", 7), d = G(e, "children", 7);
  const { suspended: f, errors: m, setFinal: g } = M7({ final: o() });
  Ht(() => g(o())), Ht(() => {
    var C;
    n() || (C = a()) == null || C();
  }), Ht(() => {
    var C;
    n() && ((C = l()) == null || C());
  }), Ht(() => {
    var C;
    r().length > 0 && ((C = c()) == null || C(r()));
  });
  const v = new Zn(), _ = KI();
  ui([_, f, m], ([C, P, T]) => {
    if (C) {
      if (P || T.length) {
        C.remove(v);
        return;
      }
      return C.add(v), () => {
        C.remove(v);
      };
    }
  });
  var y = pq(), w = dt(y);
  pt(w, {
    is: v,
    attach: !1,
    children: (C, P) => {
      var T = At(), I = dt(T);
      Wt(I, () => d() ?? Bt, () => ({
        suspended: n(),
        errors: r()
      })), ut(C, T);
    },
    $$slots: { default: !0 }
  });
  var x = Wn(w, 2);
  {
    var M = (C) => {
      var P = At(), T = dt(P);
      Wt(T, () => u() ?? Bt, () => ({ errors: r() })), ut(C, P);
    }, A = (C) => {
      var P = At(), T = dt(P);
      {
        var I = (D) => {
          var U = At(), L = dt(U);
          Wt(L, () => h() ?? Bt), ut(D, U);
        };
        Ai(
          T,
          (D) => {
            n() && D(I);
          },
          !0
        );
      }
      ut(C, P);
    };
    Ai(x, (C) => {
      r().length ? C(M) : C(A, !1);
    });
  }
  ut(s, y);
  var E = Pt({
    get final() {
      return o();
    },
    set final(C = !1) {
      o(C), V();
    },
    get onload() {
      return a();
    },
    set onload(C) {
      a(C), V();
    },
    get onsuspend() {
      return l();
    },
    set onsuspend(C) {
      l(C), V();
    },
    get onerror() {
      return c();
    },
    set onerror(C) {
      c(C), V();
    },
    get error() {
      return u();
    },
    set error(C) {
      u(C), V();
    },
    get fallback() {
      return h();
    },
    set fallback(C) {
      h(C), V();
    },
    get children() {
      return d();
    },
    set children(C) {
      d(C), V();
    },
    $set: Lt,
    $on: (C, P) => It(e, C, P)
  });
  return i(), E;
}
Ut(
  R3,
  {
    final: {},
    onload: {},
    onsuspend: {},
    onerror: {},
    error: {},
    fallback: {},
    children: {}
  },
  [],
  [],
  !0
);
const mq = () => {
  const s = {
    portals: Xn(/* @__PURE__ */ new Map()),
    addPortal(e, t) {
      s.portals.update((i) => (i.has(t) ? console.warn(`Portal with id ${t} already exists. Skipping portal creation.`) : i.set(t, e), i));
    },
    removePortal(e) {
      s.portals.update((t) => (t.has(e) ? t.delete(e) : console.warn(`Portal with id ${e} does not exist. Skipping portal removal.`), t));
    },
    getPortal(e) {
      return Cl(s.portals, (t) => t.get(e));
    },
    hasPortal(e) {
      return s.portals.current.has(e);
    }
  };
  return s;
}, D3 = () => OS("threlte-portals", mq());
function I3(s, e) {
  if (new.target) return Rt({ component: I3, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(pe(d), "$portal", t), r = () => Bn(h, "$target", t);
  let o = G(e, "id", 7, "default"), a = G(e, "object", 7), l = G(e, "children", 7);
  const { getPortal: c } = D3(), u = Gn([]), h = Gn();
  let d = /* @__PURE__ */ wt(() => c(o()));
  $e(() => h.set(a() ?? n())), ui([u, h], ([y, w]) => {
    if (w !== void 0) {
      for (const x of y)
        w.children.includes(x) || w.add(x);
      return () => {
        for (const x of y)
          w.children.includes(x) && w.remove(x);
      };
    }
  });
  const f = new tn();
  f.add = (y) => (u.update((w) => (w.push(y), w)), y), f.remove = (y) => (u.update((w) => (w.splice(w.indexOf(y), 1), w)), y);
  var m = At(), g = dt(m);
  {
    var v = (y) => {
      pt(y, {
        is: f,
        attach: !1,
        children: (w, x) => {
          var M = At(), A = dt(M);
          Wt(A, () => l() ?? Bt), ut(w, M);
        },
        $$slots: { default: !0 }
      });
    };
    Ai(g, (y) => {
      r() && y(v);
    });
  }
  ut(s, m);
  var _ = Pt({
    get id() {
      return o();
    },
    set id(y = "default") {
      o(y), V();
    },
    get object() {
      return a();
    },
    set object(y) {
      a(y), V();
    },
    get children() {
      return l();
    },
    set children(y) {
      l(y), V();
    },
    $set: Lt,
    $on: (y, w) => It(e, y, w)
  });
  return i(), _;
}
Ut(I3, { id: {}, object: {}, children: {} }, [], [], !0);
function L3(s, e) {
  if (new.target) return Rt({ component: L3, ...s });
  Ct(e, !0);
  const [t, i] = $i(), n = () => Bn(o, "$parent", t);
  let r = G(e, "id", 7, "default");
  const o = To();
  if (!n())
    throw new Error("<PortalTarget> must be used within a <Canvas> component.");
  const { addPortal: a, removePortal: l } = D3();
  ui(o, (u) => {
    if (!(!u || !bn(u, "Object3D")))
      return a(u, r()), () => {
        l(r());
      };
  });
  var c = Pt({
    get id() {
      return r();
    },
    set id(u = "default") {
      r(u), V();
    },
    $set: Lt,
    $on: (u, h) => It(e, u, h)
  });
  return i(), c;
}
Ut(L3, { id: {} }, [], [], !0);
function gq() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(n, r) {
    var o = n.id, a = n.name, l = n.dependencies;
    l === void 0 && (l = []);
    var c = n.init;
    c === void 0 && (c = function() {
    });
    var u = n.getTransferables;
    if (u === void 0 && (u = null), !s[o])
      try {
        l = l.map(function(d) {
          return d && d.isWorkerModule && (e(d, function(f) {
            if (f instanceof Error)
              throw f;
          }), d = s[d.id].value), d;
        }), c = i("<" + a + ">.init", c), u && (u = i("<" + a + ">.getTransferables", u));
        var h = null;
        typeof c == "function" ? h = c.apply(void 0, l) : console.error("worker module init function failed to rehydrate"), s[o] = {
          id: o,
          value: h,
          getTransferables: u
        }, r(h);
      } catch (d) {
        d && d.noLog || console.error(d), r(d);
      }
  }
  function t(n, r) {
    var o, a = n.id, l = n.args;
    (!s[a] || typeof s[a].value != "function") && r(new Error("Worker module " + a + ": not found or its 'init' did not return a function"));
    try {
      var c = (o = s[a]).value.apply(o, l);
      c && typeof c.then == "function" ? c.then(u, function(h) {
        return r(h instanceof Error ? h : new Error("" + h));
      }) : u(c);
    } catch (h) {
      r(h);
    }
    function u(h) {
      try {
        var d = s[a].getTransferables && s[a].getTransferables(h);
        (!d || !Array.isArray(d) || !d.length) && (d = void 0), r(h, d);
      } catch (f) {
        console.error(f), r(f);
      }
    }
  }
  function i(n, r) {
    var o = void 0;
    self.troikaDefine = function(l) {
      return o = l;
    };
    var a = URL.createObjectURL(
      new Blob(
        ["/** " + n.replace(/\*/g, "") + ` **/

troikaDefine(
` + r + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(a);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(a), delete self.troikaDefine, o;
  }
  self.addEventListener("message", function(n) {
    var r = n.data, o = r.messageId, a = r.action, l = r.data;
    try {
      a === "registerModule" && e(l, function(c) {
        c instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: { isCallable: typeof c == "function" }
        });
      }), a === "callModule" && t(l, function(c, u) {
        c instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: c
        }, u || void 0);
      });
    } catch (c) {
      postMessage({
        messageId: o,
        success: !1,
        error: c.stack
      });
    }
  });
}
function vq(s) {
  var e = function() {
    for (var t = [], i = arguments.length; i--; ) t[i] = arguments[i];
    return e._getInitResult().then(function(n) {
      if (typeof n == "function")
        return n.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = s.dependencies, i = s.init;
    t = Array.isArray(t) ? t.map(
      function(r) {
        return r && r._getInitResult ? r._getInitResult() : r;
      }
    ) : [];
    var n = Promise.all(t).then(function(r) {
      return i.apply(null, r);
    });
    return e._getInitResult = function() {
      return n;
    }, n;
  }, e;
}
var U3 = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return U3 = function() {
    return s;
  }, s;
}, _q = 0, yq = 0, Tb = !1, xp = /* @__PURE__ */ Object.create(null), bp = /* @__PURE__ */ Object.create(null), j1 = /* @__PURE__ */ Object.create(null);
function Ld(s) {
  if ((!s || typeof s.init != "function") && !Tb)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, t = s.init, i = s.getTransferables, n = s.workerId;
  if (!U3())
    return vq(s);
  n == null && (n = "#default");
  var r = "workerModule" + ++_q, o = s.name || r, a = null;
  e = e && e.map(function(c) {
    return typeof c == "function" && !c.workerModuleData && (Tb = !0, c = Ld({
      workerId: n,
      name: "<" + o + "> function dependency: " + c.name,
      init: `function(){return (
` + Hv(c) + `
)}`
    }), Tb = !1), c && c.workerModuleData && (c = c.workerModuleData), c;
  });
  function l() {
    for (var c = [], u = arguments.length; u--; ) c[u] = arguments[u];
    if (!a) {
      a = cC(n, "registerModule", l.workerModuleData);
      var h = function() {
        a = null, bp[n].delete(h);
      };
      (bp[n] || (bp[n] = /* @__PURE__ */ new Set())).add(h);
    }
    return a.then(function(d) {
      var f = d.isCallable;
      if (f)
        return cC(n, "callModule", { id: r, args: c });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return l.workerModuleData = {
    isWorkerModule: !0,
    id: r,
    name: o,
    dependencies: e,
    init: Hv(t),
    getTransferables: i && Hv(i)
  }, l;
}
function xq(s) {
  bp[s] && bp[s].forEach(function(e) {
    e();
  }), xp[s] && (xp[s].terminate(), delete xp[s]);
}
function Hv(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function bq(s) {
  var e = xp[s];
  if (!e) {
    var t = Hv(gq);
    e = xp[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var n = i.data, r = n.messageId, o = j1[r];
      if (!o)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete j1[r], o(n);
    };
  }
  return e;
}
function cC(s, e, t) {
  return new Promise(function(i, n) {
    var r = ++yq;
    j1[r] = function(o) {
      o.success ? i(o.result) : n(new Error("Error in worker " + e + " call: " + o.error));
    }, bq(s).postMessage({
      messageId: r,
      action: e,
      data: t
    });
  });
}
const k3 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function q1(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(i, n) {
    let r = Ft[n];
    return r ? q1(r) : i;
  }
  return s.replace(e, t);
}
const hr = [];
for (let s = 0; s < 256; s++)
  hr[s] = (s < 16 ? "0" : "") + s.toString(16);
function wq() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (hr[s & 255] + hr[s >> 8 & 255] + hr[s >> 16 & 255] + hr[s >> 24 & 255] + "-" + hr[e & 255] + hr[e >> 8 & 255] + "-" + hr[e >> 16 & 15 | 64] + hr[e >> 24 & 255] + "-" + hr[t & 63 | 128] + hr[t >> 8 & 255] + "-" + hr[t >> 16 & 255] + hr[t >> 24 & 255] + hr[i & 255] + hr[i >> 8 & 255] + hr[i >> 16 & 255] + hr[i >> 24 & 255]).toUpperCase();
}
const xc = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let i = arguments[e];
    if (i)
      for (let n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (s[n] = i[n]);
  }
  return s;
}, Sq = Date.now(), uC = /* @__PURE__ */ new WeakMap(), hC = /* @__PURE__ */ new Map();
let Mq = 1e10;
function Z1(s, e) {
  const t = Cq(e);
  let i = uC.get(s);
  if (i || uC.set(s, i = /* @__PURE__ */ Object.create(null)), i[t])
    return new i[t]();
  const n = `_onBeforeCompile${t}`, r = function(c, u) {
    s.onBeforeCompile.call(this, c, u);
    const h = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
    let d = hC[h];
    if (!d) {
      const f = Eq(this, c, e, t);
      d = hC[h] = f;
    }
    c.vertexShader = d.vertexShader, c.fragmentShader = d.fragmentShader, xc(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - Sq;
      }
    }), this[n] && this[n](c);
  }, o = function() {
    return a(e.chained ? s : s.clone());
  }, a = function(c) {
    const u = Object.create(c, l);
    return Object.defineProperty(u, "baseMaterial", { value: s }), Object.defineProperty(u, "id", { value: Mq++ }), u.uuid = wq(), u.uniforms = xc({}, c.uniforms, e.uniforms), u.defines = xc({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = xc({}, c.extensions, e.extensions), u._listeners = void 0, u;
  }, l = {
    constructor: { value: o },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => s.type,
      set: (c) => {
        s.type = c;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        const u = this.baseMaterial;
        return c === u || u.isDerivedMaterial && u.isDerivedFrom(c) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(c) {
        this[n] = c;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        return s.copy.call(this, c), !s.isShaderMaterial && !s.isDerivedMaterial && (xc(this.extensions, c.extensions), xc(this.defines, c.defines), xc(this.uniforms, Fl.clone(c.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const c = new s.constructor();
        return a(c).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._depthMaterial;
        return c || (c = this._depthMaterial = Z1(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Ru({ depthPacking: Md }),
          e
        ), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._distanceMaterial;
        return c || (c = this._distanceMaterial = Z1(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new Cd(),
          e
        ), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: c, _distanceMaterial: u } = this;
        c && c.dispose(), u && u.dispose(), s.dispose.call(this);
      }
    }
  };
  return i[t] = o, new o();
}
function Eq(s, { vertexShader: e, fragmentShader: t }, i, n) {
  let {
    vertexDefs: r,
    vertexMainIntro: o,
    vertexMainOutro: a,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: m
  } = i;
  if (r = r || "", o = o || "", a = a || "", c = c || "", u = u || "", h = h || "", (l || f) && (e = q1(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = q1(t)), f) {
    let g = f({ vertexShader: e, fragmentShader: t });
    e = g.vertexShader, t = g.fragmentShader;
  }
  if (d) {
    let g = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (v) => (g.push(v), "")
    ), h = `${d}
${g.join(`
`)}
${h}`;
  }
  if (m) {
    const g = `
uniform float ${m};
`;
    r = g + r, c = g + c;
  }
  return l && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, r = `${r}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, o = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (g, v, _, y) => /\battribute\s+vec[23]\s+$/.test(y.substr(0, _)) ? v : `troika_${v}_${n}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = dC(e, n, r, o, a), t = dC(t, n, c, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function dC(s, e, t, i, n) {
  return (i || n || t) && (s = s.replace(
    k3,
    `
${t}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${n}
}`), s;
}
function Tq(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let Aq = 0;
const fC = /* @__PURE__ */ new Map();
function Cq(s) {
  const e = JSON.stringify(s, Tq);
  let t = fC.get(e);
  return t == null && fC.set(e, t = ++Aq), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function Pq() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(n) {
      var r = e._bin, o = new Uint8Array(n);
      if (r.readASCII(o, 0, 4) == "ttcf") {
        var a = 4;
        r.readUshort(o, a), a += 2, r.readUshort(o, a), a += 2;
        var l = r.readUint(o, a);
        a += 4;
        for (var c = [], u = 0; u < l; u++) {
          var h = r.readUint(o, a);
          a += 4, c.push(e._readFont(o, h));
        }
        return c;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, r) {
      var o = e._bin, a = r;
      o.readFixed(n, r), r += 4;
      var l = o.readUshort(n, r);
      r += 2, o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2;
      for (var c = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: a }, h = {}, d = 0; d < l; d++) {
        var f = o.readASCII(n, r, 4);
        r += 4, o.readUint(n, r), r += 4;
        var m = o.readUint(n, r);
        r += 4;
        var g = o.readUint(n, r);
        r += 4, h[f] = { offset: m, length: g };
      }
      for (d = 0; d < c.length; d++) {
        var v = c[d];
        h[v] && (u[v.trim()] = e[v.trim()].parse(n, h[v].offset, h[v].length, u));
      }
      return u;
    }, _tabOffset: function(n, r, o) {
      for (var a = e._bin, l = a.readUshort(n, o + 4), c = o + 12, u = 0; u < l; u++) {
        var h = a.readASCII(n, c, 4);
        c += 4, a.readUint(n, c), c += 4;
        var d = a.readUint(n, c);
        if (c += 4, a.readUint(n, c), c += 4, h == r) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, r) {
      return (n[r] << 8 | n[r + 1]) + (n[r + 2] << 8 | n[r + 3]) / 65540;
    }, readF2dot14: function(n, r) {
      return e._bin.readShort(n, r) / 16384;
    }, readInt: function(n, r) {
      return e._bin._view(n).getInt32(r);
    }, readInt8: function(n, r) {
      return e._bin._view(n).getInt8(r);
    }, readShort: function(n, r) {
      return e._bin._view(n).getInt16(r);
    }, readUshort: function(n, r) {
      return e._bin._view(n).getUint16(r);
    }, readUshorts: function(n, r, o) {
      for (var a = [], l = 0; l < o; l++) a.push(e._bin.readUshort(n, r + 2 * l));
      return a;
    }, readUint: function(n, r) {
      return e._bin._view(n).getUint32(r);
    }, readUint64: function(n, r) {
      return 4294967296 * e._bin.readUint(n, r) + e._bin.readUint(n, r + 4);
    }, readASCII: function(n, r, o) {
      for (var a = "", l = 0; l < o; l++) a += String.fromCharCode(n[r + l]);
      return a;
    }, readUnicode: function(n, r, o) {
      for (var a = "", l = 0; l < o; l++) {
        var c = n[r++] << 8 | n[r++];
        a += String.fromCharCode(c);
      }
      return a;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, r, o) {
      var a = e._bin._tdec;
      return a && r == 0 && o == n.length ? a.decode(n) : e._bin.readASCII(n, r, o);
    }, readBytes: function(n, r, o) {
      for (var a = [], l = 0; l < o; l++) a.push(n[r + l]);
      return a;
    }, readASCIIArray: function(n, r, o) {
      for (var a = [], l = 0; l < o; l++) a.push(String.fromCharCode(n[r + l]));
      return a;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, r, o, a, l) {
      var c = e._bin, u = {}, h = r;
      c.readFixed(n, r), r += 4;
      var d = c.readUshort(n, r);
      r += 2;
      var f = c.readUshort(n, r);
      r += 2;
      var m = c.readUshort(n, r);
      return r += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + m, l), u;
    }, e._lctf.readLookupList = function(n, r, o) {
      var a = e._bin, l = r, c = [], u = a.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var d = a.readUshort(n, r);
        r += 2;
        var f = e._lctf.readLookupTable(n, l + d, o);
        c.push(f);
      }
      return c;
    }, e._lctf.readLookupTable = function(n, r, o) {
      var a = e._bin, l = r, c = { tabs: [] };
      c.ltype = a.readUshort(n, r), r += 2, c.flag = a.readUshort(n, r), r += 2;
      var u = a.readUshort(n, r);
      r += 2;
      for (var h = c.ltype, d = 0; d < u; d++) {
        var f = a.readUshort(n, r);
        r += 2;
        var m = o(n, h, l + f, c);
        c.tabs.push(m);
      }
      return c;
    }, e._lctf.numOfOnes = function(n) {
      for (var r = 0, o = 0; o < 32; o++) n >>> o & 1 && r++;
      return r;
    }, e._lctf.readClassDef = function(n, r) {
      var o = e._bin, a = [], l = o.readUshort(n, r);
      if (r += 2, l == 1) {
        var c = o.readUshort(n, r);
        r += 2;
        var u = o.readUshort(n, r);
        r += 2;
        for (var h = 0; h < u; h++) a.push(c + h), a.push(c + h), a.push(o.readUshort(n, r)), r += 2;
      }
      if (l == 2) {
        var d = o.readUshort(n, r);
        for (r += 2, h = 0; h < d; h++) a.push(o.readUshort(n, r)), r += 2, a.push(o.readUshort(n, r)), r += 2, a.push(o.readUshort(n, r)), r += 2;
      }
      return a;
    }, e._lctf.getInterval = function(n, r) {
      for (var o = 0; o < n.length; o += 3) {
        var a = n[o], l = n[o + 1];
        if (n[o + 2], a <= r && r <= l) return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, r) {
      var o = e._bin, a = {};
      a.fmt = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      return r += 2, a.fmt == 1 && (a.tab = o.readUshorts(n, r, l)), a.fmt == 2 && (a.tab = o.readUshorts(n, r, 3 * l)), a;
    }, e._lctf.coverageIndex = function(n, r) {
      var o = n.tab;
      if (n.fmt == 1) return o.indexOf(r);
      if (n.fmt == 2) {
        var a = e._lctf.getInterval(o, r);
        if (a != -1) return o[a + 2] + (r - o[a]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, r) {
      var o = e._bin, a = r, l = [], c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readASCII(n, r, 4);
        r += 4;
        var d = o.readUshort(n, r);
        r += 2;
        var f = e._lctf.readFeatureTable(n, a + d);
        f.tag = h.trim(), l.push(f);
      }
      return l;
    }, e._lctf.readFeatureTable = function(n, r) {
      var o = e._bin, a = r, l = {}, c = o.readUshort(n, r);
      r += 2, c > 0 && (l.featureParams = a + c);
      var u = o.readUshort(n, r);
      r += 2, l.tab = [];
      for (var h = 0; h < u; h++) l.tab.push(o.readUshort(n, r + 2 * h));
      return l;
    }, e._lctf.readScriptList = function(n, r) {
      var o = e._bin, a = r, l = {}, c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readASCII(n, r, 4);
        r += 4;
        var d = o.readUshort(n, r);
        r += 2, l[h.trim()] = e._lctf.readScriptTable(n, a + d);
      }
      return l;
    }, e._lctf.readScriptTable = function(n, r) {
      var o = e._bin, a = r, l = {}, c = o.readUshort(n, r);
      r += 2, c > 0 && (l.default = e._lctf.readLangSysTable(n, a + c));
      var u = o.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, r, 4);
        r += 4;
        var f = o.readUshort(n, r);
        r += 2, l[d.trim()] = e._lctf.readLangSysTable(n, a + f);
      }
      return l;
    }, e._lctf.readLangSysTable = function(n, r) {
      var o = e._bin, a = {};
      o.readUshort(n, r), r += 2, a.reqFeature = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      return r += 2, a.features = o.readUshorts(n, r, l), a;
    }, e.CFF = {}, e.CFF.parse = function(n, r, o) {
      var a = e._bin;
      (n = new Uint8Array(n.buffer, r, o))[r = 0], n[++r], n[++r], n[++r], r++;
      var l = [];
      r = e.CFF.readIndex(n, r, l);
      for (var c = [], u = 0; u < l.length - 1; u++) c.push(a.readASCII(n, r + l[u], l[u + 1] - l[u]));
      r += l[l.length - 1];
      var h = [];
      r = e.CFF.readIndex(n, r, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++) d.push(e.CFF.readDict(n, r + h[u], r + h[u + 1]));
      r += h[h.length - 1];
      var f = d[0], m = [];
      r = e.CFF.readIndex(n, r, m);
      var g = [];
      for (u = 0; u < m.length - 1; u++) g.push(a.readASCII(n, r + m[u], m[u + 1] - m[u]));
      if (r += m[m.length - 1], e.CFF.readSubrs(n, r, f), f.CharStrings) {
        r = f.CharStrings, m = [], r = e.CFF.readIndex(n, r, m);
        var v = [];
        for (u = 0; u < m.length - 1; u++) v.push(a.readBytes(n, r + m[u], m[u + 1] - m[u]));
        f.CharStrings = v;
      }
      if (f.ROS) {
        r = f.FDArray;
        var _ = [];
        for (r = e.CFF.readIndex(n, r, _), f.FDArray = [], u = 0; u < _.length - 1; u++) {
          var y = e.CFF.readDict(n, r + _[u], r + _[u + 1]);
          e.CFF._readFDict(n, y, g), f.FDArray.push(y);
        }
        r += _[_.length - 1], r = f.FDSelect, f.FDSelect = [];
        var w = n[r];
        if (r++, w != 3) throw w;
        var x = a.readUshort(n, r);
        for (r += 2, u = 0; u < x + 1; u++) f.FDSelect.push(a.readUshort(n, r), n[r + 2]), r += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, g), f;
    }, e.CFF._readFDict = function(n, r, o) {
      var a;
      for (var l in r.Private && (a = r.Private[1], r.Private = e.CFF.readDict(n, a, a + r.Private[0]), r.Private.Subrs && e.CFF.readSubrs(n, a + r.Private.Subrs, r.Private)), r) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(l) != -1 && (r[l] = o[r[l] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, r, o) {
      var a = e._bin, l = [];
      r = e.CFF.readIndex(n, r, l);
      var c, u = l.length;
      c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = c, o.Subrs = [];
      for (var h = 0; h < l.length - 1; h++) o.Subrs.push(a.readBytes(n, r + l[h], l[h + 1] - l[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, r) {
      for (var o = 0; o < n.charset.length; o++) if (n.charset[o] == r) return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, r) {
      return r < 0 || r > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[r]);
    }, e.CFF.readEncoding = function(n, r, o) {
      e._bin;
      var a = [".notdef"], l = n[r];
      if (r++, l != 0) throw "error: unknown encoding format: " + l;
      var c = n[r];
      r++;
      for (var u = 0; u < c; u++) a.push(n[r + u]);
      return a;
    }, e.CFF.readCharset = function(n, r, o) {
      var a = e._bin, l = [".notdef"], c = n[r];
      if (r++, c == 0) for (var u = 0; u < o; u++) {
        var h = a.readUshort(n, r);
        r += 2, l.push(h);
      }
      else {
        if (c != 1 && c != 2) throw "error: format: " + c;
        for (; l.length < o; ) {
          h = a.readUshort(n, r), r += 2;
          var d = 0;
          for (c == 1 ? (d = n[r], r++) : (d = a.readUshort(n, r), r += 2), u = 0; u <= d; u++) l.push(h), h++;
        }
      }
      return l;
    }, e.CFF.readIndex = function(n, r, o) {
      var a = e._bin, l = a.readUshort(n, r) + 1, c = n[r += 2];
      if (r++, c == 1) for (var u = 0; u < l; u++) o.push(n[r + u]);
      else if (c == 2) for (u = 0; u < l; u++) o.push(a.readUshort(n, r + 2 * u));
      else if (c == 3) for (u = 0; u < l; u++) o.push(16777215 & a.readUint(n, r + 3 * u - 1));
      else if (l != 1) throw "unsupported offset size: " + c + ", count: " + l;
      return (r += l * c) - 1;
    }, e.CFF.getCharString = function(n, r, o) {
      var a = e._bin, l = n[r], c = n[r + 1];
      n[r + 2], n[r + 3], n[r + 4];
      var u = 1, h = null, d = null;
      l <= 20 && (h = l, u = 1), l == 12 && (h = 100 * l + c, u = 2), 21 <= l && l <= 27 && (h = l, u = 1), l == 28 && (d = a.readShort(n, r + 1), u = 3), 29 <= l && l <= 31 && (h = l, u = 1), 32 <= l && l <= 246 && (d = l - 139, u = 1), 247 <= l && l <= 250 && (d = 256 * (l - 247) + c + 108, u = 2), 251 <= l && l <= 254 && (d = 256 * -(l - 251) - c - 108, u = 2), l == 255 && (d = a.readInt(n, r + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, r, o) {
      for (var a = r + o, l = e._bin, c = []; r < a; ) {
        var u = n[r], h = n[r + 1];
        n[r + 2], n[r + 3], n[r + 4];
        var d = 1, f = null, m = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (m = l.readShort(n, r + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (m = u - 139, d = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (m = l.readInt(n, r + 1) / 65535, d = 5), c.push(m ?? "o" + f), r += d;
      }
      return c;
    }, e.CFF.readDict = function(n, r, o) {
      for (var a = e._bin, l = {}, c = []; r < o; ) {
        var u = n[r], h = n[r + 1];
        n[r + 2], n[r + 3], n[r + 4];
        var d = 1, f = null, m = null;
        if (u == 28 && (m = a.readShort(n, r + 1), d = 3), u == 29 && (m = a.readInt(n, r + 1), d = 5), 32 <= u && u <= 246 && (m = u - 139, d = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - h - 108, d = 2), u == 255) throw m = a.readInt(n, r + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var g = [];
          for (d = 1; ; ) {
            var v = n[r + d];
            d++;
            var _ = v >> 4, y = 15 & v;
            if (_ != 15 && g.push(_), y != 15 && g.push(y), y == 15) break;
          }
          for (var w = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], M = 0; M < g.length; M++) w += x[g[M]];
          m = parseFloat(w);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (l[f] = c.length == 1 ? c[0] : c, c = []) : c.push(m), r += d;
      }
      return l;
    }, e.cmap = {}, e.cmap.parse = function(n, r, o) {
      n = new Uint8Array(n.buffer, r, o), r = 0;
      var a = e._bin, l = {};
      a.readUshort(n, r), r += 2;
      var c = a.readUshort(n, r);
      r += 2;
      var u = [];
      l.tables = [];
      for (var h = 0; h < c; h++) {
        var d = a.readUshort(n, r);
        r += 2;
        var f = a.readUshort(n, r);
        r += 2;
        var m = a.readUint(n, r);
        r += 4;
        var g = "p" + d + "e" + f, v = u.indexOf(m);
        if (v == -1) {
          var _;
          v = l.tables.length, u.push(m);
          var y = a.readUshort(n, m);
          y == 0 ? _ = e.cmap.parse0(n, m) : y == 4 ? _ = e.cmap.parse4(n, m) : y == 6 ? _ = e.cmap.parse6(n, m) : y == 12 ? _ = e.cmap.parse12(n, m) : console.debug("unknown format: " + y, d, f, m), l.tables.push(_);
        }
        if (l[g] != null) throw "multiple tables for one platform+encoding";
        l[g] = v;
      }
      return l;
    }, e.cmap.parse0 = function(n, r) {
      var o = e._bin, a = {};
      a.format = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      r += 2, o.readUshort(n, r), r += 2, a.map = [];
      for (var c = 0; c < l - 6; c++) a.map.push(n[r + c]);
      return a;
    }, e.cmap.parse4 = function(n, r) {
      var o = e._bin, a = r, l = {};
      l.format = o.readUshort(n, r), r += 2;
      var c = o.readUshort(n, r);
      r += 2, o.readUshort(n, r), r += 2;
      var u = o.readUshort(n, r);
      r += 2;
      var h = u / 2;
      l.searchRange = o.readUshort(n, r), r += 2, l.entrySelector = o.readUshort(n, r), r += 2, l.rangeShift = o.readUshort(n, r), r += 2, l.endCount = o.readUshorts(n, r, h), r += 2 * h, r += 2, l.startCount = o.readUshorts(n, r, h), r += 2 * h, l.idDelta = [];
      for (var d = 0; d < h; d++) l.idDelta.push(o.readShort(n, r)), r += 2;
      for (l.idRangeOffset = o.readUshorts(n, r, h), r += 2 * h, l.glyphIdArray = []; r < a + c; ) l.glyphIdArray.push(o.readUshort(n, r)), r += 2;
      return l;
    }, e.cmap.parse6 = function(n, r) {
      var o = e._bin, a = {};
      a.format = o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2, o.readUshort(n, r), r += 2, a.firstCode = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      r += 2, a.glyphIdArray = [];
      for (var c = 0; c < l; c++) a.glyphIdArray.push(o.readUshort(n, r)), r += 2;
      return a;
    }, e.cmap.parse12 = function(n, r) {
      var o = e._bin, a = {};
      a.format = o.readUshort(n, r), r += 2, r += 2, o.readUint(n, r), r += 4, o.readUint(n, r), r += 4;
      var l = o.readUint(n, r);
      r += 4, a.groups = [];
      for (var c = 0; c < l; c++) {
        var u = r + 12 * c, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        a.groups.push([h, d, f]);
      }
      return a;
    }, e.glyf = {}, e.glyf.parse = function(n, r, o, a) {
      for (var l = [], c = 0; c < a.maxp.numGlyphs; c++) l.push(null);
      return l;
    }, e.glyf._parseGlyf = function(n, r) {
      var o = e._bin, a = n._data, l = e._tabOffset(a, "glyf", n._offset) + n.loca[r];
      if (n.loca[r] == n.loca[r + 1]) return null;
      var c = {};
      if (c.noc = o.readShort(a, l), l += 2, c.xMin = o.readShort(a, l), l += 2, c.yMin = o.readShort(a, l), l += 2, c.xMax = o.readShort(a, l), l += 2, c.yMax = o.readShort(a, l), l += 2, c.xMin >= c.xMax || c.yMin >= c.yMax) return null;
      if (c.noc > 0) {
        c.endPts = [];
        for (var u = 0; u < c.noc; u++) c.endPts.push(o.readUshort(a, l)), l += 2;
        var h = o.readUshort(a, l);
        if (l += 2, a.length - l < h) return null;
        c.instructions = o.readBytes(a, l, h), l += h;
        var d = c.endPts[c.noc - 1] + 1;
        for (c.flags = [], u = 0; u < d; u++) {
          var f = a[l];
          if (l++, c.flags.push(f), (8 & f) != 0) {
            var m = a[l];
            l++;
            for (var g = 0; g < m; g++) c.flags.push(f), u++;
          }
        }
        for (c.xs = [], u = 0; u < d; u++) {
          var v = (2 & c.flags[u]) != 0, _ = (16 & c.flags[u]) != 0;
          v ? (c.xs.push(_ ? a[l] : -a[l]), l++) : _ ? c.xs.push(0) : (c.xs.push(o.readShort(a, l)), l += 2);
        }
        for (c.ys = [], u = 0; u < d; u++)
          v = (4 & c.flags[u]) != 0, _ = (32 & c.flags[u]) != 0, v ? (c.ys.push(_ ? a[l] : -a[l]), l++) : _ ? c.ys.push(0) : (c.ys.push(o.readShort(a, l)), l += 2);
        var y = 0, w = 0;
        for (u = 0; u < d; u++) y += c.xs[u], w += c.ys[u], c.xs[u] = y, c.ys[u] = w;
      } else {
        var x;
        c.parts = [];
        do {
          x = o.readUshort(a, l), l += 2;
          var M = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (c.parts.push(M), M.glyphIndex = o.readUshort(a, l), l += 2, 1 & x) {
            var A = o.readShort(a, l);
            l += 2;
            var E = o.readShort(a, l);
            l += 2;
          } else
            A = o.readInt8(a, l), l++, E = o.readInt8(a, l), l++;
          2 & x ? (M.m.tx = A, M.m.ty = E) : (M.p1 = A, M.p2 = E), 8 & x ? (M.m.a = M.m.d = o.readF2dot14(a, l), l += 2) : 64 & x ? (M.m.a = o.readF2dot14(a, l), l += 2, M.m.d = o.readF2dot14(a, l), l += 2) : 128 & x && (M.m.a = o.readF2dot14(a, l), l += 2, M.m.b = o.readF2dot14(a, l), l += 2, M.m.c = o.readF2dot14(a, l), l += 2, M.m.d = o.readF2dot14(a, l), l += 2);
        } while (32 & x);
        if (256 & x) {
          var C = o.readUshort(a, l);
          for (l += 2, c.instr = [], u = 0; u < C; u++) c.instr.push(a[l]), l++;
        }
      }
      return c;
    }, e.GDEF = {}, e.GDEF.parse = function(n, r, o, a) {
      var l = r;
      r += 4;
      var c = e._bin.readUshort(n, r);
      return { glyphClassDef: c === 0 ? null : e._lctf.readClassDef(n, l + c) };
    }, e.GPOS = {}, e.GPOS.parse = function(n, r, o, a) {
      return e._lctf.parse(n, r, o, a, e.GPOS.subt);
    }, e.GPOS.subt = function(n, r, o, a) {
      var l = e._bin, c = o, u = {};
      if (u.fmt = l.readUshort(n, o), o += 2, r == 1 || r == 2 || r == 3 || r == 7 || r == 8 && u.fmt <= 2) {
        var h = l.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + c);
      }
      if (r == 1 && u.fmt == 1) {
        var d = l.readUshort(n, o);
        o += 2, d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (r == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = l.readUshort(n, o), o += 2;
        var f = l.readUshort(n, o);
        o += 2;
        var m = e._lctf.numOfOnes(d), g = e._lctf.numOfOnes(f);
        if (u.fmt == 1) {
          u.pairsets = [];
          var v = l.readUshort(n, o);
          o += 2;
          for (var _ = 0; _ < v; _++) {
            var y = c + l.readUshort(n, o);
            o += 2;
            var w = l.readUshort(n, y);
            y += 2;
            for (var x = [], M = 0; M < w; M++) {
              var A = l.readUshort(n, y);
              y += 2, d != 0 && (D = e.GPOS.readValueRecord(n, y, d), y += 2 * m), f != 0 && (U = e.GPOS.readValueRecord(n, y, f), y += 2 * g), x.push({ gid2: A, val1: D, val2: U });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var E = l.readUshort(n, o);
          o += 2;
          var C = l.readUshort(n, o);
          o += 2;
          var P = l.readUshort(n, o);
          o += 2;
          var T = l.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, c + E), u.classDef2 = e._lctf.readClassDef(n, c + C), u.matrix = [], _ = 0; _ < P; _++) {
            var I = [];
            for (M = 0; M < T; M++) {
              var D = null, U = null;
              d != 0 && (D = e.GPOS.readValueRecord(n, o, d), o += 2 * m), f != 0 && (U = e.GPOS.readValueRecord(n, o, f), o += 2 * g), I.push({ val1: D, val2: U });
            }
            u.matrix.push(I);
          }
        }
      } else if (r == 4 && u.fmt == 1) u.markCoverage = e._lctf.readCoverage(n, l.readUshort(n, o) + c), u.baseCoverage = e._lctf.readCoverage(n, l.readUshort(n, o + 2) + c), u.markClassCount = l.readUshort(n, o + 4), u.markArray = e.GPOS.readMarkArray(n, l.readUshort(n, o + 6) + c), u.baseArray = e.GPOS.readBaseArray(n, l.readUshort(n, o + 8) + c, u.markClassCount);
      else if (r == 6 && u.fmt == 1) u.mark1Coverage = e._lctf.readCoverage(n, l.readUshort(n, o) + c), u.mark2Coverage = e._lctf.readCoverage(n, l.readUshort(n, o + 2) + c), u.markClassCount = l.readUshort(n, o + 4), u.mark1Array = e.GPOS.readMarkArray(n, l.readUshort(n, o + 6) + c), u.mark2Array = e.GPOS.readBaseArray(n, l.readUshort(n, o + 8) + c, u.markClassCount);
      else {
        if (r == 9 && u.fmt == 1) {
          var L = l.readUshort(n, o);
          o += 2;
          var k = l.readUint(n, o);
          if (o += 4, a.ltype == 9) a.ltype = L;
          else if (a.ltype != L) throw "invalid extension substitution";
          return e.GPOS.subt(n, a.ltype, c + k);
        }
        console.debug("unsupported GPOS table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, r, o) {
      var a = e._bin, l = [];
      return l.push(1 & o ? a.readShort(n, r) : 0), r += 1 & o ? 2 : 0, l.push(2 & o ? a.readShort(n, r) : 0), r += 2 & o ? 2 : 0, l.push(4 & o ? a.readShort(n, r) : 0), r += 4 & o ? 2 : 0, l.push(8 & o ? a.readShort(n, r) : 0), r += 8 & o ? 2 : 0, l;
    }, e.GPOS.readBaseArray = function(n, r, o) {
      var a = e._bin, l = [], c = r, u = a.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        for (var d = [], f = 0; f < o; f++) d.push(e.GPOS.readAnchorRecord(n, c + a.readUshort(n, r))), r += 2;
        l.push(d);
      }
      return l;
    }, e.GPOS.readMarkArray = function(n, r) {
      var o = e._bin, a = [], l = r, c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = e.GPOS.readAnchorRecord(n, o.readUshort(n, r + 2) + l);
        h.markClass = o.readUshort(n, r), a.push(h), r += 4;
      }
      return a;
    }, e.GPOS.readAnchorRecord = function(n, r) {
      var o = e._bin, a = {};
      return a.fmt = o.readUshort(n, r), a.x = o.readShort(n, r + 2), a.y = o.readShort(n, r + 4), a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, r, o, a) {
      return e._lctf.parse(n, r, o, a, e.GSUB.subt);
    }, e.GSUB.subt = function(n, r, o, a) {
      var l = e._bin, c = o, u = {};
      if (u.fmt = l.readUshort(n, o), o += 2, r != 1 && r != 2 && r != 4 && r != 5 && r != 6) return null;
      if (r == 1 || r == 2 || r == 4 || r == 5 && u.fmt <= 2 || r == 6 && u.fmt <= 2) {
        var h = l.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, c + h);
      }
      if (r == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1) u.delta = l.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = l.readUshort(n, o);
          o += 2, u.newg = l.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (r == 2 && u.fmt == 1) {
        d = l.readUshort(n, o), o += 2, u.seqs = [];
        for (var f = 0; f < d; f++) {
          var m = l.readUshort(n, o) + c;
          o += 2;
          var g = l.readUshort(n, m);
          u.seqs.push(l.readUshorts(n, m + 2, g));
        }
      } else if (r == 4)
        for (u.vals = [], d = l.readUshort(n, o), o += 2, f = 0; f < d; f++) {
          var v = l.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, c + v));
        }
      else if (r == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var _ = l.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, c + _), u.scset = [];
          var y = l.readUshort(n, o);
          for (o += 2, f = 0; f < y; f++) {
            var w = l.readUshort(n, o);
            o += 2, u.scset.push(w == 0 ? null : e.GSUB.readSubClassSet(n, c + w));
          }
        }
      } else if (r == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = l.readUshort(n, o), o += 2;
            for (var x = [], M = 0; M < d; M++) x.push(e._lctf.readCoverage(n, c + l.readUshort(n, o + 2 * M)));
            o += 2 * d, f == 0 && (u.backCvg = x), f == 1 && (u.inptCvg = x), f == 2 && (u.ahedCvg = x);
          }
          d = l.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (r == 7 && u.fmt == 1) {
          var A = l.readUshort(n, o);
          o += 2;
          var E = l.readUint(n, o);
          if (o += 4, a.ltype == 9) a.ltype = A;
          else if (a.ltype != A) throw "invalid extension substitution";
          return e.GSUB.subt(n, a.ltype, c + E);
        }
        console.debug("unsupported GSUB table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, r) {
      var o = e._bin.readUshort, a = r, l = [], c = o(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o(n, r);
        r += 2, l.push(e.GSUB.readSubClassRule(n, a + h));
      }
      return l;
    }, e.GSUB.readSubClassRule = function(n, r) {
      var o = e._bin.readUshort, a = {}, l = o(n, r), c = o(n, r += 2);
      r += 2, a.input = [];
      for (var u = 0; u < l - 1; u++) a.input.push(o(n, r)), r += 2;
      return a.substLookupRecords = e.GSUB.readSubstLookupRecords(n, r, c), a;
    }, e.GSUB.readSubstLookupRecords = function(n, r, o) {
      for (var a = e._bin.readUshort, l = [], c = 0; c < o; c++) l.push(a(n, r), a(n, r + 2)), r += 4;
      return l;
    }, e.GSUB.readChainSubClassSet = function(n, r) {
      var o = e._bin, a = r, l = [], c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readUshort(n, r);
        r += 2, l.push(e.GSUB.readChainSubClassRule(n, a + h));
      }
      return l;
    }, e.GSUB.readChainSubClassRule = function(n, r) {
      for (var o = e._bin, a = {}, l = ["backtrack", "input", "lookahead"], c = 0; c < l.length; c++) {
        var u = o.readUshort(n, r);
        r += 2, c == 1 && u--, a[l[c]] = o.readUshorts(n, r, u), r += 2 * a[l[c]].length;
      }
      return u = o.readUshort(n, r), r += 2, a.subst = o.readUshorts(n, r, 2 * u), r += 2 * a.subst.length, a;
    }, e.GSUB.readLigatureSet = function(n, r) {
      var o = e._bin, a = r, l = [], c = o.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = o.readUshort(n, r);
        r += 2, l.push(e.GSUB.readLigature(n, a + h));
      }
      return l;
    }, e.GSUB.readLigature = function(n, r) {
      var o = e._bin, a = { chain: [] };
      a.nglyph = o.readUshort(n, r), r += 2;
      var l = o.readUshort(n, r);
      r += 2;
      for (var c = 0; c < l - 1; c++) a.chain.push(o.readUshort(n, r)), r += 2;
      return a;
    }, e.head = {}, e.head.parse = function(n, r, o) {
      var a = e._bin, l = {};
      return a.readFixed(n, r), r += 4, l.fontRevision = a.readFixed(n, r), r += 4, a.readUint(n, r), r += 4, a.readUint(n, r), r += 4, l.flags = a.readUshort(n, r), r += 2, l.unitsPerEm = a.readUshort(n, r), r += 2, l.created = a.readUint64(n, r), r += 8, l.modified = a.readUint64(n, r), r += 8, l.xMin = a.readShort(n, r), r += 2, l.yMin = a.readShort(n, r), r += 2, l.xMax = a.readShort(n, r), r += 2, l.yMax = a.readShort(n, r), r += 2, l.macStyle = a.readUshort(n, r), r += 2, l.lowestRecPPEM = a.readUshort(n, r), r += 2, l.fontDirectionHint = a.readShort(n, r), r += 2, l.indexToLocFormat = a.readShort(n, r), r += 2, l.glyphDataFormat = a.readShort(n, r), r += 2, l;
    }, e.hhea = {}, e.hhea.parse = function(n, r, o) {
      var a = e._bin, l = {};
      return a.readFixed(n, r), r += 4, l.ascender = a.readShort(n, r), r += 2, l.descender = a.readShort(n, r), r += 2, l.lineGap = a.readShort(n, r), r += 2, l.advanceWidthMax = a.readUshort(n, r), r += 2, l.minLeftSideBearing = a.readShort(n, r), r += 2, l.minRightSideBearing = a.readShort(n, r), r += 2, l.xMaxExtent = a.readShort(n, r), r += 2, l.caretSlopeRise = a.readShort(n, r), r += 2, l.caretSlopeRun = a.readShort(n, r), r += 2, l.caretOffset = a.readShort(n, r), r += 2, r += 8, l.metricDataFormat = a.readShort(n, r), r += 2, l.numberOfHMetrics = a.readUshort(n, r), r += 2, l;
    }, e.hmtx = {}, e.hmtx.parse = function(n, r, o, a) {
      for (var l = e._bin, c = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < a.maxp.numGlyphs; d++) d < a.hhea.numberOfHMetrics && (u = l.readUshort(n, r), r += 2, h = l.readShort(n, r), r += 2), c.aWidth.push(u), c.lsBearing.push(h);
      return c;
    }, e.kern = {}, e.kern.parse = function(n, r, o, a) {
      var l = e._bin, c = l.readUshort(n, r);
      if (r += 2, c == 1) return e.kern.parseV1(n, r - 2, o, a);
      var u = l.readUshort(n, r);
      r += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        r += 2, o = l.readUshort(n, r), r += 2;
        var f = l.readUshort(n, r);
        r += 2;
        var m = f >>> 8;
        if ((m &= 15) != 0) throw "unknown kern table format: " + m;
        r = e.kern.readFormat0(n, r, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, r, o, a) {
      var l = e._bin;
      l.readFixed(n, r), r += 4;
      var c = l.readUint(n, r);
      r += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < c; h++) {
        l.readUint(n, r), r += 4;
        var d = l.readUshort(n, r);
        r += 2, l.readUshort(n, r), r += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0) throw "unknown kern table format: " + f;
        r = e.kern.readFormat0(n, r, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, r, o) {
      var a = e._bin, l = -1, c = a.readUshort(n, r);
      r += 2, a.readUshort(n, r), r += 2, a.readUshort(n, r), r += 2, a.readUshort(n, r), r += 2;
      for (var u = 0; u < c; u++) {
        var h = a.readUshort(n, r);
        r += 2;
        var d = a.readUshort(n, r);
        r += 2;
        var f = a.readShort(n, r);
        r += 2, h != l && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var m = o.rval[o.rval.length - 1];
        m.glyph2.push(d), m.vals.push(f), l = h;
      }
      return r;
    }, e.loca = {}, e.loca.parse = function(n, r, o, a) {
      var l = e._bin, c = [], u = a.head.indexToLocFormat, h = a.maxp.numGlyphs + 1;
      if (u == 0) for (var d = 0; d < h; d++) c.push(l.readUshort(n, r + (d << 1)) << 1);
      if (u == 1) for (d = 0; d < h; d++) c.push(l.readUint(n, r + (d << 2)));
      return c;
    }, e.maxp = {}, e.maxp.parse = function(n, r, o) {
      var a = e._bin, l = {}, c = a.readUint(n, r);
      return r += 4, l.numGlyphs = a.readUshort(n, r), r += 2, c == 65536 && (l.maxPoints = a.readUshort(n, r), r += 2, l.maxContours = a.readUshort(n, r), r += 2, l.maxCompositePoints = a.readUshort(n, r), r += 2, l.maxCompositeContours = a.readUshort(n, r), r += 2, l.maxZones = a.readUshort(n, r), r += 2, l.maxTwilightPoints = a.readUshort(n, r), r += 2, l.maxStorage = a.readUshort(n, r), r += 2, l.maxFunctionDefs = a.readUshort(n, r), r += 2, l.maxInstructionDefs = a.readUshort(n, r), r += 2, l.maxStackElements = a.readUshort(n, r), r += 2, l.maxSizeOfInstructions = a.readUshort(n, r), r += 2, l.maxComponentElements = a.readUshort(n, r), r += 2, l.maxComponentDepth = a.readUshort(n, r), r += 2), l;
    }, e.name = {}, e.name.parse = function(n, r, o) {
      var a = e._bin, l = {};
      a.readUshort(n, r), r += 2;
      var c = a.readUshort(n, r);
      r += 2, a.readUshort(n, r);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = r += 2, f = 0; f < c; f++) {
        var m = a.readUshort(n, r);
        r += 2;
        var g = a.readUshort(n, r);
        r += 2;
        var v = a.readUshort(n, r);
        r += 2;
        var _ = a.readUshort(n, r);
        r += 2;
        var y = a.readUshort(n, r);
        r += 2;
        var w = a.readUshort(n, r);
        r += 2;
        var x, M = h[_], A = d + 12 * c + w;
        if (m == 0) x = a.readUnicode(n, A, y / 2);
        else if (m == 3 && g == 0) x = a.readUnicode(n, A, y / 2);
        else if (g == 0) x = a.readASCII(n, A, y);
        else if (g == 1) x = a.readUnicode(n, A, y / 2);
        else if (g == 3) x = a.readUnicode(n, A, y / 2);
        else {
          if (m != 1) throw "unknown encoding " + g + ", platformID: " + m;
          x = a.readASCII(n, A, y), console.debug("reading unknown MAC encoding " + g + " as ASCII");
        }
        var E = "p" + m + "," + v.toString(16);
        l[E] == null && (l[E] = {}), l[E][M !== void 0 ? M : _] = x, l[E]._lang = v;
      }
      for (var C in l) if (l[C].postScriptName != null && l[C]._lang == 1033) return l[C];
      for (var C in l) if (l[C].postScriptName != null && l[C]._lang == 0) return l[C];
      for (var C in l) if (l[C].postScriptName != null && l[C]._lang == 3084) return l[C];
      for (var C in l) if (l[C].postScriptName != null) return l[C];
      for (var C in l) {
        u = C;
        break;
      }
      return console.debug("returning name table with languageID " + l[u]._lang), l[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, r, o) {
      var a = e._bin.readUshort(n, r);
      r += 2;
      var l = {};
      if (a == 0) e["OS/2"].version0(n, r, l);
      else if (a == 1) e["OS/2"].version1(n, r, l);
      else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(n, r, l);
      else {
        if (a != 5) throw "unknown OS/2 table version: " + a;
        e["OS/2"].version5(n, r, l);
      }
      return l;
    }, e["OS/2"].version0 = function(n, r, o) {
      var a = e._bin;
      return o.xAvgCharWidth = a.readShort(n, r), r += 2, o.usWeightClass = a.readUshort(n, r), r += 2, o.usWidthClass = a.readUshort(n, r), r += 2, o.fsType = a.readUshort(n, r), r += 2, o.ySubscriptXSize = a.readShort(n, r), r += 2, o.ySubscriptYSize = a.readShort(n, r), r += 2, o.ySubscriptXOffset = a.readShort(n, r), r += 2, o.ySubscriptYOffset = a.readShort(n, r), r += 2, o.ySuperscriptXSize = a.readShort(n, r), r += 2, o.ySuperscriptYSize = a.readShort(n, r), r += 2, o.ySuperscriptXOffset = a.readShort(n, r), r += 2, o.ySuperscriptYOffset = a.readShort(n, r), r += 2, o.yStrikeoutSize = a.readShort(n, r), r += 2, o.yStrikeoutPosition = a.readShort(n, r), r += 2, o.sFamilyClass = a.readShort(n, r), r += 2, o.panose = a.readBytes(n, r, 10), r += 10, o.ulUnicodeRange1 = a.readUint(n, r), r += 4, o.ulUnicodeRange2 = a.readUint(n, r), r += 4, o.ulUnicodeRange3 = a.readUint(n, r), r += 4, o.ulUnicodeRange4 = a.readUint(n, r), r += 4, o.achVendID = [a.readInt8(n, r), a.readInt8(n, r + 1), a.readInt8(n, r + 2), a.readInt8(n, r + 3)], r += 4, o.fsSelection = a.readUshort(n, r), r += 2, o.usFirstCharIndex = a.readUshort(n, r), r += 2, o.usLastCharIndex = a.readUshort(n, r), r += 2, o.sTypoAscender = a.readShort(n, r), r += 2, o.sTypoDescender = a.readShort(n, r), r += 2, o.sTypoLineGap = a.readShort(n, r), r += 2, o.usWinAscent = a.readUshort(n, r), r += 2, o.usWinDescent = a.readUshort(n, r), r += 2;
    }, e["OS/2"].version1 = function(n, r, o) {
      var a = e._bin;
      return r = e["OS/2"].version0(n, r, o), o.ulCodePageRange1 = a.readUint(n, r), r += 4, o.ulCodePageRange2 = a.readUint(n, r), r += 4;
    }, e["OS/2"].version2 = function(n, r, o) {
      var a = e._bin;
      return r = e["OS/2"].version1(n, r, o), o.sxHeight = a.readShort(n, r), r += 2, o.sCapHeight = a.readShort(n, r), r += 2, o.usDefault = a.readUshort(n, r), r += 2, o.usBreak = a.readUshort(n, r), r += 2, o.usMaxContext = a.readUshort(n, r), r += 2;
    }, e["OS/2"].version5 = function(n, r, o) {
      var a = e._bin;
      return r = e["OS/2"].version2(n, r, o), o.usLowerOpticalPointSize = a.readUshort(n, r), r += 2, o.usUpperOpticalPointSize = a.readUshort(n, r), r += 2;
    }, e.post = {}, e.post.parse = function(n, r, o) {
      var a = e._bin, l = {};
      return l.version = a.readFixed(n, r), r += 4, l.italicAngle = a.readFixed(n, r), r += 4, l.underlinePosition = a.readShort(n, r), r += 2, l.underlineThickness = a.readShort(n, r), r += 2, l;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, r) {
      var o = n.cmap, a = -1;
      if (o.p0e4 != null ? a = o.p0e4 : o.p3e1 != null ? a = o.p3e1 : o.p1e0 != null ? a = o.p1e0 : o.p0e3 != null && (a = o.p0e3), a == -1) throw "no familiar platform and encoding!";
      var l = o.tables[a];
      if (l.format == 0) return r >= l.map.length ? 0 : l.map[r];
      if (l.format == 4) {
        for (var c = -1, u = 0; u < l.endCount.length; u++) if (r <= l.endCount[u]) {
          c = u;
          break;
        }
        return c == -1 || l.startCount[c] > r ? 0 : 65535 & (l.idRangeOffset[c] != 0 ? l.glyphIdArray[r - l.startCount[c] + (l.idRangeOffset[c] >> 1) - (l.idRangeOffset.length - c)] : r + l.idDelta[c]);
      }
      if (l.format == 12) {
        if (r > l.groups[l.groups.length - 1][1]) return 0;
        for (u = 0; u < l.groups.length; u++) {
          var h = l.groups[u];
          if (h[0] <= r && r <= h[1]) return h[2] + (r - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + l.format;
    }, e.U.glyphToPath = function(n, r) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[r]) {
        var a = n.SVG.entries[r];
        return a == null ? o : (typeof a == "string" && (a = e.SVG.toPath(a), n.SVG.entries[r] = a), a);
      }
      if (n.CFF) {
        var l = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, c = n.CFF, u = n.CFF.Private;
        if (c.ROS) {
          for (var h = 0; c.FDSelect[h + 2] <= r; ) h += 2;
          u = c.FDArray[c.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[r], l, c, u, o);
      } else n.glyf && e.U._drawGlyf(r, n, o);
      return o;
    }, e.U._drawGlyf = function(n, r, o) {
      var a = r.glyf[n];
      a == null && (a = r.glyf[n] = e.glyf._parseGlyf(r, n)), a != null && (a.noc > -1 ? e.U._simpleGlyph(a, o) : e.U._compoGlyph(a, r, o));
    }, e.U._simpleGlyph = function(n, r) {
      for (var o = 0; o < n.noc; o++) {
        for (var a = o == 0 ? 0 : n.endPts[o - 1] + 1, l = n.endPts[o], c = a; c <= l; c++) {
          var u = c == a ? l : c - 1, h = c == l ? a : c + 1, d = 1 & n.flags[c], f = 1 & n.flags[u], m = 1 & n.flags[h], g = n.xs[c], v = n.ys[c];
          if (c == a) if (d) {
            if (!f) {
              e.U.P.moveTo(r, g, v);
              continue;
            }
            e.U.P.moveTo(r, n.xs[u], n.ys[u]);
          } else f ? e.U.P.moveTo(r, n.xs[u], n.ys[u]) : e.U.P.moveTo(r, (n.xs[u] + g) / 2, (n.ys[u] + v) / 2);
          d ? f && e.U.P.lineTo(r, g, v) : m ? e.U.P.qcurveTo(r, g, v, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(r, g, v, (g + n.xs[h]) / 2, (v + n.ys[h]) / 2);
        }
        e.U.P.closePath(r);
      }
    }, e.U._compoGlyph = function(n, r, o) {
      for (var a = 0; a < n.parts.length; a++) {
        var l = { cmds: [], crds: [] }, c = n.parts[a];
        e.U._drawGlyf(c.glyphIndex, r, l);
        for (var u = c.m, h = 0; h < l.crds.length; h += 2) {
          var d = l.crds[h], f = l.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < l.cmds.length; h++) o.cmds.push(l.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, r) {
      var o = e._lctf.getInterval(r, n);
      return o == -1 ? 0 : r[o + 2];
    }, e.U._applySubs = function(n, r, o, a) {
      for (var l = n.length - r - 1, c = 0; c < o.tabs.length; c++) if (o.tabs[c] != null) {
        var u, h = o.tabs[c];
        if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[r])) != -1) {
          if (o.ltype == 1) n[r], h.fmt == 1 ? n[r] = n[r] + h.delta : n[r] = h.newg[u];
          else if (o.ltype == 4) for (var d = h.vals[u], f = 0; f < d.length; f++) {
            var m = d[f], g = m.chain.length;
            if (!(g > l)) {
              for (var v = !0, _ = 0, y = 0; y < g; y++) {
                for (; n[r + _ + (1 + y)] == -1; ) _++;
                m.chain[y] != n[r + _ + (1 + y)] && (v = !1);
              }
              if (v) {
                for (n[r] = m.nglyph, y = 0; y < g + _; y++) n[r + y + 1] = -1;
                break;
              }
            }
          }
          else if (o.ltype == 5 && h.fmt == 2) for (var w = e._lctf.getInterval(h.cDef, n[r]), x = h.cDef[w + 2], M = h.scset[x], A = 0; A < M.length; A++) {
            var E = M[A], C = E.input;
            if (!(C.length > l)) {
              for (v = !0, y = 0; y < C.length; y++) {
                var P = e._lctf.getInterval(h.cDef, n[r + 1 + y]);
                if (w == -1 && h.cDef[P + 2] != C[y]) {
                  v = !1;
                  break;
                }
              }
              if (v) {
                var T = E.substLookupRecords;
                for (f = 0; f < T.length; f += 2) T[f], T[f + 1];
              }
            }
          }
          else if (o.ltype == 6 && h.fmt == 3) {
            if (!e.U._glsCovered(n, h.backCvg, r - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, r) || !e.U._glsCovered(n, h.ahedCvg, r + h.inptCvg.length)) continue;
            var I = h.lookupRec;
            for (A = 0; A < I.length; A += 2) {
              w = I[A];
              var D = a[I[A + 1]];
              e.U._applySubs(n, r + w, D, a);
            }
          }
        }
      }
    }, e.U._glsCovered = function(n, r, o) {
      for (var a = 0; a < r.length; a++)
        if (e._lctf.coverageIndex(r[a], n[o + a]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, r, o) {
      for (var a = { cmds: [], crds: [] }, l = 0, c = 0; c < r.length; c++) {
        var u = r[c];
        if (u != -1) {
          for (var h = c < r.length - 1 && r[c + 1] != -1 ? r[c + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2) a.crds.push(d.crds[f] + l), a.crds.push(d.crds[f + 1]);
          for (o && a.cmds.push(o), f = 0; f < d.cmds.length; f++) a.cmds.push(d.cmds[f]);
          o && a.cmds.push("X"), l += n.hmtx.aWidth[u], c < r.length - 1 && (l += e.U.getPairAdjustment(n, u, h));
        }
      }
      return a;
    }, e.U.P = {}, e.U.P.moveTo = function(n, r, o) {
      n.cmds.push("M"), n.crds.push(r, o);
    }, e.U.P.lineTo = function(n, r, o) {
      n.cmds.push("L"), n.crds.push(r, o);
    }, e.U.P.curveTo = function(n, r, o, a, l, c, u) {
      n.cmds.push("C"), n.crds.push(r, o, a, l, c, u);
    }, e.U.P.qcurveTo = function(n, r, o, a, l) {
      n.cmds.push("Q"), n.crds.push(r, o, a, l);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, r, o, a, l) {
      for (var c = r.stack, u = r.nStems, h = r.haveWidth, d = r.width, f = r.open, m = 0, g = r.x, v = r.y, _ = 0, y = 0, w = 0, x = 0, M = 0, A = 0, E = 0, C = 0, P = 0, T = 0, I = { val: 0, size: 0 }; m < n.length; ) {
        e.CFF.getCharString(n, m, I);
        var D = I.val;
        if (m += I.size, D == "o1" || D == "o18") c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0;
        else if (D == "o3" || D == "o23")
          c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0;
        else if (D == "o4") c.length > 1 && !h && (d = c.shift() + a.nominalWidthX, h = !0), f && e.U.P.closePath(l), v += c.pop(), e.U.P.moveTo(l, g, v), f = !0;
        else if (D == "o5") for (; c.length > 0; ) g += c.shift(), v += c.shift(), e.U.P.lineTo(l, g, v);
        else if (D == "o6" || D == "o7") for (var U = c.length, L = D == "o6", k = 0; k < U; k++) {
          var B = c.shift();
          L ? g += B : v += B, L = !L, e.U.P.lineTo(l, g, v);
        }
        else if (D == "o8" || D == "o24") {
          U = c.length;
          for (var j = 0; j + 6 <= U; ) _ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), g = w + c.shift(), v = x + c.shift(), e.U.P.curveTo(l, _, y, w, x, g, v), j += 6;
          D == "o24" && (g += c.shift(), v += c.shift(), e.U.P.lineTo(l, g, v));
        } else {
          if (D == "o11") break;
          if (D == "o1234" || D == "o1235" || D == "o1236" || D == "o1237") D == "o1234" && (y = v, w = (_ = g + c.shift()) + c.shift(), T = x = y + c.shift(), A = x, C = v, g = (E = (M = (P = w + c.shift()) + c.shift()) + c.shift()) + c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v)), D == "o1235" && (_ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), P = w + c.shift(), T = x + c.shift(), M = P + c.shift(), A = T + c.shift(), E = M + c.shift(), C = A + c.shift(), g = E + c.shift(), v = C + c.shift(), c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v)), D == "o1236" && (_ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), T = x = y + c.shift(), A = x, E = (M = (P = w + c.shift()) + c.shift()) + c.shift(), C = A + c.shift(), g = E + c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v)), D == "o1237" && (_ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), P = w + c.shift(), T = x + c.shift(), M = P + c.shift(), A = T + c.shift(), E = M + c.shift(), C = A + c.shift(), Math.abs(E - g) > Math.abs(C - v) ? g = E + c.shift() : v = C + c.shift(), e.U.P.curveTo(l, _, y, w, x, P, T), e.U.P.curveTo(l, M, A, E, C, g, v));
          else if (D == "o14") {
            if (c.length > 0 && !h && (d = c.shift() + o.nominalWidthX, h = !0), c.length == 4) {
              var q = c.shift(), Z = c.shift(), N = c.shift(), z = c.shift(), J = e.CFF.glyphBySE(o, N), se = e.CFF.glyphBySE(o, z);
              e.U._drawCFF(o.CharStrings[J], r, o, a, l), r.x = q, r.y = Z, e.U._drawCFF(o.CharStrings[se], r, o, a, l);
            }
            f && (e.U.P.closePath(l), f = !1);
          } else if (D == "o19" || D == "o20")
            c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0, m += u + 7 >> 3;
          else if (D == "o21") c.length > 2 && !h && (d = c.shift() + a.nominalWidthX, h = !0), v += c.pop(), g += c.pop(), f && e.U.P.closePath(l), e.U.P.moveTo(l, g, v), f = !0;
          else if (D == "o22") c.length > 1 && !h && (d = c.shift() + a.nominalWidthX, h = !0), g += c.pop(), f && e.U.P.closePath(l), e.U.P.moveTo(l, g, v), f = !0;
          else if (D == "o25") {
            for (; c.length > 6; ) g += c.shift(), v += c.shift(), e.U.P.lineTo(l, g, v);
            _ = g + c.shift(), y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), g = w + c.shift(), v = x + c.shift(), e.U.P.curveTo(l, _, y, w, x, g, v);
          } else if (D == "o26") for (c.length % 2 && (g += c.shift()); c.length > 0; ) _ = g, y = v + c.shift(), g = w = _ + c.shift(), v = (x = y + c.shift()) + c.shift(), e.U.P.curveTo(l, _, y, w, x, g, v);
          else if (D == "o27") for (c.length % 2 && (v += c.shift()); c.length > 0; ) y = v, w = (_ = g + c.shift()) + c.shift(), x = y + c.shift(), g = w + c.shift(), v = x, e.U.P.curveTo(l, _, y, w, x, g, v);
          else if (D == "o10" || D == "o29") {
            var K = D == "o10" ? a : o;
            if (c.length == 0) console.debug("error: empty stack");
            else {
              var Q = c.pop(), de = K.Subrs[Q + K.Bias];
              r.x = g, r.y = v, r.nStems = u, r.haveWidth = h, r.width = d, r.open = f, e.U._drawCFF(de, r, o, a, l), g = r.x, v = r.y, u = r.nStems, h = r.haveWidth, d = r.width, f = r.open;
            }
          } else if (D == "o30" || D == "o31") {
            var ce = c.length, _e = (j = 0, D == "o31");
            for (j += ce - (U = -3 & ce); j < U; ) _e ? (y = v, w = (_ = g + c.shift()) + c.shift(), v = (x = y + c.shift()) + c.shift(), U - j == 5 ? (g = w + c.shift(), j++) : g = w, _e = !1) : (_ = g, y = v + c.shift(), w = _ + c.shift(), x = y + c.shift(), g = w + c.shift(), U - j == 5 ? (v = x + c.shift(), j++) : v = x, _e = !0), e.U.P.curveTo(l, _, y, w, x, g, v), j += 4;
          } else {
            if ((D + "").charAt(0) == "o") throw console.debug("Unknown operation: " + D, n), D;
            c.push(D);
          }
        }
      }
      r.x = g, r.y = v, r.nStems = u, r.haveWidth = h, r.width = d, r.open = f;
    };
    var t = e, i = { Typr: t };
    return s.Typr = t, s.default = i, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function Rq() {
  return function(s) {
    var e = Uint8Array, t = Uint16Array, i = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), r = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), a = function(D, U) {
      for (var L = new t(31), k = 0; k < 31; ++k) L[k] = U += 1 << D[k - 1];
      var B = new i(L[30]);
      for (k = 1; k < 30; ++k) for (var j = L[k]; j < L[k + 1]; ++j) B[j] = j - L[k] << 5 | k;
      return [L, B];
    }, l = a(n, 2), c = l[0], u = l[1];
    c[28] = 258, u[258] = 28;
    for (var h = a(r, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var m = (43690 & f) >>> 1 | (21845 & f) << 1;
      m = (61680 & (m = (52428 & m) >>> 2 | (13107 & m) << 2)) >>> 4 | (3855 & m) << 4, d[f] = ((65280 & m) >>> 8 | (255 & m) << 8) >>> 1;
    }
    var g = function(D, U, L) {
      for (var k = D.length, B = 0, j = new t(U); B < k; ++B) ++j[D[B] - 1];
      var q, Z = new t(U);
      for (B = 0; B < U; ++B) Z[B] = Z[B - 1] + j[B - 1] << 1;
      {
        q = new t(1 << U);
        var N = 15 - U;
        for (B = 0; B < k; ++B) if (D[B]) for (var z = B << 4 | D[B], J = U - D[B], se = Z[D[B] - 1]++ << J, K = se | (1 << J) - 1; se <= K; ++se) q[d[se] >>> N] = z;
      }
      return q;
    }, v = new e(288);
    for (f = 0; f < 144; ++f) v[f] = 8;
    for (f = 144; f < 256; ++f) v[f] = 9;
    for (f = 256; f < 280; ++f) v[f] = 7;
    for (f = 280; f < 288; ++f) v[f] = 8;
    var _ = new e(32);
    for (f = 0; f < 32; ++f) _[f] = 5;
    var y = g(v, 9), w = g(_, 5), x = function(D) {
      for (var U = D[0], L = 1; L < D.length; ++L) D[L] > U && (U = D[L]);
      return U;
    }, M = function(D, U, L) {
      var k = U / 8 | 0;
      return (D[k] | D[k + 1] << 8) >> (7 & U) & L;
    }, A = function(D, U) {
      var L = U / 8 | 0;
      return (D[L] | D[L + 1] << 8 | D[L + 2] << 16) >> (7 & U);
    }, E = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], C = function(D, U, L) {
      var k = new Error(U || E[D]);
      if (k.code = D, Error.captureStackTrace && Error.captureStackTrace(k, C), !L) throw k;
      return k;
    }, P = function(D, U, L) {
      var k = D.length;
      if (!k || L && !L.l && k < 5) return U || new e(0);
      var B = !U || L, j = !L || L.i;
      L || (L = {}), U || (U = new e(3 * k));
      var q, Z = function(Le) {
        var ot = U.length;
        if (Le > ot) {
          var tt = new e(Math.max(2 * ot, Le));
          tt.set(U), U = tt;
        }
      }, N = L.f || 0, z = L.p || 0, J = L.b || 0, se = L.l, K = L.d, Q = L.m, de = L.n, ce = 8 * k;
      do {
        if (!se) {
          L.f = N = M(D, z, 1);
          var _e = M(D, z + 1, 3);
          if (z += 3, !_e) {
            var Fe = D[(Oe = ((q = z) / 8 | 0) + (7 & q && 1) + 4) - 4] | D[Oe - 3] << 8, Ie = Oe + Fe;
            if (Ie > k) {
              j && C(0);
              break;
            }
            B && Z(J + Fe), U.set(D.subarray(Oe, Ie), J), L.b = J += Fe, L.p = z = 8 * Ie;
            continue;
          }
          if (_e == 1) se = y, K = w, Q = 9, de = 5;
          else if (_e == 2) {
            var Ee = M(D, z, 31) + 257, me = M(D, z + 10, 15) + 4, xe = Ee + M(D, z + 5, 31) + 1;
            z += 14;
            for (var $ = new e(xe), Ue = new e(19), Me = 0; Me < me; ++Me) Ue[o[Me]] = M(D, z + 3 * Me, 7);
            z += 3 * me;
            var oe = x(Ue), Te = (1 << oe) - 1, Ye = g(Ue, oe);
            for (Me = 0; Me < xe; ) {
              var Oe, X = Ye[M(D, z, Te)];
              if (z += 15 & X, (Oe = X >>> 4) < 16) $[Me++] = Oe;
              else {
                var Y = 0, fe = 0;
                for (Oe == 16 ? (fe = 3 + M(D, z, 3), z += 2, Y = $[Me - 1]) : Oe == 17 ? (fe = 3 + M(D, z, 7), z += 3) : Oe == 18 && (fe = 11 + M(D, z, 127), z += 7); fe--; ) $[Me++] = Y;
              }
            }
            var ue = $.subarray(0, Ee), te = $.subarray(Ee);
            Q = x(ue), de = x(te), se = g(ue, Q), K = g(te, de);
          } else C(1);
          if (z > ce) {
            j && C(0);
            break;
          }
        }
        B && Z(J + 131072);
        for (var Se = (1 << Q) - 1, ye = (1 << de) - 1, Ae = z; ; Ae = z) {
          var Ce = (Y = se[A(D, z) & Se]) >>> 4;
          if ((z += 15 & Y) > ce) {
            j && C(0);
            break;
          }
          if (Y || C(2), Ce < 256) U[J++] = Ce;
          else {
            if (Ce == 256) {
              Ae = z, se = null;
              break;
            }
            var Ge = Ce - 254;
            if (Ce > 264) {
              var De = n[Me = Ce - 257];
              Ge = M(D, z, (1 << De) - 1) + c[Me], z += De;
            }
            var Ve = K[A(D, z) & ye], ze = Ve >>> 4;
            if (Ve || C(3), z += 15 & Ve, te = h[ze], ze > 3 && (De = r[ze], te += A(D, z) & (1 << De) - 1, z += De), z > ce) {
              j && C(0);
              break;
            }
            B && Z(J + 131072);
            for (var Ze = J + Ge; J < Ze; J += 4) U[J] = U[J - te], U[J + 1] = U[J + 1 - te], U[J + 2] = U[J + 2 - te], U[J + 3] = U[J + 3 - te];
            J = Ze;
          }
        }
        L.l = se, L.p = Ae, L.b = J, se && (N = 1, L.m = Q, L.d = K, L.n = de);
      } while (!N);
      return J == U.length ? U : function(Le, ot, tt) {
        (tt == null || tt > Le.length) && (tt = Le.length);
        var mt = new (Le instanceof t ? t : Le instanceof i ? i : e)(tt - ot);
        return mt.set(Le.subarray(ot, tt)), mt;
      }(U, 0, J);
    }, T = new e(0), I = typeof TextDecoder < "u" && new TextDecoder();
    try {
      I.decode(T, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(D) {
      var U = new DataView(D), L = 0;
      function k() {
        var Ee = U.getUint16(L);
        return L += 2, Ee;
      }
      function B() {
        var Ee = U.getUint32(L);
        return L += 4, Ee;
      }
      function j(Ee) {
        Fe.setUint16(Ie, Ee), Ie += 2;
      }
      function q(Ee) {
        Fe.setUint32(Ie, Ee), Ie += 4;
      }
      for (var Z = { signature: B(), flavor: B(), length: B(), numTables: k(), reserved: k(), totalSfntSize: B(), majorVersion: k(), minorVersion: k(), metaOffset: B(), metaLength: B(), metaOrigLength: B(), privOffset: B(), privLength: B() }, N = 0; Math.pow(2, N) <= Z.numTables; ) N++;
      N--;
      for (var z = 16 * Math.pow(2, N), J = 16 * Z.numTables - z, se = 12, K = [], Q = 0; Q < Z.numTables; Q++) K.push({ tag: B(), offset: B(), compLength: B(), origLength: B(), origChecksum: B() }), se += 16;
      var de, ce = new Uint8Array(12 + 16 * K.length + K.reduce(function(Ee, me) {
        return Ee + me.origLength + 4;
      }, 0)), _e = ce.buffer, Fe = new DataView(_e), Ie = 0;
      return q(Z.flavor), j(Z.numTables), j(z), j(N), j(J), K.forEach(function(Ee) {
        q(Ee.tag), q(Ee.origChecksum), q(se), q(Ee.origLength), Ee.outOffset = se, (se += Ee.origLength) % 4 != 0 && (se += 4 - se % 4);
      }), K.forEach(function(Ee) {
        var me, xe = D.slice(Ee.offset, Ee.offset + Ee.compLength);
        if (Ee.compLength != Ee.origLength) {
          var $ = new Uint8Array(Ee.origLength);
          me = new Uint8Array(xe, 2), P(me, $);
        } else $ = new Uint8Array(xe);
        ce.set($, Ee.outOffset);
        var Ue = 0;
        (se = Ee.outOffset + Ee.origLength) % 4 != 0 && (Ue = 4 - se % 4), ce.set(new Uint8Array(Ue).buffer, Ee.outOffset + Ee.origLength), de = se + Ue;
      }), _e.slice(0, de);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function Dq(s, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, r = 2, o = 4, a = 8, l = 16, c = 32;
  let u;
  function h(E) {
    if (!u) {
      const C = {
        R: r,
        L: n,
        D: o,
        C: l,
        U: c,
        T: a
      };
      u = /* @__PURE__ */ new Map();
      for (let P in i) {
        let T = 0;
        i[P].split(",").forEach((I) => {
          let [D, U] = I.split("+");
          D = parseInt(D, 36), U = U ? parseInt(U, 36) : 0, u.set(T += D, C[P]);
          for (let L = U; L--; )
            u.set(++T, C[P]);
        });
      }
    }
    return u.get(E) || c;
  }
  const d = 1, f = 2, m = 3, g = 4, v = [null, "isol", "init", "fina", "medi"];
  function _(E) {
    const C = new Uint8Array(E.length);
    let P = c, T = d, I = -1;
    for (let D = 0; D < E.length; D++) {
      const U = E.codePointAt(D);
      let L = h(U) | 0, k = d;
      L & a || (P & (n | o | l) ? L & (r | o | l) ? (k = m, (T === d || T === m) && C[I]++) : L & (n | c) && (T === f || T === g) && C[I]-- : P & (r | c) && (T === f || T === g) && C[I]--, T = C[D] = k, P = L, I = D, U > 65535 && D++);
    }
    return C;
  }
  function y(E, C) {
    const P = [];
    for (let I = 0; I < C.length; I++) {
      const D = C.codePointAt(I);
      D > 65535 && I++, P.push(s.U.codeToGlyph(E, D));
    }
    const T = E.GSUB;
    if (T) {
      const { lookupList: I, featureList: D } = T;
      let U;
      const L = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, k = [];
      D.forEach((B) => {
        if (L.test(B.tag))
          for (let j = 0; j < B.tab.length; j++) {
            if (k[B.tab[j]]) continue;
            k[B.tab[j]] = !0;
            const q = I[B.tab[j]], Z = /^(isol|init|fina|medi)$/.test(B.tag);
            Z && !U && (U = _(C));
            for (let N = 0; N < P.length; N++)
              (!U || !Z || v[U[N]] === B.tag) && s.U._applySubs(P, N, q, I);
          }
      });
    }
    return P;
  }
  function w(E, C) {
    const P = new Int16Array(C.length * 3);
    let T = 0;
    for (; T < C.length; T++) {
      const L = C[T];
      if (L === -1) continue;
      P[T * 3 + 2] = E.hmtx.aWidth[L];
      const k = E.GPOS;
      if (k) {
        const B = k.lookupList;
        for (let j = 0; j < B.length; j++) {
          const q = B[j];
          for (let Z = 0; Z < q.tabs.length; Z++) {
            const N = q.tabs[Z];
            if (q.ltype === 1) {
              if (s._lctf.coverageIndex(N.coverage, L) !== -1 && N.pos) {
                U(N.pos, T);
                break;
              }
            } else if (q.ltype === 2) {
              let z = null, J = I();
              if (J !== -1) {
                const se = s._lctf.coverageIndex(N.coverage, C[J]);
                if (se !== -1) {
                  if (N.fmt === 1) {
                    const K = N.pairsets[se];
                    for (let Q = 0; Q < K.length; Q++)
                      K[Q].gid2 === L && (z = K[Q]);
                  } else if (N.fmt === 2) {
                    const K = s.U._getGlyphClass(C[J], N.classDef1), Q = s.U._getGlyphClass(L, N.classDef2);
                    z = N.matrix[K][Q];
                  }
                  if (z) {
                    z.val1 && U(z.val1, J), z.val2 && U(z.val2, T);
                    break;
                  }
                }
              }
            } else if (q.ltype === 4) {
              const z = s._lctf.coverageIndex(N.markCoverage, L);
              if (z !== -1) {
                const J = I(D), se = J === -1 ? -1 : s._lctf.coverageIndex(N.baseCoverage, C[J]);
                if (se !== -1) {
                  const K = N.markArray[z], Q = N.baseArray[se][K.markClass];
                  P[T * 3] = Q.x - K.x + P[J * 3] - P[J * 3 + 2], P[T * 3 + 1] = Q.y - K.y + P[J * 3 + 1];
                  break;
                }
              }
            } else if (q.ltype === 6) {
              const z = s._lctf.coverageIndex(N.mark1Coverage, L);
              if (z !== -1) {
                const J = I();
                if (J !== -1) {
                  const se = C[J];
                  if (x(E, se) === 3) {
                    const K = s._lctf.coverageIndex(N.mark2Coverage, se);
                    if (K !== -1) {
                      const Q = N.mark1Array[z], de = N.mark2Array[K][Q.markClass];
                      P[T * 3] = de.x - Q.x + P[J * 3] - P[J * 3 + 2], P[T * 3 + 1] = de.y - Q.y + P[J * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (E.kern && !E.cff) {
        const B = I();
        if (B !== -1) {
          const j = E.kern.glyph1.indexOf(C[B]);
          if (j !== -1) {
            const q = E.kern.rval[j].glyph2.indexOf(L);
            q !== -1 && (P[B * 3 + 2] += E.kern.rval[j].vals[q]);
          }
        }
      }
    }
    return P;
    function I(L) {
      for (let k = T - 1; k >= 0; k--)
        if (C[k] !== -1 && (!L || L(C[k])))
          return k;
      return -1;
    }
    function D(L) {
      return x(E, L) === 1;
    }
    function U(L, k) {
      for (let B = 0; B < 3; B++)
        P[k * 3 + B] += L[B] || 0;
    }
  }
  function x(E, C) {
    const P = E.GDEF && E.GDEF.glyphClassDef;
    return P ? s.U._getGlyphClass(C, P) : 0;
  }
  function M(...E) {
    for (let C = 0; C < E.length; C++)
      if (typeof E[C] == "number")
        return E[C];
  }
  function A(E) {
    const C = /* @__PURE__ */ Object.create(null), P = E["OS/2"], T = E.hhea, I = E.head.unitsPerEm, D = M(P && P.sTypoAscender, T && T.ascender, I), U = {
      unitsPerEm: I,
      ascender: D,
      descender: M(P && P.sTypoDescender, T && T.descender, 0),
      capHeight: M(P && P.sCapHeight, D),
      xHeight: M(P && P.sxHeight, D),
      lineGap: M(P && P.sTypoLineGap, T && T.lineGap),
      supportsCodePoint(L) {
        return s.U.codeToGlyph(E, L) > 0;
      },
      forEachGlyph(L, k, B, j) {
        let q = 0;
        const Z = 1 / U.unitsPerEm * k, N = y(E, L);
        let z = 0;
        const J = w(E, N);
        return N.forEach((se, K) => {
          if (se !== -1) {
            let Q = C[se];
            if (!Q) {
              const { cmds: de, crds: ce } = s.U.glyphToPath(E, se);
              let _e = "", Fe = 0;
              for (let $ = 0, Ue = de.length; $ < Ue; $++) {
                const Me = t[de[$]];
                _e += de[$];
                for (let oe = 1; oe <= Me; oe++)
                  _e += (oe > 1 ? "," : "") + ce[Fe++];
              }
              let Ie, Ee, me, xe;
              if (ce.length) {
                Ie = Ee = 1 / 0, me = xe = -1 / 0;
                for (let $ = 0, Ue = ce.length; $ < Ue; $ += 2) {
                  let Me = ce[$], oe = ce[$ + 1];
                  Me < Ie && (Ie = Me), oe < Ee && (Ee = oe), Me > me && (me = Me), oe > xe && (xe = oe);
                }
              } else
                Ie = me = Ee = xe = 0;
              Q = C[se] = {
                index: se,
                advanceWidth: E.hmtx.aWidth[se],
                xMin: Ie,
                yMin: Ee,
                xMax: me,
                yMax: xe,
                path: _e
              };
            }
            j.call(
              null,
              Q,
              q + J[K * 3] * Z,
              J[K * 3 + 1] * Z,
              z
            ), q += J[K * 3 + 2] * Z, B && (q += B * k);
          }
          z += L.codePointAt(z) > 65535 ? 2 : 1;
        }), q;
      }
    };
    return U;
  }
  return function(C) {
    const P = new Uint8Array(C, 0, 4), T = s._bin.readASCII(P, 0, 4);
    if (T === "wOFF")
      C = e(C);
    else if (T === "wOF2")
      throw new Error("woff2 fonts not supported");
    return A(s.parse(C)[0]);
  };
}
const Iq = /* @__PURE__ */ Ld({
  name: "Typr Font Parser",
  dependencies: [Pq, Rq, Dq],
  init(s, e, t) {
    const i = s(), n = e();
    return t(i, n);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function Lq() {
  return function(s) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(w) {
      var x = w >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & w));
    }, e.prototype.has = function(w) {
      var x = this.buckets.get(w >> 5);
      return x !== void 0 && (x & 1 << (31 & w)) != 0;
    }, e.prototype.serialize = function() {
      var w = [];
      return this.buckets.forEach(function(x, M) {
        w.push((+M).toString(36) + ":" + x.toString(36));
      }), w.join(",");
    }, e.prototype.deserialize = function(w) {
      var x = this;
      this.buckets.clear(), w.split(",").forEach(function(M) {
        var A = M.split(":");
        x.buckets.set(parseInt(A[0], 36), parseInt(A[1], 36));
      });
    };
    var t = Math.pow(2, 8), i = t - 1, n = ~i;
    function r(w) {
      var x = function(A) {
        return A & n;
      }(w).toString(16), M = function(A) {
        return (A & n) + t - 1;
      }(w).toString(16);
      return "codepoint-index/plane" + (w >> 16) + "/" + x + "-" + M + ".json";
    }
    function o(w, x) {
      var M = w & i, A = x.codePointAt(M / 6 | 0);
      return ((A = (A || 48) - 48) & 1 << M % 6) != 0;
    }
    function a(w, x) {
      var M;
      (M = w, M.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(A) {
        return A.split("-").map(function(E) {
          return parseInt(E.trim(), 16);
        });
      })).forEach(function(A) {
        var E = A[0], C = A[1];
        C === void 0 && (C = E), x(E, C);
      });
    }
    function l(w, x) {
      a(w, function(M, A) {
        for (var E = M; E <= A; E++) x(E);
      });
    }
    var c = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(w) {
      var x = h.get(w);
      return x || (x = new e(), l(w.ranges, function(M) {
        return x.add(M);
      }), h.set(w, x)), x;
    }
    var m, g = /* @__PURE__ */ new Map();
    function v(w, x, M) {
      return w[x] ? x : w[M] ? M : function(A) {
        for (var E in A) return E;
      }(w);
    }
    function _(w, x) {
      var M = x;
      if (!w.includes(M)) {
        M = 1 / 0;
        for (var A = 0; A < w.length; A++) Math.abs(w[A] - x) < Math.abs(M - x) && (M = w[A]);
      }
      return M;
    }
    function y(w) {
      return m || (m = /* @__PURE__ */ new Set(), l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        m.add(x);
      })), m.has(w);
    }
    return s.CodePointSet = e, s.clearCache = function() {
      c = {}, u = {};
    }, s.getFontsForString = function(w, x) {
      x === void 0 && (x = {});
      var M, A = x.lang;
      A === void 0 && (A = new RegExp("\\p{Script=Hangul}", "u").test(M = w) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(M) ? "ja" : "en");
      var E = x.category;
      E === void 0 && (E = "sans-serif");
      var C = x.style;
      C === void 0 && (C = "normal");
      var P = x.weight;
      P === void 0 && (P = 400);
      var T = (x.dataUrl || d).replace(/\/$/g, ""), I = /* @__PURE__ */ new Map(), D = new Uint8Array(w.length), U = {}, L = {}, k = new Array(w.length), B = /* @__PURE__ */ new Map(), j = !1;
      function q(z) {
        var J = g.get(z);
        return J || (J = fetch(T + "/" + z).then(function(se) {
          if (!se.ok) throw new Error(se.statusText);
          return se.json().then(function(K) {
            if (!Array.isArray(K) || K[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + K[0]);
            return K[1];
          });
        }).catch(function(se) {
          if (T !== d) return j || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + T + '", trying default CDN. ' + se.message), j = !0), T = d, g.delete(z), q(z);
          throw se;
        }), g.set(z, J)), J;
      }
      for (var Z = function(z) {
        var J = w.codePointAt(z), se = r(J);
        k[z] = se, c[se] || B.has(se) || B.set(se, q(se).then(function(K) {
          c[se] = K;
        })), J > 65535 && (z++, N = z);
      }, N = 0; N < w.length; N++) Z(N);
      return Promise.all(B.values()).then(function() {
        B.clear();
        for (var z = function(se) {
          var K = w.codePointAt(se), Q = null, de = c[k[se]], ce = void 0;
          for (var _e in de) {
            var Fe = L[_e];
            if (Fe === void 0 && (Fe = L[_e] = new RegExp(_e).test(A || "en")), Fe) {
              for (var Ie in ce = _e, de[_e]) if (o(K, de[_e][Ie])) {
                Q = Ie;
                break;
              }
              break;
            }
          }
          if (!Q) {
            e: for (var Ee in de) if (Ee !== ce) {
              for (var me in de[Ee]) if (o(K, de[Ee][me])) {
                Q = me;
                break e;
              }
            }
          }
          Q || (console.debug("No font coverage for U+" + K.toString(16)), Q = "latin"), k[se] = Q, u[Q] || B.has(Q) || B.set(Q, q("font-meta/" + Q + ".json").then(function(xe) {
            u[Q] = xe;
          })), K > 65535 && (se++, J = se);
        }, J = 0; J < w.length; J++) z(J);
        return Promise.all(B.values());
      }).then(function() {
        for (var z, J = null, se = 0; se < w.length; se++) {
          var K = w.codePointAt(se);
          if (J && (y(K) || f(J).has(K))) D[se] = D[se - 1];
          else {
            J = u[k[se]];
            var Q = U[J.id];
            if (!Q) {
              var de = J.typeforms, ce = v(de, E, "sans-serif"), _e = v(de[ce], C, "normal"), Fe = _((z = de[ce]) === null || z === void 0 ? void 0 : z[_e], P);
              Q = U[J.id] = T + "/font-files/" + J.id + "/" + ce + "." + _e + "." + Fe + ".woff";
            }
            var Ie = I.get(Q);
            Ie == null && (Ie = I.size, I.set(Q, Ie)), D[se] = Ie;
          }
          K > 65535 && (se++, D[se] = D[se - 1]);
        }
        return { fontUrls: Array.from(I.keys()), chars: D };
      });
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({});
}
function Uq(s, e) {
  const t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function n(o, a) {
    const l = (c) => {
      console.error(`Failure loading font ${o}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", o, !0), c.responseType = "arraybuffer", c.onload = function() {
        if (c.status >= 400)
          l(new Error(c.statusText));
        else if (c.status > 0)
          try {
            const u = s(c.response);
            u.src = o, a(u);
          } catch (u) {
            l(u);
          }
      }, c.onerror = l, c.send();
    } catch (c) {
      l(c);
    }
  }
  function r(o, a) {
    let l = t[o];
    l ? a(l) : i[o] ? i[o].push(a) : (i[o] = [a], n(o, (c) => {
      c.src = o, t[o] = c, i[o].forEach((u) => u(c)), delete i[o];
    }));
  }
  return function(o, a, {
    lang: l,
    fonts: c = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), m = [];
    o.length || y();
    const g = /* @__PURE__ */ new Map(), v = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), c && !Array.isArray(c) && (c = [c]), c = c.slice().filter((x) => !x.lang || x.lang.test(l)).reverse(), c.length) {
      let E = 0;
      (function C(P = 0) {
        for (let T = P, I = o.length; T < I; T++) {
          const D = o.codePointAt(T);
          if (E === 1 && m[f[T - 1]].supportsCodePoint(D) || /\s/.test(o[T]))
            f[T] = f[T - 1], E === 2 && (v[v.length - 1][1] = T);
          else
            for (let U = f[T], L = c.length; U <= L; U++)
              if (U === L) {
                const k = E === 2 ? v[v.length - 1] : v[v.length] = [T, T];
                k[1] = T, E = 2;
              } else {
                f[T] = U;
                const { src: k, unicodeRange: B } = c[U];
                if (!B || w(D, B)) {
                  const j = t[k];
                  if (!j) {
                    r(k, () => {
                      C(T);
                    });
                    return;
                  }
                  if (j.supportsCodePoint(D)) {
                    let q = g.get(j);
                    typeof q != "number" && (q = m.length, m.push(j), g.set(j, q)), f[T] = q, E = 1;
                    break;
                  }
                }
              }
          D > 65535 && T + 1 < I && (f[T + 1] = f[T], T++, E === 2 && (v[v.length - 1][1] = T));
        }
        _();
      })();
    } else
      v.push([0, o.length - 1]), _();
    function _() {
      if (v.length) {
        const x = v.map((M) => o.substring(M[0], M[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: l || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: M, chars: A }) => {
          const E = m.length;
          let C = 0;
          v.forEach((T) => {
            for (let I = 0, D = T[1] - T[0]; I <= D; I++)
              f[T[0] + I] = A[C++] + E;
            C++;
          });
          let P = 0;
          M.forEach((T, I) => {
            r(T, (D) => {
              m[I + E] = D, ++P === M.length && y();
            });
          });
        });
      } else
        y();
    }
    function y() {
      a({
        chars: f,
        fonts: m
      });
    }
    function w(x, M) {
      for (let A = 0; A < M.length; A++) {
        const [E, C = E] = M[A];
        if (E <= x && x <= C)
          return !0;
      }
      return !1;
    }
  };
}
const kq = /* @__PURE__ */ Ld({
  name: "FontResolver",
  dependencies: [
    Uq,
    Iq,
    Lq
  ],
  init(s, e, t) {
    return s(e, t());
  }
});
function Oq(s, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", r = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: m, lang: g, fonts: v, style: _, weight: y, preResolvedFonts: w, unicodeFontsURL: x }, M) {
    const A = ({ chars: E, fonts: C }) => {
      let P, T;
      const I = [];
      for (let D = 0; D < E.length; D++)
        E[D] !== T ? (T = E[D], I.push(P = { start: D, end: D, fontObj: C[E[D]] })) : P.end = D;
      M(I);
    };
    w ? A(w) : s(
      m,
      A,
      { lang: g, fonts: v, style: _, weight: y, unicodeFontsURL: x }
    );
  }
  function a({
    text: m = "",
    font: g,
    lang: v,
    sdfGlyphSize: _ = 64,
    fontSize: y = 400,
    fontWeight: w = 1,
    fontStyle: x = "normal",
    letterSpacing: M = 0,
    lineHeight: A = "normal",
    maxWidth: E = 1 / 0,
    direction: C,
    textAlign: P = "left",
    textIndent: T = 0,
    whiteSpace: I = "normal",
    overflowWrap: D = "normal",
    anchorX: U = 0,
    anchorY: L = 0,
    metricsOnly: k = !1,
    unicodeFontsURL: B,
    preResolvedFonts: j = null,
    includeCaretPositions: q = !1,
    chunkedBoundsSize: Z = 8192,
    colorRanges: N = null
  }, z) {
    const J = h(), se = { fontLoad: 0, typesetting: 0 };
    m.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), m = m.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), y = +y, M = +M, E = +E, A = A || "normal", T = +T, o({
      text: m,
      lang: v,
      style: x,
      weight: w,
      fonts: typeof g == "string" ? [{ src: g }] : g,
      unicodeFontsURL: B,
      preResolvedFonts: j
    }, (K) => {
      se.fontLoad = h() - J;
      const Q = isFinite(E);
      let de = null, ce = null, _e = null, Fe = null, Ie = null, Ee = null, me = null, xe = null, $ = 0, Ue = 0, Me = I !== "nowrap";
      const oe = /* @__PURE__ */ new Map(), Te = h();
      let Ye = T, Oe = 0, X = new d();
      const Y = [X];
      K.forEach((ye) => {
        const { fontObj: Ae } = ye, { ascender: Ce, descender: Ge, unitsPerEm: De, lineGap: Ve, capHeight: ze, xHeight: Ze } = Ae;
        let Le = oe.get(Ae);
        if (!Le) {
          const ve = y / De, be = A === "normal" ? (Ce - Ge + Ve) * ve : A * y, Xe = (be - (Ce - Ge) * ve) / 2, We = Math.min(be, (Ce - Ge) * ve), Ne = (Ce + Ge) / 2 * ve + We / 2;
          Le = {
            index: oe.size,
            src: Ae.src,
            fontObj: Ae,
            fontSizeMult: ve,
            unitsPerEm: De,
            ascender: Ce * ve,
            descender: Ge * ve,
            capHeight: ze * ve,
            xHeight: Ze * ve,
            lineHeight: be,
            baseline: -Xe - Ce * ve,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: Ne,
            caretBottom: Ne - We
          }, oe.set(Ae, Le);
        }
        const { fontSizeMult: ot } = Le, tt = m.slice(ye.start, ye.end + 1);
        let mt, le;
        Ae.forEachGlyph(tt, y, M, (ve, be, Xe, We) => {
          be += Oe, We += ye.start, mt = be, le = ve;
          const Ne = m.charAt(We), ct = ve.advanceWidth * ot, gt = X.count;
          let nt;
          if ("isEmpty" in ve || (ve.isWhitespace = !!Ne && new RegExp(n).test(Ne), ve.canBreakAfter = !!Ne && r.test(Ne), ve.isEmpty = ve.xMin === ve.xMax || ve.yMin === ve.yMax || i.test(Ne)), !ve.isWhitespace && !ve.isEmpty && Ue++, Me && Q && !ve.isWhitespace && be + ct + Ye > E && gt) {
            if (X.glyphAt(gt - 1).glyphObj.canBreakAfter)
              nt = new d(), Ye = -be;
            else
              for (let at = gt; at--; )
                if (at === 0 && D === "break-word") {
                  nt = new d(), Ye = -be;
                  break;
                } else if (X.glyphAt(at).glyphObj.canBreakAfter) {
                  nt = X.splitAt(at + 1);
                  const ft = nt.glyphAt(0).x;
                  Ye -= ft;
                  for (let Qe = nt.count; Qe--; )
                    nt.glyphAt(Qe).x -= ft;
                  break;
                }
            nt && (X.isSoftWrapped = !0, X = nt, Y.push(X), $ = E);
          }
          let je = X.glyphAt(X.count);
          je.glyphObj = ve, je.x = be + Ye, je.y = Xe, je.width = ct, je.charIndex = We, je.fontData = Le, Ne === `
` && (X = new d(), Y.push(X), Ye = -(be + ct + M * y) + T);
        }), Oe = mt + le.advanceWidth * ot + M * y;
      });
      let fe = 0;
      Y.forEach((ye) => {
        let Ae = !0;
        for (let Ce = ye.count; Ce--; ) {
          const Ge = ye.glyphAt(Ce);
          Ae && !Ge.glyphObj.isWhitespace && (ye.width = Ge.x + Ge.width, ye.width > $ && ($ = ye.width), Ae = !1);
          let { lineHeight: De, capHeight: Ve, xHeight: ze, baseline: Ze } = Ge.fontData;
          De > ye.lineHeight && (ye.lineHeight = De);
          const Le = Ze - ye.baseline;
          Le < 0 && (ye.baseline += Le, ye.cap += Le, ye.ex += Le), ye.cap = Math.max(ye.cap, ye.baseline + Ve), ye.ex = Math.max(ye.ex, ye.baseline + ze);
        }
        ye.baseline -= fe, ye.cap -= fe, ye.ex -= fe, fe += ye.lineHeight;
      });
      let ue = 0, te = 0;
      if (U && (typeof U == "number" ? ue = -U : typeof U == "string" && (ue = -$ * (U === "left" ? 0 : U === "center" ? 0.5 : U === "right" ? 1 : c(U)))), L && (typeof L == "number" ? te = -L : typeof L == "string" && (te = L === "top" ? 0 : L === "top-baseline" ? -Y[0].baseline : L === "top-cap" ? -Y[0].cap : L === "top-ex" ? -Y[0].ex : L === "middle" ? fe / 2 : L === "bottom" ? fe : L === "bottom-baseline" ? -Y[Y.length - 1].baseline : c(L) * fe)), !k) {
        const ye = e.getEmbeddingLevels(m, C);
        de = new Uint16Array(Ue), ce = new Uint8Array(Ue), _e = new Float32Array(Ue * 2), Fe = {}, me = [1 / 0, 1 / 0, -1 / 0, -1 / 0], xe = [], q && (Ee = new Float32Array(m.length * 4)), N && (Ie = new Uint8Array(Ue * 3));
        let Ae = 0, Ce = -1, Ge = -1, De, Ve;
        if (Y.forEach((ze, Ze) => {
          let { count: Le, width: ot } = ze;
          if (Le > 0) {
            let tt = 0;
            for (let We = Le; We-- && ze.glyphAt(We).glyphObj.isWhitespace; )
              tt++;
            let mt = 0, le = 0;
            if (P === "center")
              mt = ($ - ot) / 2;
            else if (P === "right")
              mt = $ - ot;
            else if (P === "justify" && ze.isSoftWrapped) {
              let We = 0;
              for (let Ne = Le - tt; Ne--; )
                ze.glyphAt(Ne).glyphObj.isWhitespace && We++;
              le = ($ - ot) / We;
            }
            if (le || mt) {
              let We = 0;
              for (let Ne = 0; Ne < Le; Ne++) {
                let ct = ze.glyphAt(Ne);
                const gt = ct.glyphObj;
                ct.x += mt + We, le !== 0 && gt.isWhitespace && Ne < Le - tt && (We += le, ct.width += le);
              }
            }
            const ve = e.getReorderSegments(
              m,
              ye,
              ze.glyphAt(0).charIndex,
              ze.glyphAt(ze.count - 1).charIndex
            );
            for (let We = 0; We < ve.length; We++) {
              const [Ne, ct] = ve[We];
              let gt = 1 / 0, nt = -1 / 0;
              for (let je = 0; je < Le; je++)
                if (ze.glyphAt(je).charIndex >= Ne) {
                  let at = je, ft = je;
                  for (; ft < Le; ft++) {
                    let Qe = ze.glyphAt(ft);
                    if (Qe.charIndex > ct)
                      break;
                    ft < Le - tt && (gt = Math.min(gt, Qe.x), nt = Math.max(nt, Qe.x + Qe.width));
                  }
                  for (let Qe = at; Qe < ft; Qe++) {
                    const xt = ze.glyphAt(Qe);
                    xt.x = nt - (xt.x + xt.width - gt);
                  }
                  break;
                }
            }
            let be;
            const Xe = (We) => be = We;
            for (let We = 0; We < Le; We++) {
              const Ne = ze.glyphAt(We);
              be = Ne.glyphObj;
              const ct = be.index, gt = ye.levels[Ne.charIndex] & 1;
              if (gt) {
                const nt = e.getMirroredCharacter(m[Ne.charIndex]);
                nt && Ne.fontData.fontObj.forEachGlyph(nt, 0, 0, Xe);
              }
              if (q) {
                const { charIndex: nt, fontData: je } = Ne, at = Ne.x + ue, ft = Ne.x + Ne.width + ue;
                Ee[nt * 4] = gt ? ft : at, Ee[nt * 4 + 1] = gt ? at : ft, Ee[nt * 4 + 2] = ze.baseline + je.caretBottom + te, Ee[nt * 4 + 3] = ze.baseline + je.caretTop + te;
                const Qe = nt - Ce;
                Qe > 1 && u(Ee, Ce, Qe), Ce = nt;
              }
              if (N) {
                const { charIndex: nt } = Ne;
                for (; nt > Ge; )
                  Ge++, N.hasOwnProperty(Ge) && (Ve = N[Ge]);
              }
              if (!be.isWhitespace && !be.isEmpty) {
                const nt = Ae++, { fontSizeMult: je, src: at, index: ft } = Ne.fontData, Qe = Fe[at] || (Fe[at] = {});
                Qe[ct] || (Qe[ct] = {
                  path: be.path,
                  pathBounds: [be.xMin, be.yMin, be.xMax, be.yMax]
                });
                const xt = Ne.x + ue, yt = Ne.y + ze.baseline + te;
                _e[nt * 2] = xt, _e[nt * 2 + 1] = yt;
                const Mt = xt + be.xMin * je, nn = yt + be.yMin * je, zt = xt + be.xMax * je, $t = yt + be.yMax * je;
                Mt < me[0] && (me[0] = Mt), nn < me[1] && (me[1] = nn), zt > me[2] && (me[2] = zt), $t > me[3] && (me[3] = $t), nt % Z === 0 && (De = { start: nt, end: nt, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, xe.push(De)), De.end++;
                const qt = De.rect;
                if (Mt < qt[0] && (qt[0] = Mt), nn < qt[1] && (qt[1] = nn), zt > qt[2] && (qt[2] = zt), $t > qt[3] && (qt[3] = $t), de[nt] = ct, ce[nt] = ft, N) {
                  const en = nt * 3;
                  Ie[en] = Ve >> 16 & 255, Ie[en + 1] = Ve >> 8 & 255, Ie[en + 2] = Ve & 255;
                }
              }
            }
          }
        }), Ee) {
          const ze = m.length - Ce;
          ze > 1 && u(Ee, Ce, ze);
        }
      }
      const Se = [];
      oe.forEach(({ index: ye, src: Ae, unitsPerEm: Ce, ascender: Ge, descender: De, lineHeight: Ve, capHeight: ze, xHeight: Ze }) => {
        Se[ye] = { src: Ae, unitsPerEm: Ce, ascender: Ge, descender: De, lineHeight: Ve, capHeight: ze, xHeight: Ze };
      }), se.typesetting = h() - Te, z({
        glyphIds: de,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: ce,
        //index into fontData for each glyph
        glyphPositions: _e,
        //x,y of each glyph's origin in layout
        glyphData: Fe,
        //dict holding data about each glyph appearing in the text
        fontData: Se,
        //data about each font used in the text
        caretPositions: Ee,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: Ie,
        //color for each glyph, if color ranges supplied
        chunkedBounds: xe,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: y,
        //calculated em height
        topBaseline: te + Y[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          ue,
          te - fe,
          ue + $,
          te
        ],
        visibleBounds: me,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: se
      });
    });
  }
  function l(m, g) {
    a({ ...m, metricsOnly: !0 }, (v) => {
      const [_, y, w, x] = v.blockBounds;
      g({
        width: w - _,
        height: x - y
      });
    });
  }
  function c(m) {
    let g = m.match(/^([\d.]+)%$/), v = g ? parseFloat(g[1]) : NaN;
    return isNaN(v) ? 0 : v / 100;
  }
  function u(m, g, v) {
    const _ = m[g * 4], y = m[g * 4 + 1], w = m[g * 4 + 2], x = m[g * 4 + 3], M = (y - _) / v;
    for (let A = 0; A < v; A++) {
      const E = (g + A) * 4;
      m[E] = _ + M * A, m[E + 1] = _ + M * (A + 1), m[E + 2] = w, m[E + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(m) {
      let g = d.flyweight;
      return g.data = this.data, g.index = m, g;
    },
    splitAt(m) {
      let g = new d();
      return g.data = this.data.splice(m * f.length), g;
    }
  }, d.flyweight = f.reduce((m, g, v, _) => (Object.defineProperty(m, g, {
    get() {
      return this.data[this.index * f.length + v];
    },
    set(y) {
      this.data[this.index * f.length + v] = y;
    }
  }), m), { data: null, index: 0 }), {
    typeset: a,
    measure: l
  };
}
const su = () => (self.performance || Date).now(), hy = /* @__PURE__ */ cy();
let pC;
function Fq(s, e, t, i, n, r, o, a, l, c, u = !0) {
  return u ? Bq(s, e, t, i, n, r, o, a, l, c).then(
    null,
    (h) => (pC || (console.warn("WebGL SDF generation failed, falling back to JS", h), pC = !0), gC(s, e, t, i, n, r, o, a, l, c))
  ) : gC(s, e, t, i, n, r, o, a, l, c);
}
const Wv = [], Nq = 5;
let K1 = 0;
function O3() {
  const s = su();
  for (; Wv.length && su() - s < Nq; )
    Wv.shift()();
  K1 = Wv.length ? setTimeout(O3, 0) : 0;
}
const Bq = (...s) => new Promise((e, t) => {
  Wv.push(() => {
    const i = su();
    try {
      hy.webgl.generateIntoCanvas(...s), e({ timing: su() - i });
    } catch (n) {
      t(n);
    }
  }), K1 || (K1 = setTimeout(O3, 0));
}), zq = 4, Vq = 2e3, mC = {};
let Gq = 0;
function gC(s, e, t, i, n, r, o, a, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + Gq++ % zq;
  let h = mC[u];
  return h || (h = mC[u] = {
    workerModule: Ld({
      name: u,
      workerId: u,
      dependencies: [
        cy,
        su
      ],
      init(d, f) {
        const m = d().javascript.generate;
        return function(...g) {
          const v = f();
          return {
            textureData: m(...g),
            timing: f() - v
          };
        };
      },
      getTransferables(d) {
        return [d.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(s, e, t, i, n, r).then(({ textureData: d, timing: f }) => {
    const m = su(), g = new Uint8Array(d.length * 4);
    for (let v = 0; v < d.length; v++)
      g[v * 4 + c] = d[v];
    return hy.webglUtils.renderImageData(o, g, a, l, s, e, 1 << 3 - c), f += su() - m, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      xq(u);
    }, Vq)), { timing: f };
  });
}
function Hq(s) {
  s._warm || (hy.webgl.isSupported(s), s._warm = !0);
}
const Wq = hy.webglUtils.resizeWebGLCanvasWithoutClearing, Hf = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, Xq = /* @__PURE__ */ new rt();
function Th() {
  return (self.performance || Date).now();
}
const vC = /* @__PURE__ */ Object.create(null);
function F3(s, e) {
  s = qq({}, s);
  const t = Th(), i = [];
  if (s.font && i.push({ label: "user", src: Zq(s.font) }), s.font = i, s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || Hf.sdfGlyphSize, s.unicodeFontsURL = s.unicodeFontsURL || Hf.unicodeFontsURL, s.colorRanges != null) {
    let h = {};
    for (let d in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(d)) {
        let f = s.colorRanges[d];
        typeof f != "number" && (f = Xq.set(f).getHex()), h[d] = f;
      }
    s.colorRanges = h;
  }
  Object.freeze(s);
  const { textureWidth: n, sdfExponent: r } = Hf, { sdfGlyphSize: o } = s, a = n / o * 4;
  let l = vC[o];
  if (!l) {
    const h = document.createElement("canvas");
    h.width = n, h.height = o * 256 / a, l = vC[o] = {
      glyphCount: 0,
      sdfGlyphSize: o,
      sdfCanvas: h,
      sdfTexture: new ei(
        h,
        void 0,
        void 0,
        void 0,
        Sn,
        Sn
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, l.sdfTexture.generateMipmaps = !1, Yq(l);
  }
  const { sdfTexture: c, sdfCanvas: u } = l;
  $q(s).then((h) => {
    const { glyphIds: d, glyphFontIndices: f, fontData: m, glyphPositions: g, fontSize: v, timings: _ } = h, y = [], w = new Float32Array(d.length * 4);
    let x = 0, M = 0;
    const A = Th(), E = m.map((D) => {
      let U = l.glyphsByFont.get(D.src);
      return U || l.glyphsByFont.set(D.src, U = /* @__PURE__ */ new Map()), U;
    });
    d.forEach((D, U) => {
      const L = f[U], { src: k, unitsPerEm: B } = m[L];
      let j = E[L].get(D);
      if (!j) {
        const { path: J, pathBounds: se } = h.glyphData[k][D], K = Math.max(se[2] - se[0], se[3] - se[1]) / o * (Hf.sdfMargin * o + 0.5), Q = l.glyphCount++, de = [
          se[0] - K,
          se[1] - K,
          se[2] + K,
          se[3] + K
        ];
        E[L].set(D, j = { path: J, atlasIndex: Q, sdfViewBox: de }), y.push(j);
      }
      const { sdfViewBox: q } = j, Z = g[M++], N = g[M++], z = v / B;
      w[x++] = Z + q[0] * z, w[x++] = N + q[1] * z, w[x++] = Z + q[2] * z, w[x++] = N + q[3] * z, d[U] = j.atlasIndex;
    }), _.quads = (_.quads || 0) + (Th() - A);
    const C = Th();
    _.sdf = {};
    const P = u.height, T = Math.ceil(l.glyphCount / a), I = Math.pow(2, Math.ceil(Math.log2(T * o)));
    I > P && (console.info(`Increasing SDF texture size ${P}->${I}`), Wq(u, n, I), c.dispose()), Promise.all(y.map(
      (D) => N3(D, l, s.gpuAccelerateSDF).then(({ timing: U }) => {
        _.sdf[D.atlasIndex] = U;
      })
    )).then(() => {
      y.length && !l.contextLost && (B3(l), c.needsUpdate = !0), _.sdfTotal = Th() - C, _.total = Th() - t, e(Object.freeze({
        parameters: s,
        sdfTexture: c,
        sdfGlyphSize: o,
        sdfExponent: r,
        glyphBounds: w,
        glyphAtlasIndices: d,
        glyphColors: h.glyphColors,
        caretPositions: h.caretPositions,
        chunkedBounds: h.chunkedBounds,
        ascender: h.ascender,
        descender: h.descender,
        lineHeight: h.lineHeight,
        capHeight: h.capHeight,
        xHeight: h.xHeight,
        topBaseline: h.topBaseline,
        blockBounds: h.blockBounds,
        visibleBounds: h.visibleBounds,
        timings: h.timings
      }));
    });
  }), Promise.resolve().then(() => {
    l.contextLost || Hq(u);
  });
}
function N3({ path: s, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: i, sdfCanvas: n, contextLost: r }, o) {
  if (r)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: a, sdfExponent: l } = Hf, c = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (a / i) * i, d = Math.floor(u / (a / i)) * i, f = e % 4;
  return Fq(i, i, s, t, c, l, n, h, d, f, o);
}
function Yq(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), s.contextLost = !1;
    const i = [];
    s.glyphsByFont.forEach((n) => {
      n.forEach((r) => {
        i.push(N3(r, s, !0));
      });
    }), Promise.all(i).then(() => {
      B3(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function jq({ font: s, characters: e, sdfGlyphSize: t }, i) {
  let n = Array.isArray(e) ? e.join(`
`) : "" + e;
  F3({ font: s, sdfGlyphSize: t, text: n }, i);
}
function qq(s, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (s[t] = e[t]);
  return s;
}
let vv;
function Zq(s) {
  return vv || (vv = typeof document > "u" ? {} : document.createElement("a")), vv.href = s, vv.href;
}
function B3(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = s, { width: i, height: n } = e, r = s.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    (!o || o.length !== i * n * 4) && (o = new Uint8Array(i * n * 4), t.image = { width: i, height: n, data: o }, t.flipY = !1, t.isDataTexture = !0), r.readPixels(0, 0, i, n, r.RGBA, r.UNSIGNED_BYTE, o);
  }
}
const Kq = /* @__PURE__ */ Ld({
  name: "Typesetter",
  dependencies: [
    Oq,
    kq,
    a3
  ],
  init(s, e, t) {
    return s(e, t());
  }
}), $q = /* @__PURE__ */ Ld({
  name: "Typesetter",
  dependencies: [
    Kq
  ],
  init(s) {
    return function(e) {
      return new Promise((t) => {
        s.typeset(e, t);
      });
    };
  },
  getTransferables(s) {
    const e = [];
    for (let t in s)
      s[t] && s[t].buffer && e.push(s[t].buffer);
    return e;
  }
}), _C = {};
function Jq(s) {
  let e = _C[s];
  return e || (e = _C[s] = new $r(1, 1, s, s).translate(0.5, 0.5, 0)), e;
}
const Qq = "aTroikaGlyphBounds", yC = "aTroikaGlyphIndex", eZ = "aTroikaGlyphColor";
class tZ extends pm {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new fi(), this.boundingBox = new yn();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = Jq(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = t.attributes[i].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, i, n, r) {
    this.updateAttributeData(Qq, e, 4), this.updateAttributeData(yC, t, 1), this.updateAttributeData(eZ, r, 3), this._blockBounds = i, this._chunkedBounds = n, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: i } = this;
      if (t) {
        const { PI: n, floor: r, min: o, max: a, sin: l, cos: c } = Math, u = n / 2, h = n * 2, d = Math.abs(t), f = e[0] / d, m = e[2] / d, g = r((f + u) / h) !== r((m + u) / h) ? -d : o(l(f) * d, l(m) * d), v = r((f - u) / h) !== r((m - u) / h) ? d : a(l(f) * d, l(m) * d), _ = r((f + n) / h) !== r((m + n) / h) ? d * 2 : a(d - c(f) * d, d - c(m) * d);
        i.min.set(g, e[1], t < 0 ? -_ : 0), i.max.set(v, e[3], t < 0 ? 0 : _);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(yC).count, i = this._chunkedBounds;
    if (i)
      for (let n = i.length; n--; ) {
        t = i[n].end;
        let r = i[n].rect;
        if (r[1] < e.w && r[3] > e.y && r[0] < e.z && r[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(e, t, i) {
    const n = this.getAttribute(e);
    t ? n && n.array.length === t.length ? (n.array.set(t), n.needsUpdate = !0) : (this.setAttribute(e, new Jo(t, i)), delete this._maxInstanceCount, this.dispose()) : n && this.deleteAttribute(e);
  }
}
const nZ = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, iZ = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, rZ = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, sZ = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function oZ(s) {
  const e = Z1(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Be() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Kt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Kt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Be() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new rt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Jt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: nZ,
    vertexTransform: iZ,
    fragmentDefs: rZ,
    fragmentColorTransform: sZ,
    customRewriter({ vertexShader: t, fragmentShader: i }) {
      let n = /\buniform\s+vec3\s+diffuse\b/;
      return n.test(i) && (i = i.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(t) || (t = t.replace(
        k3,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: i };
    }
  });
  return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const oM = /* @__PURE__ */ new qn({
  color: 16777215,
  side: wi,
  transparent: !0
}), xC = 8421504, bC = /* @__PURE__ */ new _t(), _v = /* @__PURE__ */ new H(), Ab = /* @__PURE__ */ new H(), Cf = [], aZ = /* @__PURE__ */ new H(), Cb = "+x+y";
function wC(s) {
  return Array.isArray(s) ? s[0] : s;
}
let z3 = () => {
  const s = new it(
    new $r(1, 1),
    oM
  );
  return z3 = () => s, s;
}, V3 = () => {
  const s = new it(
    new $r(1, 1, 32, 1),
    oM
  );
  return V3 = () => s, s;
};
const lZ = { type: "syncstart" }, cZ = { type: "synccomplete" }, G3 = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], uZ = G3.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
let H3 = class extends it {
  constructor() {
    const e = new tZ();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = xC, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = Cb, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(lZ), F3({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((n) => n && n());
      })), this.dispatchEvent(cZ), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, i, n, r, o) {
    this.sync(), r.isTroikaTextMaterial && this._prepareForRender(r);
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(e) {
    return oZ(e);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = oM.clone());
    if ((!e || !e.isDerivedFrom(t)) && (e = this._derivedMaterial = this.createDerivedMaterial(t), t.addEventListener("dispose", function i() {
      t.removeEventListener("dispose", i), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function n() {
        e.removeEventListener("dispose", n), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return wC(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return wC(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, i = e.uniforms, n = this.textRenderInfo;
    if (n) {
      const { sdfTexture: a, blockBounds: l } = n;
      i.uTroikaSDFTexture.value = a, i.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height), i.uTroikaSDFGlyphSize.value = n.sdfGlyphSize, i.uTroikaSDFExponent.value = n.sdfExponent, i.uTroikaTotalBounds.value.fromArray(l), i.uTroikaUseGlyphColors.value = !t && !!n.glyphColors;
      let c = 0, u = 0, h = 0, d, f, m, g = 0, v = 0;
      if (t) {
        let { outlineWidth: y, outlineOffsetX: w, outlineOffsetY: x, outlineBlur: M, outlineOpacity: A } = this;
        c = this._parsePercent(y) || 0, u = Math.max(0, this._parsePercent(M) || 0), d = A, g = this._parsePercent(w) || 0, v = this._parsePercent(x) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (m = this.strokeColor, i.uTroikaStrokeColor.value.set(m ?? xC), f = this.strokeOpacity, f == null && (f = 1)), d = this.fillOpacity;
      i.uTroikaDistanceOffset.value = c, i.uTroikaPositionOffset.value.set(g, v), i.uTroikaBlurRadius.value = u, i.uTroikaStrokeWidth.value = h, i.uTroikaStrokeOpacity.value = f, i.uTroikaFillOpacity.value = d ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let _ = this.clipRect;
      if (_ && Array.isArray(_) && _.length === 4)
        i.uTroikaClipRect.value.fromArray(_);
      else {
        const y = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          l[0] - y,
          l[1] - y,
          l[2] + y,
          l[3] + y
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const r = t ? this.outlineColor || 0 : this.color;
    if (r == null)
      delete e.color;
    else {
      const a = e.hasOwnProperty("color") ? e.color : e.color = new rt();
      (r !== a._input || typeof r == "object") && a.set(a._input = r);
    }
    let o = this.orientation || Cb;
    if (o !== e._orientation) {
      let a = i.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let l = o !== Cb && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, h, d] = l;
        _v.set(0, 0, 0)[u] = c === "-" ? 1 : -1, Ab.set(0, 0, 0)[d] = h === "-" ? -1 : 1, bC.lookAt(aZ, _v.cross(Ab), Ab), a.setFromMatrix4(bC);
      } else
        a.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), i = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new Be()) {
    t.copy(e);
    const i = this.curveRadius;
    return i && (t.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new Be()) {
    return _v.copy(e), this.localPositionToTextCoords(this.worldToLocal(_v), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: i, curveRadius: n } = this;
    if (i) {
      const r = i.blockBounds, o = n ? V3() : z3(), a = o.geometry, { position: l, uv: c } = a.attributes;
      for (let u = 0; u < c.count; u++) {
        let h = r[0] + c.getX(u) * (r[2] - r[0]);
        const d = r[1] + c.getY(u) * (r[3] - r[1]);
        let f = 0;
        n && (f = n - Math.cos(h / n) * n, h = Math.sin(h / n) * n), l.setXYZ(u, h, d, f);
      }
      a.boundingSphere = this.geometry.boundingSphere, a.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, Cf.length = 0, o.raycast(e, Cf);
      for (let u = 0; u < Cf.length; u++)
        Cf[u].object = this, t.push(Cf[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, uZ.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
G3.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(H3.prototype, s, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
new yn();
new rt();
function W3(s, e) {
  if (new.target) return Rt({ component: W3, ...s });
  Ct(e, !0);
  let t = G(e, "font", 7), i = G(e, "characters", 7), n = G(e, "sdfGlyphSize", 7), r = G(e, "ref", 15), o = G(e, "onsync", 7), a = G(e, "children", 7), l = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "font",
    "characters",
    "sdfGlyphSize",
    "ref",
    "onsync",
    "children"
  ]);
  const c = new H3(), { invalidate: u } = cn(), h = async () => {
    await aw(), c.sync(() => {
      var m;
      u(), (m = o()) == null || m();
    });
  }, d = [
    "text",
    "anchorX",
    "anchorY",
    "curveRadius",
    "direction",
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "glyphGeometryDetail",
    "sdfGlyphSize",
    "outlineWidth",
    "outlineColor",
    "outlineOpacity",
    "outlineBlur",
    "outlineOffsetX",
    "outlineOffsetY",
    "strokeWidth",
    "strokeColor",
    "strokeOpacity",
    "fillOpacity",
    "characters",
    "colorRanges"
  ];
  zs(() => d.map((m) => l[m]), () => {
    h();
  });
  const f = Vl();
  return $e(() => {
    f(new Promise((m) => jq(
      {
        font: t(),
        characters: i(),
        sdfGlyphSize: n()
      },
      m
    )));
  }), pt(s, sn({ is: c }, () => l, {
    get font() {
      return t();
    },
    get characters() {
      return i();
    },
    get sdfGlyphSize() {
      return n();
    },
    get ref() {
      return r();
    },
    set ref(m) {
      r(m);
    },
    children: (m, g) => {
      var v = At(), _ = dt(v);
      Wt(_, () => a() ?? Bt, () => ({ ref: c })), ut(m, v);
    },
    $$slots: { default: !0 }
  })), Pt({
    get font() {
      return t();
    },
    set font(m) {
      t(m), V();
    },
    get characters() {
      return i();
    },
    set characters(m) {
      i(m), V();
    },
    get sdfGlyphSize() {
      return n();
    },
    set sdfGlyphSize(m) {
      n(m), V();
    },
    get ref() {
      return r();
    },
    set ref(m) {
      r(m), V();
    },
    get onsync() {
      return o();
    },
    set onsync(m) {
      o(m), V();
    },
    get children() {
      return a();
    },
    set children(m) {
      a(m), V();
    },
    $set: Lt,
    $on: (m, g) => It(e, m, g)
  });
}
Ut(
  W3,
  {
    font: {},
    characters: {},
    sdfGlyphSize: {},
    ref: {},
    onsync: {},
    children: {}
  },
  [],
  [],
  !0
);
const bc = /* @__PURE__ */ new Map(), hZ = {
  audioListeners: bc,
  addAudioListener: (s, e = "default") => {
    if (bc.has(e)) {
      console.warn(`An AudioListener with the id "${e}" has already been added, aborting.`);
      return;
    }
    bc.set(e, s);
  },
  removeAudioListener: (s = "default") => {
    if (!bc.has(s)) {
      console.warn(`No AudioListener with the id "${s}" found, aborting.`);
      return;
    }
    bc.delete(s);
  },
  getAudioListener: (s = "default") => {
    if (!bc.has(s)) {
      console.warn(`No AudioListener with the id "${s}" found, aborting.`);
      return;
    }
    return bc.get(s);
  }
};
function aM() {
  return OS("threlte-audio", hZ);
}
function X3(s, e) {
  if (new.target) return Rt({ component: X3, ...s });
  Ct(e, !0);
  let t = G(e, "id", 7), i = G(e, "masterVolume", 7), n = G(e, "ref", 15), r = G(e, "children", 7), o = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "masterVolume",
    "ref",
    "children"
  ]);
  const a = new RI(), l = a.context, c = () => a.context.resume();
  $e(() => {
    i() !== void 0 && a.setMasterVolume(i());
  });
  const { addAudioListener: u, removeAudioListener: h } = aM();
  return u(a, t()), Ki(() => {
    h(t());
  }), pt(s, sn({ is: a }, () => o, {
    get ref() {
      return n();
    },
    set ref(d) {
      n(d);
    },
    children: (d, f) => {
      var m = At(), g = dt(m);
      Wt(g, () => r() ?? Bt, () => ({ ref: a })), ut(d, m);
    },
    $$slots: { default: !0 }
  })), Pt({
    audioContext: l,
    resumeContext: c,
    get id() {
      return t();
    },
    set id(d) {
      t(d), V();
    },
    get masterVolume() {
      return i();
    },
    set masterVolume(d) {
      i(d), V();
    },
    get ref() {
      return n();
    },
    set ref(d) {
      n(d), V();
    },
    get children() {
      return r();
    },
    set children(d) {
      r(d), V();
    },
    $set: Lt,
    $on: (d, f) => It(e, d, f)
  });
}
Ut(
  X3,
  {
    id: {},
    masterVolume: {},
    ref: {},
    children: {}
  },
  [],
  ["audioContext", "resumeContext"],
  !0
);
const Y3 = (s, e = {}) => {
  const t = Xn(!1), i = Xn(!1), n = Xn(!1);
  let r = !1;
  const o = mm(CI), a = async (v) => {
    var _, y, w;
    t.set(!1);
    try {
      if (typeof v == "string") {
        const x = await o.load(v, {
          onProgress(M) {
            var A;
            (A = e.onprogress) == null || A.call(e, M);
          }
        });
        s.setBuffer(x);
      } else v instanceof AudioBuffer ? s.setBuffer(v) : v instanceof HTMLMediaElement ? s.setMediaElementSource(v) : v instanceof AudioBufferSourceNode ? s.setNodeSource(v) : v instanceof MediaStream && s.setMediaStreamSource(v);
      t.set(!0), s.buffer ? (_ = e.onload) == null || _.call(e, s.buffer) : (y = e.onload) == null || y.call(e);
    } catch (x) {
      (w = e.onerror) == null || w.call(e, x);
    }
  }, l = (v) => {
    s.setVolume(v ?? 1);
  }, c = (v) => {
    s.setPlaybackRate(v ?? 1);
  }, u = async (v) => {
    if (!t.current) {
      n.set(!0);
      return;
    }
    if (!(s.context.state !== "running" && (await s.context.resume(), r)))
      return s.play(v);
  }, h = () => s.pause(), d = () => s.source ? s.stop() : s, f = (v) => {
    i.set(v ?? !1);
  }, m = (v) => {
    s.source && s.detune && s.setDetune(v ?? 0);
  }, g = (v) => {
    s.setLoop(v ?? !1);
  };
  return ui([t, i, n], ([v, _, y]) => {
    if (!v) {
      s.isPlaying && d();
      return;
    }
    (_ || y) && u();
  }), Ki(() => {
    try {
      r = !0, d();
    } catch (v) {
      console.warn("Error while destroying audio", v);
    }
  }), {
    setVolume: l,
    setSrc: a,
    setPlaybackRate: c,
    setAutoPlay: f,
    setDetune: m,
    setLoop: g,
    play: u,
    pause: h,
    stop: d
  };
};
function j3(s, e) {
  if (new.target) return Rt({ component: j3, ...s });
  Ct(e, !0);
  let t = G(e, "src", 7), i = G(e, "id", 7), n = G(e, "volume", 7), r = G(e, "playbackRate", 7), o = G(e, "autoplay", 7), a = G(e, "detune", 7), l = G(e, "loop", 7), c = G(e, "ref", 15), u = G(e, "children", 7), h = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "ref",
    "children"
  ]);
  const { getAudioListener: d } = aM(), f = d(i());
  if (!f)
    throw new Error(`No Audiolistener with id ${i()} found.`);
  const m = new wS(f), {
    setAutoPlay: g,
    setDetune: v,
    setLoop: _,
    setPlaybackRate: y,
    setSrc: w,
    setVolume: x,
    ...M
  } = Y3(m, h), A = M.pause, E = M.play, C = M.stop;
  return Ht(() => g(o())), Ht(() => void w(t())), Ht(() => x(n())), Ht(() => y(r())), Ht(() => _(l())), Ht(() => v(a())), pt(s, sn({ is: m }, () => h, {
    get ref() {
      return c();
    },
    set ref(P) {
      c(P);
    },
    children: (P, T) => {
      var I = At(), D = dt(I);
      Wt(D, () => u() ?? Bt, () => ({ ref: m })), ut(P, I);
    },
    $$slots: { default: !0 }
  })), Pt({
    pause: A,
    play: E,
    stop: C,
    get src() {
      return t();
    },
    set src(P) {
      t(P), V();
    },
    get id() {
      return i();
    },
    set id(P) {
      i(P), V();
    },
    get volume() {
      return n();
    },
    set volume(P) {
      n(P), V();
    },
    get playbackRate() {
      return r();
    },
    set playbackRate(P) {
      r(P), V();
    },
    get autoplay() {
      return o();
    },
    set autoplay(P) {
      o(P), V();
    },
    get detune() {
      return a();
    },
    set detune(P) {
      a(P), V();
    },
    get loop() {
      return l();
    },
    set loop(P) {
      l(P), V();
    },
    get ref() {
      return c();
    },
    set ref(P) {
      c(P), V();
    },
    get children() {
      return u();
    },
    set children(P) {
      u(P), V();
    },
    $set: Lt,
    $on: (P, T) => It(e, P, T)
  });
}
Ut(
  j3,
  {
    src: {},
    id: {},
    volume: {},
    playbackRate: {},
    autoplay: {},
    detune: {},
    loop: {},
    ref: {},
    children: {}
  },
  [],
  ["pause", "play", "stop"],
  !0
);
function q3(s, e) {
  if (new.target) return Rt({ component: q3, ...s });
  Ct(e, !0);
  let t = G(e, "src", 7), i = G(e, "id", 7), n = G(e, "volume", 7), r = G(e, "playbackRate", 7), o = G(e, "autoplay", 7), a = G(e, "detune", 7), l = G(e, "loop", 7), c = G(e, "directionalCone", 7), u = G(e, "refDistance", 7), h = G(e, "rolloffFactor", 7), d = G(e, "distanceModel", 7), f = G(e, "maxDistance", 7), m = G(e, "ref", 15), g = G(e, "children", 7), v = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "directionalCone",
    "refDistance",
    "rolloffFactor",
    "distanceModel",
    "maxDistance",
    "ref",
    "children"
  ]);
  const { getAudioListener: _ } = aM(), y = _(i());
  if (!y)
    throw new Error(`No Audiolistener with id ${i()} found.`);
  const w = new DI(y);
  Ht(() => {
    u() !== void 0 && w.setRefDistance(u()), h() !== void 0 && w.setRolloffFactor(h()), d() !== void 0 && w.setDistanceModel(d()), f() !== void 0 && w.setMaxDistance(f()), c() !== void 0 && w.setDirectionalCone(c().coneInnerAngle, c().coneOuterAngle, c().coneOuterGain);
  });
  const {
    setAutoPlay: x,
    setDetune: M,
    setLoop: A,
    setPlaybackRate: E,
    setSrc: C,
    setVolume: P,
    ...T
  } = Y3(w, v), I = T.pause, D = T.play, U = T.stop;
  return Ht(() => x(o())), Ht(() => void C(t())), Ht(() => P(n())), Ht(() => E(r())), Ht(() => A(l())), Ht(() => M(a())), pt(s, sn({ is: w }, () => v, {
    get ref() {
      return m();
    },
    set ref(L) {
      m(L);
    },
    children: (L, k) => {
      var B = At(), j = dt(B);
      Wt(j, () => g() ?? Bt, () => ({ ref: w })), ut(L, B);
    },
    $$slots: { default: !0 }
  })), Pt({
    pause: I,
    play: D,
    stop: U,
    get src() {
      return t();
    },
    set src(L) {
      t(L), V();
    },
    get id() {
      return i();
    },
    set id(L) {
      i(L), V();
    },
    get volume() {
      return n();
    },
    set volume(L) {
      n(L), V();
    },
    get playbackRate() {
      return r();
    },
    set playbackRate(L) {
      r(L), V();
    },
    get autoplay() {
      return o();
    },
    set autoplay(L) {
      o(L), V();
    },
    get detune() {
      return a();
    },
    set detune(L) {
      a(L), V();
    },
    get loop() {
      return l();
    },
    set loop(L) {
      l(L), V();
    },
    get directionalCone() {
      return c();
    },
    set directionalCone(L) {
      c(L), V();
    },
    get refDistance() {
      return u();
    },
    set refDistance(L) {
      u(L), V();
    },
    get rolloffFactor() {
      return h();
    },
    set rolloffFactor(L) {
      h(L), V();
    },
    get distanceModel() {
      return d();
    },
    set distanceModel(L) {
      d(L), V();
    },
    get maxDistance() {
      return f();
    },
    set maxDistance(L) {
      f(L), V();
    },
    get ref() {
      return m();
    },
    set ref(L) {
      m(L), V();
    },
    get children() {
      return g();
    },
    set children(L) {
      g(L), V();
    },
    $set: Lt,
    $on: (L, k) => It(e, L, k)
  });
}
Ut(
  q3,
  {
    src: {},
    id: {},
    volume: {},
    playbackRate: {},
    autoplay: {},
    detune: {},
    loop: {},
    directionalCone: {},
    refDistance: {},
    rolloffFactor: {},
    distanceModel: {},
    maxDistance: {},
    ref: {},
    children: {}
  },
  [],
  ["pause", "play", "stop"],
  !0
);
var dZ = Object.defineProperty, fZ = (s, e, t) => e in s ? dZ(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, Pr = (s, e, t) => (fZ(s, typeof e != "symbol" ? e + "" : e, t), t);
const Z3 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function $1(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(i, n) {
    let r = Ft[n];
    return r ? $1(r) : i;
  }
  return s.replace(e, t);
}
const dr = [];
for (let s = 0; s < 256; s++)
  dr[s] = (s < 16 ? "0" : "") + s.toString(16);
function pZ() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (dr[s & 255] + dr[s >> 8 & 255] + dr[s >> 16 & 255] + dr[s >> 24 & 255] + "-" + dr[e & 255] + dr[e >> 8 & 255] + "-" + dr[e >> 16 & 15 | 64] + dr[e >> 24 & 255] + "-" + dr[t & 63 | 128] + dr[t >> 8 & 255] + "-" + dr[t >> 16 & 255] + dr[t >> 24 & 255] + dr[i & 255] + dr[i >> 8 & 255] + dr[i >> 16 & 255] + dr[i >> 24 & 255]).toUpperCase();
}
const wc = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let i = arguments[e];
    if (i)
      for (let n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (s[n] = i[n]);
  }
  return s;
}, mZ = Date.now(), SC = /* @__PURE__ */ new WeakMap(), MC = /* @__PURE__ */ new Map();
let gZ = 1e10;
function n_(s, e) {
  const t = xZ(e);
  let i = SC.get(s);
  if (i || SC.set(s, i = /* @__PURE__ */ Object.create(null)), i[t])
    return new i[t]();
  const n = `_onBeforeCompile${t}`, r = function(c, u) {
    s.onBeforeCompile.call(this, c, u);
    const h = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
    let d = MC[h];
    if (!d) {
      const f = vZ(this, c, e, t);
      d = MC[h] = f;
    }
    c.vertexShader = d.vertexShader, c.fragmentShader = d.fragmentShader, wc(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - mZ;
      }
    }), this[n] && this[n](c);
  }, o = function() {
    return a(e.chained ? s : s.clone());
  }, a = function(c) {
    const u = Object.create(c, l);
    return Object.defineProperty(u, "baseMaterial", { value: s }), Object.defineProperty(u, "id", { value: gZ++ }), u.uuid = pZ(), u.uniforms = wc({}, c.uniforms, e.uniforms), u.defines = wc({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = wc({}, c.extensions, e.extensions), u._listeners = void 0, u;
  }, l = {
    constructor: { value: o },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => s.type,
      set: (c) => {
        s.type = c;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        const u = this.baseMaterial;
        return c === u || u.isDerivedMaterial && u.isDerivedFrom(c) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(c) {
        this[n] = c;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        return s.copy.call(this, c), !s.isShaderMaterial && !s.isDerivedMaterial && (wc(this.extensions, c.extensions), wc(this.defines, c.defines), wc(this.uniforms, Fl.clone(c.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const c = new s.constructor();
        return a(c).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._depthMaterial;
        return c || (c = this._depthMaterial = n_(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Ru({ depthPacking: Md }),
          e
        ), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._distanceMaterial;
        return c || (c = this._distanceMaterial = n_(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new Cd(),
          e
        ), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: c, _distanceMaterial: u } = this;
        c && c.dispose(), u && u.dispose(), s.dispose.call(this);
      }
    }
  };
  return i[t] = o, new o();
}
function vZ(s, { vertexShader: e, fragmentShader: t }, i, n) {
  let {
    vertexDefs: r,
    vertexMainIntro: o,
    vertexMainOutro: a,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: m
  } = i;
  if (r = r || "", o = o || "", a = a || "", c = c || "", u = u || "", h = h || "", (l || f) && (e = $1(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = $1(t)), f) {
    let g = f({ vertexShader: e, fragmentShader: t });
    e = g.vertexShader, t = g.fragmentShader;
  }
  if (d) {
    let g = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (v) => (g.push(v), "")
    ), h = `${d}
${g.join(`
`)}
${h}`;
  }
  if (m) {
    const g = `
uniform float ${m};
`;
    r = g + r, c = g + c;
  }
  return l && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, r = `${r}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, o = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (g, v, _, y) => /\battribute\s+vec[23]\s+$/.test(y.substr(0, _)) ? v : `troika_${v}_${n}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = EC(e, n, r, o, a), t = EC(t, n, c, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function EC(s, e, t, i, n) {
  return (i || n || t) && (s = s.replace(
    Z3,
    `
${t}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${n}
}`), s;
}
function _Z(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let yZ = 0;
const TC = /* @__PURE__ */ new Map();
function xZ(s) {
  const e = JSON.stringify(s, _Z);
  let t = TC.get(e);
  return t == null && TC.set(e, t = ++yZ), t;
}
const bZ = {
  MeshDepthMaterial: "depth",
  MeshDistanceMaterial: "distanceRGBA",
  MeshNormalMaterial: "normal",
  MeshBasicMaterial: "basic",
  MeshLambertMaterial: "lambert",
  MeshPhongMaterial: "phong",
  MeshToonMaterial: "toon",
  MeshStandardMaterial: "physical",
  MeshPhysicalMaterial: "physical",
  MeshMatcapMaterial: "matcap",
  LineBasicMaterial: "basic",
  LineDashedMaterial: "dashed",
  PointsMaterial: "points",
  ShadowMaterial: "shadow",
  SpriteMaterial: "sprite"
};
function wZ(s) {
  let e = bZ[s.type];
  return e ? Dr[e] : s;
}
function AC(s) {
  let e = /\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g, t = /* @__PURE__ */ Object.create(null), i;
  for (; (i = e.exec(s)) !== null; )
    t[i[2]] = i[1];
  return t;
}
function SZ(s) {
  let e = [], t = "";
  const i = n_(s, {
    chained: !0,
    customRewriter({ vertexShader: r, fragmentShader: o }) {
      let a = [], l = [], c = [], u = AC(r), h = AC(o);
      return e.forEach((d) => {
        let f = u[d], m = h[d];
        const g = f || m;
        if (g) {
          const v = new RegExp(`\\buniform\\s+${g}\\s+${d}\\s*;`, "g"), _ = new RegExp(`\\b${d}\\b`, "g"), y = `troika_attr_${d}`, w = `troika_vary_${d}`;
          if (a.push(`attribute ${g} ${y};`), f && (r = r.replace(v, ""), r = r.replace(_, y)), m) {
            o = o.replace(v, ""), o = o.replace(_, w);
            let x = `varying ${m} ${w};`;
            a.push(x), c.push(x), l.push(`${w} = ${y};`);
          }
        }
      }), r = `${a.join(`
`)}
${r.replace(Z3, `
$&
${l.join(`
`)}`)}`, c.length && (o = `${c.join(`
`)}
${o}`), { vertexShader: r, fragmentShader: o };
    }
  });
  i.setUniformNames = function(r) {
    e = r || [];
    const o = e.sort().join("|");
    o !== t && (t = o, this.needsUpdate = !0);
  };
  const n = i.customProgramCacheKey();
  return i.customProgramCacheKey = function() {
    return n + "|" + t;
  }, i.isInstancedUniformsMaterial = !0, i;
}
class MZ extends Td {
  constructor(e, t, i) {
    super(e, t, i), this._maxCount = i, this._instancedUniformNames = [];
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied geometry with one that will
   * carry our extra InstancedBufferAttribute(s). We do the wrapping lazily on _read_ rather
   * than write to avoid unnecessary wrapping on transient values.
   */
  get geometry() {
    let e = this._derivedGeometry;
    const t = this._baseGeometry;
    return (!e || e.baseGeometry !== t) && (e = this._derivedGeometry = Object.create(t), e.baseGeometry = t, e.attributes = Object.create(t.attributes), t.addEventListener("dispose", function i() {
      t.removeEventListener("dispose", i), e.dispose();
    })), e;
  }
  set geometry(e) {
    this._baseGeometry = e;
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied material with our upgrades. We do the
   * wrapping lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
   */
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = new qn());
    return (!e || e.baseMaterial !== t) && (e = this._derivedMaterial = SZ(t), t.addEventListener("dispose", function i() {
      t.removeEventListener("dispose", i), e.dispose();
    })), e.setUniformNames(this._instancedUniformNames), e;
  }
  set material(e) {
    if (Array.isArray(e))
      throw new Error("InstancedUniformsMesh does not support multiple materials");
    for (; e && e.isInstancedUniformsMaterial; )
      e = e.baseMaterial;
    this._baseMaterial = e;
  }
  get customDepthMaterial() {
    return this.material.getDepthMaterial();
  }
  get customDistanceMaterial() {
    return this.material.getDistanceMaterial();
  }
  /**
   * Set the value of a shader uniform for a single instance.
   * @param {string} name - the name of the shader uniform
   * @param {number} index - the index of the instance to set the value for
   * @param {number|Vector2|Vector3|Vector4|Color|Array|Matrix3|Matrix4|Quaternion} value - the uniform value for this instance
   */
  setUniformAt(e, t, i) {
    const n = this.geometry.attributes, r = `troika_attr_${e}`;
    let o = n[r];
    if (!o) {
      const a = EZ(this._baseMaterial, e), l = TZ(a);
      if (o = n[r] = new Jo(new Float32Array(l * this._maxCount), l), a !== null)
        for (let c = 0; c < this._maxCount; c++)
          CC(o, c, a);
      this._instancedUniformNames = [...this._instancedUniformNames, e];
    }
    CC(o, t, i), o.needsUpdate = !0;
  }
  /**
   * Unset all instance-specific values for a given uniform, reverting back to the original
   * uniform value for all.
   * @param {string} name
   */
  unsetUniform(e) {
    this.geometry.deleteAttribute(`troika_attr_${e}`), this._instancedUniformNames = this._instancedUniformNames.filter((t) => t !== e);
  }
}
function CC(s, e, t) {
  let i = s.itemSize;
  i === 1 ? s.setX(e, t) : i === 2 ? s.setXY(e, t.x, t.y) : i === 3 ? t.isColor ? s.setXYZ(e, t.r, t.g, t.b) : s.setXYZ(e, t.x, t.y, t.z) : i === 4 ? s.setXYZW(e, t.x, t.y, t.z, t.w) : t.toArray ? t.toArray(s.array, e * i) : s.set(t, e * i);
}
function EZ(s, e) {
  let t = s.uniforms;
  return t && t[e] || (t = wZ(s).uniforms, t && t[e]) ? t[e].value : null;
}
function TZ(s) {
  return s == null ? 0 : typeof s == "number" ? 1 : s.isVector2 ? 2 : s.isVector3 || s.isColor ? 3 : s.isVector4 || s.isQuaternion ? 4 : s.elements ? s.elements.length : Array.isArray(s) ? s.length : 0;
}
const AZ = (s, e) => {
  const t = s.split(`
`), i = /vMapUv|vAlphaMapUv|vNormalMapUv/g;
  return t.map((n) => !n.includes("varying") && !n.includes("uniform") ? n.replace(i, e) : n).join(`
`);
}, CZ = (s, e) => {
  const t = {
    USE_UV: ""
  };
  return e && (t.TRI_GEOMETRY = ""), n_(s, {
    defines: t,
    uniforms: {
      /** GPGPU animation driven data */
      animationData: { value: null },
      animationDataSize: { value: 0 },
      /* Repeat animation in a loop */
      billboarding: { value: 0 },
      /** flip uvs on x */
      flipX: { value: 0 },
      /** flip uvs on y */
      flipY: { value: 0 },
      /**
       * DataArrayTexture - data stored in columns. Rows are:
       * 0 - Frames declaration - RGBA[x,y,w,h]
       * 1 - Animation lengths RGBA[length,0,0,0]
       * 2 - Animation0 - RGBA [id,duration, 0,0]
       * 3 - Animation1 - RGBA [id,duration, 0,0]
       * ....etc
       */
      spritesheetData: { value: null },
      /**util for reading data texture in spritesheetData */
      dataSize: { value: new Be(0, 0) },
      /**
       * Tinting - Vector4 (enabled 0/1, H (0-3), S (0-1), V(0-1))
       */
      tint: { value: new Kt(0, 0, 0, 0) }
    },
    /**
     *
     * VERTEX
     * - billboarding
     *
     * */
    vertexDefs: (
      /*glsl*/
      `
    uniform float billboarding;
    flat varying int vId;
    `
    ),
    vertexMainOutro: (
      /*glsl*/
      `
    vId = gl_InstanceID;
    if(billboarding == 1.){
      vec3 instancePosition = vec3(instanceMatrix[3]);
      vec3 instanceScale = vec3(length(instanceMatrix[0]), length(instanceMatrix[1]), length(instanceMatrix[2]));

      vec3 cameraRight_worldspace = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
      vec3 cameraUp_worldspace = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

      vec3 vertexPosition_worldspace = instancePosition
        + cameraRight_worldspace * position.x * instanceScale.x
        + cameraUp_worldspace * position.y * instanceScale.y;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition_worldspace, 1.0);
    }
    `
    ),
    /**
     *
     * FRAGMENT REWRITER
     *
     * */
    customRewriter: ({ vertexShader: i, fragmentShader: n }) => (n = n.replace(
      "void main() {",
      `void main() {
      float y = float(vId / animationDataSize) / float(animationDataSize);
      float x = mod(float(vId),float(animationDataSize)) / float(animationDataSize);

      float spritesheetFrameId = texture2D(animationData, vec2(x,y)).r;

			// x,y,w,h
			vec4 frameMeta = readData(spritesheetFrameId, 0.f);

			vec2 fSize = frameMeta.zw;
			vec2 fOffset = vec2(frameMeta.xy);

      vec2 transformedPlaneUv = vUv + vec2(0.,0.);

      // todo  == 1. caused a flickering bug. look into Precision/interpolation?
      if(flipX > 0.){
        transformedPlaneUv.x = 1. - transformedPlaneUv.x;
      }
      if(flipY > 0.){
        transformedPlaneUv.y = 1. - transformedPlaneUv.y;
      }

			vec2 spriteUv = fSize * transformedPlaneUv + fOffset ;

      #ifdef TRI_GEOMETRY
        // Shift UVs if mesh uses triangle geometry
        // TODO optimize ugly math
        if(vUv.y>0.5 || vUv.x<0.25 || vUv.x>0.75){
          discard;
        }

        vec2 zoomCenter = vec2(fSize.x * 0.5,0.) + fOffset;
        float zoomFactor = 2.;
        vec2 shiftedUV = spriteUv - zoomCenter;
        shiftedUV *= zoomFactor;
        shiftedUV += zoomCenter;
        spriteUv = shiftedUV;
      #endif



			`
    ), n = `
			
			uniform sampler2D animationData;
      uniform int animationDataSize;
			uniform sampler2D spritesheetData;
      uniform float startTime;
			uniform float time;
			uniform float flipX;
			uniform float flipY;
			uniform vec2 dataSize;
      uniform vec4 tint;

      flat varying int vId;
			
			
			vec4 readData(float col, float row) {
				float wStep = 1.f / dataSize.x;
				float wHalfStep = wStep * 0.5f;
				float hStep = 1.f / dataSize.y;
				float hHalfStep = 1.f / dataSize.y * 0.5f;
				return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
			}

      vec2 zoomUV(vec2 uv, vec2 zoomCenter, float zoomFactor) {
        // Shift UVs so that the zoom center is the origin
        vec2 shiftedUV = uv - zoomCenter;

        // Scale (zoom) the UV coordinates
        shiftedUV *= zoomFactor;

        // Shift back
        shiftedUV += zoomCenter;

        return shiftedUV;
    }
			
			${n}
			`, n = n.replace(
      "vec4 sampledDiffuseColor = texture2D( map, vMapUv );",
      /*glsl*/
      `
        vec4 sampledDiffuseColor = texture2D( map, vMapUv );
        if(tint.w == 1.){
          vec3 hue_term = 1.0 - min(abs(vec3(tint.x) - vec3(0,2.0,1.0)), 1.0);
          hue_term.x = 1.0 - dot(hue_term.yz, vec2(1));
          vec3 res = vec3(dot(sampledDiffuseColor.xyz, hue_term.xyz), dot(sampledDiffuseColor.xyz, hue_term.zxy), dot(sampledDiffuseColor.xyz, hue_term.yzx));
          res = mix(vec3(dot(res, vec3(0.2, 0.5, 0.3))), res, tint.y);
          res = res * tint.z;

          sampledDiffuseColor = vec4(res, sampledDiffuseColor.a);
        }

        // sampledDiffuseColor = vec4(texture2D(animationData, vUv).rgb, 1.);
      `
    ), n = AZ(n, "spriteUv"), { vertexShader: i, fragmentShader: n })
  });
}, PZ = (s) => {
  const { frames: e, animationLengths: t, animations: i } = s, n = Math.max(
    e.length,
    t.length,
    ...Object.values(i).map((f) => f.length)
  ), r = 2 + Object.values(i).length, o = e.flat().concat(new Array((n - e.length) * 4).fill(0)), a = t.map((f) => [f, 0, 0, 0]).flat().concat(new Array((n - t.length) * 4).fill(0)), l = [], c = /* @__PURE__ */ new Map();
  for (let f = 0; f < Object.keys(i).length; f++) {
    const m = Object.keys(i)[f];
    c.set(m, f);
    const g = i[m].map((v) => [...v, 0, 0]).flat().concat(new Array((n - i[m].length) * 4).fill(0));
    l.push(...g);
  }
  const u = [
    ...o,
    ...a,
    ...l
  ], h = new Float32Array(u);
  h.set(u);
  const d = new yr(
    h,
    n,
    r,
    di,
    Un
  );
  return d.type = Un, d.minFilter = Tn, d.magFilter = Tn, d.wrapS = gr, d.wrapT = Ns, d.needsUpdate = !0, { dataTexture: d, dataWidth: n, dataHeight: r, animMap: c };
}, RZ = () => {
  const s = new Gt(), e = new Float32Array([
    // top
    0,
    1,
    0,
    // bot-left
    -1,
    -1,
    0,
    // bot-right
    1,
    -1,
    0
  ]);
  s.setAttribute("position", new Nt(e, 3));
  const t = new Float32Array([
    // top
    0.5,
    1,
    // bot-left
    0,
    0,
    // bot-right
    1,
    0
  ]);
  return s.setAttribute("uv", new Nt(t, 2)), s.computeVertexNormals(), s;
}, DZ = new Ua(-1, 1, 1, -1, 0, 1);
class IZ extends Gt {
  constructor() {
    super(), this.setAttribute("position", new Tt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Tt([0, 2, 0, 0, 2, 0], 2));
  }
}
const LZ = new IZ();
class UZ {
  constructor(e) {
    this._mesh = new it(LZ, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, DZ);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class kZ {
  constructor(e, t, i) {
    this.variables = [], this.currentTextureIndex = 0;
    let n = Un;
    const r = {
      passThruTexture: { value: null }
    }, o = c(h(), r), a = new UZ(o);
    this.setDataType = function(d) {
      return n = d, this;
    }, this.addVariable = function(d, f, m) {
      const g = this.createShaderMaterial(f), v = {
        name: d,
        initialValueTexture: m,
        material: g,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: Tn,
        magFilter: Tn
      };
      return this.variables.push(v), v;
    }, this.setVariableDependencies = function(d, f) {
      d.dependencies = f;
    }, this.init = function() {
      if (i.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let d = 0; d < this.variables.length; d++) {
        const f = this.variables[d];
        f.renderTargets[0] = this.createRenderTarget(e, t, f.wrapS, f.wrapT, f.minFilter, f.magFilter), f.renderTargets[1] = this.createRenderTarget(e, t, f.wrapS, f.wrapT, f.minFilter, f.magFilter), this.renderTexture(f.initialValueTexture, f.renderTargets[0]), this.renderTexture(f.initialValueTexture, f.renderTargets[1]);
        const m = f.material, g = m.uniforms;
        if (f.dependencies !== null)
          for (let v = 0; v < f.dependencies.length; v++) {
            const _ = f.dependencies[v];
            if (_.name !== f.name) {
              let y = !1;
              for (let w = 0; w < this.variables.length; w++)
                if (_.name === this.variables[w].name) {
                  y = !0;
                  break;
                }
              if (!y)
                return "Variable dependency not found. Variable=" + f.name + ", dependency=" + _.name;
            }
            g[_.name] = { value: null }, m.fragmentShader = `
uniform sampler2D ` + _.name + `;
` + m.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const d = this.currentTextureIndex, f = this.currentTextureIndex === 0 ? 1 : 0;
      for (let m = 0, g = this.variables.length; m < g; m++) {
        const v = this.variables[m];
        if (v.dependencies !== null) {
          const _ = v.material.uniforms;
          for (let y = 0, w = v.dependencies.length; y < w; y++) {
            const x = v.dependencies[y];
            _[x.name].value = x.renderTargets[d].texture;
          }
        }
        this.doRenderTarget(v.material, v.renderTargets[f]);
      }
      this.currentTextureIndex = f;
    }, this.getCurrentRenderTarget = function(d) {
      return d.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(d) {
      return d.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      a.dispose();
      const d = this.variables;
      for (let f = 0; f < d.length; f++) {
        const m = d[f];
        m.initialValueTexture && m.initialValueTexture.dispose();
        const g = m.renderTargets;
        for (let v = 0; v < g.length; v++)
          g[v].dispose();
      }
    };
    function l(d) {
      d.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
    }
    this.addResolutionDefine = l;
    function c(d, f) {
      f = f || {};
      const m = new Mi({
        name: "GPUComputationShader",
        uniforms: f,
        vertexShader: u(),
        fragmentShader: d
      });
      return l(m), m;
    }
    this.createShaderMaterial = c, this.createRenderTarget = function(d, f, m, g, v, _) {
      return d = d || e, f = f || t, m = m || gr, g = g || gr, v = v || Tn, _ = _ || Tn, new Bs(d, f, {
        wrapS: m,
        wrapT: g,
        minFilter: v,
        magFilter: _,
        format: di,
        type: n,
        depthBuffer: !1
      });
    }, this.createTexture = function() {
      const d = new Float32Array(e * t * 4), f = new yr(d, e, t, di, Un);
      return f.needsUpdate = !0, f;
    }, this.renderTexture = function(d, f) {
      r.passThruTexture.value = d, this.doRenderTarget(o, f), r.passThruTexture.value = null;
    }, this.doRenderTarget = function(d, f) {
      const m = i.getRenderTarget(), g = i.xr.enabled, v = i.shadowMap.autoUpdate;
      i.xr.enabled = !1, i.shadowMap.autoUpdate = !1, a.material = d, i.setRenderTarget(f), a.render(i), a.material = o, i.xr.enabled = g, i.shadowMap.autoUpdate = v, i.setRenderTarget(m);
    };
    function u() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function h() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
const OZ = (
  /*glsl*/
  `
  #include <common>
  uniform sampler2D instructionsTexture;

  uniform sampler2D spritesheetData;
  uniform vec2 dataSize;
  uniform float fps;
  uniform float deltaTime;

  // read spritesheet metadata
  vec4 readData(float col, float row, sampler2D tex) {
    float wStep = 1.f / dataSize.x;
    float wHalfStep = wStep * 0.5f;
    float hStep = 1.f / dataSize.y;
    float hHalfStep = 1.f / dataSize.y * 0.5f;
    return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
  }



  void main()	{

    // OUTPUT FROM THIS SHADER
    // progressValue.r - picked animation frame
    // progressValue.g - previous progress state (for pause, reverse & pingpong consistency)
    // progressValue.b - not used yet
    // progressValue.a - previous animationID

    vec2 cellSize = 1.0 / resolution.xy;
    vec2 uv = gl_FragCoord.xy * cellSize;


    vec4 progressValue = texture2D( progress, uv );

    vec4 instructions = texture2D( instructionsTexture, uv);

    // FREEZE FRAME - return to save calculations?
    if(instructions.a >=10.){
      progressValue.r = instructions.a - 10.;
      progressValue.a = instructions.x;
      progressValue.g = progressValue.g;
      gl_FragColor = progressValue;
      return;
    }


    progressValue.b = 0.;

    // todo shouldn't be rounding here, pick
    float animationId = round(instructions.x);

    float offset = instructions.g;

    float animLength = readData(animationId, 1.f, spritesheetData).r;
    float totalTime = animLength / fps;

    // new delta is % of animation
    float newProgress = deltaTime / totalTime;
    // add new delta to saved progress
    float frameTimedId = mod(progressValue.g + newProgress, 1.);
    // frameTimedId = 0.;
    // float frameTimedId = progressValue.g;
    // save for use in next frame



    float playMode = mod(instructions.b, 10.);

    // forward
    if(playMode == 0.){
      frameTimedId = progressValue.g + newProgress;
    }
    // reverse
    if(playMode == 1.){
      frameTimedId = progressValue.g - newProgress;
    }
    // 2 - pause - do nothing
    if(playMode == 2.){
      frameTimedId = progressValue.g;
    }

    // //todo pingpong
    // if(playMode == 3.){
    // }

    // loop (play once over 10.)
    if(instructions.b < 10.){
      frameTimedId = mod(frameTimedId, 1.);
    }

    // todo This could be optional and user would reset manually,
    // todo allowing for consistent movement across multiple animations
    // todo for example - running steps being syncec
    // start anim from beginning if animationID changes
    if(progressValue.a != instructions.x){
      frameTimedId = 0.;
    }

    float frameId = floor(animLength * frameTimedId);
    float spritesheetFrameId = readData(frameId, 2.f + animationId, spritesheetData).r;



    // Picked sprite frame that goes to material
    progressValue.r = spritesheetFrameId;

    progressValue.a = instructions.x;
    progressValue.g = frameTimedId;

    gl_FragColor = progressValue;
  }
`
), FZ = (s = 512) => {
  const e = new Float32Array(s ** 2 * 4);
  for (let i = 0; i < s ** 2 * 4; i++)
    e[i] = 0;
  const t = new yr(
    e,
    s,
    s,
    di,
    Un
  );
  return t.minFilter = Tn, t.magFilter = Tn, t.wrapS = gr, t.wrapT = Ns, t.needsUpdate = !0, t;
}, NZ = (s) => {
  if (s <= 0)
    return 1;
  let e = 1;
  for (; e < s; )
    e <<= 1;
  return e;
}, BZ = (s, e) => {
  const t = NZ(Math.sqrt(e)), i = new kZ(
    t,
    t,
    s
  ), n = i.createTexture(), r = i.addVariable(
    "progress",
    OZ,
    n
  ), o = FZ(t);
  r.material.uniforms.instructionsTexture = {
    value: o
  }, r.material.uniforms.spritesheetData = { value: null }, r.material.uniforms.fps = { value: 0 }, r.material.uniforms.deltaTime = { value: 0 }, r.material.uniforms.dataSize = { value: new Be() }, i.setVariableDependencies(r, [r]);
  const a = i.init();
  a !== null && console.error(a);
  let l = !1;
  return {
    gpuCompute: i,
    animationRunner: r,
    progressDataTexture: o,
    utils: {
      updateAnimationAt: (c, u) => {
        const h = c * 4;
        o.image.data[h] = u, l = !0;
      },
      updateOffsetAt: (c, u) => {
        const h = c * 4;
        o.image.data[h + 1] = u, l = !0;
      },
      updatePlaymodeAt: (c, u) => {
        const h = c * 4;
        o.image.data[h + 2] = u, l = !0;
      },
      updateFrameAt: (c, u) => {
        const h = c * 4;
        o.image.data[h + 3] = u + 10, l = !0;
      }
    },
    update: () => {
      l && (o.needsUpdate = !0, l = !1), i.compute();
    }
  };
};
class zZ {
  constructor() {
    Pr(this, "_previousTime"), Pr(this, "_currentTime"), Pr(this, "_startTime"), Pr(this, "_delta"), Pr(this, "_elapsed"), Pr(this, "_timescale"), Pr(this, "_useFixedDelta"), Pr(this, "_fixedDelta"), Pr(this, "_usePageVisibilityAPI"), Pr(this, "_pageVisibilityHandler"), this._previousTime = 0, this._currentTime = 0, this._startTime = Pb(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = !1, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < "u" && document.hidden !== void 0, this._usePageVisibilityAPI === !0 && (this._pageVisibilityHandler = VZ.bind(this), document.addEventListener(
      "visibilitychange",
      this._pageVisibilityHandler,
      !1
    ));
  }
  disableFixedDelta() {
    return this._useFixedDelta = !1, this;
  }
  dispose() {
    return this._usePageVisibilityAPI === !0 && document.removeEventListener(
      "visibilitychange",
      this._pageVisibilityHandler
    ), this;
  }
  enableFixedDelta() {
    return this._useFixedDelta = !0, this;
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getFixedDelta() {
    return this._fixedDelta / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  reset() {
    return this._currentTime = Pb() - this._startTime, this;
  }
  setFixedDelta(e) {
    return this._fixedDelta = e * 1e3, this;
  }
  setTimescale(e) {
    return this._timescale = e, this;
  }
  update() {
    return this._useFixedDelta === !0 ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = Pb() - this._startTime, this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;
  }
}
function Pb() {
  return (typeof performance > "u" ? Date : performance).now();
}
function VZ() {
  document.hidden === !1 && this.reset();
}
const Rb = {
  FORWARD: 0,
  REVERSE: 1,
  PAUSE: 2,
  PINGPONG: 3
};
class GZ extends MZ {
  constructor(e, t, i, n = {
    geometry: "quad"
  }) {
    let r;
    n.geometry || (n.geometry = "quad"), n.geometry === "tri" && (r = RZ()), n.geometry === "quad" && (r = new $r(1, 1)), n.geometry && typeof n.geometry != "string" && (r = n.geometry);
    const o = CZ(
      e,
      (n == null ? void 0 : n.geometry) === "tri"
    );
    super(r, o, t), Pr(this, "_spriteMaterial"), Pr(this, "_spritesheet"), Pr(this, "_animationMap"), Pr(this, "_fps", 15), Pr(this, "_timer"), Pr(this, "compute"), this.instanceMatrix.clearUpdateRanges(), this.instanceMatrix.addUpdateRange(0, t * 16), this.instanceColor && (this.instanceColor.clearUpdateRanges(), this.instanceColor.addUpdateRange(0, t * 3)), this.compute = BZ(i, t), this._spriteMaterial = o, n.spritesheet && this.updateSpritesheet(n.spritesheet), this._timer = new zZ(), this._animationMap = /* @__PURE__ */ new Map(), this._spriteMaterial.uniforms.animationData.value = this.compute.gpuCompute.getCurrentRenderTarget(
      this.compute.animationRunner
    ).texture, this._spriteMaterial.uniforms.animationDataSize.value = this.compute.progressDataTexture.image.width;
  }
  updateSpritesheet(e) {
    const { dataTexture: t, dataWidth: i, dataHeight: n, animMap: r } = PZ(e);
    this._spriteMaterial.uniforms.spritesheetData.value = t, this._spriteMaterial.uniforms.dataSize.value.x = i, this._spriteMaterial.uniforms.dataSize.value.y = n, this.compute.animationRunner.material.uniforms.dataSize.value = new Be(i, n), this.compute.animationRunner.material.uniforms.spritesheetData.value = t, this._animationMap = r;
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(e) {
    this.updateSpritesheet(e), this._spritesheet = e;
  }
  get animationMap() {
    return this._animationMap;
  }
  get animation() {
    return {
      setAt: (e, t) => {
        this.compute.utils.updateAnimationAt(
          e,
          this._animationMap.get(t) || 0
        );
      }
    };
  }
  get frame() {
    return {
      setAt: (e, t, i) => {
        var n;
        let r = t;
        i && (r = (n = this.spritesheet) == null ? void 0 : n.animations[i][t][0]), this.compute.utils.updateFrameAt(e, r);
      },
      unsetAt: (e) => {
        this.compute.utils.updateFrameAt(e, -10);
      },
      unsetAll: () => {
        for (let e = 0; e < this.count; e++)
          this.compute.utils.updateFrameAt(e, -10);
      }
    };
  }
  get playmode() {
    return {
      setAt: (e, t) => {
        this.compute.utils.updatePlaymodeAt(e, Rb[t]);
      },
      setAll: (e) => {
        for (let t = 0; t < this.count; t++) {
          const i = this.compute.progressDataTexture.image.data[t * 4 + 2] >= 10 ? 10 : 0;
          this.compute.utils.updatePlaymodeAt(t, i + Rb[e]);
        }
      }
    };
  }
  get billboarding() {
    return {
      setAt: (e, t) => {
        this.setUniformAt("billboarding", e, t ? 1 : 0);
      },
      setAll: (e) => {
        this._spriteMaterial.uniforms.billboarding.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("billboarding");
      }
    };
  }
  get offset() {
    return {
      setAt: (e, t) => {
        this.compute.utils.updateOffsetAt(e, t);
      },
      randomizeAll: (e = 1) => {
        for (let t = 0; t < this.count; t++)
          this.compute.utils.updateOffsetAt(t, Math.random() * e);
      }
    };
  }
  get loop() {
    return {
      setAt: (e, t) => {
        const i = this.compute.progressDataTexture.image.data[e * 4 + 2] % 10;
        this.compute.utils.updatePlaymodeAt(
          e,
          i + (t ? 0 : 10)
        );
      },
      setAll: (e) => {
        for (let t = 0; t < this.count; t++) {
          const i = this.compute.progressDataTexture.image.data[t * 4 + 2] % 10;
          this.compute.utils.updatePlaymodeAt(t, i + (e ? 0 : 10));
        }
      }
    };
  }
  get flipX() {
    return {
      setAt: (e, t) => {
        this.setUniformAt("flipX", e, t ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipX.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipX");
      }
    };
  }
  get flipY() {
    return {
      setAt: (e, t) => {
        this.setUniformAt("flipY", e, t ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipY.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipY");
      }
    };
  }
  play(e, t = !0, i = "FORWARD") {
    return {
      at: (n) => {
        this.compute.utils.updateAnimationAt(
          n,
          this._animationMap.get(e) || 0
        ), this.compute.utils.updatePlaymodeAt(
          n,
          Rb[i] + (t ? 0 : 10)
        );
      }
    };
  }
  /** HSV shift tinting */
  get hueShift() {
    const e = new Kt();
    return {
      // TODO - per instance tinting doesnt work - artifacts
      // setAt: (
      //   instanceId: number,
      //   tint?: { h: number; s: number; v: number }
      // ) => {
      //   if (tint) {
      //     tVector.set(tint.h, tint.s, tint.v, 1);
      //   } else {
      //     tVector.setW(0);
      //   }
      //   this.setUniformAt("tint", instanceId, tVector);
      // },
      setGlobal: (t) => {
        t ? e.set(t.h, t.s, t.v, 1) : e.setW(0), this._spriteMaterial.uniforms.tint.value = e;
      }
      // unsetAll: () => {
      //   this.unsetUniform("tint");
      // },
    };
  }
  get fps() {
    return this._fps;
  }
  set fps(e) {
    this._fps = e, this.compute.animationRunner.material.uniforms.fps.value = e;
  }
  update() {
    this._timer.update();
    const e = this._timer.getDelta();
    this.compute.animationRunner.material.uniforms.deltaTime.value = e, this.compute.update();
  }
}
var K3 = { exports: {} };
K3.exports = dy;
K3.exports.default = dy;
function dy(s, e, t) {
  t = t || 2;
  var i = e && e.length, n = i ? e[0] * t : s.length, r = $3(s, 0, n, t, !0), o = [];
  if (!r || r.next === r.prev)
    return o;
  var a, l, c, u, h, d, f;
  if (i && (r = jZ(s, e, r, t)), s.length > 80 * t) {
    a = c = s[0], l = u = s[1];
    for (var m = t; m < n; m += t)
      h = s[m], d = s[m + 1], h < a && (a = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
    f = Math.max(c - a, u - l), f = f !== 0 ? 32767 / f : 0;
  }
  return Zp(r, o, t, a, l, f, 0), o;
}
function $3(s, e, t, i, n) {
  var r, o;
  if (n === ew(s, e, t, i) > 0)
    for (r = e; r < t; r += i)
      o = PC(r, s[r], s[r + 1], o);
  else
    for (r = t - i; r >= e; r -= i)
      o = PC(r, s[r], s[r + 1], o);
  return o && fy(o, o.next) && ($p(o), o = o.next), o;
}
function Mu(s, e) {
  if (!s)
    return s;
  e || (e = s);
  var t = s, i;
  do
    if (i = !1, !t.steiner && (fy(t, t.next) || _i(t.prev, t, t.next) === 0)) {
      if ($p(t), t = e = t.prev, t === t.next)
        break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Zp(s, e, t, i, n, r, o) {
  if (s) {
    !o && r && JZ(s, i, n, r);
    for (var a = s, l, c; s.prev !== s.next; ) {
      if (l = s.prev, c = s.next, r ? WZ(s, i, n, r) : HZ(s)) {
        e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), $p(s), s = c.next, a = c.next;
        continue;
      }
      if (s = c, s === a) {
        o ? o === 1 ? (s = XZ(Mu(s), e, t), Zp(s, e, t, i, n, r, 2)) : o === 2 && YZ(s, e, t, i, n, r) : Zp(Mu(s), e, t, i, n, r, 1);
        break;
      }
    }
  }
}
function HZ(s) {
  var e = s.prev, t = s, i = s.next;
  if (_i(e, t, i) >= 0)
    return !1;
  for (var n = e.x, r = t.x, o = i.x, a = e.y, l = t.y, c = i.y, u = n < r ? n < o ? n : o : r < o ? r : o, h = a < l ? a < c ? a : c : l < c ? l : c, d = n > r ? n > o ? n : o : r > o ? r : o, f = a > l ? a > c ? a : c : l > c ? l : c, m = i.next; m !== e; ) {
    if (m.x >= u && m.x <= d && m.y >= h && m.y <= f && Nh(n, a, r, l, o, c, m.x, m.y) && _i(m.prev, m, m.next) >= 0)
      return !1;
    m = m.next;
  }
  return !0;
}
function WZ(s, e, t, i) {
  var n = s.prev, r = s, o = s.next;
  if (_i(n, r, o) >= 0)
    return !1;
  for (var a = n.x, l = r.x, c = o.x, u = n.y, h = r.y, d = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, m = u < h ? u < d ? u : d : h < d ? h : d, g = a > l ? a > c ? a : c : l > c ? l : c, v = u > h ? u > d ? u : d : h > d ? h : d, _ = J1(f, m, e, t, i), y = J1(g, v, e, t, i), w = s.prevZ, x = s.nextZ; w && w.z >= _ && x && x.z <= y; ) {
    if (w.x >= f && w.x <= g && w.y >= m && w.y <= v && w !== n && w !== o && Nh(a, u, l, h, c, d, w.x, w.y) && _i(w.prev, w, w.next) >= 0 || (w = w.prevZ, x.x >= f && x.x <= g && x.y >= m && x.y <= v && x !== n && x !== o && Nh(a, u, l, h, c, d, x.x, x.y) && _i(x.prev, x, x.next) >= 0))
      return !1;
    x = x.nextZ;
  }
  for (; w && w.z >= _; ) {
    if (w.x >= f && w.x <= g && w.y >= m && w.y <= v && w !== n && w !== o && Nh(a, u, l, h, c, d, w.x, w.y) && _i(w.prev, w, w.next) >= 0)
      return !1;
    w = w.prevZ;
  }
  for (; x && x.z <= y; ) {
    if (x.x >= f && x.x <= g && x.y >= m && x.y <= v && x !== n && x !== o && Nh(a, u, l, h, c, d, x.x, x.y) && _i(x.prev, x, x.next) >= 0)
      return !1;
    x = x.nextZ;
  }
  return !0;
}
function XZ(s, e, t) {
  var i = s;
  do {
    var n = i.prev, r = i.next.next;
    !fy(n, r) && J3(n, i, i.next, r) && Kp(n, r) && Kp(r, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(r.i / t | 0), $p(i), $p(i.next), i = s = r), i = i.next;
  } while (i !== s);
  return Mu(i);
}
function YZ(s, e, t, i, n, r) {
  var o = s;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && tK(o, a)) {
        var l = Q3(o, a);
        o = Mu(o, o.next), l = Mu(l, l.next), Zp(o, e, t, i, n, r, 0), Zp(l, e, t, i, n, r, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== s);
}
function jZ(s, e, t, i) {
  var n = [], r, o, a, l, c;
  for (r = 0, o = e.length; r < o; r++)
    a = e[r] * i, l = r < o - 1 ? e[r + 1] * i : s.length, c = $3(s, a, l, i, !1), c === c.next && (c.steiner = !0), n.push(eK(c));
  for (n.sort(qZ), r = 0; r < n.length; r++)
    t = ZZ(n[r], t);
  return t;
}
function qZ(s, e) {
  return s.x - e.x;
}
function ZZ(s, e) {
  var t = KZ(s, e);
  if (!t)
    return e;
  var i = Q3(t, s);
  return Mu(i, i.next), Mu(t, t.next);
}
function KZ(s, e) {
  var t = e, i = s.x, n = s.y, r = -1 / 0, o;
  do {
    if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
      var a = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (a <= i && a > r && (r = a, o = t.x < t.next.x ? t : t.next, a === i))
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o)
    return null;
  var l = o, c = o.x, u = o.y, h = 1 / 0, d;
  t = o;
  do
    i >= t.x && t.x >= c && i !== t.x && Nh(n < u ? i : r, n, c, u, n < u ? r : i, n, t.x, t.y) && (d = Math.abs(n - t.y) / (i - t.x), Kp(t, s) && (d < h || d === h && (t.x > o.x || t.x === o.x && $Z(o, t))) && (o = t, h = d)), t = t.next;
  while (t !== l);
  return o;
}
function $Z(s, e) {
  return _i(s.prev, s, e.prev) < 0 && _i(e.next, s, s.next) < 0;
}
function JZ(s, e, t, i) {
  var n = s;
  do
    n.z === 0 && (n.z = J1(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== s);
  n.prevZ.nextZ = null, n.prevZ = null, QZ(n);
}
function QZ(s) {
  var e, t, i, n, r, o, a, l, c = 1;
  do {
    for (t = s, s = null, r = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++)
        ;
      for (l = c; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, a--) : (n = i, i = i.nextZ, l--), r ? r.nextZ = n : s = n, n.prevZ = r, r = n;
      t = i;
    }
    r.nextZ = null, c *= 2;
  } while (o > 1);
  return s;
}
function J1(s, e, t, i, n) {
  return s = (s - t) * n | 0, e = (e - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function eK(s) {
  var e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function Nh(s, e, t, i, n, r, o, a) {
  return (n - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (n - o) * (i - a);
}
function tK(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !nK(s, e) && // dones't intersect other edges
  (Kp(s, e) && Kp(e, s) && iK(s, e) && // locally visible
  (_i(s.prev, s, e.prev) || _i(s, e.prev, e)) || // does not create opposite-facing sectors
  fy(s, e) && _i(s.prev, s, s.next) > 0 && _i(e.prev, e, e.next) > 0);
}
function _i(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function fy(s, e) {
  return s.x === e.x && s.y === e.y;
}
function J3(s, e, t, i) {
  var n = xv(_i(s, e, t)), r = xv(_i(s, e, i)), o = xv(_i(t, i, s)), a = xv(_i(t, i, e));
  return !!(n !== r && o !== a || n === 0 && yv(s, t, e) || r === 0 && yv(s, i, e) || o === 0 && yv(t, s, i) || a === 0 && yv(t, e, i));
}
function yv(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function xv(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function nK(s, e) {
  var t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && J3(t, t.next, s, e))
      return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function Kp(s, e) {
  return _i(s.prev, s, s.next) < 0 ? _i(s, e, s.next) >= 0 && _i(s, s.prev, e) >= 0 : _i(s, e, s.prev) < 0 || _i(s, s.next, e) < 0;
}
function iK(s, e) {
  var t = s, i = !1, n = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && n < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== s);
  return i;
}
function Q3(s, e) {
  var t = new Q1(s.i, s.x, s.y), i = new Q1(e.i, e.x, e.y), n = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = n, n.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i;
}
function PC(s, e, t, i) {
  var n = new Q1(s, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function $p(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Q1(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
dy.deviation = function(s, e, t, i) {
  var n = e && e.length, r = n ? e[0] * t : s.length, o = Math.abs(ew(s, 0, r, t));
  if (n)
    for (var a = 0, l = e.length; a < l; a++) {
      var c = e[a] * t, u = a < l - 1 ? e[a + 1] * t : s.length;
      o -= Math.abs(ew(s, c, u, t));
    }
  var h = 0;
  for (a = 0; a < i.length; a += 3) {
    var d = i[a] * t, f = i[a + 1] * t, m = i[a + 2] * t;
    h += Math.abs(
      (s[d] - s[m]) * (s[f + 1] - s[d + 1]) - (s[d] - s[f]) * (s[m + 1] - s[d + 1])
    );
  }
  return o === 0 && h === 0 ? 0 : Math.abs((h - o) / o);
};
function ew(s, e, t, i) {
  for (var n = 0, r = e, o = t - i; r < t; r += i)
    n += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
  return n;
}
dy.flatten = function(s) {
  for (var e = s[0][0].length, t = { vertices: [], holes: [], dimensions: e }, i = 0, n = 0; n < s.length; n++) {
    for (var r = 0; r < s[n].length; r++)
      for (var o = 0; o < e; o++)
        t.vertices.push(s[n][r][o]);
    n > 0 && (i += s[n - 1].length, t.holes.push(i));
  }
  return t;
};
new Be();
new Be();
var RC;
((s) => {
  function e(n) {
    let r = n.slice();
    return r.sort(s.POINT_COMPARATOR), s.makeHullPresorted(r);
  }
  s.makeHull = e;
  function t(n) {
    if (n.length <= 1)
      return n.slice();
    let r = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a];
      for (; r.length >= 2; ) {
        const c = r[r.length - 1], u = r[r.length - 2];
        if ((c.x - u.x) * (l.y - u.y) >= (c.y - u.y) * (l.x - u.x))
          r.pop();
        else
          break;
      }
      r.push(l);
    }
    r.pop();
    let o = [];
    for (let a = n.length - 1; a >= 0; a--) {
      const l = n[a];
      for (; o.length >= 2; ) {
        const c = o[o.length - 1], u = o[o.length - 2];
        if ((c.x - u.x) * (l.y - u.y) >= (c.y - u.y) * (l.x - u.x))
          o.pop();
        else
          break;
      }
      o.push(l);
    }
    return o.pop(), r.length == 1 && o.length == 1 && r[0].x == o[0].x && r[0].y == o[0].y ? r : r.concat(o);
  }
  s.makeHullPresorted = t;
  function i(n, r) {
    return n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0;
  }
  s.POINT_COMPARATOR = i;
})(RC || (RC = {}));
function lM(s, e) {
  if (new.target) return Rt({ component: lM, ...s });
  Ct(e, !0);
  let t = G(e, "id", 7, 0), i = G(e, "position", 23, () => [0, 0, 0]), n = G(e, "scale", 23, () => [1, 1]), r = G(e, "animationName", 7), o = G(e, "playmode", 7), a = G(e, "billboarding", 7), l = G(e, "offset", 7), c = G(e, "loop", 7), u = G(e, "flipX", 7), h = G(e, "flipY", 7), d = G(e, "frameId", 7);
  const { updatePosition: f, sprite: m } = sr("instanced-sprite-ctx");
  return $e(() => {
    i() !== void 0 && f(t(), i(), n());
  }), $e(() => {
    r() !== void 0 && m.animation.setAt(t(), r());
  }), $e(() => {
    o() !== void 0 && m.playmode.setAt(t(), o());
  }), $e(() => {
    a() !== void 0 && m.billboarding.setAt(t(), a());
  }), $e(() => {
    l() !== void 0 && m.offset.setAt(t(), l());
  }), $e(() => {
    c() !== void 0 && m.loop.setAt(t(), c());
  }), $e(() => {
    u() !== void 0 && m.flipX.setAt(t(), u());
  }), $e(() => {
    h() !== void 0 && m.flipY.setAt(t(), h());
  }), $e(() => {
    d() !== void 0 && m.frame.setAt(t(), d(), r());
  }), Pt({
    get id() {
      return t();
    },
    set id(g = 0) {
      t(g), V();
    },
    get position() {
      return i();
    },
    set position(g = [0, 0, 0]) {
      i(g), V();
    },
    get scale() {
      return n();
    },
    set scale(g = [1, 1]) {
      n(g), V();
    },
    get animationName() {
      return r();
    },
    set animationName(g) {
      r(g), V();
    },
    get playmode() {
      return o();
    },
    set playmode(g) {
      o(g), V();
    },
    get billboarding() {
      return a();
    },
    set billboarding(g) {
      a(g), V();
    },
    get offset() {
      return l();
    },
    set offset(g) {
      l(g), V();
    },
    get loop() {
      return c();
    },
    set loop(g) {
      c(g), V();
    },
    get flipX() {
      return u();
    },
    set flipX(g) {
      u(g), V();
    },
    get flipY() {
      return h();
    },
    set flipY(g) {
      h(g), V();
    },
    get frameId() {
      return d();
    },
    set frameId(g) {
      d(g), V();
    },
    $set: Lt,
    $on: (g, v) => It(e, g, v)
  });
}
Ut(
  lM,
  {
    id: {},
    position: {},
    scale: {},
    animationName: {},
    playmode: {},
    billboarding: {},
    offset: {},
    loop: {},
    flipX: {},
    flipY: {},
    frameId: {}
  },
  [],
  [],
  !0
);
function eU(s, e) {
  if (new.target) return Rt({ component: eU, ...s });
  Ct(e, !0);
  let t = G(e, "autoUpdate", 7, !0), i = G(e, "baseMaterial", 7, qn), n = G(e, "fps", 7, 15), r = G(e, "billboarding", 7), o = G(e, "playmode", 7, "FORWARD"), a = G(e, "count", 7, 1e3), l = G(e, "alphaTest", 7, 0.1), c = G(e, "transparent", 7, !0), u = G(e, "hueShift", 7), h = G(e, "randomPlaybackOffset", 7, !1), d = G(e, "spritesheet", 7), f = G(e, "ref", 15), m = G(e, "children", 7), g = /* @__PURE__ */ an(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "autoUpdate",
    "baseMaterial",
    "fps",
    "billboarding",
    "playmode",
    "count",
    "alphaTest",
    "transparent",
    "hueShift",
    "randomPlaybackOffset",
    "spritesheet",
    "ref",
    "children"
  ]);
  const v = new (i())({
    transparent: c(),
    alphaTest: l(),
    // needs to be double side for shading
    side: wi
  }), { renderer: _ } = cn(), y = new GZ(v, a(), _);
  f(y);
  const w = Gn(/* @__PURE__ */ new Map());
  $e(() => {
    d() && (y.spritesheet = d().spritesheet, w.set(y.animationMap), y.material.map = d().texture, y.material.needsUpdate = !0);
  }), $e(() => {
    y.material.alphaTest = l();
  }), $e(() => {
    y.material.transparent = c();
  }), $e(() => {
    y.fps = n();
  }), $e(() => y.hueShift.setGlobal(u())), $e(() => {
    if (r() === void 0) {
      y.billboarding.unsetAll();
      return;
    } else
      y.billboarding.setAll(r());
  }), $e(() => {
    if (o() === void 0) {
      y.playmode.setAll("PAUSE");
      return;
    } else
      y.playmode.setAll(o());
  });
  let x = Us(!1);
  $e(() => {
    if (pe(x) === !1 && h() && y.offset.randomizeAll(h() === !0 ? 100 : h()), pe(x) === !0 && !h())
      for (let C = 0; C < a(); C++)
        y.offset.setAt(C, 0);
    In(x, pr(!!h()));
  });
  let M = !1;
  const A = new _t(), E = (C, P, T = [1, 1]) => {
    A.makeScale(T[0], T[1], 1), A.setPosition(...P), y.setMatrixAt(C, A), M = !0;
  };
  return xr("instanced-sprite-ctx", {
    sprite: y,
    count: a(),
    animationMap: w,
    updatePosition: E
  }), ti(() => {
    t() && y.update(), M && (y.instanceMatrix.needsUpdate = !0, M = !1);
  }), y.update(), pt(s, sn({ is: y, frustumCulled: !1 }, () => g, {
    children: (C, P) => {
      var T = At(), I = dt(T);
      Wt(I, () => m() ?? Bt, () => ({ Instance: lM })), ut(C, T);
    },
    $$slots: { default: !0 }
  })), Pt({
    get autoUpdate() {
      return t();
    },
    set autoUpdate(C = !0) {
      t(C), V();
    },
    get baseMaterial() {
      return i();
    },
    set baseMaterial(C = qn) {
      i(C), V();
    },
    get fps() {
      return n();
    },
    set fps(C = 15) {
      n(C), V();
    },
    get billboarding() {
      return r();
    },
    set billboarding(C) {
      r(C), V();
    },
    get playmode() {
      return o();
    },
    set playmode(C = "FORWARD") {
      o(C), V();
    },
    get count() {
      return a();
    },
    set count(C = 1e3) {
      a(C), V();
    },
    get alphaTest() {
      return l();
    },
    set alphaTest(C = 0.1) {
      l(C), V();
    },
    get transparent() {
      return c();
    },
    set transparent(C = !0) {
      c(C), V();
    },
    get hueShift() {
      return u();
    },
    set hueShift(C) {
      u(C), V();
    },
    get randomPlaybackOffset() {
      return h();
    },
    set randomPlaybackOffset(C = !1) {
      h(C), V();
    },
    get spritesheet() {
      return d();
    },
    set spritesheet(C) {
      d(C), V();
    },
    get ref() {
      return f();
    },
    set ref(C) {
      f(C), V();
    },
    get children() {
      return m();
    },
    set children(C) {
      m(C), V();
    },
    $set: Lt,
    $on: (C, P) => It(e, C, P)
  });
}
Ut(
  eU,
  {
    autoUpdate: {},
    baseMaterial: {},
    fps: {},
    billboarding: {},
    playmode: {},
    count: {},
    alphaTest: {},
    transparent: {},
    hueShift: {},
    randomPlaybackOffset: {},
    spritesheet: {},
    ref: {},
    children: {}
  },
  [],
  [],
  !0
);
var rK = /* @__PURE__ */ ni("<!> <!>", 1), sK = /* @__PURE__ */ ni("<!> <!>", 1), oK = /* @__PURE__ */ ni("<!> <!>", 1), aK = /* @__PURE__ */ ni("<!> <!>", 1), lK = /* @__PURE__ */ ni("<!> <!>", 1), cK = /* @__PURE__ */ ni("<!> <!>", 1), uK = /* @__PURE__ */ ni('<div style="width: 100%; height: 100%; position: relative;"><!></div>');
function tU(s, e) {
  if (new.target) return Rt({ component: tU, ...s });
  Ct(e, !1);
  let t = Xf(), i = Xf(1), n = Xf();
  new H(0, -200, 0);
  const r = () => {
    pe(n) && Vo.fromTo(pe(n).rotation, { y: 60 * Kr.DEG2RAD }, {
      y: -60 * Kr.DEG2RAD,
      scrollTrigger: {
        trigger: pe(t),
        start: "top bottom",
        end: "bottom top",
        scrub: !0
      }
    });
  };
  So(() => {
    const l = () => {
      pe(t) && In(i, pe(t).clientWidth / pe(t).clientHeight);
    };
    return l(), window.addEventListener("resize", l), () => {
      window.removeEventListener("resize", l), pn.getAll().forEach((c) => c.kill());
    };
  }), ul(() => pe(n), () => {
    pe(n) && r();
  }), lw(), Au();
  var o = uK(), a = Ic(o);
  return US(a, {
    children: (l, c) => {
      var u = cK(), h = dt(u);
      const d = /* @__PURE__ */ bv(() => [50, pe(i), 0.1, 100]), f = /* @__PURE__ */ bv(() => -5 * Kr.DEG2RAD), m = /* @__PURE__ */ bv(() => 5 * Kr.DEG2RAD);
      pt.PerspectiveCamera(h, {
        get args() {
          return pe(d);
        },
        makeDefault: !0,
        position: [0, 2, 25],
        get "rotation.x"() {
          return pe(f);
        },
        get "rotation.z"() {
          return pe(m);
        },
        zoom: 2.5
      });
      var g = Wn(h, 2);
      pt.Group(g, {
        position: [0, -0.5, 0],
        children: (v, _) => {
          var y = lK(), w = dt(y);
          pt.Mesh(w, {
            name: "flora-person",
            children: (M, A) => {
              var E = rK(), C = dt(E);
              pt.PlaneGeometry(C, { args: [1, 5] });
              var P = Wn(C, 2);
              gp(P, {
                transparent: !0,
                side: 2,
                url: "https://cdn.prod.website-files.com/67a0fb16e98014c2e8572448/67c0f925d2b40212f348b3a7_flora.png"
              }), ut(M, E);
            },
            $$slots: { default: !0 }
          });
          var x = Wn(w, 2);
          pt.Group(x, {
            get ref() {
              return pe(n);
            },
            set ref(M) {
              In(n, M);
            },
            children: (M, A) => {
              var E = aK(), C = dt(E);
              pt.Mesh(C, {
                name: "flora-shadow",
                "rotation.x": Math.PI / 2,
                position: [-0.4, -2.45, 1.75],
                children: (T, I) => {
                  var D = sK(), U = dt(D);
                  pt.PlaneGeometry(U, { args: [1, 5] });
                  var L = Wn(U, 2);
                  gp(L, {
                    transparent: !0,
                    side: 2,
                    url: "https://cdn.prod.website-files.com/67a0fb16e98014c2e8572448/67c0f92a0f6906a8aa87c079_flora-shadow.png"
                  }), ut(T, D);
                },
                $$slots: { default: !0 }
              });
              var P = Wn(C, 2);
              pt.Mesh(P, {
                name: "flora-frame",
                position: [0, 2, -4],
                children: (T, I) => {
                  var D = oK(), U = dt(D);
                  pt.PlaneGeometry(U, { args: [1.5, 3] });
                  var L = Wn(U, 2);
                  gp(L, {
                    side: 2,
                    transparent: !0,
                    url: "https://cdn.prod.website-files.com/67a0fb16e98014c2e8572448/67b7be73078ec50bf1b6ce04_flora-frame.png"
                  }), ut(T, D);
                },
                $$slots: { default: !0 }
              }), ut(M, E);
            },
            $$slots: { default: !0 },
            $$legacy: !0
          }), ut(v, y);
        },
        $$slots: { default: !0 }
      }), ut(l, u);
    },
    $$slots: { default: !0 }
  }), Dc(o), Vh(o, (l) => In(t, l), () => pe(t)), ut(s, o), Pt({
    $set: Lt,
    $on: (l, c) => It(e, l, c)
  });
}
customElements.define("florag-three-canvas", Ut(tU, {}, [], [], !0));
export {
  tU as FloraThreeCanvas,
  tD as WebflowExport
};
